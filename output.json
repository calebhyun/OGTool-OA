{
  "team_id": "aline123",
  "items": [
    {
      "title": "Gift Interviews",
      "content": "We helped write the sequel to \"Cracking the Coding Interview\".\nRead 9 chapters for free\n→\ninterviewing.io\nOpen menu\nInterview resources\nFor employers\nGift mock interviews\nBlog\nFAQ\nLog in\nGive it a try\nHelp someone get awesome at technical interviews\nGift to\nTheir name\nTheir email\nGift from\nYour name\nYour email\nNumber of interviews\nTotal (15% off for 4 interviews or more)\n$225\nPayment method\nOptional gift message\nPay & send gift\nQuestions? Email\nsupport@interviewing.io\nWe know exactly what to do and say to get the company, title, and salary you want.\nInterview prep and job hunting are chaos and pain. We can help. Really.\nGet started for free",
      "content_type": "blog",
      "source_url": "https://interviewing.io/gift-practice-interviews",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Don't make recruiters think, or, why your resume is bad and how to fix it",
      "content": "Years ago, Steve Krug wrote a book about web design called Don’t Make Me Think. It’s a classic, and the main point is that good design should make everything painfully obvious to users without demanding anything of them.\nResumes are just the same. Your resume shouldn’t make recruiters think. It should serve up the most important things about you on a platter that they can digest in 30 seconds or less.\nBefore I share some resume tips, there’s something important I want to reiterate: Don’t spend a lot of time on your resume. You can read my piece about how resume writing is snake oil, but the TL;DR is that recruiters spend a median of 30 seconds looking at resumes, and most of that is spent looking for top-tier companies. If you don’t have top-tier companies (and in some cases niche skills), wordsmithing your bullets or rearranging your sections or changing your layout won’t help. If you do have top-tier companies, sometimes doing some wordsmithing and rearrangement will help… if your top company experience or niche skills are buried.\nIf you don’t have top-tier brands, the best bang for your buck is to switch from online applications to hiring manager outreach. Here’s how to do it.\nWith that said, I know that no matter what I say, people will still grind on their resumes instead of doing outreach. Grinding on resumes is safe. Outreach is scary and opens you up to personal (rather than impersonal) rejection. So, look, if you’re going to do something to your resume, let’s make sure that that something is low-effort and high-return. Unlike the endless resume tweaking that most candidates do, these changes directly address how recruiters actually read resumes.\nHere we go.\nYour \"About\" or \"Summary\" section is prime real estate. Yet so many candidates fill this section with meaningless jargon like \"passionate self-starter\" or \"detail-oriented team player.\" Instead, use this section to explicitly tell recruiters the 2-3 most impressive things about you in plain English. This is your chance to control the narrative. Want recruiters to take something away from reading your resume? Don’t assume they’ll figure it out. They’re not reading it long enough to intuit anything. Spell it out for them verbatim in this section. Do this, not that:\n❌ Results-driven full-stack engineer with a passion for scalable systems and user-centric design\n✅ Senior engineer with 3 years at Amazon, promoted twice in 3 years (2X the company average)1\nThis is simple but effective: only include your GPA if it's 3.8 or higher2. A middling GPA doesn't help your case and might inadvertently signal academic mediocrity.\nIf your GPA isn't stellar, focus on other academic achievements: hackathons, technical competitions, fellowships or scholarships. These provide better signals about your capabilities than a so-so GPA.\nIf you've worked at Google or Facebook, recruiters instantly get what kind of company you're coming from. But when you have \"TechStartup123\" on your resume, they have no idea what they're looking at or how impressive it might be.\nFor lesser-known companies, include a one-line description explaining what the company does, along with any impressive metrics or investors:\n❌ \"Software Engineer, DevTools Inc.\"\n✅ \"Software Engineer, DevTools Inc. ($50M Series B from Sequoia, 2M+ active users)\"\nThis simple addition provides crucial context that helps recruiters evaluate your experience properly. Without it, they might discount valuable experience simply because they don't recognize the company name.\nHere's a common mistake: listing each role at the same company as if they were separate jobs. This can make recruiters think you've job-hopped, which is often seen as a red flag.\nInstead, group different roles under the same company heading:\n❌ Listing separate entries for \"Junior Developer at XYZ\" and \"Senior Developer at XYZ\"\n✅ \"XYZ Company - Senior Developer (2021-Present) - Junior Developer (2019-2021) Promoted in 2 years vs. company average of 3.5 years\"\nThe second format clearly shows growth within a single company and explicitly highlights faster-than-average promotion, which is a strong positive signal. (You may also want to carry over your promotion cadence into your “About” section, as you saw above.)\nThis one is particularly crucial if you have a foreign-sounding name and/or education outside the US. I've seen many qualified candidates get passed over because recruiters assumed they needed visa sponsorship when they actually didn't. Don't leave this to chance.\nMake your work status explicit in your header or summary section:\n❌ No mention of work authorization (leaving recruiters to guess)\n✅ \"US Citizen\" or \"Green Card Holder\" or \"Authorized to work in the US without visa sponsorship\"\nIf you've switched careers, your resume can look confusing without proper context. Recruiters might struggle to understand why someone with your background is applying for this role, or they might not recognize how your previous experience translates to your current trajectory.\nAddress this head-on in your “About” section.\n❌ Listing previous career experience with no explanation of your transition\n✅ \"Transitioned from marketing to software engineering in 2021 after completing a bootcamp\" or \"Former accountant who pivoted to data science through self-study and online courses while continuing full-time work\"\nThis context helps recruiters understand your timeline and puts your current title and achievements in perspective. Without it, you risk serious misinterpretation:\nBoth misinterpretations can be fatal to your application. By providing a clear timeline of your transition, you help recruiters accurately gauge your experience level and set appropriate expectations. This transparency also demonstrates valuable traits like adaptability and determination.\nAnd here's another key point for career changers: you don't need to list all your previous positions before the transition... unless they're impressive. Be selective about what pre-transition experience you include:\n❌ DON'T include mundane or irrelevant details from your previous career that add nothing to your current narrative. Your three years as a retail associate before becoming a developer probably won't strengthen your software engineering application.\n✅ DO highlight prestigious achievements from your previous career. If you were, say, a concert pianist, a lawyer who graduated from a top-tier law school, or a management consultant at McKinsey, absolutely include that. These signal that you're smart and high-achieving, regardless of domain.\nIf you do all these things, you may or may not see a return. After all, even the impact of these tweaks pales in comparison to having top brands on your resume. But, given that these will take you a few minutes to do, it doesn’t hurt. Here’s the TL;DR:\nFootnotes:\nI have no idea what the average promotion cadence is at Amazon, and this example is meant to be illustrative rather than accurate, though maybe my readers will tell me the cadence now. ↩\nI realize this diverges from the advice in Beyond Cracking the Coding Interview, where Gayle recommends including it if it’s 3.0 or more. This is one of the cases where the authors had differing opinions. We’re (mostly) human. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/stop-trying-to-make-recruiters-think-or-why-your-resume-is-bad-and-how-to-fix-it",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Why resume writing is snake oil",
      "content": "I just asked ChatGPT to size the global resume writing industry. Here’s what it had to say:\nThe global resume writing industry was valued at approximately $1.37 billion in 2024 and is expected to grow steadily, reaching around $1.44 billion by 2025, and about $1.59 billion by 2033... The growth is driven by increased demand for professional resume services due to heightened job market competition, coupled with advancements in technology and personalization through AI-driven resume writing tools.\nI don’t know if these numbers are exactly true, and I don't know what portion of that is resume writing for engineers specifically, but it doesn’t really matter. I am certain that they are directionally correct. As the market has gotten worse, I’ve heard more and more job seekers ask for resume reviews and rewrites, and I’ve seen many companies in the interview prep space start offering resume reviews.\nThey’re all selling snake oil, and no one should spend a dime on it. I’ll explain why in a little bit, but first let’s talk about something else I found on the internet.\nA few days ago, I saw this post on Reddit. It was a leaked internal set of hiring requirements (sometimes called a “hiring spec”) that looked like this:\nOf course, there was the usual Reddit shock and awe and pearl clutching about whether this hiring spec could be real.\nYes, it’s real. As someone who’s been in hiring for over a decade, I’m certain of it. And not only is it real, but it’s routine. It’s business as usual.\nI’ve been a head of talent at top startups, and I used to run my own recruiting agency where I hired for a bunch of companies who have since become household names. When I worked as an agency recruiter 10 years ago, companies regularly shared documents like this one with me. The only difference between then and now is the idea of a “diversity bonus.” Everything else hasn’t changed in a decade.\nDocuments like this are why I quit recruiting to start interviewing.io.\nAnd documents like this are the reason that the entirety of the resume writing profession is a snake oil pit.\nThere is one notable exception to this rule, which I’ll talk about, but most people should not spend a dime on resume writers. Here’s why.\nIn 2024, we ran a study where we asked 76 recruiters to look at resumes and indicate which candidates they’d want to interview. Recruiters are most likely to contact you if:\nWhat's missing? Things like, for example, having a quantifiable impact or demonstrating teamwork. Essentially, everything recruiters look for is stuff that you either have or you don't.\nIn this same study, we also learned that when recruiters do look at resumes, they spend an average of 30 seconds reviewing them. That's not enough time to read every bullet. Instead, they are mainly skimming for recognizable companies and schools.\nHere is an excellent example, also from Reddit, that makes this difference very clear.\nThis resume certainly passes the skim-test: good companies, appropriate roles, and a good university too. It's only when you actually spend more than 30 seconds reading the resume that you learn that not only is this resume obviously fake, but it also celebrates accomplishments like \"Spread Herpes STD to 60% of intern team.” And yet, it got a 90% callback rate. Recruiters just aren't reading the details.\nIn other words, either you already have what recruiters are looking for (which often may be different than what’s explicitly listed in a job description… because they certainly aren’t sharing the real “hiring spec”) or you don’t. If you have it, then you don’t need a resume writer — though it’s always smart to make it easier for recruiters to find the things they’re looking for. If you don’t have what they’re looking for, no amount of agonizing over how you present yourself is going to move the needle.\nSo, if recruiters aren’t reading and are just skimming for brands, why do people agonize over their resumes and give money to resume writers?\nIn interviewing.io’s Discord server, I regularly see requests for resume reviews. I also see other interview prep companies charging money for resume reviews. Presumably they charge because the demand is there. But why are people willing to pay for something that is completely useless?\nI think it’s a mix of misinformation and the desire for control.\nRecruiters rarely admit that they’re skimming primarily for brands. If you read recruiters’ advice for job seekers, it almost always includes advice about quantifying your impact, including your side projects1, and so on. These bits of advice are well-intentioned, I’m sure, but they perpetuate a harmful myth and an exploitative resume writing cottage industry.\nThe other reason is control. Job searches are intimidating, and putting yourself out there is hard. It’s much easier to retreat to the comfort of polishing up your bullet points because it’s something you can control. You get into a routine, rewrite your bullets, and upload your resume to a bunch of places. Then when you don’t hear back, you retreat to familiar ground, grind on your bullets some more, and rinse and repeat. Because it’s easier to believe that if you can just get your bullets right, you’ll finally hear back. That narrative sure beats out the idea that no one is reading your resume no matter how much you fine-tune it.\nIf you’re fortunate enough to have top brands on your resume, cleaning it up can be a good use of your time. I still wouldn’t hire a resume writer because the details don’t matter very much. Just make sure that recruiters can easily spot the brands.\nHere’s an example. Take a look at the before and after screenshots of the resume below.\nBefore\nThis resume belongs to one of our users who was kind enough to let us share it. He actually has two of the three things that recruiters look for: FAANG experience and a niche title (ML engineer). But both are buried! And the section that gets the most attention is wasted on undergraduate awards.\nAs you can see, he spent almost 3 years at Apple, but a recruiter skimming his resume might not notice that because it was a while ago. Instead, he showcases an undergrad award and some technologies/languages that he knows. Neither of those is nearly as useful to recruiters as FAANG experience.\nHis current title is also ML engineer, and one at the Principal level at that. But it wasn’t always: He went from back-end to SRE to a little bit of everything to ML, and because of that, it’s possible a recruiter would miss it as well.\nAfter\nWe edited this candidate’s resume to put all the things recruiters look for at the very top of the resume and moved the buzzword soup to the bottom. This candidate is obviously well-positioned because he has FAANG experience, several top schools, and niche skills — but before, many recruiters didn’t spot them. After he made these changes, the number of interviews he got increased by 8X.\nNote that we didn’t really rewrite anything. We just moved stuff around. You can do this yourself without needing a professional writer.\nIf you’re like most people, you don’t have top brands on their resume, so no amount of rewriting is going to move the needle much. Instead of agonizing over it, stop applying and start doing outreach to hiring managers. It’s your best shot to get noticed and to get someone to look at you as a human being, instead of a collection of brands. Here’s how to do it. For a deeper dive into both resume writing and how to get in the door, you can read Beyond Cracking the Coding Interview (both chapters are also available for free).\nFootnotes:\nWill side projects help you get a job? Good question and one that should be teased apart a bit. Getting a job has two components: getting in the door and doing well in interviews. In general, side projects are useless for getting in the door. Yes, every once in a while, a side project goes viral. Or if you build something really cool with your target company’s API, it can get some attention. But that’s pretty rare. Most side projects that adorn resumes go completely unnoticed. When it comes to performing well in interviews, it depends. If the companies you’re interviewing at test you on practical skills, then they can be a great use of time. They can also be a great use of time to help you understand how APIs work, how the internet works, how clients and servers talk to each other, and so on. But if the companies you’re targeting primarily ask algorithmic questions, then side projects probably aren’t the best use of time. Finally, will side projects make you a better engineer? Absolutely. And that’s the best reason to do them. But that’s not quite the same as getting a job, is it? Once you're actively looking for a job, your time is better spent on interview prep and outreach. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/why-resume-writing-is-snake-oil",
      "author": "",
      "user_id": ""
    },
    {
      "title": "It's OK to postpone your interviews if you're not ready",
      "content": "At interviewing.io, we’ve seen hundreds of thousands of engineers go through job searches, and the biggest mistakes we see people make are all variations on the same theme: not postponing their interview when they aren’t ready.\nI’ve found myself repeating that it’s OK to postpone interviews so often that I finally broke down and decided to make it a blog post. It’s very simple advice, so the bulk of this post will be spent trying to convince you that it’s fine to postpone. And then of course I’ll tell you what to say.\nDo any of these situations sound familiar?\nBoth of these situations are extremely common, but they’re both preventable. You can just ask to postpone. There are a few edge cases where that’s not a good idea, but in most situations, it’s the right thing to do.\nIf you’re applying to a large company with a centralized process (in other words, a process where you interview first and get matched with a team later), postponing is almost always OK. These companies are perpetually hiring, and their open roles are evergreen.1\nEven if you’re applying to a large company with a decentralized process (where you interview for a specific team), we recommend postponing unless you’re extremely excited about the team you’re talking to. In that scenario, it’s possible that if you postpone, the slot will be filled. But if it’s not a perfect fit and you’d be OK with another team, we recommend postponing — in the worst case, you’ll simply get slotted into a different team.\nThe only time when postponing isn’t a good idea is when you’re applying to a very small company that has just one open headcount. In that scenario, it is possible that postponing will cost you the opportunity because they’ll choose another candidate. However, you can ask how likely that is to happen, up front.\nWith that edge case out of the way, here’s a little-known fact about how timing works at large companies: Recruiters don’t really care when you interview. Though they’d prefer that you interview sooner rather than later so they can hit their numbers, at the end of the day, they’d rather be responsible for successful candidates than unsuccessful ones.\nEvery recruiter, in every job search, will tell you that time is of the essence because of all the other candidates in the pipeline. Most of the time, that is irrelevant and just something they say to create an artificial sense of urgency. There are always other candidates in the pipeline because the roles are evergreen. But they have nothing to do with your prospects.\nYou can use this text verbatim when postponing your interviews, and, with some small edits, you can even use it several times (e.g., before the phone screen and then again before the onsite).\nI’m really excited about interviewing at [company name]. Unfortunately, if I’m honest, I haven’t had a chance to practice as much as I’d like. I know how hard and competitive these interviews are, and I want to put my best foot forward. I think I’ll realistically need a couple of months to prepare. How about we schedule my interview for [date]?\nOne important thing to remember is to be conservative about how long it will take. You’ve probably heard the adage about how, when you have to estimate the time an engineering task will take, you should think of a number and double it. Here, you may even want to triple it.\nI’ve seen many candidates ask for 2 weeks because that feels like a reasonable thing to ask for, only to have it blow up in their face when they realize they need to ask for another extension (which is still worth doing but harder because the company may think you’re taking them for a ride). If you need two months, ask for two months.\nThis section is extra credit, but once you get comfortable with postponing your interviews when you’re not prepared, you can use the same skills to batch your interviews and ultimately control the timing of your job search.\nWhat does it mean to control the timing of your job search? Ideally, you want all of your offers to come in at the same time, both because it maximizes optionality (one company that arbitrarily offers first doesn’t rush you into making a decision) and maximizes leverage (you can negotiate from a position of power).\nIf you want to dive deeper into this process, take a look at a book I recently co-wrote, Beyond Cracking the Coding Interview. It includes a full chapter about how to manage your job search, which covers everything from determining the order in which to approach companies to how to speed them up and slow them down once you’re in process. There’s a lot more detail than I can touch in this post, and much of it depends on your specific circumstances, but you can probably get 50% of the way there just by postponing your interviews in batches.\nThe big insight here is that, except for the edge cases we discussed above, a recruiting process can be paused at any point.\nIn other words, you can do a bunch of outreach to companies, then do a bunch of enthusiastic recruiter calls, and THEN pause all the processes until you’re prepared to do technical phone screens.\nThen, you batch the phone screens.\nFinally, if needed, you pause again to give yourself time to prepare for onsites. Onsite interviews require a different skill set than technical phone screens. The technical phone screen isn’t about depth or fit — it’s just a way to cut people who aren’t likely to pass the onsite.\nThe onsite, on the other hand, isn’t just meant to cut poor performers. It’s at once a deeper dive into your technical ability and a way to gauge fit. If you’ll be interviewing with your future team (typical at companies with a decentralized process), it’s also meant to assess your ability to work together, collaborate on hard things, complement the team's existing skillset, and so on. It usually has some coding (to verify that your technical phone screen wasn’t a fluke), but the focus is usually on system design and behavioral interviews2, which are also the interviews commonly used for leveling decisions.\nSo, onsite prep is much more about system design and getting your stories right for your behavioral interviews. Some people can pull off prepping for both coding and sys design/behavioral at the same time. For many, depending on their existing familiarity with the material, it’s a tall order. So, it’s wise to take the time you need and prepare.\nThen, once you’re ready, you batch the onsites.\nWhen your offers come in, you should ask for extensions as needed, speed companies up, and start negotiating (which we’ve written about in the past and which, of course, is covered at great depth in the book).\nFootnotes:\nYes, it’s true that in 2022, we saw several FAANGs and many other companies freeze hiring, and if you had postponed your interviews, you’d have been left out in the cold. Despite how devastating these freezes were to affected candidates (and to the tech economy as whole), they are extremely rare, and in our humble opinion, not worth optimizing for or worrying about. You are very unlikely to have to deal with an impending freeze. ↩\nSome companies will also have technical deep dives, project presentations, assessments of niche skills, and so on. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/its-ok-to-postpone-your-interviews-if-youre-not-ready",
      "author": "",
      "user_id": ""
    },
    {
      "title": " Read nine chapters of Beyond Cracking the Coding Interview for free",
      "content": "Along with Gayle Laakmann McDowell, Mike Mroczka, and Nil Mamano, I wrote the official sequel to Cracking the Coding Interview. It's fittingly called Beyond Cracking the Coding Interview..\nNow, we're releasing 9 chapters of the book for free! There are two PDFs in the linked folder:\nTake a look, and let me know what you think. You can reach me at aline@interviewing.io.\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/nine-free-chapters-of-beyond-cracking-the-coding-interview",
      "author": "",
      "user_id": ""
    },
    {
      "title": "We co-wrote the official sequel to Cracking the Coding Interview",
      "content": "EDIT 2: Read 9 chapters of the book for free! These include:\nEDIT: Beyond Cracking the Coding Interview is out now! Here's the table of contents:\nI have some exciting news. Along with Gayle Laakmann McDowell, Mike Mroczka, and Nil Mamano, I’m writing the official sequel to Cracking the Coding Interview (often called the bible of technical interview prep). It's fittingly called Beyond Cracking the Coding Interview.\nI’ve always wanted to write a book about technical interviewing. And this is it. And of course it'll draw on all the hiring data we've collected over the past decade at interviewing.io.\nTechnical interviews are much harder today than they used to be. Engineers study for months and routinely get down-leveled despite that. Beyond Cracking the Coding Interview, in addition to covering a bunch of new questions and topics, teaches you how to think instead of memorizing. Grinding and memorization isn’t the way in this market (though in fairness, it’s never really the way). With us, you’ll still have to do the work, of course, but we’ll teach you to work smarter.\nWe added at least thirteen new technical topics (I say “at least” because we’re still writing, and it might be more like twenty)—and over 150 new problems. Each problem includes step-by-step walkthroughs, and you can work each problem with our (actually good) AI Interviewer. And of course this book was written in partnership with interviewing.io. We’ve pulled in data from over 100k FAANG mock interviews on interviewing.io, and we include hundreds of curated interview replays from interviewing.io (shared with permission of course) – watch people make mistakes and learn so you’re not doomed to repeat them.\nBut it’s not just about interview prep. In today’s job market, the bar is higher but it’s also harder than ever to get noticed and run your job search end-to-end. My excellent co-authors killed it on the technical chapters. I focused on writing the job search stuff, including, but not limited to:\nI also spend some time on owning and sharing data on how flawed technical interviewing is and, most importantly, how to manage your psychology so you can get past that. I see so many engineers opting out of this interview style, arguably for good reason. But you’re leaving a lot of good opportunities on the table, and it doesn’t have to be like that.\nThis book is so much of what I’ve blogged about for the last 15 years, but it’s fleshed out with much more detail and actionable advice. If you read it, let me know what you think. Technical interviewing sucks (and so does looking for a job). But this book will help you do it well and get out alive.\nPurchases of Beyond Cracking the Coding Interview get a $50 discount for interviewing.io. The book costs $45, so it’s not a bad deal. The book is out in January of 2025, and you can get it on Amazon.\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/we-co-wrote-the-official-sequel-to-cracking-the-coding-interview-introducing-beyond-ctci",
      "author": "",
      "user_id": ""
    },
    {
      "title": "I love meritocracy, but all the recent anti-DEI rhetoric is bad",
      "content": "I’m the founder of interviewing.io, an anonymous technical recruiting marketplace. In some ways, I’m the meritocracy hipster who was writing about how eng hiring should be meritocratic and about how quotas are bad, way before saying either was cool. At interviewing.io, my team and I have been trying to make hiring meritocratic for the last decade. Briefly, we do anonymous mock interviews. If people perform well in those interviews, they get introduced directly to decision-makers at top-tier companies, regardless of how they look on paper. 40% of the thousands of people we’ve helped were excellent engineers who did not look good on paper and would NOT have gotten in the door through traditional, “meritocratic” channels. Many of those engineers were rejected based on their resumes by the very same companies where they were later hired through us.\nRecently, there’s been a lot of pro-meritocracy, anti-DEI rhetoric. The most salient example is Alexandr Wang’s (CEO of Scale AI) tweet about how their hiring process has to be meritocratic (including a catchy new acronym, “MEI”).\nToday we’ve formalized an important hiring policy at Scale. We hire for MEI: merit, excellence, and intelligence.\n— Alexandr Wang (@alexandr\\_wang) June 13, 2024\nThis is the email I’ve shared with our @scale\\_AI team.\n———————————————————\nMERITOCRACY AT SCALE\nIn the wake of our fundraise, I’ve been getting a lot of questions…\nThe post got a resounding “Great!” from Elon Musk a half hour later, followed by a wall of accolades from the Twitterverse. Since then, a “meritocracy board” has sprung up as well.\nIf you read Wang’s post carefully, you’ll see that he provides no specific examples of how Scale AI makes hiring meritocratic and doesn’t share any details about their current hiring process. I don’t know anyone from the Scale AI team personally, but after doing eng hiring in some form or another for over 15 years, I have questions. Does Scale AI’s hiring process differ substantially from other companies’? Or are they doing the same thing as everyone else: recruiters look at resumes, pick people who have top brands on their resume, and interview them?\nIf their process is indeed like everyone else’s, no matter what they say, they’re no more meritocratic than the companies who tout DEI hiring practices… and are just virtue signaling on Twitter.\nI’ll be the first to admit that DEI is ideologically flawed because of its emphasis on race and gender-based outcomes and its insistence on equality of those outcomes. In the last decade, we’ve seen some pretty bad DEI practices, the most egregious being a company looking up candidate photos on LinkedIn and rejecting qualified white, male candidates. (I talk more about the worst-offending hiring practices I’ve seen over the last decade in the section called The dark side of diversity… and two stories of diversity initiatives gone wrong below. If you just want the juicy bits, read that part.)\nHowever, yelling “Meritocracy!” as if it’s a fait accompli is just as harmful as the worst parts of DEI. In the last decade, we’ve seen countless companies claim to be meritocratic but refuse to talk to candidates unless they had a CS degree from one of a select few schools. There is nothing meritocratic about that. After seeing the pendulum swing back and forth a bunch in this space, I’d even go so far to say that, ironically, the DEI movement has done more for meritocracy than the loud pro-meritocracy movement is doing right now.\nI’m delighted that “meritocracy” is no longer a dirty word. But, just saying it isn’t enough. We have to change our hiring practices. We need to stop using meritocracy as a shield to preserve the status quo. If we could instead put into practice the best part of DEI – openness to hiring candidates from non-traditional backgrounds while eliminating the toxic hyperfocus on race and gender and the insistence on equality of outcomes, then we could create a real meritocracy, which is what most reasonable people actually want.1\nA quick disclaimer before we go further. To the right, DEI has come to mean mediocrity, and as such, it’s pitted, apples to apples, against meritocracy. That is not the intent here. When I talk about DEI, I’m not talking about the political side of it or how it’s often co-opted by the left as a gateway to Marxism. Similarly, meritocracy has been co-opted by the right to justify racism, eugenics, and god knows what other horrid things. Both extremes are bad. I’m trying to shed all political associations from either word and to just talk about them purely as hiring ideologies.\nOn its face, increasing diversity sounds great. Some groups are underrepresented in tech, likely because of inequality of opportunity. Talent is distributed uniformly, opportunity is not. Let’s fix it!\nTwitter threads like this one (from an engineering leader at Google) are hard to argue with. You should read the whole thing — it’s about a (white) lumberjack’s son who ended up as one of the founding employees at SpaceX.\nEveryone loves SpaceX, and thinks of Elon as the genius founder that invents new types of rockets that are cheaper, faster, more efficient.\n— Mekka 💉x7 @mekkaokereke@hachyderm.io (@mekkaokerekebye) January 5, 2019\nIt's fun to think of it as SpaceX versus NASA, or Silicon Valley vs Aerospace.\nBut let's talk about D&I, and logs. Logs as in timber. 🌲\nAnd indeed, ostensibly, DEI is hard to argue against because it speaks to our innate desire for fairness and equal access to opportunity. Many DEI leaders honestly believe this. However, despite the good intentions, in practice, DEI tends to laser focus on race and gender outcomes, and that is hard to argue for.\nOver the years, I’ve seen claims that diverse teams perform better, as well as claims that one must have a diverse workforce if one has a diverse customer base. Though it’s often stated as fact, the former is inconclusive — there are studies with clear results for AND clear results against.2 To the best of my knowledge, the latter point is unsubstantiated as well — isn’t the hallmark of a good designer that they be able to design for customers who are different than they are?3\nThe arguments for diversity are inconclusive, and as such, the ultimate measure of success for diversity isn’t about the performance of an organization or about customer satisfaction. Those are packaged up as obvious side benefits. The way we measure success for diversity is tautological: success is measured by the diversity of our workforce.\nWhat does that mean? In practice, recruiting orgs usually define success by looking at some demographic and its representation in the general population. So, in the case of women in tech, women make up half the U.S. population, so 50% of engineers in an organization should be women. Similarly, 12% of the U.S. population is Black, so for hiring to be equitable, 12% of the engineers in an organization should be Black. Likewise, 19% of the U.S. population is Hispanic, so 19% of engineers should be Hispanic, and so on.\nWhat’s the problem with this approach? It does not account for inputs. The most basic input is: How many female engineers are there in the US? And how many Black or Hispanic engineers are there in the US?\nThe answer: not enough. Only 20% of CS graduates in the US are women. And there are also not enough engineers of color to get to race parity either. Only 6% of CS graduates in the US are Black, and only 7% are Hispanic.4\nThose numbers get even more grim when you pare them down to how companies usually hire: from top-ranked schools. We’ll talk more about this pedigree-based approach to hiring when we discuss the pitfalls of meritocracy. For now, suffice it to say that a few years ago, we ran the numbers to show that getting to gender parity in software engineering is mathematically impossible given companies’ focus on pedigree; though it was unfashionable to admit it, we called out that there really is a pipeline problem.\nAnd then there’s this issue: What portion of those candidates are even applying to your company in the first place? And what portion of those applicants are actually qualified to do the work? The ONLY way to really take race and gender bias off the table is to do blind as much of the hiring process as possible and then to accept that you may not get the numbers you want but that your outcomes will actually be fair.\nIn addition to mock interviews, interviewing.io also helps companies source engineering candidates. We know how people perform in mock interviews, and that lets us reliably predict who’ll do well in real interviews. We identify the top performers from practice and introduce them to companies. We’ve been doing it for a while, and our top performers have consistently outperformed candidates from other sources by about 3X.\nI promised in the beginning of this post that I’d spill some juicy tidbits. Here goes.\nYears ago, we pitched Facebook’s university recruiting team on using us to hire for their intern class. The pitch was that we had thousands of college students from all over the U.S. who had done a bunch of mock interviews, and that we knew who the top performers were. Many of our students did NOT come from the handful of top-tier schools that Meta typically recruited from. If they were to recruit through us, they’d have to do way fewer interviews (we had already taken care of technical vetting), and they’d get a much more diverse slice of the population.\nOur only process request was that they conduct interviews with students anonymously, on our platform, so they wouldn’t be biased against top-performing students who didn’t go to top schools.\nWe didn’t get the gig. The main bit of pushback from Facebook was that anonymity violated guidelines set by the OFCCP. The OFCCP (Office of Federal Contract Compliance Programs) is part of the U.S. Department of Labor and is “responsible for ensuring that employers doing business with the Federal government comply with the laws and regulations requiring nondiscrimination.” One of the many things that the OFCCP requires you to track, if you do business with the federal government, is the race and gender of your applicants. We couldn’t agree to this. While the requirement makes sense on the surface — as they say, you can’t fix what you can’t measure — in this case, it was a Kafkaesque roadblock to achieving the very thing that the OFCCP is fighting for: reducing discrimination.5\nMore broadly, you can’t take an outcomes-based approach unless your inputs are homogenous and the playing field is level. The biggest advocates of DEI will argue, correctly, that the playing field is not level. Given that it’s not level, focusing exclusively on outcomes creates all manners of perverse incentives — the dark side of diversity is the logical conclusion of an outcomes-based approach: incentivizing the selection of candidates based on race and gender and ultimately discriminating against non-URM candidates.\nWe’ve worked with companies of all sizes, from seed stage startups to FAANG, and at one point or another, we’ve worked with most FAANGs and FAANG-adjacent companies. We’ve seen it all. In 2022, at the height of diversity fever, one well-known FAANG-adjacent customer approached us with a specific request. Let’s call them AcmeCorp (name obviously changed; they’re a household name, but I don’t want to rake them over the coals publicly because they were a great partner to us until this thing happened).\nAcmeCorp’s recruiting team wanted us to do some pre-filtering on the candidates we introduced to them.\nWe already do some pre-filtering: location, years of experience, visa status, and obviously historical performance in mock interviews. Only the top few percent of our candidates get to talk to employers.\nBut on our platform, everything is candidate driven. We don’t have a searchable candidate database, and we don’t share candidate data with companies. Rather, we list the companies who hire through us, and our top-performing users can connect with them.\nOver our lifetime, plenty of companies have approached us asking if they could get access to just top-performing women and people of color on our platform. It makes sense. Recruiters are given marching orders to find more “diverse” candidates, and this is the result. And it’s a convenient way to pass on liability. Now, instead of their sourcers having to filter out candidates who aren’t “diverse”, we have to do it.\nOf course, we’ve always denied these requests. We’re not a “diversity” platform, and we can’t imagine a world where we’d block what jobs and employers our users could see based on their race and gender (information we don’t collect systematically in the first place).6\nEven though, on their face, these requests weren’t really OK, we got so many of them that, over time, we got desensitized and would joke internally about how yet another company wanted a binder full of women.\nHowever, AcmeCorp’s request was more egregious than the rest because it gave us visibility into how many companies were behaving internally when faced with diversity goals. It was common knowledge that many companies were doing diversity-specific sourcing, so we weren’t shocked when we were asked to help with that. What wasn’t common knowledge is that companies were blatantly rejecting qualified applicants who didn’t meet their diversity criteria.\nAcmeCorp had a fairly complex candidate filtering process in place, and they wanted us to run that same process on any of our top performers who expressed interest in working there.\nHere’s how their process worked. Note that AcmeCorp, like many companies, pays differently depending on where you live.\nIn other words, a white man from San Francisco would have no shot at getting an interview at this company — he would be auto-rejected and left to wonder what was wrong with his resume.\nWhy did this company take this approach? They were willing to pay top dollar for women and people of color but not for other types of engineers, and they hid behind geography to do it. Because of the geographical element, it’s not as blatant as outright rejecting people based on race and gender, but for all intents and purposes, it’s the same.\nOutside of this practice being questionably legal at best, it’s also unethical. You can argue that companies should be able to do outreach to any demographic groups that they want. It’s much harder to argue that it’s ok to reject applicants based on their race and gender.\nWe terminated the relationship.7\nUnfortunately, when you tie the success of your recruiting program to gender and race outcomes, these are the behaviors that inevitably arise. For all its flaws, though, the DEI movement, coupled with increasing demand for engineers, propelled companies to make deep changes to their hiring processes. For every DEI horror story, there is an equal and opposing story about a Head of Talent or investor engineering leader who persuaded their eng hiring managers to stop looking just at students from MIT and Stanford, to change their interview processes, to blind resumes, and to do a bunch of other useful things that benefitted every non-traditional candidate.\nBut, back to what’s happening today. You don’t just get to say “meritocracy” and be done with it. In practice, meritocratic hiring doesn’t really exist, and what companies call meritocracy is anything but.\nFor most sane people, the concept of meritocracy is hard to argue against. Shouldn’t the most qualified person get the job?\nUnfortunately, because the definition of “qualified” is murky, meritocracy often becomes a justification for over-indexing on pedigree: where people went to school or where they worked previously. “We just hire the best” often means “we hire people from FAANG, MIT, and Stanford.” Unfortunately, those are proxies for ability, not actual measures of it. Our research has consistently shown that where people go to school isn’t very predictive of what they can do. Where they’ve worked is somewhat predictive, but it’s not the most important thing.8\nDespite that, those are the main criteria that companies use when they decide whom to interview, and because that’s the first step in a hiring funnel, it’s the one that gets applied to the most candidates. Any attempts at making the process meritocratic after the resume review (e.g., training interviewers, doing anonymous interviews) are bound to be less impactful because they affect 10X-100X fewer candidates.\nFortunately, for all their flaws, at least technical interviews do focus on ability — once you get in the door, it’s not about how you look on paper but about how you perform. As a result, all other things being equal, how you decide which candidates to let into your process is the litmus test for whether your process is truly meritocratic or not.\nUnfortunately, the pedigree-based approach isn’t particularly meritocratic. In our 9 years, we’ve diligently tracked the backgrounds of our candidates, and as I mentioned in the intro to this post, about 40% of our top performers don’t look good on paper (but do as well as or outperform their pedigreed counterparts in interviews).\nOne of our users got rejected from a top-tier social network company three times… THREE TIMES… based on his resume before he got hired there through us, after doing very well in an anonymous interview. I’ve shared a few diversity horror stories, but the sad reality is that (faux) meritocracy horror stories like this one happen every day. I wish I had a real meritocracy horror story to share, but as far as I know, eng hiring has never been truly meritocratic. If you know otherwise, please do share.\nOur data also shows that pedigree has very little bearing on interview performance. Where people went to school has no bearing on their interview performance, and though where people have worked does carry some signal, it’s not nearly as important as other traits — in past research, we’ve found that not having typos/grammatical errors on your resume is a much stronger signal than whether they’ve worked at a top company, as is whether they’ve done a lot of autodidactic work.8\nMoreover, in two separate studies completed a decade apart, where recruiters had to judge resumes and try to pick out the strong candidates, we consistently saw that recruiters are only as accurate as a coin flip and largely disagree with each other about what a good candidate looks like.9\nThat’s why posts like the one from Scale AI get my hackles up. You don’t get to say that you’re meritocratic if you’re just scanning resumes for top brands. That’s not meritocracy. It’s co-opting a hot-button word for clout.\nAnd it’s not just Scale AI. This is how tech companies define being meritocratic and hiring the best. It’s just that not all of them are so self-congratulatory about it.\nSo how do you ensure that your hiring is actually meritocratic?\nIn a recent study, we looked at how recruiters read resumes and how good they are at finding talent. As you saw above, we learned that recruiters are barely better than a coin flip. Another thing we looked at in the same study was what made them pick certain resumes over others.\nThe two traits that were the most predictive of whether a recruiter would pick you? First, whether you had top brands on your resume, and second, whether you were Black or Hispanic. This is how recruiters work today. If you don’t intervene and make changes, today’s competing approaches will both be implemented by your team simultaneously, resulting in a farcical chimera of fake meritocracy and outcomes-based diversity goals.\nSo what can you actually do, if you, in good faith, want to run a meritocratic hiring process? (By the way, if you believe that talent is distributed uniformly, by definition, this approach will entail being open to talent from traditionally underrepresented backgrounds.)\nFirst, you have to move away from identity politics and expand the definition of “underrepresented.” You have to believe, in your heart of hearts, that great talent can come from anywhere and must stop focusing arbitrarily on one marginalized group at the expense of another. Basically, you have to be open to any candidate who’s good, regardless of how they look on paper, without prioritizing race and gender. This certainly includes race and gender, but it also includes socioeconomic status, educational background (or lack thereof), and any number of other traits that have nothing to do with someone’s ability to do the job. Hell, why not just stop worrying about candidate backgrounds and have a process that welcomes all and surfaces the best? Following this path will logically require moving away from race and gender outcomes-based goals.\nThen, you have to accept and internalize that your current method of deciding who gets to interview, which is very likely focused on brands (where people have worked or where they’ve gone to school), is not only NOT meritocratic but also ineffective. We talked above about how pedigree is very limited in its ability to predict performance.\nIf you accept both of these premises — expanding the definition of “underrepresented” and moving away from focusing on brands — the hard work begins. Companies have used resumes (and brands by extension) since time immemorial because they’re easy, and as you saw in our data above, they do carry some signal. But even though they carry a little signal, recruiters are not very good at extracting it.\nHere’s what you should do to pragmatically and realistically revamp your hiring process to be more meritocratic. I challenge Scale AI and all the leaders on the “meritocracy board” to publicly commit to at least two of these — or to name the specific, actionable approaches they plan to take.\nFirst, SLOW DOWN. In the study I mentioned above, we saw that recruiters take a median of 31 seconds to judge a resume, but spending just 15 extra seconds reading a resume could improve your accuracy by 34%.\nOur second piece of advice is this. More than 20 years ago, Freada Kapor Klein from Kapor Capital coined the term “distance traveled,” referring to what someone accomplished, in the context of where they started. For instance, Kapor Klein recommends that, in their admissions processes, universities should consider not just the number of AP tests a candidate has passed but the number of AP tests taken divided by the total number offered at their high school. For example, if an applicant took 5 AP tests and their school offered 27, that paints a very different picture from another applicant who also took 5 AP tests when that’s the total number offered at their school. Kapor Capital uses distance traveled as one of their metrics for determining which entrepreneurs to fund. One can easily apply this concept to hiring as well.\nThe data shows that slowing down is important, and as part of slowing down, when you read a resume, try to evaluate candidates’ achievements, not in a vacuum, but in the context of where they came from. Think about the denominator. But don’t think for a moment that we recommend that you lower the bar — absolutely not. On interviewing.io, we regularly see nontraditional candidates objectively outperforming their FAANG counterparts.\nMy friends at KeepSafe and I ran an experiment about a decade ago where we tried replacing resumes with a writing sample about a past project. It was a huge success.\nEven today, when we hire at interviewing.io, we use this approach. We mostly hire off of our own platform (we just list our own open positions alongside others). However, not all of our users have done enough mock interviews to have a rating, and for those users, we have a different flow where we ask them to write about a past project. Boy, are the results telling.\nHere’s what our application form looks like. Steal it if you want.\nTake-homes and asynchronous assessments are not well-loved by candidates, primarily because of value asymmetry. They ask a lot of the candidate but nothing of the company, and it’s not uncommon for a candidate to have to do hours of work and then never hear anything back.\nTo be clear, this is NOT the setup we’re advocating. Here’s what we’d advise instead:\nGive candidates the option of doing a take-home/assessment that takes no more than 1 hour, instead of submitting their resume. When we say option, we mean that the candidate can decide whether they want to do the take-home or not. If they choose not to, then you’ll read their resume, hopefully using our suggestions above. If they choose to complete the take-home, then you forgo their resume and make your go/no-go decision based entirely on the results of the take-home.\nIf you choose this route, it’s critical to come up with an assessment whose results you trust. Many companies use a take-home in addition to getting the resume and will still not move forward with candidates who look good on paper. That’s not meritocratic. Take the time you need to come up with a question that’s hard to cheat on and that gets you the signal you need. Yes, coming up with a good assessment takes work. But no one said that making your hiring process meritocratic was easy.\nThis advice probably applies more to big companies than smaller ones, because bigger ones have more resources to effect change. Regardless, if you believe in meritocracy, then you understand that a true meritocracy is not possible without a level playing field for your candidates. One of the best things about the DEI movement is that it’s made us aware how unlevel the playing field really is. Whether you subscribe to DEI or not, this is probably not a controversial statement, and if you want to see true, meritocratic hiring, you have some obligation to help promote equality of opportunity.\nWhere to begin?\nAlthough I expect that it’s not level in many places, and there are plenty of opportunities to effect change, starting with elementary education11, I'll talk about the inequality I’ve observed firsthand repeatedly over the last decade: the technical interview practice gap. How much you practice is the biggest predictive factor of interview performance — not seniority, not gender, and not a CS degree. And so is socialization. After all, if you’re around people going through the same thing, like at a top-tier CS school, rather than beating yourself up after a disappointing interview, you’ll start to internalize that technical interviewing is flawed and that the outcomes are sometimes unpredictable. Fortunately, there are interventions one can make to close these gaps, and the simplest is to provide practice and community for people who don’t have access to them. Reach out to us about this, find a non-profit that helps people practice, donate to your favorite university if they have a good practice program, or any number of other things.\nUltimately, which gap you choose to help close and how you choose to do it is up to you. But if your company has the means, it’s your responsibility to invest in gap-closing measures. You don’t have to donate money. You can offer mock interviews to your candidates before their real interviews. You can start an apprenticeship program. You can encourage your engineers to do some tutoring. However you approach it, though, you can’t talk about meritocracy with a straight face and not do something to level the playing field.\nFootnotes:\nIn fairness, the Scale AI post positioned them as symbiotic. I believe that as well. ↩\nThere are many sources arguing for and against diversity leading to better-performing teams. Here are some examples:\nFor: https://www.mckinsey.com/featured-insights/diversity-and-inclusion/diversity-wins-how-inclusion-matters\nAgainst: https://medium.com/the-liberators/in-depth-the-double-edged-sword-of-diversity-in-teams-765ff72a55da (except for “age diversity”) and https://corpgov.law.harvard.edu/2021/05/25/diversity-and-performance-in-entrepreneurial-teams/ ↩\nOne of the most insulting examples of the “we need a diverse workforce to serve our diverse customer base” argument occurred when I was pitching Amazon on using interviewing.io to hire. This was years ago, and back then, out of curiosity, I’d always ask the organizations we were pitching why they valued diversity. I don’t think I ever got a good answer, but this one was especially bad. One of the recruiters we met with went on a long diatribe about how Amazon sells lots of shoes and you need women on the eng team because women understand shoes better than men. ↩\nGetting more women and people of color to study computer science is a worthy cause. Hell, getting anyone who’s historically been marginalized to study computer science is worthwhile. It’s great for our economy, and it’s currently one of the best levers for upward social mobility available. But, while we hope more companies do these things, it is not reasonable to expect that companies can be responsible for educational interventions that often need to start at the elementary school level. Of course, companies should do what they can. But expecting them to pull off mathematical impossibilities is irrational, and the DEI movement’s stalwart refusal to acknowledge the pipeline problem undermines the movement as a whole. ↩\nI was actually able to get in touch with a former OFCCP higher-up who admitted that rejecting anonymity in hiring was against the spirit of OFCCP requirements. But they sadly wouldn’t go on the record. ↩\nThe closest we’ve ever come to doing this is our Fellowship program, where we gave free practice to engineers from traditionally underrepresented backgrounds. It was a great program, but what made it great was that our interviewers were eager to help these candidates. We were able to do free practice because our interviewers graciously agreed not to charge. That said, if I were to run this program again, I’d probably focus more on socioeconomic status and non-traditional credentials rather than just race and gender. ↩\nHere’s the email we ended the relationship with. I’m including it because it was hard to write and even harder to hit send on, but I think we did the right thing, and maybe someone else will need to write something like this in the future… in which case, please steal our copy. ↩\nResearch that shows that having attended a top school isn’t very predictive and that, while experience at a top company is somewhat predictive, it’s not the most important thing:\nAnyone who’s read my writing for a long time will pause here and wonder why I’m OK with resumes and recommending anything about reading them. Until recently, I was stalwartly against resumes and convinced that they carried no signal whatsoever. Then, as part of the recruiter study I mentioned, we built some simple ML models to judge resumes and compared their performance to human recruiters. They all outperformed recruiters, and that surprising result made me reverse my stance. ↩\nFirst study (2014): https://interviewing.io/blog/resumes-suck-heres-the-data\nSecond study (2024): https://interviewing.io/blog/are-recruiters-better-than-a-coin-flip-at-judging-resumes ↩\nThere are other gaps that start way before someone gets to college. Enumerating the is out of scope of this piece, but this writeup by the National Math and Science Initiative is a good place to start. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/i-love-meritocracy-but-all-the-recent-anti-dei-rhetoric-is-bad",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How well do LeetCode ratings predict interview performance? Here's the data.",
      "content": "Mike Mroczka, a former senior SWE (Google, Salesforce, GE), is the primary author of Beyond Cracking the Coding Interview—the official sequel to Gayle McDowell's original CTCI. He works as a tech consultant and has a decade of experience helping engineers land their dream jobs. He’s a top-rated mentor (interviewing.io, Karat, Pathrise, Skilled.inc) and the author of viral technical content on system design and technical interview strategies featured on HackerNews, Business Insider, and Wired. He also sometimes writes technical content for interviewing.io (like this piece) and was one of the authors of interviewing.io’s A Senior Engineer's Guide to the System Design Interview.\nYou can find him online at mikemroczka.com, LinkedIn, and X.\nHave you ever wondered if you should spend more time on LeetCode, participate in those contests, or focus on solving harder problems? A popular Reddit post suggests you need 700+ questions and a LeetCode rating between 1800-2000 to pass FAANG interviews. Is this really what the data supports? To answer these questions and more, we looked at our users' LeetCode ranks and ratings and tied them back to interview performance on our platform and whether those users worked at FAANG.\nIn this post, we’ll share what we’ve learned.\ninterviewing.io is an interview practice platform and recruiting marketplace for engineers. Engineers use us for mock interviews. Companies use us to hire top performers. Hundreds of thousands of engineers have used our platform to prepare for interviews, and we have performance data for over 100k technical interviews (split between real interviews and mocks).\nWe surveyed almost 700 of our users and asked them to share their LeetCode and LinkedIn profiles. From those profiles, we pulled our users’ employment history, as well as their LeetCode data: number of problems worked, ratings, and, if they had it, contest performance. Finally, we cross-referenced all this data with their performance in mock and real interviews on interviewing.io.\nThis data set allowed us to start asking interesting questions. How much LeetCoding is useful? What kinds of problems are most useful to practice? How does LeetCode performance relate to performance in interviews with real people? Do LeetCode contest scores predict interview performance, and is a competitive coder likelier to work at a big tech company? Are hard questions worth solving or should we just stick with mediums? Let's find out!\nThe matrix below summarizes our findings. In addition to all LeetCode fields listed below, we also looked into global ratings and contest ratings. It was harder to find a large enough sample size to see any effect of those who did contests. Since the results were not large enough to be informative we have excluded them from the rest of this piece. All findings listed below are statistically significant, with lighter squares indicating stronger correlations.\nFor each profile, we looked at the following attributes:\nThis matrix summarizes the correlations between LeetCode attributes (y axis) with 1) whether people worked at a FAANG and 2) how well they performed in interviews on interviewing.io (x axis). The higher the number (and the darker the color), the stronger the relationship.\nFor instance, the number of questions a user solved correlates with working at a FAANG company and a user’s percentile ranking on interviewing.io. We see that it is a stronger predictor of interview performance than it is for working at a FAANG company (0.27 and 0.17, respectively).\nLet's dig into the most exciting findings!\nUnsurprisingly, the total number of questions a user has completed correlates with having FAANG on their resume and doing well in technical interviews. Those who work at FAANG companies appear to have completed more questions than those who do not.\nDon't fret, though, as this doesn't mean you're doomed to be behind people who have started sooner and have amassed thousands of questions. The vast majority of our top users stop LeetCoding after they've hit about 500 questions. Only a fraction of top users have done more than ~500 questions, and only about 10 did more than a thousand questions. As you might expect, there are seriously diminishing returns associated with doing more than 500 questions. Those who continued past the 500 questions performed only marginally better than those who had stopped near 500.\nIn the zero-sum interviewing game, those who complete the most LeetCode questions generally get the highest interview scores and work at the most desirable tech companies, but completing ~500 questions will put you among the top talent in the current market.\nIt is common wisdom on the LeetCode discussion board and subreddits to \"do medium questions, not hard questions,\" with the argument that companies don't ask LeetCode hards. Does this advice stand up to scrutiny? Mostly no.\nThe data shows a clear bias towards those who solved more challenging problems, the exact point at which this matters is up for debate. At interviewing.io we find that before tackling difficult questions, you just need to first start doing problems. Getting started matters more than attempting to complete a particular question difficulty, so don't focus arbitrarily on medium/hard questions, just focus on practicing!\nTip 1: Start with anything. Getting started matters more than picking the perfect set of questions. For those just starting, you might think, \"I'm a straight-A student and a fast learner, so I should be able to manage hard questions.\" Don't make this mistake, or you'll burn out quickly. Instead, just focus on doing questions and getting into the habit of translating your thoughts into code efficiently.\nBefore tackling mediums and hards, we need to first get good at easy questions. Once we can tackle mediums, for each additional 50 questions you complete, you increase your score of passing your interviews by three percentage points.\nOn the other hand, a LeetCode hard carries over twice the benefits of a medium question. Completing 50 hard questions increases your interview score by seven percentage points! Our data shows that you'd need to complete close to 233 medium questions to get the same benefits that 100 hard questions would give. Consider these two people (fictitious but inspired by real examples in our data):\n| Question Difficulty | Alex | Kara |\n|---|---|---|\n| Easy | 50 | 25 |\n| Medium | 630 | 50 |\n| Hard | 10 | 135 |\n| Total | 690 | 210 |\nThese two people are statistically likely to have similar interview scores, yet Kara completed half the number of questions Alex did. While it goes against standard advice, harder questions having a higher benefit make sense. A LeetCode medium tends to require you to do one thing (perform a DFS, scan an array, etc.) to get the correct answer. In contrast, hard questions require you to do multiple things (memoize results while performing a DFS, tally prefix sums while scanning an array, etc.). The compounding nature of multiple tasks in harder questions necessitates deeper learning in fewer questions.\nAdmittedly, there is a chicken-and-egg scenario going on here. Naively, one might think everyone should just do hard questions, but that doesn't work in practice. Jumping straight to hard questions is an infeasible leap for most people, and the reason many people can complete hard questions is precisely because they have finished many medium questions first. Our advice is not to jump to hard questions immediately. Instead, you should be mindful and not stay at the medium difficulty level longer than necessary. It isn't that the advice to \"do medium questions\" is wrong—it is just overused. It is natural to want to be able to complete a question regularly in a short period of time. Still, if you find yourself completing LeetCode mediums quickly, it indicates that you have stagnated and would be better off moving on to hards. If you have solved 100 or more medium questions, you'll likely get more bang for your buck by transitioning to hard.\nTip 2: Don't ignore hard questions. Balance your medium questions with the hard ones. The compounding nature of multiple tasks in harder questions necessitates deeper learning in fewer questions.\nFinally, we must also acknowledge that not all hard questions are created equal. This tip is my gut feeling, and we don't have data to back it up, but intuitively, we've all done hard questions that seem impossible, hard questions that seemed like they should have been rated medium, and even medium questions that seem like they should have been hard. Question difficulty is somewhat subjective, so if you focus on hard questions, choose questions with a high acceptance rating and/or ones that are \"frequently asked.\" These questions tend to be achievable (they don't have a single impossible trick you need to just have known), realistic (they don't test nonsense algorithms no one knows like Manacher’s algorithm), and solution-flexible (there is often more than one valid approach).\nTip 3: When choosing hard questions, pick popular questions. They are more likely to be achievable, realistic, and solution-flexible, which will likely result in more learning per question.\nSurprisingly, we found no correlation between LeetCode ratings and their interviewing percentile. Those who were great at contests also didn't appear more likely to have FAANG on their resume. Two confounding variables that might have caused these unexpected results are:\nTip 4: Don't worry about contests unless you enjoy them. They provide a way to practice managing your time and keep yourself honest with how fast you are moving, but they don't contribute much to your success apart from containing more questions for you to attempt.\nIn the end, LeetCode questions are a reasonable proxy for predictors of interview performance. While ratings and contest scores don't seem to matter,1 questions —and question difficulty—do. Focus on tackling increasingly difficult questions until you've hit that point of diminishing returns near ~500. Don't stagnate with medium questions; pick popular and frequently asked hard questions, too. And don't stress if your friend has a higher LeetCode score than you do; turns out it doesn't mean much!\nFootnotes:\nA caveat here is that, strictly speaking, we're reporting correlations—not necessarily causal relationships. This leaves open the possibility that what we were measuring was not exactly a return to LeetCode but rather the effect of some third variable that increases both LeetCode activity and job prospects. For example, say MIT has a course that emphasizes coding puzzles, and MIT grads also get better jobs. In that case, what might look like a LeetCode benefit is actually an MIT benefit, and controlling for that would make the apparent benefit disappear. At the very least, though, these patterns are informative about the typical profile of successful engineers, which is likely a useful thing to emulate in general. Also, remember that our data still shows solving a healthy number of questions regardless of their difficulty can boost your chances of getting through difficult interviews. By definition, many people can pass interviews with far fewer problems completed, and many will pass after doing more problems. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/how-well-do-leetcode-ratings-predict-interview-performance",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to get in the door at top companies: cold outreach to hiring managers. Part 2 of 2.",
      "content": "In part 1 of this post, we talked about which channels are most effective for getting in the door and did an analysis of those channels along two axes: effectiveness and how much control you actually have. Here’s a quick summary.\nIn the quadrant above, you can see that while getting contacted by an in-house recruiter is very effective, whether you get contacted or not is largely out of your hands. The channel that maximizes both effectiveness and control is cold outreach to hiring managers (not recruiters!) “done right”. What does “done right” mean? That’s what we’ll talk about in this post (part 2 of 2). Most people do this type of outreach incorrectly. Here, we’ll get very tactical and tell you exactly what to say and do to reach out to hiring managers at the companies you’re interested in and actually get responses.\nHere’s our recommended, hyper-practical approach.\nIf you’re an engineer, chances are you haven’t ever done sales (maybe you had a job in high school selling Cutco knives or magazines, in which case what we’re about to say will resonate). But if you do sales for any appreciable amount of time, you’ll start thinking about everything in life as a funnel.\nFunnels are wide at the top and narrow at the bottom. That’s why they’re such an apt metaphor for the sales process — you do a lot of outreach, and you don’t get many responses. Of the responses you do get, relatively few will do the thing you want them to do. And even fewer will ultimately “close” (aka, buying — or, in this case, hiring).\nIn your engineering career, you’ve intellectually mastered many abstract concepts that are much more complex than a funnel. Despite its simplicity, however, the funnel is one of the hardest concepts to internalize emotionally, especially for people who are used to having control over outcomes. When you write code for n hours, you can expect that you will build m features.\nIn sales though, you do a lot of work, very little of it will pan out, and when it does pan out, it can feel almost random; an impersonal, mediocre email gets a response while your beautifully targeted email is met with deafening silence.\nAnd then there’s rejection. When you apply to jobs online and don’t hear back, it stings, but the sting is softened by the possibility that a human never even saw your application. You’re not reaching out to people when you apply online; you’re dealing with a bureaucratic machine.\nOn the other hand, when you email a real human and they don’t respond, that hurts: you put yourself out there, someone made a value judgment about you, and you lost.\nThe good news is that, after a while, the pain lessens, and you build up some useful emotional calluses and acquire the thousand-yard stare of someone who’s been rejected a million times for a million reasons, ranging from soul-crushingly legitimate to incontrovertibly random. Sadly, there’s no shortcut. You’ve got to do the reps, you’ve got to get the rejections, and you’ve got to pick yourself up again. You get used to it, and then it doesn’t hurt as much, because experience has taught you that if you keep going, you will eventually get to a yes.\nFirst, come up with a target list of companies. How to do that is out of scope for this post, but we may write about it in the future. For now, we’ll assume you have a list.\nOnce you have your list of companies, use LinkedIn Sales Navigator to find hiring managers at those companies (or founders or directors or VPs, as above). Below is an example query where we look for Google hiring managers.\nYou might think that Google is so big that sifting through all their various hiring managers will be intractable. Fortunately, you can whittle down the list to a pretty manageable size by applying some filters.\nHere are our filters:\nOnce you have your list, put their LinkedIn URLs into a spreadsheet. Then, do a pass through your targets’ profiles and see if any of them link to personal websites, social media accounts, blogs, or anything else that will help you find common ground with them. Add any useful links in your spreadsheet because we’ll be mining them when we actually write our emails.\nOnce you have your list of LinkedIn URLs, use a tool like RocketReach to look up their emails.\nWhy not reach out on LinkedIn? While recruiters live on LinkedIn, managers generally do not. Possibly, they don't even like or check LinkedIn much. They live in their emails, so that's where you want to target them.\nRocketReach is a nice tool for email discovery because 1) it takes LinkedIn URLs as inputs and 2) its email database is generally up-to-date and correct.1\nIf RocketReach fails or you don't wish to pay for it, you might just be able to guess their email address, as email addresses tend to follow common forms: aline@interviewing.io (my actual email address), alerner@interviewing.io, or aline.lerner@interviewing.io.\nWhere possible, contact managers via their work email address.2 In some cases, you won’t be able to find their work email, in which case it’s acceptable to fall back to their personal email.\nNext, compose a fairly personalized, yet short, email. All too often, candidates write a long, generic cover letter that’s obviously been sent to a ton of people. I get many emails that look like this:\nDon’t do this!\nDon’t do this either! There is nothing here about why this candidate is a good fit for interviewing.io, and the bullets aren’t compelling enough on their own. Note that this particular email is from a marketer, not an engineer, but the anti-patterns are the same.\nEmails like the above are impersonal, but worst of all, they have a poor signal-to-noise ratio — I want to find a reason to say yes and to invest my valuable time into this person. But they’re not giving me one, and they’re making me work for it in the process.\nMore broadly, if you want someone to go out on a limb for you, make it dead simple for them to justify expending their social/political capital on you. Hiring managers, as a rule, want to help. Make it a no-brainer for them.\nThere are three components to a great cold email:\nNot every cold email will have (1) because you won’t always be able to find common ground with everyone — there’s simply not enough information out there about some targets to be able to craft a compelling narrative that’s highly personalized to them.\nBut every cold email you write should have (2). It is your job to sell yourself quickly and succinctly. You want your target to feel like they’d be an idiot to pass up the chance to talk to you.\nThe email below is personal, succinct, and finds common ground. Not only that, but it conveniently finds common ground that benefits the candidate (a soft-spot for non-traditional candidates, like himself!).\nTo find common ground, reference something your target cares about. Then either show them that you care about it too or that helping you would fit into their worldview and further that cause.\nAs we mentioned above, finding common ground may be tough because there might not be enough information available about your target, but it’s important to do the work before you give up on this route — finding common ground is the tactic that’s going to get you the highest response rates.\nHere are some examples of great ways to build common ground:\nWe understand that you won't always be able to find common ground. But if you can, it'll help you a lot, especially if you’re light on social proof or accomplishments.\nSelling yourself is usually about one of two things:\nSome people are fortunate enough to have both, but many will have just one. That’s okay. We’ll work with what you have!\nWhat have you done that most other people haven’t? What have you done that, if you were to tell it to a stranger, would cause them to pause and think you're special or interesting?\nBelow are some examples:\nSocial proof is more about your pedigree. If you attended a top school or worked at a company known for having a high engineering bar, you should absolutely mention it! People won't click on links or open your resume until after they're interested, so you need to get them interested right away. That is: you should spoon feed them the most impressive-sounding things about you out of the gate. This may feel strange and uncomfortable, like you’re bragging. We assure you, however, that it’s necessary to get your target’s attention. They’re not thinking you’re bragging. They’re thinking, “Is this worth my time?” Your job is to convince them that it is.\nAlso, don’t forget to link to your LinkedIn or personal website. Attaching a resume may feel too heavy-handed for a first conversation, as we discussed above.\nHere's an example of a prospective intern, leveraging both social proof and accomplishments, to write a compelling email. His email isn't super personalized, but he did make some effort to say that what we do at interviewing.io is important.\nA call to action is an invitation for the recipient to do something. You can go one of two ways with your call to action: ask for a job interview or start a conversation. Which you do should be a function of how much firepower you have in the way of social proof and accomplishments. It’s not fair, but if you can get your target’s attention with one or both of those, being bold and asking for a job interview makes sense. This approach can be effective, but it won’t work for most people… because most people don’t have enough social proof or accomplishments to justify this type of request.\nIf you can’t leverage social proof or accomplishments, you’re going to have to work harder and bank entirely on building common ground, which will likely take some time and effort and involve a live conversation before they’re convinced to expend their social capital on you.\nIf you’re asking for an interview, just come right out and say it. You can use the intern candidate’s email from earlier as a guide. However, this isn’t our preferred way to do it, and we really recommend starting a conversation instead.\nTake a look at the email below.\nIn this email, the candidate doesn’t ask me about jobs — he just asks to meet to discuss a topic. Indeed, he’s done his research. I write a ton about judging resumes, and it’s a topic I could go on about for hours if you’ll let me. His email read like he’s genuinely interested in the subject and that we’d have a good conversation, so of course I responded. You’d be surprised how rare emails like this are. If you can find the topic your target cares about and write something that shows earnest, genuine interest, they’ll respond.\nWith these emails, you’re asking for a conversation, not a job interview… because the conversation is what will hopefully prove to the hiring manager that you’re worth interviewing. Then, once you have a conversation, the hiring manager will walk away with the impression that you’re a competent, thoughtful human being who’s interested in this sort of work. From there, getting a job interview will feel like an afterthought.\nAs such, don’t talk about jobs at all in this type of email, and in this particular case, don’t attach your resume — that will feel out of place and transactional. You can and should link to your LinkedIn so they know who you are and have some context. But spend the bulk of the email building common ground and coming up with an interesting reason for the two of you to talk.\nThis approach is much more effective than asking for an interview out of the gate! You’re not going to land a job from one email, so, as with any seemingly insurmountable goal, it’s important to think of your outreach as a series of steps where you put one foot in front of the other. Like in sales, all you need is to get to a conversation.\nIf your call to action is to set up a time to talk (which it probably should be because it’s specific), we recommend providing them with a time window. \"Would you want to meet up sometime?\" puts the burden on the recipient to pose a time, while \"Can we talk next Monday at 3pm?\" is problematic because, most likely, they aren't free then. Instead, try something like the candidate above did: \"Would you be available sometime within the next two weeks for a thirty-minute call? I'm free most weekdays between X and Y and can pretty much do any time on weekends if those are better for you.\"\nBelow are two templates you can use for cold outreach. The first one is ideal but requires more effort and can't always be used. The second one is weaker but more generic. You can choose what fits your needs best. We expect both of these templates to be far more effective than throwing your resume into the blackhole of online portals.\nThis template includes common ground, accomplishments/social proof, and a call to action. It will get you the highest response rates, possibly anywhere from 25-50%. However, it can be challenging to use because it requires you to 1) do a deep dive into their online presence and 2) tie what you find back to something you’re doing. Sometimes, that tie-in might be tenuous or non-existent (in which case, maybe skip it).\nHey {Their First Name},\nI’ve read your work on {insert some details about their writing}, and I {insert your thoughts on the work}.\n{If you can make the connection between their work and yours, talk about something similar you’ve been working on.}\n{If you cannot, ask them a specific, thoughtful question about your work. Don’t worry about making it “the perfect question” like you might when you attend a talk and want to sound smart. Any earnest question will do. You don’t have to use this as a chance to show off!}\n{Finally, close with a sentence or two about you, if you have some social proof or impressive accomplishments you can share.}\nWould you be up for a quick chat this week or next?\nBest,\n{Your name}\n{Insert 1-2 useful links about you. If you have a personal site, that’s great. If not, a LinkedIn will do.}\nNote that in this template, we leave some places for you to insert some social proof and your accomplishments. Even though this email is primarily about them and their work, and your references to yourself are primarily through that lens, it never hurts to drop in a few pieces of evidence that you’re someone who’s accomplished things and/or someone who looks good on paper.\nThe reality is that you won’t always have enough information about your target to find common ground. In this case, you’ll lead with accomplishments/social proof and a strong call to action. We expect this template will get you response rates anywhere from 5-25%, depending on the strength of your achievements and pedigree. That said, we recommend treating this template as a last resort. Using it means you’ve exhausted any possibility of writing something personal.\nHey {Their First Name},\n{List 2 things about you. They can be impressive accomplishments of yours or social proof, as above.}\nI’m really interested in the work you’re doing at {Company Name}. {If you know what team they’re on and are interested in that specific team or are familiar with that team’s accomplishments, great! If not, just write a few earnest sentences about why the company is interesting to you.}\nWould you be up for a quick chat this week or next?\nBest,\n{Your name}\n{Insert 1-2 useful links about you. If you have a personal site, that’s great. If not, a LinkedIn will do.}\nKeep your note short. The intent here is to make your target believe you’re an entity worth paying attention to, rather than them doing the easy thing: deleting your email.\nRegardless of which template you use, just like you have to manage your psychology when you prepare for technical interviews, you have to manage your psychology when doing outreach like this. You have to:\nNow that you’ve girded your proverbial loins, it’s time to do the work. If you follow our advice, you’ll get 1-2 orders of magnitude more responses than from applying online, and with this approach, you’ll have at least a hiring manager at that company rooting for you!\nFootnotes:\nRocketReach also has a LinkedIn-like faceted search you can use to find engineering managers, but we’ve found that it’s not nearly as reliable or rich as LinkedIn, which is why we recommend using LinkedIn for search and then RocketReach for email discovery. ↩\nRecruiters should not contact candidates on their work email address, but that's because they're trying to make the candidate leave their job. You are trying to join the manager, which is why it's okay to use their work email address. ↩\nMany people think that for something to be worth mentioning, it has to have gone viral. That’s simply not correct — in our niche space, a few hundred likes or a few thousand upvotes is already really impressive. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/how-to-get-in-the-door-at-top-companies-cold-out-reach-to-hiring-managers-part-2",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to get in the door at top companies: a data-driven guide for software engineers. Part 1.",
      "content": "In this post (part 1 of 2), we’ll share some data about which channels are most effective for getting into the door at great companies and why. In part 2, we get very tactical and tell you exactly what to say and do to get responses.\ninterviewing.io is an anonymous mock interview platform — we help engineers prepare for technical interviews by pairing them with senior FAANG and FAANG-adjacent engineers for mock interviews and feedback. In this market, many of our users are struggling with getting in the door at companies, so we ran a survey to see what’s worked well for our users and what hasn’t, in today’s difficult climate.\nIn our survey, we gave people the following channels for getting into companies and asked them which were the most and least effective:\nWe also asked them which types of companies they got responses from:\nWe got ~500 responses. Among survey respondents, which channels were most effective was largely consistent, regardless of company type, but there were some twists depending on who the candidates were. More on that in a bit.\nBelow are the channels, ranked by effectiveness.1 When more people found a channel effective than ineffective, it ended up in the first list. When more people found a channel to be ineffective than effective, it ended up on the second list.\nRecruiting channels that our users found to be effective (ranked from most to least effective):\nRecruiting channels that our users found to be ineffective (ranked from least to most ineffective):\nThis data came primarily from surveying experienced engineers (4+ years), rather than juniors (we don’t have that many juniors on our platform; average years of experience is 8). If you’re a junior engineer in this market, you already know you’re in for a tough time, and we’d advise you to take your destiny into your own hands as much as possible by reaching out directly to hiring managers (the same advice we give many of our more experienced users). More on that later in the post.\nInterestingly, these results were quite consistent between company types. In other words, channels that worked well for FAANGs tended to work well for startups and vice versa.\nOverall, the most useful channels were in-house recruiters (when they reached out to you) and warm referrals. Unfortunately, both of these channels are somewhat out of your control. You have very little control over whether internal recruiters reach out to you. There are some things you can do to increase the chances, but they’re all tied up in your work history and identity, neither of which you can easily change. We’ll talk more about that later on.\nWarm referrals (i.e., referrals from people you know), on the other hand, are very useful and are a bit more in your control, but they still depend on the quality of your network.\nBelow is a diagram comparing the utility of all the channels to how much control you have over them.\nYou might wonder why we speculatively singled out cold outreach to hiring managers as something that can be done right, versus the other channels. In our experience, that channel is both misused and underutilized and is the best bet for many candidates, provided they do it correctly. In our next post, we’ll tell you exactly what to do and what to say when you reach out to hiring managers — especially if you come from a non-traditional background and aren’t getting a lot of recruiter outreach/don’t have the network to get warm referrals, reaching out to hiring managers is your absolute best bet. Now let’s look at each channel in detail.\nThis channel is one of the two where you have the least amount of control (the other is agency recruiters contacting you, though that one is way less useful).\nSo, how much control do you have over this channel? One bit of analysis we did on our survey data was to try to find patterns in the background of people who find in-house recruiters particularly useful. Not too surprisingly, some patterns did emerge.\nIn-house recruiters are most likely to contact you if:\nThese results aren’t unique to just this survey. We recently did a study where we asked a bunch of recruiters to look at resumes and tell us which candidates they’d want to interview. While the intent of the study was to see if recruiters are good at identifying talent (spoiler: they were barely better than a coin flip), we learned some other interesting things, including what recruiters actually look for when they read a resume.\nThe two most sought-after resume traits were: 1) experience at a top-tier tech company (FAANG or FAANG-adjacent) and 2) URM (underrepresented minority) status (in tech, this means being Black or Hispanic).\nThis mirrored what we saw in our user survey when we looked at commonalities among candidates who got value from in-house recruiters.\nSo how do you use this information to your advantage? You obviously can’t magic FAANG/FAANG-adjacent experience or URM status out of thin air2, but if you do have either, our pragmatic advice is to highlight it and make it really easy for recruiters to spot. Of course, whether you want to lead with URM status is a personal decision. We’ve heard differing opinions on this and are not here to judge. All we can do is share the data — do with it what you will.\nSo, how do you make sure that, say, your FAANG experience stands out to recruiters? Take a look at the before and after screenshots of the resume below3. This resume belongs to one of our users who was kind enough to let us share it. He actually has two of the three things that recruiters look for: FAANG experience and a niche title (ML engineer). But both are buried! And the section that gets the most attention is wasted on undergraduate awards.\nAs you can see, he spent almost 3 years at Apple, but a recruiter skimming his resume might not notice that because it was a while ago. Instead, he showcases an undergrad award and some technologies/languages that he knows. Neither of those is nearly as useful to recruiters as FAANG experience.\nHis current title is also ML engineer, and one at the Principal level at that. But it wasn’t always: He went from back-end to SRE to a little bit of everything to ML, and because of that, it’s possible a recruiter would miss it as well.\nWe edited this candidate’s resume to put all the things recruiters look for at the very top of the resume and moved the buzzword soup to the bottom. This candidate is obviously well-positioned because he has FAANG experience, several top schools, and niche skills — but before, many recruiters didn’t spot them. After he made these changes, the number of interviews he got increased by 8X.\nIf you’ve ever applied to jobs online, then you know it’s kind of like screaming into a black hole. Though, according to our survey, some candidates (specifically people applying to FAANG/FAANG-adjacent companies and small startups) get some value out of this channel, it’s still a numbers game. And for large startups, it’s a losing proposition.\nAccording to recruiting tool Gem, applicants that come from recruiter outreach (called “outbound” in recruiter lingo) are 6 - 10X more likely to get hired than applicants who apply online (called “inbound”).\nAs Lyft recruiting manager Nate Wylie put it:\nOur data… showed higher pass-through rates for candidates [we reached out to] at each stage of the interview process vs. applicants via the careers page. It’s not that we want to ignore applicants; it’s just that historically we don’t get what we’re looking for — and with speed — through that channel.\nHaving been a recruiter myself, I can confirm that many companies do indeed ignore their online careers page. Many years ago, when I first joined the recruiting team at a top-tier startup, I spent my first few days going through the resumes of people who had applied online. I found a treasure trove of candidates, including very experienced applicants from top-tier companies.4 But no one had seen these applicants because no one had been monitoring inbound activity for months!\nThe silver lining here is that when you don’t hear back from a company (or even when you get an automatic rejection email wishing you \"the best in your future endeavors\"), it’s not because a human looked at your resume and made a deliberate, thoughtful decision about you. It’s tempting to think that way because it plays so well into our insecurities. The reality is that a human probably never saw your resume in the first place.\nSo why do people apply online, despite knowing in their gut that it’s not an effective strategy? Simply put, it’s predictable and easy. You get into a routine, you upload your resume, you connect your LinkedIn, and you can knock out hundreds of applications in a matter of hours.\nThe other encouraging thing about this channel is that, when we analyzed specifically which types of candidates had success with it, we couldn’t find any patterns — the channel worked equally well (poorly?) for people who looked good on paper vs. not, and there was no preferential treatment for traditionally underrepresented groups in tech (e.g., women and people of color).\nTL;DR Applying online doesn’t hurt… provided that you don’t take rejection personally. If you do, it’ll wear you down over time.\nWarm referrals are, of course, excellent. That is, assuming it's a real referral — someone who can actually vouch for you, and ideally your work.\nPer capita, referrals are most companies’ best source of candidates, and they were a great channel for our users across all company types (they were the best channel for FAANGs/FAANG-adjacents, as well as large startups, and second best for small startups, behind in-house recruiters reaching out).\nIf you have the network, you should absolutely use it. Of course, it’s unlikely that you’ll have meaningful connections at every company you want to work at. What do you do then?\nShould you ask people you don't know to refer you? Our survey data says probably not. Cold referrals were net negative for both FAANG and small startups and neutral for large startups.\nYears ago, trying to collect cold referrals was a decent strategy. You could track down someone at the company and ask them to toss your proverbial hat into the ring\nEngineers were often happy to refer someone — even someone they didn't know — either to be kind, to avoid the awkwardness of declining, or to collect the potential referral bonus. They couldn't vouch for you, but the referral would ensure that a human looked at your resume.\nThis became so common that Blind actually spun out an entire referral marketplace called Rooftop Slushie (the link is to some press because the actual site is now defunct), where applicants would pay a small sum for a referral.\nThen, companies wised up and realized that these referrals weren't all that different from normal in-bound applicants. So why treat them differently? Many companies nowadays separate referrals into \"true referrals\" and \"leads.\" It’s great for maintaining the delicate dance of social dynamics, but it’s completely useless for getting hired — dropping someone’s resume into the “leads” pile is basically the same as throwing it into the inbound black hole.\nGiven that cold referrals aren’t zero effort, our advice is to expend that energy elsewhere. More on that shortly.\nAgency recruiters were the worst channel overall, according to our survey, and were net negative for all company types.\nFAANGs and FAANG-adjacent companies tend to rely less on agencies than startups, and when they do, it’s to fill some very specific need (rather than “Hey we need more SWEs”), so it’s not surprising that our users didn’t get much value from this channel when applying to FAANGs.\nWhile both large and small startups use agencies liberally, clearly the value to candidates is limited.5 Out of all of our survey respondents, only a handful of our users said that agencies were useful to them, and of those who mentioned agencies, the majority said that they were the worst channel.\nWe won’t belabor the point, but it’s probably not in your best interest to spend much time on working with agency recruiters. It has opportunity cost and not much upside. And you can routinely get screwed in salary negotiations when you work with an agency recruiter, if you even get that far.\nNot all cold outreach is created equal, for two reasons. First, there’s your audience: hiring managers vs. recruiters. And then there’s the quality of the outreach itself. We’ll come back to how to write the kinds of messages that will get you responses. First, let’s talk about the audience.\nYou can see in our survey results that cold outreach to hiring managers was net positive for FAANG/FAANG-adjacent companies and neutral for the other company types. Cold outreach to recruiters, on the other hand, was net negative for both FAANG/FAANG-adjacents and small startups and neutral for large startups.\nIgnoring the quality of the outreach for a moment, which we expect is probably comparable for both types, why does this difference exist?\nIf you had to answer the question of who’s the right person to reach out to about jobs, your gut instinct might be to say it’s recruiters. After all, hiring is officially their job! However, that’s not strictly true. Recruiters are not incentivized to make hires, at least not directly. Just like everyone else, recruiters’ main priority is to keep their jobs.\nHow does a recruiter keep their job?6 By bringing in the types of candidates that their manager tasked them with. How is that different from hiring? Hiring implies that you’re evaluated on whether the people you bring in actually get hired, but most in-house recruiters aren’t evaluated this way… because it takes too long.\nInstead, recruiters are sometimes evaluated on what portion of their candidates get offers or get to onsite. However, because of drop-off and latency (getting an offer can still take months), your organization has to be pretty good at tracking. Many are not.\nAs such, many recruiting orgs prefer simpler, faster metrics:\nThe downside of measuring success in a single part of the funnel is that you don’t incentivize people to care about what happens downstream (that is, how many are hired). This would be like if marketers only paid attention to ad clicks, rather than actual purchases. But that’s how recruiting operates: individuals aren’t really incentivized to care what happens downstream.\nSo, if you are typically just measuring the response rates of your reports, as a recruiting manager, you have to set some guardrails for the types of candidates that you want your team to reach out to. If you don’t, they’ll end up just reaching out to people who are likely to respond instead of people who are a good fit for the job.\nUnfortunately, you don’t know who is a good fit for the job. You can’t just say, “Go on LinkedIn, and find me good engineers.”\nThat doesn’t exist. So instead, you come up with some rules that look like this:\nThere may be a few other items on the list if the role requires specific skills (e.g., Android development), but by and large, that’s what recruiters are tasked with, and that’s what they’re focused on.\nIt seems counterintuitive, but if you’re either fairly junior (fewer than 4 years of experience) or you don’t have fancy brands and schools on your resume, recruiters are not incentivized to help you because you don’t meet their criteria, and they’re not incentivized to take risks on candidates because they’re not getting rewarded when the company makes hires (or punished when the company doesn’t).\nWhat does this mean for you? If you’re not the type of candidate that recruiters are reaching out to already (senior, well-pedigreed), they will not help you.\nWith that sad reality in mind, here’s the good news: there is someone who’s actually incentivized to make hires and is much more open-minded: the hiring manager7!\nAt this point, you might be skeptical. After all, according to the graph comparing all channels, hiring manager outreach is the worst of the best. Sure, it’s net positive for FAANG/FAANG-adjacent companies, but it lags behind in-house recruiters, warm referrals, and online applications with respect to effectiveness.\nHere’s the thing. Hiring manager outreach is the channel with the most untapped potential for effectiveness, while also being the one where you have the most control. Because companies often ignore them, online applications can’t come close to the same level of control, and warm referrals have a low ceiling. In-house recruiter outreach is largely out of your control (except for maybe making some limited profile tweaks, as we saw above).\nWhy is this the right channel?\nUnlike recruiters, hiring managers are actually incentivized to make hires and tend to be more open-minded about candidate backgrounds, all because hiring managers are judged on results. Specifically, they’re judged on how quickly and effectively they’re able to build stuff, and are — directly or indirectly — incentivized to grow headcount. For hiring managers, it’s not about the appearance of doing the work. It’s about the cold, hard reality of whether the work got done. And because they’re judged on actually getting stuff done, hiring managers are also much more incentivized than recruiters to take risks.\nOutside of needing more people to build things, hiring managers are also incentivized to hire for their teams because the better they are at recruiting and filling headcount, the more likely they are to get promoted.\nAs such, in our minds, when people say that hiring manager outreach hasn’t worked for them, it’s because they’re not doing it right. So, how do you do it?\nIn our next post, we’ll get very practical about outreach, provide a bunch of examples of good and bad outreach, and share two templates that you can steal.\nFootnotes:\nFirst, here’s how we got to these rankings. We asked each engineer who took our survey to rank all the channels they used to get in the door, from best to worst. Then we tallied up the points (+1 for best two channels, -1 for worst two). We didn’t do a more granular point system (e.g., +2 and -2) because the difference between the top two channels wasn’t always 2X, and generally, from talking to our users, preferences were somewhat muddy. As such, these results are directionally correct, but we didn’t feel comfortable numerically comparing them to one another. Finally, we divided the total tally by the number of times that channel came up. As a result, we were able to rank channels from most effective to least effective. ↩\nThis is why I generally view resume writers as selling snake oil. Either you have the things recruiters are looking for or you don’t. If you don’t, no amount of wordsmithing your bullet points or reorganizing the page is going to make a significant difference. Sure, check your resume for typos, and make sure that it reads decently well. Any more time invested in your resume after those basic things will have diminishing returns. Beware of anyone who tells you otherwise, and beware of any products or services who charge for resume review. ↩\nWe realize that recruiters won’t always have access to your resume when doing outreach and are likely looking at your LinkedIn instead. The same advice stands. Make sure that your About section has all the most important tidbits about you, front and center. Also, even though we didn’t see the same strong preference for FAANGs and URM status when applying online (more on that in the next section), making these types of changes to your resume certainly won’t hurt. ↩\nOf course we don’t share the point of view that you can only be a good candidate if you have a brand-name company on your resume. However, many recruiters do, and they are still ignoring this channel. ↩\nWe’d argue that the value to companies is limited as well. Though there are a handful of excellent agency recruiters out there, most are terrible. The hard thing is that, as an employer, you can’t immediately tell who’s terrible, and you end up wasting a bunch of time reviewing profiles of candidates who might look promising on the surface, but because of selection bias (these are the people who decided to work with bad agency recruiters, after all) are not a fit. That or they’re not interested in your company (and have possibly never even opted in to talk to you) or both. ↩\nAt larger companies, recruiting is usually split into two functions: sourcing (these are the people who reach out to candidates) and recruiting (these are the people who manage candidates’ journey through the process and extend offers). In this post, for simplicity, we’re lumping them together because separating them out would change some of the details but wouldn’t change the key takeaways. ↩\nNote that if you’re interested in smaller startups (Series A and below), you can substitute “founder” for “hiring manager” in the steps below. Founders are the most incentivized to get shit done and take risks, regardless of company size and stage, but at larger startups, they may be less likely to read cold emails because they get bombarded with all manners of requests and sales pitches. At a Series B or C company or at public companies with fewer than, say, 3000 employees, in addition to hiring managers, you should also target Directors and VPs — they have the power to get things done and aren’t so far removed from feeling the pain of not filling roles that making an extra hire or two is out of their purview. At large public companies, targeting Directors and above doesn’t make much sense — they ARE too far removed from doing the work to make individual hires. If you do contact them, the best outcome is that they’ll pass you on to one of their direct reports. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/how-to-get-in-the-door-at-top-companies-part-1",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Why engineers don’t like take-homes and how companies can fix them",
      "content": "[My experiences with take-homes] drive home the idea that this employer doesn't care if you are a carbon-based life form, as long as code comes out of one or more of your orifices.\nTake-home assignments could, in theory, be great for both companies and candidates. What better, fairer way to evaluate someone’s ability to do the work… than to have them do the work?\nUnfortunately, in practice, take-homes typically suck for engineers.\nWe surveyed almost 700 of our users about their experiences with take-homes and interviewed a handful more for deeper insights. We learned a lot—mostly about candidates' poor experiences and negative feelings toward take-homes. They take a lot of time. They don’t respect candidates’ time. Candidates often get no feedback. And candidates are almost never compensated.\nThe good news? Turns out there are some pretty simple things companies can do to vastly improve their take-home assignments. But before we dive into that…\nTake-homes vary a ton by role and company in terms of the types of questions, subject matter, length, and intensity. At their simplest, take-homes can be the same questions as in an algorithmic interview, except done asynchronously. The other extreme is asking candidates to build an entire app and deploy it.\nWe were surprised to see how often companies use take-homes. About 85% of our users got one at some point in their career, independent of their experience level. Of the users who encountered them, they tended to see them as part of the process about 20% of the time, again, independent of their experience level1.\nWhy are take-homes relatively popular among employers? They mostly use them to save time in the hiring process. There are, however, some more noble reasons a company might use a take-home assignment:\nAccordingly, here’s the relevant part of a great conversation between Vincent Woo of CoderPad and Patrick McKenzie (known to Hacker News folks as patio11) of Stripe, formerly of Starfighter.\nVincent: What general sort of high level change do you think that recruiters at tech companies that are roughly Stripe’s size or bigger ought to make?\nPatrick: If I could wave a magic wand and sell the world on one concept, it would be selling the world on the desirability of work sample testing… where the way to tell if someone is good at something is to have them do the something.\nDespite enthusiasm for the theory of take-homes and some very well-intentioned reasons, candidates overwhelmingly don’t like take-homes. Here’s why.\nThough users expressed a lot of frustration with take-homes, we were surprised to see very few take a hard-line stance and refuse to do them. Only 6% outright refuse, and 66% of people complete take-homes all or most of the time. Surprisingly, these stats didn’t really change when we looked only at senior engineers. I was expecting that experienced engineers would do them almost never, if at all, but that’s not what the data shows. It’s possible that seniors are just louder in their disapproval.\nNevertheless, the more desirable a company, the more likely candidates will do the take-home and feel OK about it—70% told us they completed them because they “Really wanted to work at the company and were willing to do what it took.”\nI found Weedmaps [to be] a very interesting company. They were the first marijuana related company to IPO. So you'd be on the frontier working for them. I found that exciting. So I applied and they had [a] take-home. I was like, sure, of course I’ll do this.\nOther reasons our users gave for completion included: “Because the take-home would be discussed at the onsite” (38%) and “Interesting/cool assignment” (37%). However, many of those who did finish them had such a poor experience that they said they’d never apply to certain companies ever again. We’ll talk about what makes the experience poor in a little bit.\nOf the people who refused to do at least one take-home at some point in their career, here were their reasons.\nThe common thread among all of these reasons is value asymmetry. The worst take-homes feel unrewarding to candidates. Even exploitative. Take-home assignments ask a lot of candidates: a significant investment of their time, with an often unclear scope, no guarantee of progressing to the next round, often without feedback, and almost always without compensation. Meanwhile, the company has basically invested nothing, except to send the task. We heard this a lot.\nWhen I'm interviewing, I look for things that are proxies for valuing team members… or not. If they want me to do a take-home test, and they haven't even spent 30 minutes on a phone screen, I begin to sense an asymmetry in our relationship, with their time and resources being very valuable, and mine not being valuable at all.\nA divergence between how much effort they want me to put in, and how much they want to put in themselves. It signals that they are more worried about their time than mine, their costs than mine. It also means they underestimate how much effort it takes to write code, so that if I go to work for them, I am likely to face demands to work uncompensated overtime to meet their optimistic estimates.\nSpending five hours on their one-hour test for nothing leaves hard feelings. And if they ghost me after the test, I will happily tell every developer who asks what cheapskates they are.\nPerhaps surprisingly, our data says no. We ran a regression to compare our survey respondents’ interview performance on our platform to how likely they were to do take-homes. The relationship was so weak as to be negligible.\nSimilarly, we ran a regression to see if people who look good on paper are more or less likely to do take-homes. The relationship there was negligible as well.\nIn other words, contrary to some popular opinions, you’re not necessarily weeding out your best candidates by doing take-homes, whether you define “best” in terms of how their resume looks or how they perform in interviews.\nAfter reading the stats above, you might think that, despite their grumblings, candidates generally do take-homes, and the best candidates won’t be weeded out. So, if you’re one of the many companies that uses them, it may not make sense to invest your limited time into making them better. It’s not that simple. For some companies, like the FAANGs, who have extremely strong brands and are known to pay well, changes are probably not worth it, especially in this market, where junior and senior engineers are willing to jump through more hoops than ever before.\nIf you’re not a FAANG, though, listen up. Here are some questions you can ask yourself to figure out if you should indeed make some changes to your take-homes.\nFirst, take an honest look in the mirror and ask yourself about your brand strength. Are you a household name? Does having you on candidates’ resumes give them automatic prestige? Are you known to pay above market? If the answer to all of these questions isn’t a resounding yes, your brand strength is probably not strong enough to make people jump through hoops.\nHere’s a sketch to drive that point home. Unless you have a ton of brand strength, candidates’ willingness to jump through hoops drops off sharply.\nIf you aren’t maxing out on brand strength, there are two questions you should ask yourself:\nIf your completion rate is below, say, 60% (our data shows that candidates complete take-homes around 62% of the time), then it’s DEFINITELY time to make a change. Honestly, regardless of what our data says, if people aren’t completing them at least 85% of the time, it’s probably time to make a change—losing more than 15% of your candidates to attrition at any given stage in the funnel is bad.\nWhat about your offer acceptance rate? If it’s less than 50% and you’re using a take-home already, there’s an opportunity to make some improvements. You might be wondering what this has to do with take-homes in the first place. To answer that, let’s change how we think about different parts of the interview process. At face value, every part of the process is there to vet candidates, to determine if they’re the right fit for your organization. However, when used correctly, every part of your process should become a selling vehicle as well. This is especially important for companies who do not have a strong, well-known brand. The FAANGs can get away with using their interview processes primarily as vetting exercises because candidates are already sold on the pay or prestige or sometimes on the work and the product. When you don’t have an established brand, the candidates who come to you are, at best, open to learning more, and the interview process is the instrument that teaches them. Wield it accordingly.\nThough we strongly advocate coming up with great, unique interview questions2 and making sure you have great interviewers, if your process does have a take-home component, it is one of the more overlooked parts of the process when it comes to selling. You have the opportunity to have someone do the actual work that you do! This is your chance to pick the coolest stuff you’ve worked on and serve it up to someone on a platter and make it stick in their brains and make them imagine what it’d be like to work on these kinds of problems every day! Why wouldn’t you jump at this opportunity?\nYou may think you don’t need to sell in this market. But just because employers have all the power right now, it doesn’t mean that will always be the case. And great senior engineers still have a lot of leverage.\nIf, after considering your take-home completion rate and your offer acceptance rate, it looks like you do need to make some changes, here are some practical tips, based on what we’ve learned from talking to our users (overwhelmingly senior engineers who are targeting top-tier companies—probably the people you want). Let’s start with what we just talked about: using the take-home as a selling vehicle.\nYou're getting a chance to spend a couple of hours with somebody in a take-home (metaphorically). Why wouldn't you do everything you can to get them excited? Pick a problem that you've worked on, and get them hooked on it. Pick the kernel of an interesting problem that you've solved, and build something around it that will challenge candidates. Something that gets them thinking, “I could have done that better” or “This is a different or more efficient way to do it.” That's going to be more effective than the standard perks many companies offer.\n[Best take-home I’ve seen was an] open-ended system design question on the type of system I would work on, was meant to simulate a team discussion on the system we needed to build, and was a great way for me to start thinking about what I'd be working on there.\nOne way you could do this, is to have your engineering team keep a shared doc of ‘cool’ solutions they've found, or new things they've tried. These can serve as jumping-off points for creating your take-homes.\nThe… challenge was for an internal tooling team that specialized in incident response tools; their challenge was to create a scaled down version of a tool already in use at the company. The focus was more on understanding the domain and customer than wiring up a bunch of complicated stuff, and it was a delight. It being a greenfield also gave you an opportunity to showcase some software design skills. I did not get this job, but enjoyed the experience and still feel connected to the team.\nIt was conceptually related to the sort of work the team was performing, but it was simplified and stand-alone enough to clearly not be unpaid labor for their product.\nJust be sure that when you come up with a practical problem that you strip out the annoying parts and focus only on the juicy kernel of the problem, the part that’s actually cool and lets the candidate be smart and creative. Don’t make them do grunt work or wrestle with their dev environment!\n[This] was for a tooling team in Support, where they didn't have a lot of experience creating challenges or interviewing. One of the engineers took a difficult task that he had accomplished recently and just made that the take home challenge. It involved a lot of Ruby version conflict debugging. It was completely demoralizing and felt like hazing.\nCandidates overwhelmingly favor take-homes that respect their time, i.e., short ones.\nThe best were short and brief, took no more than 2 hours and were directly related to what I would be doing on the job.\nBest are realistic and time bound, i.e., low time investment required.\nShort and quick take-homes are great.\nOver 80% of survey respondents said that take-homes should take 4 hours or less, and a plurality thought that they should take 2 hours.\nTake-homes being short in theory is one thing… but we got a lot of feedback that take-homes often go far beyond how long companies tell candidates that take-homes should take.\nThis disconnect between actual time and expected time is another instance of value asymmetry: companies didn't even bother to have someone on their team do the take-home themselves and time it.\nI've done a couple of algorithm questions as take-homes that the interviewer said should take an hour. They routinely take longer than that.\nCompanies will say, ‘don’t spend more than X hours on it,’ but then it actually takes 5X that amount. It's just too much time. And most of the time they didn’t give feedback at all even though I spent so much time on it.\nCompanies should clearly communicate the expected time commitment for a take-home. And they should be realistic about how much time it should take.\nBest was an interesting problem with a realistic time frame. They estimated 2 hours and it took me exactly that, which was refreshing and made the process seem fair.\nI've done a couple of exercises where they were truly respectful of my time. The tasks were small, clearly defined, and they gave me a realistic timeframe to complete them.\nFor the best take-home I did, the company told me: ‘Tell us when you're going to start, and you'll have 4 hours. We'll be available over email that whole time, and we'll answer your questions within minutes.’ That felt respectful of my time, and was a more reliable signal of my capabilities than a 20-minute algorithms exercise.\nTo get a realistic estimate, companies could simply QA their own take-homes—just by having someone on your team take it, and time them.\nStill, some candidates will spend more time anyway, because they really want to work for a certain company. And it can be easy for candidates to go down a rabbit hole and get most of a take-home done in the first few hours, then spend another day or more, perfecting it to give themselves a better chance.\nDo you want me to literally only work two hours on something that's clearly going to take 10 to really be able to have a conversation with you about how I think about things? Because two hours of decisions isn't as good as 10 hours of decisions.\nIt’s okay if candidates want to put in extra time, but it should be made clear that that's not the expectation.\nThe scope was poorly defined, which made the assignment not only tedious, but also seemed like a waste of time.\nHaving clear, straightforward instructions can significantly enhance the take-home experience for candidates, making them feel purposeful and relevant. The best take-homes are those that directly align with the actual job. When candidates are asked to solve a simplified version of a real problem your company is facing, it not only tests relevant skills, but also gives a candidate insight into what work at your company would be like, which is really what selling is. (This is, of course, assuming that you believe what you’re working on is cool… If you don’t, how will you ever convince others?)\nOne was a great learning experience because I had to solve a problem similar to what I would face in the job. It was concise and focused.\nBeing able to ask questions before or during the take-home, e.g., having a direct contact point who’s an engineer at the company, can also be a big plus.\nWe expect that many of the companies reading this piece have take-homes as the first step in their process, before ever talking to a human. This decision isn’t very popular.\nIf a company calls me for a screening interview, it means they've read my resume and cover letter, and not immediately dismissed my application as inappropriate. It also means they're putting a person on a phone call with me for the duration of the screening interview. This is symmetric, my effort matches theirs.\n[I] did a take home that was automatically sent to me after applying, before even speaking to a human. The feedback was 'you are too expensive,' no feedback on the coding.\nCompany needs to build an investment with the candidate first—they shouldn't ask for it before meeting the candidate at least once.\nThat said, take-homes can be a great way to let candidates who don’t look good on paper show what they can do, and those candidates are more likely to complete them. To prevent candidate unhappiness/attrition, give them a choice. Either submit a resume or do the take-home assignment or both. If you go this route, though, design a take-home that you trust. We’ve seen companies take this approach and then throw out perfect-scoring take-homes when they didn’t like the resume. If you use a take-home, then respect your candidates enough to follow up with the ones who’ve done well, even if they don’t look good on paper.\nAnother way to make take-homes purposeful is to give your candidates an explicit choice about whether they’d rather do a technical interview or a take-home. Engineers are, in fact, split on which they’d prefer. Giving them a choice allows them to showcase their skills in the format they prefer and feel best prepared for. If you have good questions, you should be able to get good signal from either.\nOnly 10% of respondents told us that they were given the choice of take-home versus technical interview. So there is an opportunity for more companies to do this. It's a candidate-friendly gesture that shows empathy and can help candidates shine.\nMany candidates have spent months preparing for standard technical interviews. So it can feel anticlimactic when they find out that a company they're excited about doesn't do them. Others get so nervous in a live interview that they don’t perform.\nI rarely don't pass take-home assessments, but I often fail to pass live interviews.\nInterestingly, one user we interviewed told us that they spend far less time on a take-home compared to preparing for a live technical interview. And because of that they prefer take-homes.\nI prefer take-homes over all other assessments because I find I spend far less time on take-homes then I do preparing for live interviews. It's hard to overestimate the amount of extra time I spend preparing for a technical interview, compared to doing a take-home—for me it’s maybe 10 times as much. I've spent hundreds of hours, maybe 500 hours, over the course of my career preparing for technical interviews. And if I have one pop up, I can't just drop everything and do it right away. I have to spend a lot of extra time just ramping up for a particular interview, in addition to the hundreds of hours that I've done.\nClear communication about the purpose of a take-home in the hiring process, as well as why it’s rational to spend time on it, is important for candidates. It’s a way to make sure it feels purposeful and not like a random task.\nOne way to make the take-home feel deliberate is to replace some parts of your process with it. A standard process without a take-home has a recruiter call followed by a technical phone screen followed by an onsite (virtual or otherwise). The technical phone screen usually lasts about an hour. The onsite usually lasts 6 hours.\nLet’s say your take-home takes 2 hours to do. You can make it replace the phone screen and one of the onsite rounds, which nets out to the same number of hours spent. If you go this route, we recommend doing the math explicitly for candidates and showing them that the time they spend on the take-home is equivalent to the time they’d be spending on a process without it.\nAnother way to make the take-home feel deliberate is to incorporate it into the onsite, where at least one of the rounds, if not more, will include a code review and/or thoughtful discussion about tradeoffs and choices made. This should be standard practice, but isn’t always. 32% of our users said companies had told them this, and it was the reason they decided to do a take-home.\nThe best take-homes were ones that we discussed in the first rounds of interviews. The worst ones were ones that I submitted and we never talked about them again.\nIdeally, you do both of these things together, and very clearly explain to candidates both the math and how the take-home informs the content of the onsite.\nProbably the most striking result of our survey was that 58% of candidates think that they deserve compensation for completing take-homes. Yet only 4% reported ever receiving it. Compensation can shift candidate perceptions of the hiring process and of the company:\nThey compensated me for my time, which made the process feel very professional and respectful.\nIt was a completely open source codebase and so their process was the exact same as someone that was an employee: here's the ticket with the information to do it, set up the environment, download all the code, get everything running. They gave me a few different tasks I could choose from, I could pick two, and if I completed them I would be compensated a fixed rate, which was $100 for each task. Which in terms of the time I spent on it, is still really cheap for them.\nIf candidates know they’re going to be paid for their work on a take-home, they’ll be more likely to complete it as well. Compensating candidates is a clear gesture that shows you value their time and effort, that there’s more symmetry in the relationship. It also goes hand-in-hand with time: paying also forces a company to scope the take-home to a reasonable number of hours. So it's a forcing function for good behavior—if you can’t afford much, then don't make the take-home too long!\nResponses about how much companies should pay for take-home assignments were split.\nFixed amounts: Just over half of respondents (52%) suggested specific and reasonable fixed amounts, ranging from $50 to $500.\nHourly rates: The other almost half (47%) favored an hourly rate, with suggestions ranging from $50 an hour and upward (average of $217 an hour). Some suggested that the rate should correspond to the salary of the position being applied for, or be comparable to what an employee at that level and company would earn. As one user put it:\nMaybe just pay market?\nOne antipattern when it comes to comp is NOT having a set rate, asking the candidate to name their price, and thereby putting the candidate in a position where they feel like they need to negotiate. In this scenario, the candidate has to negotiate twice: once on the take-home and once on their actual comp, with the worry that negotiating too aggressively on the take-home might count them out… or not aggressively enough anchoring the company to lower compensation down the line. No one needs these mind-games in an already stressful process. Just have a set rate, for god’s sake.\nSymbolic compensation: This is probably not the best option, but a handful of survey respondents (1%) did mention that a minimal symbolic compensation would do. While 1% is small, we found this interesting to include because, when we interviewed people, two of them mentioned this.\nI think any compensation at all has symbolic value. A $100 Amazon card would impress me. A $50 Amazon card and a company t-shirt would at least not insult me. It’s kind of a consolation prize to say, ‘No hard feelings.’\nI feel like a couple meal vouchers would do it these days.\nOf these options, we’d recommend a reasonable fixed amount based on the task, and the actual time it’s supposed to take. And of course you know how long it takes because you had one of your engineers do it themselves, right? Right??\nLack of feedback was the primary reason our survey respondents said their experience with a given company was bad. Regardless of interview type, we’re always pro feedback, but feedback is especially important for take-homes, because in a way they ask more of a candidate. Offering constructive feedback, regardless of the hiring decision, respects the candidate's effort on the take-home.\nDespite the time and effort they invested in completing take-homes, many of our survey respondents said they received no feedback at all. This was seen as demoralizing, and it deterred candidates from applying to future opportunities at those companies.\nGetting rejected without having a chance to discuss the code with anyone is a terrible experience.\nIt is really discouraging spending a large amount of time to find out you are rejected without explanations.\nThey provided no feedback after submission, which made the whole effort feel unappreciated and one-sided.\nIncidentally, the main reason companies don’t give feedback is fear of getting sued. As it turns out, literally ZERO companies (at least in the US) have ever been sued by an engineer who received constructive post-interview feedback.\nThanks to Dan Fennessy for all the behind-the-scenes work on this post.\nFootnotes:\nSome users told us they’re seeing take-homes more recently, likely a function of worsening market conditions—the less leverage talent has, the more hoops companies can ask them to jump through. ↩\nYou might have to do this soon anyway, in all your interviews, to ward off against AI-driven cheating. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/why-engineers-dont-like-take-homes-and-how-companies-can-fix-them",
      "author": "",
      "user_id": ""
    },
    {
      "title": " Are recruiters better than a coin flip at judging resumes? Here's the data.",
      "content": "This post is a very exciting first for interviewing.io because it’s about a proper experiment run by a real, live academic research lab. If you’ve been reading my work for the past decade, you know that I’ve always been something of an armchair researcher. I ran some experiments before starting interviewing.io, and since then, my team and I have kept it up.\nOne of the experiments I ran before I founded interviewing.io was an attempt to figure out how good recruiters were at judging candidate quality based on resumes. I ran it 10 years ago and discovered that not only was everyone bad at judging resumes (about as accurate as flipping a coin), they all disagreed with each other about what a good candidate looked like.\nEven though these results were shocking at the time, the study had some serious limitations. First, I had no objective measures for which candidates were actually good. I was working as a recruiter at the time, so I knew whom I had been able to place, but that’s obviously not the be-all and end-all of engineering ability. Second, I had a non-representative sample of software engineers. Due to my brand, I had managed to attract a lot of excellent, non-traditional candidates — engineers who were actually very good but didn’t look good on paper. These types of resumes are the hardest for recruiters to judge, and the data was full of them. Finally, my sample size wasn’t that big: I ended up with 716 data points in total, only about half of which came from recruiters (the rest came from engineers and hiring managers — my original hypothesis was that they might be better at the task, but I was wrong… everyone was bad at judging resumes).\nSo, now that I’m CEO of interviewing.io, with access to a lot more data, resources, and a team of excellent academics at Learning Collider, we decided to run this study again, but with a more rigorous treatment and better conditions, to see if we could replicate the results. This time, we focused just on recruiters, given that they’re most often the gatekeepers who decide which candidates get an interview.\nBelow are all the details, but here’s the TL;DR: we reproduced my results from 10 years ago! Our new study showed that recruiters were only a bit better than a coin flip at making value judgments, and they still all disagreed with each other about what a good candidate looks like.\nIn this piece, we also talk about:\nThe rest of this piece is co-authored by Peter Bergman, Tushar Kundu, and Kadeem Noray of Learning Collider.\nIn the real world, resumes (or LinkedIn profiles) are evaluated by recruiters in minutes — even seconds — and these evaluations are THE thing that determines who gets an interview.\nBut what do these word walls tell recruiters? How predictive are their evaluations of actual interview success? Ultimately, how good are recruiters at judging resumes?\nTo answer these questions, we designed a study approximating technical recruiters’ decisions in the real world. We asked1 76 technical recruiters (both agency and in-house) to review and make judgments about 30 engineers’ resumes each, just as they would in their current roles.\nThey answered two questions per resume:\nWe ended up with nearly 2,200 evaluations of over 1,000 resumes.\nThe resumes in this study belonged to interviewing.io users (with their consent) — actual engineers currently on the job market.\nCollaborating on this study with interviewing.io is an ideal scenario, precisely because outcome data were available for comparison purposes. Each engineer in this study has completed multiple mock interviews on the platform. Performance in these interviews is quite predictive of performance in real interviews: top performers (roughly the top 5% of users) on interviewing.io are 3X more likely to pass technical interviews at top-tier companies than candidates from other sources. Even passing a single interview on interviewing.io is a strong predictor of outcomes; it's associated with a 32% increase in the chance of working at a FAANG company post-interview.\nOnce we had recruiters’ evaluations of the resumes, we compared them to how those engineers actually performed on interviewing.io: skills scores, feedback from interviewers, and ultimately, whether they passed or failed their mock interviews.\nIn aggregate, recruiters in the study recommended 62% of candidates for an interview. But how did recruiter evaluations stack up against candidates’ performance on the platform?\nWe calculated recruiter accuracy by treating each candidate’s first interview (pass/fail) as the truth, and recruiters’ decision to interview as a prediction. It turns out that recruiters chose correctly 55% of the time, which is just slightly better than a coin flip.\nRecruiters predicted the likelihood that each candidate would pass the technical interview. In most hiring processes, the technical interview follows the recruiter call and determines whether candidates proceed to the onsite. Being able to accurately predict which candidates will succeed at this stage is important and should inform the decision about whether to interview the candidate or not.\nWhat we found most surprising is how far their predictions were from the truth:\nBelow is a graph that shows recruiter predictions vs. actual performance. The x-axis is the bucketed recruiter rating. In other words, the first point is all the candidates that recruiters assigned a 0-5% likelihood of passing. The y-axis is the average interviewing.io pass rate for those candidates. The red dotted line represents 100% accuracy – in an ideal world, the higher a recruiter's ranking of a candidate, the higher their actual performance would be. The orange line represents reality – as you can see, there isn’t much correspondence between how recruiters predicted candidates would perform and their actual performance.\nRecruiters’ predictions below 40% underestimate these candidates by an average of 23 percentage points. Above 60%, they’re overestimating by an average of 20 percentage points. If this was predicting student performance, recruiters would be off by two full letter grades.\nClearly, there is lots of noise in resume evaluations. Were recruiters’ noisy judgments at least consistent when reviewing the same resumes?\nNearly 500 resumes were evaluated by more than one recruiter. Based on a random selection of two evaluations per resume, the overall likelihood of two recruiters agreeing to either interview or not interview a given candidate was 64%.\nSince recruiters also guess the probability a candidate will pass the technical interview, we can compare how different these guesses are for a given candidate. The average differential between two randomly selected recruiters’ evaluations of the same resume was 41 percentage points. So, let’s say one recruiter predicts a 30% probability the candidate would pass; another recruiter evaluating the same resume would predict, on average, a 71% probability of passing.\nTo further understand just how prevalent the disagreement is, we looked at the standard deviations for across-candidate evaluations and same-candidate evaluations:\nSo, when two recruiters are asked to judge the same candidate, their level of disagreement is nearly the same as if they evaluated two completely different candidates.\nDespite the noise and variability in the study’s resume evaluations, there were some characteristics that recruiters consistently favored: experience at a top-tier tech3 company (FAANG or FAANG-adjacent) and URM (underrepresented minority) status (in tech, this means being Black or Hispanic).\nMost predictive for Question #1 (whether a recruiter would want to interview that candidate) was experience at a top company — these candidates were 35% more likely to be picked. Black or Hispanic candidates are also associated with an increased likelihood a recruiter would interview a candidate — by 21%.4\nWith Question #2 (how likely the candidate was to pass a technical interview), having a top company on your resume is associated with a 21% increase in the likelihood that recruiters believe the candidate will pass the interview. Compared to the actual pass rates, recruiters’ predictions of FAANG candidates are generally accurate (average 4 percentage point overestimate).5 Unlike the presence of a top company, URM status didn't appear to influence recruiter decisions here.\nSo, we know what recruiters tend to favor, whether they’d admit to it or not: 1) FAANG/FAANG-adjacent experience and 2) URM status. But what’s even more interesting than why a recruiter would say yes is why they would say no.\nWhen we asked recruiters to judge a resume, we also asked them WHY they made that decision.6 Below are recruiters’ stated reasons for rejecting candidates. As you can see, “missing skill” is the main reason by far, with “no top firm” a distant third.\nSo, then, we wondered… How do recruiters’ stated reasons for rejecting candidates line up with reality? To figure that out, we analyzed the resumes that ended up in the rejected pile and looked at common traits.\nBelow is a graph of actual rejection reasons, based on our analysis. The main rejection reason isn’t “missing skill” — it’s “no top firm.” This is followed, somewhat surprisingly, but much less reliably (note the huge error bars), by having an MBA. “No top school” and having a Master’s degree come in at third and fourth. Note that these top four rejection reasons are all based on a candidate’s background, NOT their skill set.\nAnother key piece of this study is time. In hiring settings, recruiters make decisions quickly. Moving stacks of candidates through the funnel gives little room to second-guess or even wait before determining whether or not to give a candidate the opportunity to interview.\nIn our study, the median time spent on resume evaluations was just 31 seconds. Broken down further by Question #1 — whether or not the recruiter would interview them — the median time spent was:\nGiven the weight placed on single variables (e.g., experience at a top firm), how quickly recruiters make judgments isn’t surprising. But might they be more accurate if they slowed down? It turns out that spending more time on resume evaluations, notably >45 seconds, is associated with more accurate predictions — just spending 15 more seconds appears to increase accuracy by 34%.7 It could be that encouraging recruiters to slow down might result in more accurate resume screening.\nAs a gaggle of technologists and data geeks, we tested whether algorithms could quiet the noise and inconsistencies in recruiters’ predictions.\nWe trained two local, off-the-rack machine-learning models.8\nJust like human recruiters, the models were trained to predict which candidates would pass technical interviews. The training dataset was drawn from interviewing.io and included anonymized resume data (years of experience, whether they had worked at a top firm, and whether they had attended a top 10 school for either grad or undergrad), candidates’ race and gender, and interview outcomes.9\nDespite the very limited types of data we input into both models, when presented with out-of-sample candidate profiles, both models made predictions more accurately than human recruiters.\nRandom Forest was somewhat more accurate than recruiters when predicting lower performing candidates. XGBoost, however, was more accurate across the board than both the Random Forest model AND recruiters.\nIn this section, when we say “we,” we are speaking as interviewing.io, not as the researchers involved in this study. Just FYI.\nAt interviewing.io, we routinely get requests from our users to add resume review to our list of offerings. So far, we have declined to build it. Why? Because we suspected that recruiters, regardless of what they say publicly, primarily hunt for name brands on your resume. Therefore, highlighting your skills or acquiring new skills is unlikely to make a big difference in your outcomes.\nWe are sad to see the numbers back up our intuition that it mostly is about brands.10 As such, here’s an actionable piece of advice: maintain a healthy skepticism when recruiters advise you to grow your skill set. Acquiring new skills will very likely make you a better engineer. But it will very likely NOT increase your marketability.\nIf enhancing your skill set won’t help, what can you do to get in front of companies? We’re in the midst of a brutal market, the likes of which we haven’t seen since the dot-com crash in 2000. According to anecdotes shared in our Discord community, even engineering managers from FAANGs are getting something like a 10% response rate when they apply to companies online. If that’s true, what chance do the rest of us have?\nWe strongly encourage anyone looking for work in this market, especially if you come from a non-traditional background, to stop spending energy on applying online, full stop. Instead, reach out to hiring managers. The numbers will be on your side there, as relatively few candidates are targeting hiring managers directly. We plan to write a full blog post on how to do this kind of outreach well, but this CliffsNotes version will get you started:\nWe know that recruiting is a tough job, especially in the current climate, where there are more applicants than ever and fewer recruiters to parse through them. So, it rationally makes sense to us that a recruiter would spend no more than 30 seconds per resume and focus primarily on looking for top brands.\nWe hope, though, that this piece may have given a measure of pause about your approach, and we’d like to leave you with two actionable pieces of advice. First, if you do nothing else, please slow down. As you saw above, taking just 15 extra seconds to read a resume could improve your accuracy by 34%.11\nOur second piece of advice is this. Freada Kapor Klein from Kapor Capital coined the term “distance traveled” more than two decades ago. It refers to what someone accomplished, in the context of where they started. For instance, Kapor Klein recommends that, in their admissions processes, universities should consider not just the number of AP tests a candidate has passed but the number of AP tests divided by the total number offered at their high school. For example, if an applicant took 5 AP tests and their school offered 27, that paints a very different picture from another applicant who also took 5 AP tests when that’s the total number offered at their school. Kapor Capital uses distance traveled as one of their metrics for determining which entrepreneurs to fund. One can easily apply this concept to hiring as well.\nTake a look at the resume below. \"John\" (name has been changed; scrubbed resume shared with permission) studied chemical engineering and worked his way into software engineering by starting as a service engineer focused on pen testing. In the meantime, he completed a bootcamp, attended the Bradfield School of Computer Science (a school dedicated to teaching computer science at a depth beyond what many university programs, and certainly most bootcamps, offer), and ended up with a senior title in just three years.\nJohn was consistently rated poorly by recruiters but is one of the top performers on interviewing.io.\nIt takes just a bit more time, so please spend a little longer reading resumes, and evaluate candidates’ achievements in the context of where they came from. Think about the denominator. But don’t think for a moment that we recommend that you lower the bar — absolutely not. On interviewing.io, we regularly see candidates like John objectively outperforming their FAANG counterparts.\nThe last time I did this research, I wrote about how being bad at judging resumes isn’t anything to be ashamed about and that comes down to the resume itself being a low-signal and not-very-useful document.\nI held that same opinion for the last decade (and even wrote a recent post about how AI can’t do recruiting)… right up until we ran this study and successfully built two ML models that outperformed recruiters.\nSo, I stand corrected.\nAs you saw above, both models were limited – they were looking at the same types of features that recruiters do when they quickly scan a resume, certainly fewer features than recruiters have access to. But, despite that, the AI models still outperformed humans. What happens then, if you can build a model that behaves like a recruiter who really slows down and reads everything? These results make me believe that resumes do carry some signal, and you can uncover it if you carefully read what people write about their jobs and themselves and also analyze how they write it. Unfortunately, this takes more time and effort to uncover than most human recruiters are able to devote. And, in retrospect, that’s a good task for AI. Though we haven’t built a model like that for this post, I’m optimistic that we may be able to do it in the future.\nAs I said in the AI piece I linked above, in order for AI to do useful recruiting work, rather than just perpetuating the biases that human recruiters hold, it needs a data set that contains some objective measure of performance. Most recruiting AI models today do one of three things: glorified keyword matching, training on what recruiters prefer (the outcome is whether a recruiter would want to talk to the candidate, NOT whether the candidate is good), or live on top of existing tools like ChatGPT (which we recently showed doesn’t perform very well and is biased against non-traditional candidates). These three approaches just result in the wrong thing being done, faster.\nI hope that, in the not too distant future, we can use AI to make less-biased decisions, using meaningful performance data. And I hope that this type of AI solution can get adoption among the recruiting community.\nFootnotes:\nParticipating technical recruiters were paid a base rate and then received additional $$ for each accurate prediction. ↩\nDifferent roles have different requirements. To correct for that, we asked each candidate to specify which eng role they were applying for: Software Engineer (back-end or full-stack), Mobile Engineer, Front-end Engineer, ML Engineer, Data Engineer, or Engineering Manager. Then we prompted recruiters to evaluate them specifically for that role. If no role was specified by the candidate, the default role to evaluate for was Software Engineer (back-end or full-stack). ↩\nTop firms = Airbnb, Amazon, Anthropic, AWS, Apple, Asana, Atlassian, Bloomberg LP, Checkr, Coinbase, Coursera, Cruise, Dropbox, Etsy, Facebook, Flexport, GitHub, Google, Gusto, HashiCorp, Instacart, Instagram, Jane Street, Jump Trading, Khan Academy, LinkedIn, Lyft, Medium, Microsoft, Mozilla, Netflix, Oculus, OpenAI, Palantir, Peloton, Pinterest, Postmates, Quora, Reddit, Robinhood, Roblox, Salesforce, Segment, Slack, Snap, Snowflake, SpaceX, Spotify, Square, Stripe, Tesla, Thumbtack, TikTok, Twilio, Twitch, Twitter, Two Sigma, Uber, Udemy, Waymo, Whatsapp, Yelp, and Zoom. ↩\nWe corrected by FAANG & FAANG-adjacent experience (and all of our other variables) before making this statement, i.e., the effect existed for engineers from underrepresented backgrounds who did not have FAANG/FAANG-adjacent companies on their resumes. We expect that recruiters favor underrepresented minority candidates because of guidelines from their employers to focus on sourcing these types of candidates, as part of DEI initiatives. Discussion about the magnitude of this effect and its implications is out of scope of this piece. ↩\nInterestingly, recruiters might penalize, for example, alternative education. Candidates with only alternative education pathways post-high school — coding bootcamps or digital certifications — appeared to be penalized by recruiters in this study. However, with limited observations (n=11), it’s inconclusive without further study. ↩\nThat field was optional, so most of the reasons recruiters provided were in cases when they said no — presumably because the reasons for saying yes may have seemed self-evident. ↩\nIt’s not that recruiters who generally take their time make more accurate judgements. Any recruiter slowing down might make them better at judging resumes! ↩\nIt’s important to stress that neither algorithm was custom-built. The models, one using a Random Forest algorithm and the other an XGBoost algorithm, are distinct but interrelated approaches akin to Decision Tree algorithms. Decision trees sort data into groups based on features. Random forest algorithms combine multiple decision trees to improve predictions. XGBoost builds multiple decision trees one after another, with each new tree focusing on prediction errors from the previous trees. ↩\nTraining data excluded data in this study. We take user privacy very seriously, and we want to stress that all models were local and anonymized and that no data in this study was shared with cloud LLMs. ↩\nTo see a particularly egregious example of recruiters favoring brands over substance, take a close look at this fake resume that got a bunch of recruiter responses. And this one too. ↩\nWe haven’t proven causality here, but when we just scoped our analysis to the same person, it appeared that taking more time did help (in other words, it’s not just that recruiters who spend more time usually are more accurate; it’s the added time). Still, this is something that merits more work, and we'll try to investigate it causally in the future. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/are-recruiters-better-than-a-coin-flip-at-judging-resumes",
      "author": "",
      "user_id": ""
    },
    {
      "title": "The unwritten rules (till now) of negotiating with Meta",
      "content": "If you don't like reading, here's me presenting the contents of this blog post in a video. Pick your poison.\nEDIT: This post is based on stories from users who were interviewing for E4-E6 SWE and MLE roles at Meta. Other, more specialized roles may have different processes than what's described here.\nEDIT 2: As of Q1 2025, it looks like Meta is sometimes foregoing team matching in favor of driving candidates to their Monetization org (which apparently has a lot of open headcount). If this happens to you, after you pass the hiring committee, instead of entering team matching, your recruiter will tell you that you’ve been assigned to this particular org and, if you proceed, you’ll just get an offer. You won’t get to talk to your future manager, and you’ll find out team details a week after you join. From what we know, it’s possible to insist on team matching instead, with the downside that it’ll take an unknown amount of time rather than certainty.\nWhy does this matter?\nIf you’re looking to use your Meta offer primarily as leverage with other companies, this is a great thing because you’ll get numbers quickly. If you’re seriously interested in Meta, then this could be good or bad and depends where you are in the process and how much you want to work on monetization versus other things/how much you want to meet your manager before you work for them.\nSo if you’re seriously interested in Meta, whether this is good or bad depends on where you are in the process. If you need them to move quickly, it’s great because you know you won’t be stuck in team matching. However, if you need them to slow down because you aren’t as far along with other companies or because you want to work in a different org, you may want to ask your recruiter to stick with the old team matching process. In our experience, it’s ok to ask this. Your recruiter may not tell you outright that that’s an option, but if you ask, they will probably do it. Of course, you may be stuck longer than you want. But at least then you will have more of a say in what you work on.\nAt interviewing.io, one of the services we offer our users is salary negotiation. Even though I’m the founder, I still do many of the sessions myself because they give me an invaluable insider’s perspective on what’s actually going on in the engineering market, what different companies’ offers look like, how companies extend offers, what kinds of deadlines they give, and how much they go up in compensation, under what circumstances.\nAccess to this kind of data is great because it helps me make better business decisions. But sometimes I see questionable patterns of behavior among companies. Recently, I’ve observed a string of practices at Meta that I find reprehensible, and that’s what this post is about. I’ve seen the same practices with enough candidates, and across enough different titles and positions, that it’s become clear to me that they are not isolated incidents or a rogue recruiter’s doing but rather a consistent implementation of a deliberate strategy that comes from the top.\nI’m writing about this for two reasons. First, if you’re negotiating with Meta, you need to know how they operate and understand the unwritten rules of the game. If you do not know the rules, you will fail — long before you even start negotiating.\nSecond, I’m hoping that someone at Meta sees this post and that maybe it’ll spark an internal discussion about changing the rules.\nBy the way, if I’m wrong, I will gladly issue a retraction and a public apology. Please contact me if you’re a recruiter at Meta and find something incorrect in this post. My email is aline@interviewing.io.\nLastly, if you’re about to interview there or are interviewing there already, please read our free, long-form guide to their interview process and questions.\nI mentioned above that we do salary negotiation, but our main business is mock interviews. We offer anonymous mock interviews in the style of a bunch of different companies (mostly FAANGs). This means we know how many people are practicing for interviews at Google vs. Meta vs. other FAANGs, and that lets us guess (pretty accurately) how much hiring is actually happening at these companies.\nYou can read in way more detail about how all the FAANGs are doing in our recent blog post where we made 2024 predictions based on our proprietary data. But while I was writing that post, I noticed something odd. Meta was hiring way more engineers than any of the other FAANGs. In fact, Meta hiring is up more than 10X since January of last year. You can see that more recently Amazon has picked up a bit, but it’s very recent and not enough to drive major change in other companies’ behaviors (at least not yet). And, yes, Netflix is hiring too, but Meta’s eng team is more than 10X the size of Netflix’s, so in the absolute, Netflix’s hiring volume isn’t enough to balance Meta out. For all intents and purposes, Meta’s the only FAANG that’s really hiring at scale — and they’re currently getting away with treating candidates really poorly as a result.\nHere’s how Meta runs their hiring process. These practices have been consistent across every negotiation client we’ve had in the past 6 months or so.\nMeta’s hiring is centralized, which means that you enter one big interview process that’s completely divorced from which team you might end up on and you interview with people whom you might never work with again. If you do well, there will be a team matching component after you pass the onsite but before you get an offer1. With that in mind, here’s how they run their process, once you get the green light.\nBelow are the steps for negotiating with Meta in a hard climate where they have a monopoly on hiring. We hope that most of these won’t be necessary in the future. They are:\nWe wrote a whole post about how to avoid sharing information with your recruiter and why this is so vital. If you share where you’re interviewing or how far along you are, or if you start negotiating prematurely, the strategies below won’t work.\nPlease read our post on not shooting yourself in the foot during negotiations before you continue!\nYou should also be aware of a few tricks specific to Meta recruiters. If you're not forthcoming about where else you're interviewing, they may say a few sneaky things.\nFirst, they may say something like, \"Well, we just want to know where you're interviewing so we can intro you to others who interviewed at those companies but ultimately chose Meta.\" Don't fall for that early in the process. It's a trap to get information out of you. You can always ask for those intros later, when you're negotiating and it's the right time information about your other offers.\nThe other thing they do is fish, saying something like, \"Well, in case you're interviewing at {Google, Netflix, some other big company they don't want to lose candidates to}, just so you know, they move kind of slowly, so we may not be able to wait.\" There, the Meta recruiter's goal is to get you to say, \"Oh, no, don't worry, I'm not interviewing at Google!\"\nNow, you've lost leverage in their eyes because that's one less competitive company they might lose you to... and they'll be more confident about lowballing you later on.\nAs you may have guessed from reading the previous section, it’s critical to have other offers, and not just any offers but ones from top-tier companies who pay very competitively3.\nWe realize that saying “have other offers” doesn’t capture the blood, sweat, and tears that go into months of interview prep, applications, emails, recruiter calls, and interviews. We know it’s hard, but as you’ll see, it makes a huge difference in your compensation.\nGetting those offers doesn’t start when you’ve received your Meta offer. It starts months before. Make sure that you get enough initial conversations with other FAANGs, FAANG-adjacent companies, and late-stage sexy startups to end up with at least one other offer, ideally at least two. Depending on your interview performance, this might be anywhere from 4 to 10 initial conversations.4\nHaving your offers come in around the same time is critical for any negotiation, but it’s especially important with Meta because they take such a hard line — without other offers, they will not meaningfully budge.\nObviously, you’ll want to start your conversations with other companies well in advance of your Meta interviews and do everything you can to make sure they all come in at the same time. However, even with your best efforts, it’s not guaranteed that your timing will match up. Here’s how to make sure that your offers come in at the same time: slow-play Meta’s team-matching process.\nTeam matching is actually the part of your Meta journey where you have the most leverage and power. Why leverage? At this point, they know they want you, but they can’t yet hold an offer deadline over you. We’ve already mentioned that once they make the offer, your recruiter is going to push very hard to have you accept, often giving you a deadline of something like two days. In your recruiter’s eyes, you’re a ticking time bomb, where for every day you don’t sign, the deal loses momentum, and your odds of signing drop off. Recruiters are also evaluated on how many candidates they close, so it’s in their interest to create a false sense of scarcity in order to rush you and to use high-pressure sales tactics to get you to seal the deal.\nAnd what power do you have? It turns out you can really control how long team matching takes, within reason. If you’re still wrapping phone screens with other companies, slow-playing is the best thing you can do. Here’s how to do it.\nWe’ve recently heard that Meta is now insisting that hiring manager conversations happen in series, but even if Meta lets you talk to multiple hiring managers concurrently, try to serialize those conversations as much as possible. For instance, if you hear from your recruiter that you’re going to start team matching on a Monday, and they offer to set up some calls for Wednesday, ask to do the first call on a Friday and the next call the following Tuesday. When we advise our users to do this, we often get pushback because they’re worried that slowing things down will make them look disinterested/not serious. We promise you that’s not the case. The biggest risk you run when you slow-play team matching scheduling like this is losing the chance to work on a specific team. If you find that your recruiter has proposed what seems like the perfect team for you, you can and should prioritize doing that call as soon as possible.\nIn addition to serializing your hiring manager conversations, for each team, ask to talk to a few individual contributors on teams that you’re serious about. This isn’t just a stalling tactic. These are the people you’ll be working closely with every day, and they’re the ones doing the job you may have in the future. They’re also less likely to do hard sells, and if you ask thoughtful questions, you’ll learn a lot about what to expect. We’re always surprised by how few candidates ask to speak to their future peers, out of a mistaken concern that asking for too much will make them look disinterested or unengaged. Just like with hiring manager calls, if you need to slow things down, we recommend scheduling calls with your peers a few days apart.\nWe have seen two instances when our advice about slow-playing could backfire. You probably remember when companies started to freeze hiring aggressively in mid-2022 — if you didn’t get matched before the ax came down, you were left out in the cold. Much more recently, we heard from some of our users that Meta put a pause on team matching for E4 roles (largely outside the Bay Area), and many candidates were stuck in a holding pattern (while Meta figured out headcount constraints, though it looks like it’s since been resolved, and picking back up in earnest. Slow-playing and then getting stuck is obviously an unfortunate situation, as is being on the wrong end of a hiring freeze, but these situations are rare, and in our humble opinion, not worth optimizing for — in most cases, you will not be dealing with an impending freeze or stalled matching. If you’re unsure about team supply or the state of hiring, you can do two things:\nThere's one more situation where slow-playing may bite you. If you match with a team and really click well with the manager, to the point where you have your heart set on it, it may be wise to accept that team instead of trying to drag things out. We've heard of times where, even if the candidate asked the manager about open headcount and confirmed they didn't have to rush, the role got filled from under them (they were able to talk to other teams afterwards but missed the chance to be on that specific team). If a specific team feels irreplaceable to you and you'd be crushed if you didn't get it, then that may be more important than maximizing your negotiation.\nOutside of using the team-matching process to control your timeline, there is one other important tactical piece of advice: Do your best to build rapport with hiring managers.\nAs we said above, recruiters are trying to close the deal. That’s their job. Hiring managers, on the other hand, are trying to lay the groundwork for a good working relationship with you. As a result, their interests are much more aligned with yours. Of course, they still want to close you, but it’s not worth it to them to employ high-pressure tactics, and it’s not something they’re trained in or comfortable with (in fact, many of them hated these tactics when they were on the other end of it while looking for work)5.\nAs such, hiring managers will generally be a lot more transparent with you about how much time you actually have to make a decision, and their answers will likely be very different from the ones you get from recruiters.\nWe’ve advised all of our Meta candidates to ask their prospective hiring managers about when they realistically have to make a decision by, and the differences between what the hiring manager has told them (“Take your time; you have a few weeks at least.”) and what their recruiter has told them (“We’re talking to a lot of candidates for that team. To ensure your spot, you should make a decision in the next few days.”) are stark.\nThere’s simply no downside to building rapport with hiring managers. At worst, you make a professional connection. At best, you get a head start on a great working relationship with your new boss.\nOne practical note: Always ask your hiring manager for their email address in case you have more questions later. This way, if your recruiter starts telling you that you need to make a decision by Friday, you can ping your hiring manager, explain that you’re still thinking, and ask if it’s OK to take a few more days. Almost always they will say yes.\nIf you’ve done everything else in this post, the negotiation is the easy part. By now, you’ve wrapped up team matching, chosen a team, and have likely gotten an aggressive offer deadline.\nYou have also not shared any offer details till now. As we said at the beginning of this post, the success of your strategy hinges on the recruiter not being aware of the other companies you’re interviewing with. This will be the first time they find out about it, and that will put them on their proverbial back foot.\nTo respond to the offer, you can send an email6 that looks something like the below. The details will differ, and how much you reveal about the other offers will vary, but here’s the general idea.\nHey [Recruiter name],\nThank you so much for the offer, for working with me throughout this process, and for all your help with team matching. I wanted to share some details with you. I currently have offers from {Company 1}, {Company 2}, and {Company 3}.\n{Company 1} has offered me a significantly higher base salary of $220k. {Company 2} has a comparable base but has offered me significantly more equity: $500k. I know {Company 2} is a startup, but they’re late stage and handing out RSUs. Those RSUs are as valuable to me as public company equity.\nFinally, {Company 3} has thrown in a meaningful signing bonus, and their performance bonus is actually at 25%, not 15%.\nI’m very excited about the opportunity to work at Meta and about the team. {Insert some authentic reasons why you’re excited about the company, the team, your new boss, etc.} It’d be great to see a meaningful increase in compensation to make my decision easier.\nThank you, and I look forward to hearing from you.\nBy the way, this isn’t the only approach you can take, and with other companies, you might have better luck with the Reverse Used Car Salesman. However, in our experience, if you don’t share offer details, your Meta recruiter will immediately ask you to share, so you might as well control the flow of information.\nIn the template above, I’ve assumed that not all of your offers are stronger than Meta’s across the board, which is why I’ve cherry-picked which pieces to share. Sometimes, if you’re lucky, you’ll have multiple offers that have a higher base, more equity, and a higher signing bonus. In that case, it’s less of a game of skill — just throw the numbers at them, and they’ll exceed the other offers without much prompting.\nIf you run this play, your recruiter will apologize for low-balling you, blaming the “computer” for giving them those numbers. Then, like clockwork, you will see a $50k to $150k jump in your offer (precisely how much depends on where your other offers are from and how strong they are).7\nNow, whether you take that offer is up to you.\nSome closing thoughts. I’m a capitalist. Meta’s behavior here is aggressively capitalistic, if short-sighted – once other FAANGs start meaningfully hiring again, and Meta employees figure out that there’s a $150k comp differential between people with the same job title, they’re going to pay the piper and likely see a bunch of attrition. Ultimately, the market will correct these practices. However, I also believe that individuals have the right and duty to be as informed as possible and to wield whatever weapons in their arsenal to advocate for themselves, rather than waiting on the mercy of slow, indifferent market forces.\nAs such, we hope this post has given you some ammunition in your negotiations and helped reduce the information asymmetry between you and Meta, a huge, aggressive player with basically a monopoly on eng hiring at the moment. And we hope that if anyone from Meta is reading this, it’ll spark some internal conversations about what’s right. And if they don’t, other FAANGs’ recruiters will swoop in soon enough.\nWant to know if you’re ready to interview at Meta? Do anonymous mock interviews with real Meta interviewers, and see exactly where you stack up.\nHow team matching works changed fairly recently. In the past, you’d get an offer before you matched with a team and do a 6-week “bootcamp” where you’d get up to speed on Meta’s tech stack, infrastructure, and systems, followed by a multi-week “speed dating”-esque team matching cycle. Bootcamp still exists, but now it's much shorter (2-4 weeks), and the focus is getting new engineers ramped up on generic tools. After that, new engineers continue to ramp up on their specific teams. ↩\nWe’ve recently heard that Meta may now be insisting that team matching conversations happen in serial, i.e., you can only do one at a time. However, this doesn’t meaningfully change our advice. ↩\nYou might say, “Aline, why can’t I just make up offers?” We could never, in good conscience, advise that. It’s unethical, and though I’d argue that while Meta’s negotiation practices are also unethical, that’s not the way to win. Outside of ethical considerations, while the risks of getting caught are low, they’re not zero. Lying about offers, in our mind, is the last refuge of the incompetent. ↩\nThe advice in this post is orthogonal from your career goals and what you want to work on. This blog post is about navigating an unfair system filled with opaque rules while maximizing your cash. It is not about self-actualization, though we’d argue that creating the most optionality for yourself helps with self-actualization as well. You can also talk to smaller companies and use your big-co offers as leverage to increase your startup equity. There’s nothing wrong with that, but more detail on optionality and self-actualization is outside the scope of this post. ↩\nOf course, some hiring managers will use high-pressure sales tactics or create false timelines to try to close you. But that’s the exception rather than the rule. You can decide if that’s something that you want to weigh when judging whether or not you want to work for them. ↩\nWe strongly urge you to avoid negotiating over the phone and over text, whenever possible. Your recruiter does 5 of these calls a day. You might do one of these calls every few years. Do the hard part over email. It’s the best way to level the playing field. Read this post to learn how to avoid synchronous phone negotiations (just look for “phone”). ↩\nOne advanced maneuver is to pit all your other companies against each other and raise up their initial offers BEFORE talking to Meta. We’ll likely write about how to run this play in a future post. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/how-to-negotiate-with-meta",
      "author": "",
      "user_id": ""
    },
    {
      "title": "We ran an experiment to see how easy it is to cheat with ChatGPT in interviews",
      "content": "Edit: This article originally contained a TikTok video of someone cheating in an interview with ChatGPT. Videos like this still can be found online, but companies hate them, so they don't stay up for long\nChatGPT has revolutionized work as we know it. From helping small businesses automate their administrative tasks to coding entire React components for web developers, its usefulness is hard to overstate.\nAt interviewing.io, we've been thinking a lot about how ChatGPT will change technical interviewing. One big question is: Does ChatGPT make it easy to cheat in interviews? You've probably started to hear concerns about students cheating on their homework with ChatGPT, and we are certain that some people have tried to cheat in interviews with it, too!\nInitial responses to cheating software have been pretty much in line with what you’d expect:\nIt seems clear that ChatGPT can assist people during their interviews, but we wanted to know:\nTo answer these questions, we recruited some of our professional interviewers and users for a cheating experiment! Below, we’ll share everything we discovered and explain what it means for you. As a little preview, just know this: companies need to change the types of interview questions they are asking—immediately.\ninterviewing.io is an interview practice platform and recruiting marketplace for engineers. Engineers use us for mock interviews. Companies use us to hire top performers. We have thousands of professional interviewers in our ecosystem, and hundreds of thousands of engineers have used our platform to prepare for interviews.1\nInterviewers came from our pool of professional interviewers. They were broken into three groups, with each group asking a different type of question. The interviewers had no idea that the experiment was about ChatGPT or cheating; we told them that \"[this] research study aims to understand the trends in the predictability of an interviewer’s decisions over time – especially when asking standard vs. non-standard interview questions.\"\nThese were the three question types:\nExample: The Sort Colors LeetCode question is asked exactly as it is written.\nExample: The Sort Colors question above but modified to have four integers (0,1,2,3) instead of just three integers (0,1,2) in the input.\nExample: You are given a log file with the following format:\n- :  - \n- Your task is to identify the user who represents the median level of engagement in a conversation. Only consider users with a contribution score greater than 50%. Assume that the number of such users is odd, and you need to find the one right in the middle when sorted by their contribution scores. Given the file below, the correct answer is SyntaxSorcerer.\nLOG FILE START\nNullPointerNinja: \"who's going to the event tomorrow night?\" - 100%\nLambdaLancer: \"wat?\" - 5%\nNullPointerNinja: \"the event which is on 123 avenue!\" - 100%\nSyntaxSorcerer: \"I'm coming! I'll bring chips!\" - 80%\nSyntaxSorcerer: \"and something to drink!\" - 80%\nLambdaLancer: \"I can't make it\" - 25%\nLambdaLancer: \"🙁\" - 25%\nLambdaLancer: \"I really wanted to come too!\" - 25%\nBitwiseBard: \"I'll be there!\" - 25%\nCodeMystic: \"me too and I'll brink some dip\" - 75%\nLOG FILE END\nFor more information about question types and about how we designed this experiment, please read the Interviewer Experiment Guidelines doc that we shared with participating interviewers.\nInterviewees came from our pool of active users and were invited to participate in a short survey. We selected interviewees who:\nThis selection helped us skew the candidates toward people who could feasibly cheat in an interview, had the motivation to do so, and were already reasonably familiar with ChatGPT and coding interviews.\nWe told interviewees that they had to use ChatGPT in the interview, and the goal was to test their ability to cheat with ChatGPT. They were also told not to try to pass the interview with their own skills — the point was to rely on ChatGPT.\nWe ended up conducting 37 interviews overall, 32 of which we were able to use (we had to remove 5 because participants didn’t follow directions):\nA quick disclaimer. Because our platform allows for anonymity, our interviews have audio but no video. We’re anonymous because we want to create a safe space for our users to fail and learn quickly without judgment. It’s great for our users, but we acknowledge that not having video in these interviews makes our experiment less realistic. In a real interview, you will be on camera with a job on the line, which makes cheating harder — but does not eliminate it.\nAfter the interviews, both interviewers and interviewees had to complete an exit survey. We asked interviewees about the difficulties of using ChatGPT during the interview, and interviewers were given multiple chances to express concerns about the interview — we wanted to see how many interviewers would flag their interviews as problematic and report that they suspected cheating.\nWe had no idea what would happen in this experiment, but we assumed that if half the candidates that cheated got away with it and passed the interview, it would be a telling result for our industry.\nAfter removing interviews where participants did not follow instructions2, we got the following results. Our control was how candidates performed in interviewing.io mock interviews outside the study: 53%.3 Note that most mock interviews on our platform are LeetCode-style questions, which makes sense because that's primarily what FAANG companies ask. We'll come back to this in a moment.\nPredictably, the verbatim group performed the best, passing 73% of their interviews. Interviewees reported that they got the perfect solution from ChatGPT.\nThe most notable comment from the post-interview survey for this group is below — we think it is particularly telling of what was going on in many of the interviewers’ minds:\n“It's tough to determine if the candidate breezed through the question because they're actually good or if they've heard this question before. Normally, I add 1-2 unique twists to the problem to ascertain the difference.”\nNormally, this interviewer would have followed up with a modified question to get more signal, so let’s examine the “modified” group next to see if interviewers actually got more signal by adding a twist to their questions.\nRemember, this group may have had a LeetCode question given to them, which was standard but modified in a way that was not directly available online. This means ChatGPT couldn’t have had a direct answer to this question. Hence, the interviewees were much more dependent on ChatGPT's actual problem-solving abilities than its ability to regurgitate LeetCode tutorials.\nAs predicted, the results for this group weren’t too different from the “verbatim” group, with 67% of candidates passing their interviews. As it turns out, this difference was not statistically significantly different from the \"verbatim\" group, i.e., “modified” and “verbatim” are essentially the same. This result suggests that ChatGPT can handle minor modifications to questions without much trouble. Interviewees did notice, however, that it took more prompting to get ChatGPT to solve the modified questions. As one of our interviewees said:\n“Questions that are lifted directly from LeetCode were no problem at all. A follow-up question that was not so much directly LeetCode-style was much harder to get ChatGPT to answer.”\nAs expected, the “custom” question group had the lowest pass rate, with only 25% of candidates passing. Not only is it statistically significantly smaller than the other two treatment groups, it's significantly lower than the control! When you ask candidates fully custom questions, they perform worse than they do when they're not cheating (and getting asked LeetCode-style questions)!\nNote that this number, when initially calculated, was marginally higher, but after reviewing the custom questions in detail, we discovered a problem with this question type we hadn’t anticipated, which had skewed the results minorly toward a higher pass rate. Read the section below called \"Companies: Change the questions you are asking immediately!\" to find out what that problem was.\nIn our experiment, interviewers were not aware that the interviewees were being asked to cheat. As you recall, after each interview, we had interviewers complete a survey in which they had to describe how confident they were in their assessments of candidates.\nInterviewer confidence in the correctness of their assessments was high, with 72% saying they were confident in their hiring decision. One interviewer felt so strongly about an interviewee's performance that they concluded we should invite them to be an interviewer on the platform!\n“The candidate performed very well and demonstrated knowledge of a strong Amazon L6 (Google L5) SWE... and could also be considered to be an interviewer/mentor on interviewing.io.”\nThat is a lot of confidence after just one interview — probably too much!\nWe’ve long known that engineers are bad at gauging their own performance, so perhaps it shouldn’t come as a shock to find that interviewers also overestimate the effectiveness of the questions that they ask.\nOf the interviewers who were not confident in their hiring choice (28%), we asked them why. This was the frequency distribution of their reasons.\nMost interviewers concerned about their hiring decision expressed specific reasons for their lack of confidence. These issues typically included suboptimal solutions, missed edge cases, messy code, or poor communication. We specifically included an “Other Issue” category to see if they would express a concern that the interviewee was cheating, but digging deeper revealed only minor grievances like “personality issues” and “they need to speed up their coding.”\nIn addition to having this opportunity to call out cheating, interviewers were prompted three additional times to note any other concerns they had with the interview, including free-form text boxes and several multiple-choice questions with options to explain their concerns.\nWhen an interviewee bombed because they didn’t understand the ChatGPT response, the interviewer chalked up the interviewee’s odd behavior and stilted responses to a lack of practice — not cheating. One interviewer thought the candidate's problem-solving was fine but commented that they were slow and needed to consider edge cases more carefully.\n“Candidate did not seem prepared for any LeetCode questions.\"\n“Candidate's approach lacked clarity, and they jumped into the coding too early.”\n“The candidate was not prepared to tackle even the most basic coding questions on LeetCode.”\n“Good problem solving in general, but the candidate needs to be faster at coding and identifying critical edge cases.”\nSo, who reported concerns about cheating? And who got caught?\nAs it turns out, not a single interviewer mentioned concerns about any of the candidates cheating!\nWe were stunned to discover that interviewers reported no suspicions of cheating, and interestingly, interviewees were largely confident that they were getting away with it, too. 81% reported no concerns about being caught, 13% thought they might have tipped off the interviewer, and an astonishingly small 6% of participants thought the interviewer suspected them of cheating.\nThe candidates who worried they were caught did have abnormal comments from the interviewers in the post-survey analysis, but they still were not suspected of cheating. To summarize, most candidates thought they were getting away with cheating — and they were right!\nThe obvious conclusion from these results is that companies need to start asking custom questions immediately, or they are at serious risk of candidates cheating during interviews (and ultimately not getting useful signal from their interviews)!\nChatGPT has made verbatim questions obsolete; anyone relying on them will be naively leaving their hiring processes up to chance. Hiring is already tricky enough without worrying about cheating. If you’re part of a company that uses verbatim LeetCode questions, please share this post internally!\nUsing custom questions isn’t just a good way to prevent cheating. It filters out candidates who have memorized a bunch of LeetCode solutions (as you saw, our custom question pass rate was significantly lower than our control). It also meaningfully improves candidate experience, which makes people way more likely to want to work for you. A while ago, we did an analysis of what makes good interviewers good. Not surprisingly, asking good questions was one of the hallmarks, and our best-rated interviewers were the ones who tended to ask custom questions! Question quality was extremely significant in our study, regarding whether the candidate wanted to move forward with the company. It was much more important than the company’s brand strength, which mattered for getting candidates in the door but didn’t matter relative to question quality once they were in process.\nAs some of our interviewees said…\n“Always nice to get questions that are more than just plain algorithms.”\n“I liked the question — it takes a relatively simple algorithms problem (build and traverse a tree) and adds some depth. I also liked that the interviewer connected the problem to a real product at [Redacted], which made it feel less like a toy problem and more like a pared-down version of a real problem.”\n“This is my favorite question that I’ve encountered on this site. It was one of the only ones that seemed to have real-life applicability and was drawn from a real (or potentially real) business challenge. And it also nicely wove in challenges like complexity, efficiency, and blocking.”\nOne more somewhat subtle piece of advice for companies who decide to move to more custom questions. You might be tempted to take verbatim LeetCode questions and change up the wording or some of the window dressing. That makes sense, because it’s certainly easier than coming up with questions from scratch. Unfortunately, that doesn’t work.\nAs we mentioned earlier, we discovered in this experiment that just because a question looks like a custom question, doesn’t mean it is one. Questions can appear custom and still be identical to an existing LeetCode question. When making questions to ask candidates, it isn’t enough to obscure an existing problem. You need to ensure that the problem has unique inputs and outputs to be effective at stopping ChatGPT from recognizing it!\nThe questions that interviewers ask are confidential, and we cannot share the exact questions that our interviewers used in the experiment. However, we can give you an indicative example. Below is a “custom question” with this critical flaw, which is easy for ChatGPT to beat:\nFor her birthday, Mia received a mysterious box containing numbered cards\nand a note saying, \"Combine two cards that add up to 18 to unlock your gift!\"\nHelp Mia find the right pair of cards to reveal her surprise.\nInput: An array of integers (the numbers on the cards), and the target sum (18).\narr = [1, 3, 5, 10, 8], target = 18\nOutput: The indices of the two cards that add up to the target sum.\nIn this case, [3, 4] because index 3 and 4 add to 18 (10+8).\nDid you spot the issue? While this question appears “custom” at first glance, its objective is identical to the popular TwoSum question: finding two numbers that sum to a given target. The inputs and outputs are identical; the only thing “custom” about the question is the story added to the problem.\nSeeing that this is identical to known problems, it shouldn’t be a surprise to learn that ChatGPT does well on questions that have inputs and outputs identical to existing known problems — even when they have a unique story added to them.\nOne thing we’ve found incredibly useful for coming up with good, original questions is to start a shared doc with your team where every time someone solves a problem they think is interesting, no matter how small, they jot down a quick note. These notes don’t have to be fleshed out at all, but they can be the seeds for unique interview questions that give candidates insight into the day-to-day at your company. Turning these disjointed seeds into interview questions takes thought and effort — you have to prune a lot of the details and distill the essence of the problem into something that doesn’t take the candidate a lot of work/setup to grok. You’ll also likely have to iterate on these home-grown questions a few times before you get them right — but the payoff can be huge.\nTo be clear, we’re not advocating the removal of data structures and algorithms from technical interviews. DS&A questions have gotten a bad reputation because of bad, unengaged interviewers and because of companies lazily rehashing LeetCode problems, many of them bad, which have nothing to do with their work. In the hands of good interviewers, those questions are powerful and useful. If you use the approach above, you’ll be able to come up with new data structure & algorithmic questions that have a practical foundation and component that will engage candidates and get them excited about the work you’re doing.\nYou’ll also be moving our industry forward. It’s not OK that memorizing a bunch of LeetCode questions gives candidates an edge in today’s interview process, nor is it OK that interviews have gotten to a state where cheating starts to look like a rational choice. The solution is more work on the employer’s part to come up with better questions. Let’s all do it together.\nAll right, now, for all of you who are actively looking for work, listen up! Yes, a subset of your peers will now be using ChatGPT to cheat in interviews, and at companies that ask LeetCode questions (sadly, many of them), those peers will have an edge… for a short while.\nRight now, we’re in a liminal state where companies’ processes have not caught up to reality. They will, soon enough, either by moving away from using verbatim LeetCode questions entirely (which will be a boon for our entire industry) or by returning to in-person onsites (which will make cheating largely impossible past the technical screen) or both.\nIt sucks that other candidates cheating is another thing to worry about in an already difficult climate, but we cannot, in good conscience, endorse cheating to “level the playing field.”\nIn addition, interviewees who used ChatGPT uniformly reported how much more difficult the interview was to complete while juggling the AI.\nBelow, you can view one interviewee stumbling through their time complexity analysis after giving a perfect answer to an interview question. The interviewer is confused as the interviewee scrambles to explain how they got to their incorrect time complexity (secretly provided by ChatGPT).\nWhile no one was caught during the study, their cameras were off, and cheating was still difficult for many of our skilled candidates, as evidenced by this clip.\nEthics aside, cheating is difficult, stressful, and not entirely straightforward to implement. Instead, we advise investing that effort into practice, which will serve you well once companies change their processes, which hopefully should be soon. Ultimately, we hope the advent of ChatGPT will be the catalyst that finally moves our industry’s interview standards away from grinding and memorizing to actually testing engineering ability.\nMike Mroczka, a former senior SWE (Google, Salesforce, GE), is the primary author of Beyond Cracking the Coding Interview—the official sequel to Gayle McDowell's original CTCI. He works as a tech consultant and has a decade of experience helping engineers land their dream jobs. He’s a top-rated mentor (interviewing.io, Karat, Pathrise, Skilled.inc) and the author of viral technical content on system design and technical interview strategies featured on HackerNews, Business Insider, and Wired. He also sometimes writes technical content for interviewing.io (like this piece) and was one of the authors of interviewing.io’s A Senior Engineer's Guide to the System Design Interview.\nYou can find him online at mikemroczka.com, LinkedIn, and X.\nSpecial thanks to Dwight Gunning and Liz Graves for their help with this experiment. And of course a big thank you to all the interviewees and interviewers who participated!\nTo be an interviewer on our platform, you have to have at least 4 years of experience and have conducted at least 20 interviews on behalf of a FAANG or FAANG-adjacent company). ↩\nFive interviews needed to be removed because they did not meaningfully use ChatGPT. In two instances, the interviewee was familiar with the question and chose to solve the problem themselves. In one interview, the interviewee wanted to just try the question on their own and didn't prompt ChatGPT, ignoring our instructions. The last two interviews were \"custom\" interview questions that were problematic for reasons we’ll outline later in this article. ↩\nThis is a higher passthrough rate than you'd see in the wild. We think it comes down to two factors: selection bias and pre-interview prep. The users who invest in interview prep are a specific, self-selected slice of the population. Moreover, many of our users practice on their own before practicing with a human. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/how-hard-is-it-to-cheat-with-chatgpt-in-technical-interviews",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Exactly what to say when recruiters ask you to name the first number… and other negotiation word-for-words",
      "content": "There are a lot of resources out there that talk about salary negotiation but many tend to skew a bit theoretical. In my experience, one of the hardest things about negotiating your salary is knowing what to say in tough, ambiguous situations with a power balance that’s not in your favor. What’s OK? What’s rude? What are the social norms? And so on.\nBefore I started interviewing.io, I’ve worked as a software engineer, an in-house recruiter, and an agency recruiter, so I’ve literally been on all sides of the negotiating table. For the last few years, I’ve been guest-lecturing MIT’s 6.UAT, a class about technical communication for computer science majors. Every semester, negotiation is one of the most-requested topics from students. In this post, I’m sharing the content of that lecture, which is targeted toward students, but has served seasoned industry folks just as well. You’re never too young or too old to advocate for yourself.\nBtw, if you don’t like reading and prefer long, rambly diatribes in front of an unsightly glass wall, I covered most of this material (and other stuff) in a webinar I did with the fine people at Udacity (where I used to run hiring) a few months ago. So, pick your poison.\nIf you’re early in your career, you might say that negotiation isn’t worth the hassle — after all, junior roles have pretty narrow salary bands. There are a few reasons this view is short-sighted and wrong. First, though it’s pretty unlikely in the grand scheme of things, if you’re applying to a startup, there might come a magical day when your equity is worth something. This is especially true if you’re an early employee — with a good exit, a delta of a few tenths of a percent might end up being worth a down payment on a home in San Francisco.\nBut, let’s get real, your equity is likely worthless (except interviewing.io’s equity… that’s totes gonna be worth something), so let me give you a better, more immediate reason to learn to haggle early in your career, precisely because that’s when the stakes are low. Humans are frighteningly adaptable creatures. Scared of public speaking? Give 3 talks. The first one will be gut-wrenchingly horrific, the stuff of nightmares. Your voice will crack, you’ll mumble, and the whole time, you’ll want to vomit. The next one will be nerve-wracking. The last one will mostly be OK. And after that, you’ll be just fine. Same thing applies to approach anxiety, mathematical proofs, sex, and, you guessed it, salary negotiation!\nSo, make all the awkward, teeth-cringing mistakes now, while it doesn’t matter, and where failure will cost you $5K or $10K a year. Because the further along you get in your career, the bigger the upside will be… and the bigger the downside will be for not negotiating. Not only will the salary bands be wider for senior roles, but as you get more senior, more of your comp comes from equity, and equity has an even wider range for negotiating. Negotiating your stock well can make 6-figure differences and beyond (especially if you apply some of these same skills to negotiating with investors over term sheets, should you ever start your own company)… so learn these skills (and fail) while you’re young, because the older you get, the harder it’s going to be to start and the more high-stakes it’s going to be.\nSo, below, as promised, I’ll give you a few archetypal, stress-inducing situations and what to say, word-for-word in each one. But first, let me address the elephant in the room…\nAs I mentioned earlier, this blog post is coming out of a lecture I give at MIT. Every semester, I start the negotiation portion of the lecture with the unshakeable refrain that no one will ever rescind your offer for negotiating. Last semester was different, though. I was just starting to feel my oats and get into my talk (the negotiation piece comes about halfway through) and smugly recited the bit about offers never being rescinded, followed by my usual caveat… “unless you act like a douche while negotiating.” Then, a hand shot up in the back of the room. Ah ha, I thought to myself, one of the non-believers. Ready to placate him, I called on the gentleman in the back.\n“My offer got rescinded for negotiation.”\nThe class broke out into uproarious laughter. I laughed too. It was kind of funny… but it was also unnerving, and I wanted to get to the bottom of it.\n“Were you a giant jerk when you negotiated?”\n“Nope.” Shit, OK, what else can I come up with…\n“Were you applying at a really small company with maybe one open role?” I asked, praying against hope that he’d say yes.\n“Yes.”\n“Thank god.”\nSo, there’s the one exception I’ve found so far to my blanket statement. After working with hundreds and hundreds of candidates back when I was still a recruiter, I had never heard or seen an offer get rescinded (and none of my candidates acted like douches while negotiating, thank god), until then. So, if you’re talking to a super small company with one role that closes as soon as they find someone, yes, then they might rescind the offer.\nBut, to be honest, and I’m not just saying this because I was wrong in front of hundreds of bloodthirsty undergrads, an early startup punishing a prospective employee for being entrepreneurial is a huge red flag to me.\nOK, so, now onto the bit where I tell you exactly what to say.1\nThere will come a time in every job search where a recruiter will ask you about your compensation expectations. This will likely happen very early in said search, maybe even during the first call you’ll ever have with the company.\nI think this is a heinous, illaudable practice fraught with value asymmetry. Companies know their salary ranges and roughly what you’re worth to them before they ever talk to you (barring phenomenal performance in interviews which kicks you into a different band). And they know what cost of living is in your area. So they already have all the info they need about you, while you have none about them or the role or even your market value. Sure, there are some extenuating circumstances where you are too expensive, e.g. you’re like an L6 at Google and are talking to an early stage startup that can only afford to pay you 100K a year in base, but honestly even in that situation, if the job is cool enough and if you have the savings, you might take it anyway.\nSo, basically, telling them something will only hurt you and never help you. So don’t do it. Now, here’s exactly what to say when asked to name the first number.\nAt this point, I don’t feel equipped to throw out a number because I’d like to find out more about the opportunity first – right now, I simply don’t have the data to be able to say something concrete. If you end up making me an offer, I would be more than happy to iterate on it if needed and figure out something that works. I also promise not to accept other offers until I have a chance to discuss them with you.\nTADA!\nExploding offers, in my book, are the last bastion of the incompetent. The idea goes something like this… if we give a candidate an aggressive deadline, they’ll have less of a chance to talk to other companies. Game theory for the insipid.\nHaving been on the other side of the table, I know just how arbitrary offer deadlines often are. Deadlines make sense when there is a limited number of positions and applicants all come in at the same time (e.g. internships). They do not make any sense in this market, where companies are perpetually hiring all the time — therefore it’s an entirely artificial construct. Joel Spolsky, the creator of Trello and Stack Overflow, had something particularly biting to say on the matter of exploding offers many years ago (the full post, Exploding Offer Season, is really good):\n“Here’s what you’re thinking. You’re thinking, well, that’s a good company, not my first choice, but still a good offer, and I’d hate to lose this opportunity. And you don’t know for sure if your number one choice would even hire you. So you accept the offer at your second-choice company and never go to any other interviews. And now, you lost out. You’re going to spend several years of your life in some cold dark cubicle with a crazy boss who couldn’t program a twenty out of an ATM, while some recruiter somewhere gets a $1000 bonus because she was better at negotiating than you were.”\nEven in the case of internships, offer deadlines need not be as aggressive as they often are, and I’m happy to report that many college career centers have taken stands against exploding offers. Nevertheless, if you’re not a student or if your school hasn’t outlawed this vile practice, here’s exactly what to say if it ever happens to you.\nI would very much appreciate having a bit more time. I’m very excited about Company X. At the same time, choosing where I work is extremely important to me. Of course, I will not drag things out, and I will continue to keep you in the loop, but I hope you can understand my desire to make as informed of a decision as possible. How about I make a decision by…?\nAt the end of the day, the best way to get more money is to have other offers. I know, I know, interviewing sucks and is a giant gauntlet-slog, but in many cases, having just one other offer (so, I don’t know, spending a few extra days of your time spread over a few weeks) can get you at least $10K extra. It’s a pretty rational, clear-cut argument for biting the slog-bullet and doing a few more interviews.\nOne anecdote I’ll share on the subject goes like this. A few years ago, a close friend of mine who’s notoriously bad at negotiation and hates it with a passion was interviewing at one of the big 4 companies. I was trying to talk him into getting out there just a little bit, for the love of god, and talk to at least one more company. I ended up introducing him to a mid-sized startup where he quickly got an onsite interview. Just mentioning that he had an onsite at this company to his recruiter from the bigco got him an extra $5K in his signing bonus.\nOffers are, of course, better than onsites, but in a pinch, even onsites will do… because every onsite increases your odds of not accepting the offer from the company you’re negotiating with. So, let’s say you do have some offers. Do you reveal the details?\nThe answer is that it depends. If the cash parts of the offers you have are worth more than the one you have in hand, then you can reveal the details. If they’re worth more in total but less in cash, it’s a bit dicier because equity at smaller companies is kind of worthless… you can still use it as leverage if you tell the story that that equity is worth more to YOU, but that’s going to take a bit more finesse, so if you’ve never negotiated before, you might want to hold off.\nIf the cash part of your equity is not worth more, it’s sufficient to say you have offers and when pressed, you can simply say that you’re not sharing the details (it’s ok not to share the details).\nBut whether you reveal details or not, here’s the basic formula for getting more. See why I call it the reverse used car salesman?\nI have the following onsites/offers, and I’m still interviewing at Company X and Company Y, but I’m really excited about this opportunity and will drop my other stuff and SIGN TODAY if…\nSo, “if” what? I propose listing 3 things you want, which will typically be:\nThe reason I list 3 things above isn’t because I expect you’ll be able to get all 3, but this way, you’re giving the person you’re negotiating with some options. In my experience, you’ll likely get 2 out of the 3.\nSo, what amounts should you ask for when executing on the reverse used car salesman? It’s usually easier to get equity and bonuses than salary (signing bonus is a one-off rather than something that repeats every year). Therefore, it’s not crazy to ask for 1.5X-2X the equity and an extra 10-15% in salary. For the bonus portion, a lot depends on the size of the company, but if you’re talking to a company that’s beyond seed stage, you can safely ask for at least 20% of your base salary as a signing bonus.2\nWhat if the company says no to all or most of these and are a big enough brand to where you don’t have much of a leg to stand on? You can still get creative. One of our users told me about a sweet deal he came up with — he said he’d sign today if he got to choose the team he could join and had a specific team in mind.\nAs I mentioned at the beginning of this post, there are plenty of blog posts and resources on the internets about negotiation, so I’ll just mention two of my favorites. The first is a riveting, first-hand account of negotiation adventures from one of my favorite writers in this space, Haseeb Qureshi. In his post, Haseeb talks about how he negotiated for a 250K (total package) offer with Airbnb and what he learned along the way. It’s one of the most honest and thoughtful accounts of the negotiation process I’ve ever read.\nThe second post I’ll recommend is a seminal work in salary negotiation by Patrick McKenzie (patio11 on Hacker News, in case that’s more recognizable). I read it back when I was still an engineer, and it was one of those things that indelibly changed how I looked at the world. I still madly link anyone and everyone who asks me about negotiation to this piece of writing, and it’s still bookmarked in my browser.\nIf you’re an interviewing.io user and have a job offer or five that you’re weighing and want to know exactly what to say when negotiating in your own nuanced, unique situation, please email me, and I’ll whisper sweet, fiscal nothings in your ear like a modern-day Cyrano de Bergerac wooing the sweet mistress that is capitalism.3\nIf you’re interviewing at interviewing.io, USE THESE ON ME. IT'LL BE GREAT. And while you’re at it, use these on me as well. ↩\nSome of the larger tech companies offer huge signing bonuses to new grads (~100K-ish). Obviously this advice is not for that situation. ↩\nAn increasing number of our customers pay us on subscription, so we don't get more money if you do.4 And for the ones who don't, salary and recruiting fees typically come out of a different budget. ↩\nIn the early days of interviewing.io, we tried to charge a flat per-hire fee in lieu of a percentage of salary, precisely for this reason -- we wanted to set ourselves up as an entirely impartial platform where lining up with our candidates' best interests was codified into our incentive structure. Companies were pretty weirded out by the flat fee, so we went back to doing percentages, but these days we're moving over as many of our customers to subscription as possible -- it's cheaper for them, better for candidates, and I won't lie that I like to see that recurring revenue. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/negotiate-salary-recruiter",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "Predictions are hard, and, inevitably, most of them turn out wrong. But we’d like to brave the scathing mockery of the internets and try anyway! Our courage is bolstered by some useful data we have (both proprietary and gathered from the internet), which we’ll use to guess what will happen in 2024 and to answer the question foremost in many of our minds: When is hiring coming back?\nI recently ran a Twitter poll asking my followers to estimate how many engineers had been laid off from US-based startups and tech companies in 2022 and 2023 so far. Most people overestimated the number by an order of magnitude. Here's what we did to get to the actual number.\ninterviewing.io is a technical mock interview platform and technical recruiting marketplace, so we have a ton of useful data around technical interviewing and hiring. One of the most useful pieces of data in the current climate is the ever-changing technical interview bar – throughout 2022, it’s gotten progressively harder to pass technical interviews, and it’s only going to keep getting harder. We crunched the numbers and came up with a running index that quantifies where the eng bar will be, as a function of open tech jobs. The bar is clearly going up.\nOver the past few months, I’ve seen a number of fear-mongering pieces in the press about how the recession is driving tech layoffs and how tech employees (and engineers specifically) are losing their leverage as a result. The problem is that “tech” can mean anyone working at a tech company. You’re an engineer? Of course, you’re tech. You do ops? Great, you’re tech. You do marketing? You, too, are tech! These are all critical roles at tech companies, and what I take umbrage with isn’t the decision to label non-engineers as tech employees. It’s deliberately misleading your audience by implying that “tech” refers to engineers specifically.\nI don’t like imprecision, and I really don’t like fear-mongering. So, we at interviewing.io dug into the data to see if engineers do indeed have a reason to fear.\ninterviewing.io is both a mock interview platform and an eng hiring marketplace (engineers use us for technical interview practice, and top performers get fast-tracked at companies), so we have some unique insights into how recent hiring freezes have affected engineers’ behavior. We also have unique insight into which companies are actually hiring. As such, in the spirit of being useful during a hard and uncertain time, we thought it’d be interesting to survey our users to see what’s actually going on in the market. TL;DR There are lots of engineers actively looking. There are also lots of companies who are actively hiring. Read the actual post to see the full list of 447 U.S. companies who are hiring software engineers right now.\nIt looks like we’re entering a recession. One of the hardest things about it is the lack of reliable information about whether companies are still hiring and what hiring freezes even mean. Arguably the two most impactful eng hiring freezes were announced by Facebook (May 4, 2022) and then Google (July 20, 2022). Facebook’s freeze is allegedly partial, targeting roles below L7 and excluding machine learning engineers. Google’s freeze is allegedly all-encompassing but may only last 2 weeks. But what’s actually going on? To make some sense of a bunch of contradictory information about Google’s and Facebook’s hiring freezes in the press and on Blind, we decided to ask the people who, outside of Google …\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/category/recession",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "Recently, while helping our users negotiate, we've observed a string of aggressive, candidate-unfriendly hiring practices at Meta. We’ve seen the same practices with enough candidates, and across enough different titles and positions, that it’s become clear that they are not isolated incidents or a rogue recruiter’s doing but rather a consistent implementation of a deliberate strategy that comes from the top.\nIf you’re negotiating with Meta, you need to know how they operate and understand the unwritten rules of the game. If you do not know the rules, you will fail — long before you even start negotiating.\nAt interviewing.io, we’ve coached hundreds of people through salary negotiation. We’re good at it — our average user gets $50k more in cash, and we have a 94% success rate.\nHaving done this a lot, we’ve seen our users make the same two mistakes, over and over, BEFORE they start working with us. These mistakes are costly and make it harder for us to do our jobs. Both involve how you talk to recruiters at the start of your job search, way before there’s an offer. Even if you never use our service, you should absolutely avoid these mistakes.\nThere are a lot of resources out there that talk about salary negotiation but many tend to skew a bit theoretical. In my experience, one of the hardest things about negotiating your salary is knowing what to say in tough, ambiguous situations with a power balance that’s not in your favor. What’s OK? What’s rude? What are the social norms? And so on. Before I started interviewing.io, I’ve worked as a software engineer, an in-house recruiter, and an agency recruiter, so I’ve literally been on all sides of the negotiating table. For the last few years, I’ve been guest-lecturing MIT’s 6.UAT, a class about technical communication for computer science majors. Every semester, negotiation is one …\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/category/salary-negotiation",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "Nine free chapters of Beyond Cracking the Coding Interview. are now available for free.\nYou can find them here.\nThey include:\nGayle Laakmann McDowell, Mike Mroczka, and Nil Mamano, and I have written the official sequel to Cracking the Coding Interview (often called the bible of technical interview prep). The sequel is fittingly called Beyond Cracking the Coding Interview.\nWe cover everything you need to know for today's tougher technical interviews and hiring climate. We have (at least) thirteen new technical topics and over 150 new problems. We’ve also drawn on a decade of hiring data and 100k interviews from interviewing.io to help you get noticed, manage your job search, and negotiate the best possible offer.\nThe book is available now, and purchases come with $50 off on interviewing.io... given that it costs ~$45, it's not a bad deal.\nWe recently made the difficult decision to pause our Pay Later Program. In this post, we’ll talk about why we made that call and what we’ll be doing instead to ensure that engineers who can’t afford to pay for practice will still be able to get it. We’ll also explain some things we’ve learned along the way about funnel optimization, some mistakes we made while iterating on this program, and what we’ll do differently when we hopefully unpause it in the future.\nDuring the spring of 2022, I went from being a user of interviewing.io to being one of the engineers on the team.\nI discovered interviewing.io in 2021 while preparing for my internship interviews, little did I know that I would end up interviewing for interviewing.io via an interview conducted on interviewing.io to receive an internship opportunity at interviewing.io upon passing the said interview. Yes.\nDuring my 11 weeks, I solved an important business problem, quadrupled my problem-solving skills, and collaborated with the fantastic folks who built the product made for engineers, by engineers.\nIn the wake of COVID, I made a public promise to launch a program where engineers could defer paying for practice until they found a job. Today, we’re making good on that promise by launching our Pay Later Program! With this program, you get instant credits to spend on interview practice and then pay us once you’ve found a job. And if you get a job through our job board, then you don’t have to pay anything…\nI’m really excited to announce that we raised a $10M Series A, led by the fine people at M13. This round of funding is a long time coming. I don’t know what the average company age is when successfully raising an A, but it took us 6 years to get here. It was a long and windy path, and for a little while, we almost died (more on that below), but we’re still here, and we’re so grateful and excited to finally have the resources to do what we’ve always wanted to do: fix hiring, for real. What does “fixing hiring” mean? We believe that the only way to really effect change, is to make …\nI started interviewing.io because I was frustrated with how inefficient and unfair hiring was and how much emphasis employers placed on resumes. But the problem is bigger than resumes. We’ve come to learn that interview practice matters just as much. The resume gets you in the door, and your interview performance is what gets you the offer. But, even though technical interviews are hard and scary for everyone — many of our users are senior engineers from FAANG who are terrified of getting back out there and code up the kinds of problems they don’t usually see at work while someone breathes down their neck — interview prep isn’t equitably distributed. This inequity never really …\nI started interviewing.io 5 years ago. After working as both an engineer and a recruiter, my frustration with how inefficient and unfair hiring had reached a boiling point. What made me especially angry was that despite mounting evidence that resumes are poor predictors of aptitude, employers were obsessed with where people had gone to school and worked previously. In my mind, any great engineer, regardless of how they look on paper, should have the opportunity to get their foot in the door wherever they choose. So, we set out to build a better system. On interviewing.io, software engineers can book anonymous mock interviews with senior engineers from companies like Facebook, Google, and others, and if …\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/category/company-news",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "Have you ever wondered if you should spend more time on LeetCode, participate in those contests, or focus on solving harder problems? A popular Reddit post suggests you need 700+ questions and a LeetCode rating between 1800-2000 to pass FAANG interviews. Is this really what the data supports? To answer these questions and more, we looked at our users' LeetCode ranks and ratings and tied them back to interview performance on our platform and whether those users worked at FAANG.\nIn this post, we’ll share what we’ve learned.\nIn partnership with the team at Learning Collider, we ran a study to see how good recruiters were at judging resumes.\nWe asked technical recruiters to review and make judgments about engineers’ resumes, just as they would in their current roles.\nThey answered two questions per resume:\nWe ended up with nearly 2,200 evaluations of over 1,000 resumes. We then compared those judgments to how those engineers performed in interviews on our platform. Here's what we learned.\nBloomberg recently published an article saying ChatGPT has racial bias when evaluating resumes. We re-ran their numbers and saw that they didn't do any statistical significance testing. In other words, there's no evidence of racial bias, at least not in this data set. However, ChatGPT has another kind of bias -- it drastically overestimates the value of top companies and top schools and does non-traditional candidates a disservice as a result.\nSoftware engineering jobs come with a lot of perks. But that doesn’t mean our jobs are perfect. Work requires us to commute, reduces the time we can spend with family, increases our stress levels, and forces us to deal with teammates we don't gel with. And sometimes we work for companies with questionable morals and use technologies we don’t enjoy.\nFor some of us, it’s worth trading cash for a job that fits into our lives better. But how much cash?\nTo figure this out, we surveyed our users about times they took jobs with lower compensation, why they did it, and how much money they left on the table. We have the numbers!\nDoes ChatGPT make it easy to cheat in technical interviews? To find out, we ran an experiment where we instructed interviewees on our platform to use ChatGPT in their interviews, unbeknownst to their interviewers. The results were surprising, but as a preview, know this: companies need to change the types of interview questions they are asking—immediately.\nPredictions are hard, and, inevitably, most of them turn out wrong. But we’d like to brave the scathing mockery of the internets and try anyway! Our courage is bolstered by some useful data we have (both proprietary and gathered from the internet), which we’ll use to guess what will happen in 2024 and to answer the question foremost in many of our minds: When is hiring coming back?\nThe recent exciting and somewhat horrifying inflection point in AI capability tipped me into writing this blog post.\nI simply don't believe that AI can do hiring. My argument isn't about bias (though bias is a real problem) or that it's technologically impossible. It's just that the training data simply isn't available.\nMost people believe that if you can somehow combine what's available on LinkedIn, GitHub, and the social graph (who follows whom on Twitter etc.), you'll be able to find the good engineers who are actively looking and also figure out what they want. This is wrong. None of those 3 sources are actually useful. At the end of the day, you can’t use AI for hiring if you don’t have the data. And if you have the data, then you don’t strictly need AI.\nIf you’re a software engineer who’s on the market, should you list yourself as OpenToWork? Does doing so carry a negative signal? And with the recent deluge of layoffs at tech companies, has the meaning of OpenToWork changed?\nTL;DR It used to be bad. Now, it's not. Moreover, it's clear to us that the people who were laid off in the 2nd half of 2022 and 2023 so far are great... and that, by and large, these layoffs were indeed NOT based on performance.\nPeople often suggest that interviewing.io should create a certification that our users can post on their LinkedIn profile, e.g., something like “Top 10% performer on interviewing.io”. Presumably, these certifications would signal to recruiters that this person is a good engineer and worth reaching out to and should carry more signal than where said person went to school or worked previously.\nI've always thought certifications were a terrible idea, and I’ve resisted building them. Now, we've finally dug into the data to see if my hatred of them holds water. TL;DR it does.\ninterviewing.io is an anonymous mock interview platform and eng hiring marketplace. Engineers use us for mock interviews, and we use the data from those interviews to surface top performers, in a much fairer and more predictive way than a resume. If you’re a top performer on interviewing.io, we fast-track you at the world’s best companies.\nWe make money in two ways: engineers pay us for mock interviews, and employers pay us for access to the best performers. To keep our engineer customers happy, we have to make sure that our interviewers deliver value to them by conducting realistic mock interviews and giving useful, actionable feedback afterwards. To keep our employer customers happy, we have to make sure that the engineers we send them are way better than the ones they’re getting without us. Otherwise, it’s just not worth it for them.\nThis means that we live and die by the quality of our interviewers, in a way that no single employer does, no matter how much they say they care about people analytics or interviewer metrics or training. If we don’t have really well-calibrated interviewers, who also create great candidate experience, we don’t get paid.\nIn this post, we’ll explain exactly how we compute and use these metrics to get the best work out of our interviewers.\nOver the past few months, I’ve seen a number of fear-mongering pieces in the press about how the recession is driving tech layoffs and how tech employees (and engineers specifically) are losing their leverage as a result. The problem is that “tech” can mean anyone working at a tech company. You’re an engineer? Of course, you’re tech. You do ops? Great, you’re tech. You do marketing? You, too, are tech! These are all critical roles at tech companies, and what I take umbrage with isn’t the decision to label non-engineers as tech employees. It’s deliberately misleading your audience by implying that “tech” refers to engineers specifically.\nI don’t like imprecision, and I really don’t like fear-mongering. So, we at interviewing.io dug into the data to see if engineers do indeed have a reason to fear.\ninterviewing.io is both a mock interview platform and an eng hiring marketplace (engineers use us for technical interview practice, and top performers get fast-tracked at companies), so we have some unique insights into how recent hiring freezes have affected engineers’ behavior. We also have unique insight into which companies are actually hiring. As such, in the spirit of being useful during a hard and uncertain time, we thought it’d be interesting to survey our users to see what’s actually going on in the market. TL;DR There are lots of engineers actively looking. There are also lots of companies who are actively hiring. Read the actual post to see the full list of 447 U.S. companies who are hiring software engineers right now.\nThe interviewing.io platform has hosted and collected feedback from over 100K technical interviews, split between mock interviews and real ones. It’s generally accepted that to pass a technical interview, you have to not only come up with a solution to the problem (or at least make good headway), but you also have to do a good job of articulating your thoughts, explaining to your interviewer what you’re doing as you’re doing it, and coherently discussing tradeoffs and concepts like time and space complexity. But how important is communication in technical interviews, really? We looked at the data, and it turns out that talk is cheap. Read on to find out how and why.\nAt interviewing.io, we’ve hosted over 100K technical interviews, split between mock interviews and real ones. As it happens, we know where our users currently work – they tell us that when they sign up. Given that we have this data AND given that we know how well people do in their interviews, we thought it would be interesting to see which companies’ engineers are especially good at technical interviews. Our resulting top ten lists are in this post!\nRecursive Cactus has been working as a full-stack engineer at a well-known tech company for the past 5 years, but he’s now considering a career move. Over the past 6 months, Recursive Cactus (that’s his anonymous handle on interviewing.io) has been preparing himself to succeed in future interviews, dedicating as much as 20-30 hours/week plowing through LeetCode exercises, digesting algorithms textbooks, and of course, practicing interviews on our platform to benchmark his progress.\nBut this dedication to interview prep has been taking an emotional toll on him, ...\nOne of the things that sucks most about technical interviews is that they’re a black box—candidates (usually) get told whether they made it to the next round, but they’re rarely told why they got the outcome that they did. Lack of feedback, or feedback that doesn’t come right away, isn’t just frustrating to candidates. It’s bad for business. We did a whole study on this. It turns out that candidates chronically underrate and overrate their technical interview performance, like so: Where this finding starts to get actionable is that there’s a statistically significant relationship between whether people think they did well in an interview and whether they’d want to work with you. In other words, …\nIf you say the words “there’s a pipeline problem” to explain why we’ve failed to make meaningful progress toward gender parity in software engineering, you probably won’t make many friends (or many hires). The pipeline problem argument goes something like this: “There aren’t enough qualified women out there, so it’s not our fault if we don’t hire them.” Many people don’t like this reductive line of thinking because it ignores the growing body of research that points to unwelcoming environments that drive underrepresented talent out of tech: STEM in early education being unfriendly to children from underrepresented backgrounds, lack of a level playing field and unequal access to quality STEM education (see this study on …\nWhether you’re a recruiter yourself or an engineer who’s involved in hiring, you’ve probably heard of the following two recruiting-related metrics: time to hire and cost per hire. Indeed, these are THE two metrics that any self-respecting recruiting team will track. Time to hire is important because it lets you plan — if a given role has historically taken 3 months to fill, you’re going to act differently when you need to fill it again than if it takes 2 weeks. And, traditionally, cost per hire has been a planning tool as well — if you’re setting recruiting budgets for next year and have a headcount in mind, seeing what recruiting spent last year is …\nHello everyone, my name is Atomic Artichoke, and I’m the newest employee of the interviewing.io team, having joined a couple months ago as a Data Scientist. Atomic Artichoke isn’t my real name, of course. That’s the pseudonym the interviewing.io platform gave me, right before I took my final interview with the company. If you’ve never used interviewing.io before (and hey, if you haven’t already, why not sign up now?), it’s a platform where you can practice technical interviewing anonymously with experienced engineers (and do real job interviews anonymously too). When it’s time to interview, you and your partner meet in a collaborative coding environment with voice, text chat, and a whiteboard (check out recordings of …\nAt the end of the day, money is a huge driver for the decisions we make about what jobs to go after. In the past, we’ve written about how to negotiate your salary, and there are a lot of labor statistics and reports out there looking at salaries in the tech industry as a whole. But as with many things in eng hiring, there’s very little concrete data on whether technical interview performance plays a role in compensation offers. So we set out to gather the data and asked our users who had gone on to successfully get jobs after using our platform to share their salary info. With our unique dataset of real coding …\nThe modern technical interview is a rite of passage for software engineers and (hopefully!) the precursor to a great job. But it’s also a huge source of stress and endless questions for new candidates. Just searching “how do I prepare for a technical interview” turns up millions of Medium posts, coding bootcamp blogs, Quora discussions, and entire books. Despite all this conversation, people struggle to know how they’re even doing in interviews. In a previous post, we found that a surprisingly large number of interviewing.io’s users consistently underestimate their performance, making them more likely to drop out of the process and ultimately harder to hire. Now, and with considerably more data (over 10k interviews led …\ninterviewing.io is a platform where engineers practice technical interviewing anonymously. If things go well, they can unlock the ability to participate in real, still anonymous, interviews with top companies like Twitch, Lyft and more. Earlier this year, we launched an offering specifically for university students, with the intent of helping level the playing field right at the start of people’s careers. The sad truth is that with the state of college recruiting today, if you don’t attend one of very few top schools, your chances of interacting with companies on campus are slim. It’s not fair, and it sucks, but university recruiting is still dominated by career fairs. Companies pragmatically choose to visit the same …\nAt interviewing.io, we’ve analyzed and written at some depth about what makes for a good interview from the perspective of an interviewee. However, despite the inherent power imbalance, interviewing is a two-way street. I wrote a while ago about how, in this market, recruiting isn’t about vetting as much as it is about selling, and not engaging candidates in the course of talking to them for an hour is a woefully missed opportunity. But, just like solving interview questions is a learned skill that takes time and practice, so, too, is the other side of the table. Being a good interviewer takes time and effort and a fundamental willingness to get out of autopilot and …\nIf you’re reading this post, there’s a decent chance that you’re about to re-enter the crazy and scary world of technical interviewing. Maybe you’re a college student or fresh grad who is going through the interviewing process for the first time. Maybe you’re an experienced software engineer who hasn’t even thought about interviews for a few years. Either way, the first step in the interviewing process ...\nIf you’re an engineer who’s been endorsed on LinkedIn for any number of languages/frameworks/skills, you’ve probably noticed that something isn’t quite right. Maybe they’re frameworks you’ve never touched or languages you haven’t used since freshman year of college. No matter the specifics, you’re probably at least a bit wary of the value of the LinkedIn endorsements feature. The internets, too, don’t disappoint in enumerating some absurd potential endorsements or in bemoaning the lack of relevance of said endorsements, even when they’re given in earnest. Having a gut feeling for this is one thing, but we were curious about whether we could actually come up with some numbers that showed how useless endorsements can be, and …\nThe first blog post I published that got any real attention was called “Lessons from a year’s worth of hiring data“. It was my attempt to understand what attributes of someone’s resume actually mattered for getting a software engineering job. Surprisingly, as it turned out, where someone went to school didn’t matter at all, and by far and away, the strongest signal came from the number of typos and grammatical errors on their resume. Since then, I’ve discovered (and written about) how useless resumes are, but ever since writing that first post, I’ve been itching to do something similar with interviewing.io’s data. For context, interviewing.io is a platform where people can practice technical interviewing anonymously …\ninterviewing.io is a platform where people can practice technical interviewing anonymously, and if things go well, get jobs at top companies in the process. We started it because resumes suck and because we believe that anyone, regardless of how they look on paper, should have the opportunity to prove their mettle. In February of 2016, we published a post about how people’s technical interview performance, from interview to interview, seemed quite volatile. At the time, we just had a few hundred interviews to draw on, so as you can imagine, we were quite eager to rerun the numbers with the advent of more data. After drawing on over a thousand interviews, the numbers hold up. In …\ninterviewing.io is an anonymous technical interviewing platform. We started it because resumes suck and because we believe that anyone, regardless of how they look on paper, should have the opportunity to prove their mettle. In the past few months, we’ve amassed over 600 technical interviews along with their associated data and metadata. Interview questions tend to fall into the category of what you’d encounter at a phone screen for a back-end software engineering role at a top company, and interviewers typically come from a mix of larger companies like Google, Facebook, and Twitter, as well as engineering-focused startups like Asana, Mattermark, KeepSafe, and more. Over the course of the next few posts, we’ll be sharing some …\ninterviewing.io is a platform where people can practice technical interviewing anonymously and in the process, find jobs based on their interview performance rather than their resumes. Since we started, we’ve amassed data from thousands of technical interviews, and in this blog, we routinely share some of the surprising stuff we’ve learned. In this post, I’ll talk about what happened when we built real-time voice masking to investigate the magnitude of bias against women in technical interviews. \\*\\*In short, we made men sound like women and...\ninterviewing.io is a platform where people can practice technical interviewing anonymously and, in the process, find jobs. In the past few months, we’ve amassed data from hundreds of interviews, and when we looked at how the same people performed from interview to interview, we were really surprised to find quite a bit of volatility, which, in turn, made us question the reliability of single interview outcomes.\ninterviewing.io is an anonymous technical interviewing platform. We started it because resumes suck and because we believe that anyone regardless of how they look on paper, should have the opportunity to prove their mettle. In the past few months, we’ve amassed over 600 technical interviews along with their associated data and metadata. Interview questions tend to fall into the category of what you’d encounter at a phone screen for a back-end software engineering role at a top company, and interviewers typically come from a mix...\nAbout a year ago, after looking at the resumes of engineers we had interviewed at TrialPay in 2012, I learned that the strongest signal for whether someone would get an offer was the number of typos and grammatical errors on their resume. On the other hand, where people went to school, their GPA, and highest degree earned didn’t matter at all. These results were pretty unexpected, ran counter to how resumes were normally filtered, and left me scratching my head ...\nI ran technical recruiting at TrialPay for a year before going off to start my own agency. Because I used to be an engineer, one part of my job was conducting first-round technical interviews, and between January 2012 and January 2013, I interviewed roughly 300 people for our back-end/full-stack engineer position.\nTrialPay was awesome and gave me ...\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/category/data-deep-dives",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "I’m the founder of interviewing.io, and in some ways, I’m the meritocracy hipster who was writing about how eng hiring should be meritocratic and about how quotas are bad, way before saying either was cool. At interviewing.io, my team and I have been trying to make hiring meritocratic for the last decade.\nI’ll also be the first to admit that DEI is ideologically flawed because of its emphasis on race and gender-based outcomes and its insistence on equality of those outcomes. In the last decade, we've seen a lot of bad stuff done in the name of DEI, firsthand. I'll talk about those in this post.\nBut all the recent pro-meritocracy, anti-DEI rhetoric is bad. Yelling “Meritocracy!” as if it’s a fait accompli is just as harmful as the worst parts of DEI. I’d even go so far to say that the DEI movement has done more for meritocracy than the loud pro-meritocracy movement is doing right now.\nI’m delighted that “meritocracy” is no longer a dirty word. But, just saying it isn’t enough. We have to change our hiring practices. We need to stop using meritocracy as a shield to preserve the status quo.\nIn this post, I talk about the flaws of DEI, the false promise of meritocracy, and what to do to actually make hiring meritocratic and fair.\nBloomberg recently published an article saying ChatGPT has racial bias when evaluating resumes. We re-ran their numbers and saw that they didn't do any statistical significance testing. In other words, there's no evidence of racial bias, at least not in this data set. However, ChatGPT has another kind of bias -- it drastically overestimates the value of top companies and top schools and does non-traditional candidates a disservice as a result.\nI’ve been hiring engineers in some capacity for the past decade. Five years ago I founded interviewing.io, a technical recruiting marketplace that provides engineers with anonymous mock interviews and then fast-tracks top performers—regardless of who they are or how they look on paper—at top companies. We’ve hosted close to 100K technical interviews on our platform and have helped thousands of engineers find jobs. For the last year or so, we’ve also been running a Fellowship program specifically for engineers from underrepresented backgrounds. That’s all to say that even though I have developed some strong opinions about “diversity hiring” initiatives, my opinions are based not on anecdotes but on cold, hard data. And the data points …\nI’ve been hiring engineers in some capacity for the past decade, and five years ago I founded interviewing.io, a technical recruiting marketplace that provides engineers with anonymous mock interviews and then fast-tracks top performers—regardless of who they are or how they look on paper—at top companies. We’ve hosted close to 100K technical interviews on our platform and have helped thousands of engineers find jobs. Since last year, we’ve also been running a Fellowship program specifically for engineers from underrepresented backgrounds. All that is to say that even though I have strong opinions about “diversity hiring” initiatives, I’ve acquired them the honest way, through laboratory experience.\nI started interviewing.io because I was frustrated with how inefficient and unfair hiring was and how much emphasis employers placed on resumes. But the problem is bigger than resumes. We’ve come to learn that interview practice matters just as much. The resume gets you in the door, and your interview performance is what gets you the offer. But, even though technical interviews are hard and scary for everyone — many of our users are senior engineers from FAANG who are terrified of getting back out there and code up the kinds of problems they don’t usually see at work while someone breathes down their neck — interview prep isn’t equitably distributed. This inequity never really …\nIf you say the words “there’s a pipeline problem” to explain why we’ve failed to make meaningful progress toward gender parity in software engineering, you probably won’t make many friends (or many hires). The pipeline problem argument goes something like this: “There aren’t enough qualified women out there, so it’s not our fault if we don’t hire them.” Many people don’t like this reductive line of thinking because it ignores the growing body of research that points to unwelcoming environments that drive underrepresented talent out of tech: STEM in early education being unfriendly to children from underrepresented backgrounds, lack of a level playing field and unequal access to quality STEM education (see this study on …\nHello everyone, my name is Atomic Artichoke, and I’m the newest employee of the interviewing.io team, having joined a couple months ago as a Data Scientist. Atomic Artichoke isn’t my real name, of course. That’s the pseudonym the interviewing.io platform gave me, right before I took my final interview with the company. If you’ve never used interviewing.io before (and hey, if you haven’t already, why not sign up now?), it’s a platform where you can practice technical interviewing anonymously with experienced engineers (and do real job interviews anonymously too). When it’s time to interview, you and your partner meet in a collaborative coding environment with voice, text chat, and a whiteboard (check out recordings of …\ninterviewing.io is a platform where engineers practice technical interviewing anonymously. If things go well, they can unlock the ability to participate in real, still anonymous, interviews with top companies like Twitch, Lyft and more. Earlier this year, we launched an offering specifically for university students, with the intent of helping level the playing field right at the start of people’s careers. The sad truth is that with the state of college recruiting today, if you don’t attend one of very few top schools, your chances of interacting with companies on campus are slim. It’s not fair, and it sucks, but university recruiting is still dominated by career fairs. Companies pragmatically choose to visit the same …\nEDIT: Our university hiring platform is now on Product Hunt!\nIf you’re a software engineer, you probably believe that, despite some glitches here and there, folks who have the technical chops can get hired as software engineers. We regularly hear stories about college dropouts, who, through hard work and sheer determination, bootstrapped themselves into millionaires. These stories appeal to our sense of wonder and our desire for fairness in the world, but the reality is very different. For many students looking for their first job, the odds of breaking into a top company are slim because they will likely never even have the chance to show their skills in an interview. For these students ...\nIn the last few months, several large players, including Google and Facebook, have released their latest and ultimately disappointing diversity numbers. Even with increased effort and resources poured into diversity hiring programs, Facebook’s headcount for women and people of color hasn’t really increased in the past 3 years. Google’s numbers have looked remarkably similar, and both players have yet to make significant impact in the space, despite a number of initiatives spanning everything from a points system rewarding recruiters for bringing in candidates from diverse backgrounds, to increased funding for tech education, to efforts to hire more candidates from diverse backgrounds in key leadership positions. Why have gains in diversity hiring been so lackluster across …\ninterviewing.io is a platform where people can practice technical interviewing anonymously and in the process, find jobs based on their interview performance rather than their resumes. Since we started, we’ve amassed data from thousands of technical interviews, and in this blog, we routinely share some of the surprising stuff we’ve learned. In this post, I’ll talk about what happened when we built real-time voice masking to investigate the magnitude of bias against women in technical interviews. \\*\\*In short, we made men sound like women and...\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/category/diversity",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "Have you ever wondered if you should spend more time on LeetCode, participate in those contests, or focus on solving harder problems? A popular Reddit post suggests you need 700+ questions and a LeetCode rating between 1800-2000 to pass FAANG interviews. Is this really what the data supports? To answer these questions and more, we looked at our users' LeetCode ranks and ratings and tied them back to interview performance on our platform and whether those users worked at FAANG.\nIn this post, we’ll share what we’ve learned.\nIt is high time we start talking about interviewing. I know it seems like we are talking about interviewing all the time, but we are usually talking about only one half of the equation: How to be a good candidate. What about the other half? What about the interviewer?\nIn the last decade, there has been an explosion of attention for candidates and how to improve their interview performance. This stands in stark contrast to the preparation of the interviewer. If you are lucky, your interviewer might have gotten a two hour class on how to ask only bona fide work related questions and has sat through two shadow interviews. Maybe they have even done a few interviews! Consequently, there is a lot of bad interviewing being done. That needs to change.\nI’ve been an engineering manager at Amazon, Meta and Microsoft. I’ve been in many promotion reviews, and here is my advice on what it takes to get a promotion.\nSoftware engineering jobs come with a lot of perks. But that doesn’t mean our jobs are perfect. Work requires us to commute, reduces the time we can spend with family, increases our stress levels, and forces us to deal with teammates we don't gel with. And sometimes we work for companies with questionable morals and use technologies we don’t enjoy.\nFor some of us, it’s worth trading cash for a job that fits into our lives better. But how much cash?\nTo figure this out, we surveyed our users about times they took jobs with lower compensation, why they did it, and how much money they left on the table. We have the numbers!\nDoes ChatGPT make it easy to cheat in technical interviews? To find out, we ran an experiment where we instructed interviewees on our platform to use ChatGPT in their interviews, unbeknownst to their interviewers. The results were surprising, but as a preview, know this: companies need to change the types of interview questions they are asking—immediately.\nHi, I’m Lior. I spent close to five years at Meta as a software engineer and engineering manager. During my time there I conducted more than 150 behavioral interviews. In this post, I’ll be sharing what Meta looks for in a behavioral interview, and how we evaluated candidates.\nThe interviewing.io platform has hosted and collected feedback from over 100K technical interviews, split between mock interviews and real ones. It’s generally accepted that to pass a technical interview, you have to not only come up with a solution to the problem (or at least make good headway), but you also have to do a good job of articulating your thoughts, explaining to your interviewer what you’re doing as you’re doing it, and coherently discussing tradeoffs and concepts like time and space complexity. But how important is communication in technical interviews, really? We looked at the data, and it turns out that talk is cheap. Read on to find out how and why.\n“Hamtips” stands for “Hiring Manager Technical Phone Screen.” This combines two calls: the Technical Phone Screen (TPS), which is a coding exercise that usually happens before the onsite, and the HMS call, which is a call with the Hiring Manager. By combining these two steps you shorten the intro-to-offer by ~1 week and reduce candidate dropoff by 5-10%. It’s also a lot less work for recruiters playing scheduling battleship. Finally, Hiring Managers will, on average, be better at selling working at the company – it’s kind of their job.\n“The new VP wants us to double engineering’s headcount in the next six months. If we have a chance in hell to hit the hiring target, you seriously need to reconsider how fussy you’ve become.”\nIt’s never good to have a recruiter ask engineers to lower their hiring bar, but he had a point. It can take upwards of 100 engineering hours to hire a single candidate, and we had over 50 engineers to hire. Even with the majority of the team chipping in, engineers would often spend multiple hours a week in interviews. Folks began to complain about interview burnout. Also, fewer people were actually getting offers; the onsite pass rate had fallen by almost a third, from ~40% to under 30%. This meant we needed even more interviews for every hire. Visnu and I were early engineers bothered most by the state of our hiring process. We dug in. Within a few months, the onsite pass rate went back up, and interviewing burnout receded. We didn’t lower the hiring bar, though. There was a better way.\nI recently conducted my 600th interview on interviewing.io (IIO). I’d like to share lessons learned, why I approach interviews the way that I do, and shed some light on common problem areas I see happen in technical interviews. Every interviewer on the platform is different, and so your results may vary. We have some excellent folks helping out on the platform, and have a wonderful community working to better ourselves.\nWhat is the one thing you would look out for if you had to join a company? Sometime between January and February 2020, I wanted to change jobs and was looking to join a new company. This, among other reasons, led me to embark on a marathon of technical interviews – 60+ technical interviews in 30 days. Doing that many number of interviews in such a short time meant I had an interesting mix of experiences from the various companies I interviewed with, each with their unique culture and values that often reflected in the way their interviews were conducted, intentionally or not.\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/category/guest-posts",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "A lot of other platforms offer resume reviews or help with writing resumes for $$. We don't do it, despite a lot of our users asking for this feature. The reason I've refused to build them is because, simply put, resume writing is snake oil. Why? Because recruiters aren't reading resumes. If you don't have top brands, better wording won't help. If you do have top brands, the wording doesn't matter.\nI’m the founder of interviewing.io, and in some ways, I’m the meritocracy hipster who was writing about how eng hiring should be meritocratic and about how quotas are bad, way before saying either was cool. At interviewing.io, my team and I have been trying to make hiring meritocratic for the last decade.\nI’ll also be the first to admit that DEI is ideologically flawed because of its emphasis on race and gender-based outcomes and its insistence on equality of those outcomes. In the last decade, we've seen a lot of bad stuff done in the name of DEI, firsthand. I'll talk about those in this post.\nBut all the recent pro-meritocracy, anti-DEI rhetoric is bad. Yelling “Meritocracy!” as if it’s a fait accompli is just as harmful as the worst parts of DEI. I’d even go so far to say that the DEI movement has done more for meritocracy than the loud pro-meritocracy movement is doing right now.\nI’m delighted that “meritocracy” is no longer a dirty word. But, just saying it isn’t enough. We have to change our hiring practices. We need to stop using meritocracy as a shield to preserve the status quo.\nIn this post, I talk about the flaws of DEI, the false promise of meritocracy, and what to do to actually make hiring meritocratic and fair.\nIn partnership with the team at Learning Collider, we ran a study to see how good recruiters were at judging resumes.\nWe asked technical recruiters to review and make judgments about engineers’ resumes, just as they would in their current roles.\nThey answered two questions per resume:\nWe ended up with nearly 2,200 evaluations of over 1,000 resumes. We then compared those judgments to how those engineers performed in interviews on our platform. Here's what we learned.\nDoes ChatGPT make it easy to cheat in technical interviews? To find out, we ran an experiment where we instructed interviewees on our platform to use ChatGPT in their interviews, unbeknownst to their interviewers. The results were surprising, but as a preview, know this: companies need to change the types of interview questions they are asking—immediately.\nI’ve been hiring engineers in some capacity for the past decade. Five years ago I founded interviewing.io, a technical recruiting marketplace that provides engineers with anonymous mock interviews and then fast-tracks top performers—regardless of who they are or how they look on paper—at top companies. We’ve hosted close to 100K technical interviews on our platform and have helped thousands of engineers find jobs. For the last year or so, we’ve also been running a Fellowship program specifically for engineers from underrepresented backgrounds. That’s all to say that even though I have developed some strong opinions about “diversity hiring” initiatives, my opinions are based not on anecdotes but on cold, hard data. And the data points …\nI’ve been hiring engineers in some capacity for the past decade, and five years ago I founded interviewing.io, a technical recruiting marketplace that provides engineers with anonymous mock interviews and then fast-tracks top performers—regardless of who they are or how they look on paper—at top companies. We’ve hosted close to 100K technical interviews on our platform and have helped thousands of engineers find jobs. Since last year, we’ve also been running a Fellowship program specifically for engineers from underrepresented backgrounds. All that is to say that even though I have strong opinions about “diversity hiring” initiatives, I’ve acquired them the honest way, through laboratory experience.\nI started interviewing.io 5 years ago. After working as both an engineer and a recruiter, my frustration with how inefficient and unfair hiring had reached a boiling point. What made me especially angry was that despite mounting evidence that resumes are poor predictors of aptitude, employers were obsessed with where people had gone to school and worked previously. In my mind, any great engineer, regardless of how they look on paper, should have the opportunity to get their foot in the door wherever they choose. So, we set out to build a better system. On interviewing.io, software engineers can book anonymous mock interviews with senior engineers from companies like Facebook, Google, and others, and if …\nRecursive Cactus has been working as a full-stack engineer at a well-known tech company for the past 5 years, but he’s now considering a career move. Over the past 6 months, Recursive Cactus (that’s his anonymous handle on interviewing.io) has been preparing himself to succeed in future interviews, dedicating as much as 20-30 hours/week plowing through LeetCode exercises, digesting algorithms textbooks, and of course, practicing interviews on our platform to benchmark his progress.\nBut this dedication to interview prep has been taking an emotional toll on him, ...\nOne of the things that sucks most about technical interviews is that they’re a black box—candidates (usually) get told whether they made it to the next round, but they’re rarely told why they got the outcome that they did. Lack of feedback, or feedback that doesn’t come right away, isn’t just frustrating to candidates. It’s bad for business. We did a whole study on this. It turns out that candidates chronically underrate and overrate their technical interview performance, like so: Where this finding starts to get actionable is that there’s a statistically significant relationship between whether people think they did well in an interview and whether they’d want to work with you. In other words, …\nIf you say the words “there’s a pipeline problem” to explain why we’ve failed to make meaningful progress toward gender parity in software engineering, you probably won’t make many friends (or many hires). The pipeline problem argument goes something like this: “There aren’t enough qualified women out there, so it’s not our fault if we don’t hire them.” Many people don’t like this reductive line of thinking because it ignores the growing body of research that points to unwelcoming environments that drive underrepresented talent out of tech: STEM in early education being unfriendly to children from underrepresented backgrounds, lack of a level playing field and unequal access to quality STEM education (see this study on …\ninterviewing.io is a platform where engineers practice technical interviewing anonymously. If things go well, they can unlock the ability to participate in real, still anonymous, interviews with top companies like Twitch, Lyft and more. Earlier this year, we launched an offering specifically for university students, with the intent of helping level the playing field right at the start of people’s careers. The sad truth is that with the state of college recruiting today, if you don’t attend one of very few top schools, your chances of interacting with companies on campus are slim. It’s not fair, and it sucks, but university recruiting is still dominated by career fairs. Companies pragmatically choose to visit the same …\nEDIT: Our university hiring platform is now on Product Hunt!\nIf you’re a software engineer, you probably believe that, despite some glitches here and there, folks who have the technical chops can get hired as software engineers. We regularly hear stories about college dropouts, who, through hard work and sheer determination, bootstrapped themselves into millionaires. These stories appeal to our sense of wonder and our desire for fairness in the world, but the reality is very different. For many students looking for their first job, the odds of breaking into a top company are slim because they will likely never even have the chance to show their skills in an interview. For these students ...\nIf you’re an engineer who’s been endorsed on LinkedIn for any number of languages/frameworks/skills, you’ve probably noticed that something isn’t quite right. Maybe they’re frameworks you’ve never touched or languages you haven’t used since freshman year of college. No matter the specifics, you’re probably at least a bit wary of the value of the LinkedIn endorsements feature. The internets, too, don’t disappoint in enumerating some absurd potential endorsements or in bemoaning the lack of relevance of said endorsements, even when they’re given in earnest. Having a gut feeling for this is one thing, but we were curious about whether we could actually come up with some numbers that showed how useless endorsements can be, and …\nIn the last few months, several large players, including Google and Facebook, have released their latest and ultimately disappointing diversity numbers. Even with increased effort and resources poured into diversity hiring programs, Facebook’s headcount for women and people of color hasn’t really increased in the past 3 years. Google’s numbers have looked remarkably similar, and both players have yet to make significant impact in the space, despite a number of initiatives spanning everything from a points system rewarding recruiters for bringing in candidates from diverse backgrounds, to increased funding for tech education, to efforts to hire more candidates from diverse backgrounds in key leadership positions. Why have gains in diversity hiring been so lackluster across …\nAbout a year ago, after looking at the resumes of engineers we had interviewed at TrialPay in 2012, I learned that the strongest signal for whether someone would get an offer was the number of typos and grammatical errors on their resume. On the other hand, where people went to school, their GPA, and highest degree earned didn’t matter at all. These results were pretty unexpected, ran counter to how resumes were normally filtered, and left me scratching my head ...\nI ran technical recruiting at TrialPay for a year before going off to start my own agency. Because I used to be an engineer, one part of my job was conducting first-round technical interviews, and between January 2012 and January 2013, I interviewed roughly 300 people for our back-end/full-stack engineer position.\nTrialPay was awesome and gave me ...\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/category/hiring-is-broken",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "Years ago, Steve Krug wrote a book about web design called Don’t Make Me Think. It’s a classic, and the main point is that good design should make everything painfully obvious to users without demanding anything of them.\nResumes are just the same. Your resume shouldn’t make recruiters think. It should serve up the most important things about you on a platter that they can digest in 30 seconds or less. We've said before that spending a lot of time on your resume is a fool's errand, but if you’re going to do something to it, let’s make sure that that something is low-effort and high-return. Here's exactly what to do.\nA lot of other platforms offer resume reviews or help with writing resumes for $$. We don't do it, despite a lot of our users asking for this feature. The reason I've refused to build them is because, simply put, resume writing is snake oil. Why? Because recruiters aren't reading resumes. If you don't have top brands, better wording won't help. If you do have top brands, the wording doesn't matter.\nAt interviewing.io, we’ve seen hundreds of thousands of engineers go through job searches, and the biggest mistakes we see people make are all variations on the same theme: not postponing their interview when they aren’t ready. In most situations, there is no downside to postponing. In this post, we'll tell you what to do and say.\nHave you ever wondered if you should spend more time on LeetCode, participate in those contests, or focus on solving harder problems? A popular Reddit post suggests you need 700+ questions and a LeetCode rating between 1800-2000 to pass FAANG interviews. Is this really what the data supports? To answer these questions and more, we looked at our users' LeetCode ranks and ratings and tied them back to interview performance on our platform and whether those users worked at FAANG.\nIn this post, we’ll share what we’ve learned.\nIn part 1 of this post, we analyzed different ways to get into companies along two axes: effectiveness and how much control you actually have.\nThe channel that maximizes both effectiveness and control is cold outreach to hiring managers (not recruiters!). And yet, most people do this type of outreach incorrectly. In this post, we'll tell you exactly what to do and what to say to reach out to hiring managers at top companies and get responses.\ninterviewing.io is an anonymous mock interview platform — we help engineers prepare for technical interviews. In this market, many of our users are struggling with getting in the door at companies, so we ran a survey to see what’s worked well and what hasn’t, in today’s difficult climate.\nNot surprisingly, warm referrals are the best way in. On the other hand, agency recruiters are clearly the worst. But not all channels are created equal. Some, like recruiters contacting you, you have minimal control over, and whether you get contacted is largely a function of whether you have top brands on your resume or belong to an underrepresented group. With others, like reaching out to hiring managers, you are fully in control of your destiny. Here's how to make the most of a difficult landscape.\nMy name is Kevin. I am not and have never been a software engineer. I have never written or tested a single line of code, and I have never even worked as a PM. Despite that, I was able to pass a Google system design interview.\nI had just finished working on a system design interview guide and learned a LOT from doing that, but I also learned a few tricks along the way. If these tricks helped me pass, then imagine what you’ll be able to do with them.\nHi, I’m Lior. I spent close to five years at Meta as a software engineer and engineering manager. During my time there I conducted more than 150 behavioral interviews. In this post, I’ll be sharing what Meta looks for in a behavioral interview, and how we evaluated candidates.\nThe interviewing.io platform has hosted and collected feedback from over 100K technical interviews, split between mock interviews and real ones. It’s generally accepted that to pass a technical interview, you have to not only come up with a solution to the problem (or at least make good headway), but you also have to do a good job of articulating your thoughts, explaining to your interviewer what you’re doing as you’re doing it, and coherently discussing tradeoffs and concepts like time and space complexity. But how important is communication in technical interviews, really? We looked at the data, and it turns out that talk is cheap. Read on to find out how and why.\nAt interviewing.io, we’ve hosted over 100K technical interviews, split between mock interviews and real ones. As it happens, we know where our users currently work – they tell us that when they sign up. Given that we have this data AND given that we know how well people do in their interviews, we thought it would be interesting to see which companies’ engineers are especially good at technical interviews. Our resulting top ten lists are in this post!\nRecently, someone asked us how you know you’re ready to succeed in a Facebook/Amazon/Apple/Netflix/Google (FAANG) interview. It’s an interesting question, and one I’m sure many of you job seekers out there are wondering. Internally, we have our own beliefs, but we wanted to see if we could answer this question more objectively. So we set off on a journey to acquire data to try answering it.\nI recently conducted my 600th interview on interviewing.io (IIO). I’d like to share lessons learned, why I approach interviews the way that I do, and shed some light on common problem areas I see happen in technical interviews. Every interviewer on the platform is different, and so your results may vary. We have some excellent folks helping out on the platform, and have a wonderful community working to better ourselves.\nWhat is the one thing you would look out for if you had to join a company? Sometime between January and February 2020, I wanted to change jobs and was looking to join a new company. This, among other reasons, led me to embark on a marathon of technical interviews – 60+ technical interviews in 30 days. Doing that many number of interviews in such a short time meant I had an interesting mix of experiences from the various companies I interviewed with, each with their unique culture and values that often reflected in the way their interviews were conducted, intentionally or not.\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/category/interview-tips",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "We surveyed almost 700 of our users about their experiences with take-homes and interviewed a handful more for deeper insights. We learned a lot—mostly about candidates' poor experiences and negative feelings toward take-homes. They take a lot of time. They don’t respect candidates’ time. Candidates often get no feedback. And candidates are almost never compensated. Really, it's all about value asymmetry.\nThe good news? Turns out there are some pretty simple things companies can do to vastly improve their take-home assignments\nIt is high time we start talking about interviewing. I know it seems like we are talking about interviewing all the time, but we are usually talking about only one half of the equation: How to be a good candidate. What about the other half? What about the interviewer?\nIn the last decade, there has been an explosion of attention for candidates and how to improve their interview performance. This stands in stark contrast to the preparation of the interviewer. If you are lucky, your interviewer might have gotten a two hour class on how to ask only bona fide work related questions and has sat through two shadow interviews. Maybe they have even done a few interviews! Consequently, there is a lot of bad interviewing being done. That needs to change.\nThe recent exciting and somewhat horrifying inflection point in AI capability tipped me into writing this blog post.\nI simply don't believe that AI can do hiring. My argument isn't about bias (though bias is a real problem) or that it's technologically impossible. It's just that the training data simply isn't available.\nMost people believe that if you can somehow combine what's available on LinkedIn, GitHub, and the social graph (who follows whom on Twitter etc.), you'll be able to find the good engineers who are actively looking and also figure out what they want. This is wrong. None of those 3 sources are actually useful. At the end of the day, you can’t use AI for hiring if you don’t have the data. And if you have the data, then you don’t strictly need AI.\ninterviewing.io is an anonymous mock interview platform and eng hiring marketplace. We make money in two ways: engineers pay us for mock interviews, and employers pay us for access to the best performers. This means that we live and die by the quality of our interviewers in a way that no single employer does – if we don’t have really well-calibrated interviewers, who also create great candidate experience, we don’t get paid.\nIn a recent post, we shared how, over time, we came up with two metrics that, together, tell a complete and compelling story about interviewer quality: the candidate experience metric and the calibration metric. In this post, we’ll talk about how to apply our learnings about interviewer quality to your own process. We’ve made a bunch of mistakes so you don’t have to! It boils down to choosing the right people, tracking those 2 metrics diligently, rewarding good behavior, and committing to providing feedback to your candidates.\nGiving feedback will not only make candidates you want today more likely to join your team, but it’s also crucial to hiring the candidates you might want down the road. Technical interview outcomes are erratic, and according to our data, only about 25% of candidates perform consistently from interview to interview.\ninterviewing.io is an anonymous mock interview platform and eng hiring marketplace. Engineers use us for mock interviews, and we use the data from those interviews to surface top performers, in a much fairer and more predictive way than a resume. If you’re a top performer on interviewing.io, we fast-track you at the world’s best companies.\nWe make money in two ways: engineers pay us for mock interviews, and employers pay us for access to the best performers. To keep our engineer customers happy, we have to make sure that our interviewers deliver value to them by conducting realistic mock interviews and giving useful, actionable feedback afterwards. To keep our employer customers happy, we have to make sure that the engineers we send them are way better than the ones they’re getting without us. Otherwise, it’s just not worth it for them.\nThis means that we live and die by the quality of our interviewers, in a way that no single employer does, no matter how much they say they care about people analytics or interviewer metrics or training. If we don’t have really well-calibrated interviewers, who also create great candidate experience, we don’t get paid.\nIn this post, we’ll explain exactly how we compute and use these metrics to get the best work out of our interviewers.\n“Hamtips” stands for “Hiring Manager Technical Phone Screen.” This combines two calls: the Technical Phone Screen (TPS), which is a coding exercise that usually happens before the onsite, and the HMS call, which is a call with the Hiring Manager. By combining these two steps you shorten the intro-to-offer by ~1 week and reduce candidate dropoff by 5-10%. It’s also a lot less work for recruiters playing scheduling battleship. Finally, Hiring Managers will, on average, be better at selling working at the company – it’s kind of their job.\nWhen you start writing a job description, the first question you should ask yourself is, Am I trying to attract the right people, or am I trying to keep the wrong people out? Then, once you answer it, write for that audience deliberately, because it’s really hard to write for both…\nI’ve been hiring engineers in some capacity for the past decade, and five years ago I founded interviewing.io, a technical recruiting marketplace that provides engineers with anonymous mock interviews and then fast-tracks top performers—regardless of who they are or how they look on paper—at top companies. We’ve hosted close to 100K technical interviews on our platform and have helped thousands of engineers find jobs. Since last year, we’ve also been running a Fellowship program specifically for engineers from underrepresented backgrounds. All that is to say that even though I have strong opinions about “diversity hiring” initiatives, I’ve acquired them the honest way, through laboratory experience.\n“The new VP wants us to double engineering’s headcount in the next six months. If we have a chance in hell to hit the hiring target, you seriously need to reconsider how fussy you’ve become.”\nIt’s never good to have a recruiter ask engineers to lower their hiring bar, but he had a point. It can take upwards of 100 engineering hours to hire a single candidate, and we had over 50 engineers to hire. Even with the majority of the team chipping in, engineers would often spend multiple hours a week in interviews. Folks began to complain about interview burnout. Also, fewer people were actually getting offers; the onsite pass rate had fallen by almost a third, from ~40% to under 30%. This meant we needed even more interviews for every hire. Visnu and I were early engineers bothered most by the state of our hiring process. We dug in. Within a few months, the onsite pass rate went back up, and interviewing burnout receded. We didn’t lower the hiring bar, though. There was a better way.\nOne of the things that sucks most about technical interviews is that they’re a black box—candidates (usually) get told whether they made it to the next round, but they’re rarely told why they got the outcome that they did. Lack of feedback, or feedback that doesn’t come right away, isn’t just frustrating to candidates. It’s bad for business. We did a whole study on this. It turns out that candidates chronically underrate and overrate their technical interview performance, like so: Where this finding starts to get actionable is that there’s a statistically significant relationship between whether people think they did well in an interview and whether they’d want to work with you. In other words, …\nIf I’m honest, I’ve wanted to write something about employer brand for a long time. One of the things that really gets my goat is when companies build employer brand by over-indexing on banalities (“look we have a ping pong table!”, “look we’re a startup so you’ll have a huge impact”, etc.) instead of focusing on the narratives that make them special. Hiring engineers is really hard. It’s hard for tech giants, and it’s hard for small companies… but it’s especially hard for small companies people haven’t quite heard of, and they can use all the help they can get because talking about impact and ping pong tables just doesn’t cut it anymore. At interviewing.io, …\nWhether you’re a recruiter yourself or an engineer who’s involved in hiring, you’ve probably heard of the following two recruiting-related metrics: time to hire and cost per hire. Indeed, these are THE two metrics that any self-respecting recruiting team will track. Time to hire is important because it lets you plan — if a given role has historically taken 3 months to fill, you’re going to act differently when you need to fill it again than if it takes 2 weeks. And, traditionally, cost per hire has been a planning tool as well — if you’re setting recruiting budgets for next year and have a headcount in mind, seeing what recruiting spent last year is …\nAt interviewing.io, we’ve analyzed and written at some depth about what makes for a good interview from the perspective of an interviewee. However, despite the inherent power imbalance, interviewing is a two-way street. I wrote a while ago about how, in this market, recruiting isn’t about vetting as much as it is about selling, and not engaging candidates in the course of talking to them for an hour is a woefully missed opportunity. But, just like solving interview questions is a learned skill that takes time and practice, so, too, is the other side of the table. Being a good interviewer takes time and effort and a fundamental willingness to get out of autopilot and …\ninterviewing.io is an anonymous technical interviewing platform. We started it because resumes suck and because we believe that anyone, regardless of how they look on paper, should have the opportunity to prove their mettle. In the past few months, we’ve amassed over 600 technical interviews along with their associated data and metadata. Interview questions tend to fall into the category of what you’d encounter at a phone screen for a back-end software engineering role at a top company, and interviewers typically come from a mix of larger companies like Google, Facebook, and Twitter, as well as engineering-focused startups like Asana, Mattermark, KeepSafe, and more. Over the course of the next few posts, we’ll be sharing some …\nRecently, a number of founder friends have asked me about how to approach their first recruiting hire, and I’ve found myself repeating the same stuff over and over again. Below are some of my most salient thoughts on the subject. Note that I’ll be talking a lot about engineering hiring because that’s what I know, but I expect a lot of this applies to other fields as well, especially ones where the demand for labor outstrips supply. Don’t get caught up by flashy employment history; hustle trumps brands At first glance, hiring someone who’s done recruiting for highly successful tech giants seems like a no-brainer. Google and Facebook are good at hiring great engineers, right? …\ninterviewing.io is an anonymous technical interviewing platform. We started it because resumes suck and because we believe that anyone regardless of how they look on paper, should have the opportunity to prove their mettle. In the past few months, we’ve amassed over 600 technical interviews along with their associated data and metadata. Interview questions tend to fall into the category of what you’d encounter at a phone screen for a back-end software engineering role at a top company, and interviewers typically come from a mix...\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/category/for-employers-how-to-hire-better",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "It is high time we start talking about interviewing. I know it seems like we are talking about interviewing all the time, but we are usually talking about only one half of the equation: How to be a good candidate. What about the other half? What about the interviewer?\nIn the last decade, there has been an explosion of attention for candidates and how to improve their interview performance. This stands in stark contrast to the preparation of the interviewer. If you are lucky, your interviewer might have gotten a two hour class on how to ask only bona fide work related questions and has sat through two shadow interviews. Maybe they have even done a few interviews! Consequently, there is a lot of bad interviewing being done. That needs to change.\nIn partnership with the team at Learning Collider, we ran a study to see how good recruiters were at judging resumes.\nWe asked technical recruiters to review and make judgments about engineers’ resumes, just as they would in their current roles.\nThey answered two questions per resume:\nWe ended up with nearly 2,200 evaluations of over 1,000 resumes. We then compared those judgments to how those engineers performed in interviews on our platform. Here's what we learned.\nBloomberg recently published an article saying ChatGPT has racial bias when evaluating resumes. We re-ran their numbers and saw that they didn't do any statistical significance testing. In other words, there's no evidence of racial bias, at least not in this data set. However, ChatGPT has another kind of bias -- it drastically overestimates the value of top companies and top schools and does non-traditional candidates a disservice as a result.\nI’ve been an engineering manager at Amazon, Meta and Microsoft. I’ve been in many promotion reviews, and here is my advice on what it takes to get a promotion.\nThe first super-important thing I learned is that just because you're qualified for the job doesn't mean you can pass the Big Tech Interview. I'm really smart. I got a 4.9 GPA at MIT. By this time I had worked with a pretty wide range of different software languages, tools, frameworks, ideologies, etc. I had managed 30+ people and could also plan and build complex systems solo when needed. I felt very qualified for the positions I was applying for. On my first Big Tech Interview, I did terribly.\nRecently, while helping our users negotiate, we've observed a string of aggressive, candidate-unfriendly hiring practices at Meta. We’ve seen the same practices with enough candidates, and across enough different titles and positions, that it’s become clear that they are not isolated incidents or a rogue recruiter’s doing but rather a consistent implementation of a deliberate strategy that comes from the top.\nIf you’re negotiating with Meta, you need to know how they operate and understand the unwritten rules of the game. If you do not know the rules, you will fail — long before you even start negotiating.\nSoftware engineering jobs come with a lot of perks. But that doesn’t mean our jobs are perfect. Work requires us to commute, reduces the time we can spend with family, increases our stress levels, and forces us to deal with teammates we don't gel with. And sometimes we work for companies with questionable morals and use technologies we don’t enjoy.\nFor some of us, it’s worth trading cash for a job that fits into our lives better. But how much cash?\nTo figure this out, we surveyed our users about times they took jobs with lower compensation, why they did it, and how much money they left on the table. We have the numbers!\nDoes ChatGPT make it easy to cheat in technical interviews? To find out, we ran an experiment where we instructed interviewees on our platform to use ChatGPT in their interviews, unbeknownst to their interviewers. The results were surprising, but as a preview, know this: companies need to change the types of interview questions they are asking—immediately.\nPredictions are hard, and, inevitably, most of them turn out wrong. But we’d like to brave the scathing mockery of the internets and try anyway! Our courage is bolstered by some useful data we have (both proprietary and gathered from the internet), which we’ll use to guess what will happen in 2024 and to answer the question foremost in many of our minds: When is hiring coming back?\nAt interviewing.io, we’ve coached hundreds of people through salary negotiation. We’re good at it — our average user gets $50k more in cash, and we have a 94% success rate.\nHaving done this a lot, we’ve seen our users make the same two mistakes, over and over, BEFORE they start working with us. These mistakes are costly and make it harder for us to do our jobs. Both involve how you talk to recruiters at the start of your job search, way before there’s an offer. Even if you never use our service, you should absolutely avoid these mistakes.\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/page/2",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "My name is Kevin. I am not and have never been a software engineer. I have never written or tested a single line of code, and I have never even worked as a PM. Despite that, I was able to pass a Google system design interview.\nI had just finished working on a system design interview guide and learned a LOT from doing that, but I also learned a few tricks along the way. If these tricks helped me pass, then imagine what you’ll be able to do with them.\nThe recent exciting and somewhat horrifying inflection point in AI capability tipped me into writing this blog post.\nI simply don't believe that AI can do hiring. My argument isn't about bias (though bias is a real problem) or that it's technologically impossible. It's just that the training data simply isn't available.\nMost people believe that if you can somehow combine what's available on LinkedIn, GitHub, and the social graph (who follows whom on Twitter etc.), you'll be able to find the good engineers who are actively looking and also figure out what they want. This is wrong. None of those 3 sources are actually useful. At the end of the day, you can’t use AI for hiring if you don’t have the data. And if you have the data, then you don’t strictly need AI.\nIf you’re a software engineer who’s on the market, should you list yourself as OpenToWork? Does doing so carry a negative signal? And with the recent deluge of layoffs at tech companies, has the meaning of OpenToWork changed?\nTL;DR It used to be bad. Now, it's not. Moreover, it's clear to us that the people who were laid off in the 2nd half of 2022 and 2023 so far are great... and that, by and large, these layoffs were indeed NOT based on performance.\nPeople often suggest that interviewing.io should create a certification that our users can post on their LinkedIn profile, e.g., something like “Top 10% performer on interviewing.io”. Presumably, these certifications would signal to recruiters that this person is a good engineer and worth reaching out to and should carry more signal than where said person went to school or worked previously.\nI've always thought certifications were a terrible idea, and I’ve resisted building them. Now, we've finally dug into the data to see if my hatred of them holds water. TL;DR it does.\ninterviewing.io is an anonymous mock interview platform and eng hiring marketplace. We make money in two ways: engineers pay us for mock interviews, and employers pay us for access to the best performers. This means that we live and die by the quality of our interviewers in a way that no single employer does – if we don’t have really well-calibrated interviewers, who also create great candidate experience, we don’t get paid.\nIn a recent post, we shared how, over time, we came up with two metrics that, together, tell a complete and compelling story about interviewer quality: the candidate experience metric and the calibration metric. In this post, we’ll talk about how to apply our learnings about interviewer quality to your own process. We’ve made a bunch of mistakes so you don’t have to! It boils down to choosing the right people, tracking those 2 metrics diligently, rewarding good behavior, and committing to providing feedback to your candidates.\nHi, I’m Lior. I spent close to five years at Meta as a software engineer and engineering manager. During my time there I conducted more than 150 behavioral interviews. In this post, I’ll be sharing what Meta looks for in a behavioral interview, and how we evaluated candidates.\nGiving feedback will not only make candidates you want today more likely to join your team, but it’s also crucial to hiring the candidates you might want down the road. Technical interview outcomes are erratic, and according to our data, only about 25% of candidates perform consistently from interview to interview.\nI recently ran a Twitter poll asking my followers to estimate how many engineers had been laid off from US-based startups and tech companies in 2022 and 2023 so far. Most people overestimated the number by an order of magnitude. Here's what we did to get to the actual number.\ninterviewing.io is an anonymous mock interview platform and eng hiring marketplace. Engineers use us for mock interviews, and we use the data from those interviews to surface top performers, in a much fairer and more predictive way than a resume. If you’re a top performer on interviewing.io, we fast-track you at the world’s best companies.\nWe make money in two ways: engineers pay us for mock interviews, and employers pay us for access to the best performers. To keep our engineer customers happy, we have to make sure that our interviewers deliver value to them by conducting realistic mock interviews and giving useful, actionable feedback afterwards. To keep our employer customers happy, we have to make sure that the engineers we send them are way better than the ones they’re getting without us. Otherwise, it’s just not worth it for them.\nThis means that we live and die by the quality of our interviewers, in a way that no single employer does, no matter how much they say they care about people analytics or interviewer metrics or training. If we don’t have really well-calibrated interviewers, who also create great candidate experience, we don’t get paid.\nIn this post, we’ll explain exactly how we compute and use these metrics to get the best work out of our interviewers.\ninterviewing.io is a technical mock interview platform and technical recruiting marketplace, so we have a ton of useful data around technical interviewing and hiring. One of the most useful pieces of data in the current climate is the ever-changing technical interview bar – throughout 2022, it’s gotten progressively harder to pass technical interviews, and it’s only going to keep getting harder. We crunched the numbers and came up with a running index that quantifies where the eng bar will be, as a function of open tech jobs. The bar is clearly going up.\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/page/3",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "Over the past few months, I’ve seen a number of fear-mongering pieces in the press about how the recession is driving tech layoffs and how tech employees (and engineers specifically) are losing their leverage as a result. The problem is that “tech” can mean anyone working at a tech company. You’re an engineer? Of course, you’re tech. You do ops? Great, you’re tech. You do marketing? You, too, are tech! These are all critical roles at tech companies, and what I take umbrage with isn’t the decision to label non-engineers as tech employees. It’s deliberately misleading your audience by implying that “tech” refers to engineers specifically.\nI don’t like imprecision, and I really don’t like fear-mongering. So, we at interviewing.io dug into the data to see if engineers do indeed have a reason to fear.\nWe recently made the difficult decision to pause our Pay Later Program. In this post, we’ll talk about why we made that call and what we’ll be doing instead to ensure that engineers who can’t afford to pay for practice will still be able to get it. We’ll also explain some things we’ve learned along the way about funnel optimization, some mistakes we made while iterating on this program, and what we’ll do differently when we hopefully unpause it in the future.\ninterviewing.io is both a mock interview platform and an eng hiring marketplace (engineers use us for technical interview practice, and top performers get fast-tracked at companies), so we have some unique insights into how recent hiring freezes have affected engineers’ behavior. We also have unique insight into which companies are actually hiring. As such, in the spirit of being useful during a hard and uncertain time, we thought it’d be interesting to survey our users to see what’s actually going on in the market. TL;DR There are lots of engineers actively looking. There are also lots of companies who are actively hiring. Read the actual post to see the full list of 447 U.S. companies who are hiring software engineers right now.\nDuring the spring of 2022, I went from being a user of interviewing.io to being one of the engineers on the team.\nI discovered interviewing.io in 2021 while preparing for my internship interviews, little did I know that I would end up interviewing for interviewing.io via an interview conducted on interviewing.io to receive an internship opportunity at interviewing.io upon passing the said interview. Yes.\nDuring my 11 weeks, I solved an important business problem, quadrupled my problem-solving skills, and collaborated with the fantastic folks who built the product made for engineers, by engineers.\nIt looks like we’re entering a recession. One of the hardest things about it is the lack of reliable information about whether companies are still hiring and what hiring freezes even mean. Arguably the two most impactful eng hiring freezes were announced by Facebook (May 4, 2022) and then Google (July 20, 2022). Facebook’s freeze is allegedly partial, targeting roles below L7 and excluding machine learning engineers. Google’s freeze is allegedly all-encompassing but may only last 2 weeks. But what’s actually going on? To make some sense of a bunch of contradictory information about Google’s and Facebook’s hiring freezes in the press and on Blind, we decided to ask the people who, outside of Google …\nThe interviewing.io platform has hosted and collected feedback from over 100K technical interviews, split between mock interviews and real ones. It’s generally accepted that to pass a technical interview, you have to not only come up with a solution to the problem (or at least make good headway), but you also have to do a good job of articulating your thoughts, explaining to your interviewer what you’re doing as you’re doing it, and coherently discussing tradeoffs and concepts like time and space complexity. But how important is communication in technical interviews, really? We looked at the data, and it turns out that talk is cheap. Read on to find out how and why.\nAt interviewing.io, we’ve hosted over 100K technical interviews, split between mock interviews and real ones. As it happens, we know where our users currently work – they tell us that when they sign up. Given that we have this data AND given that we know how well people do in their interviews, we thought it would be interesting to see which companies’ engineers are especially good at technical interviews. Our resulting top ten lists are in this post!\nIn the wake of COVID, I made a public promise to launch a program where engineers could defer paying for practice until they found a job. Today, we’re making good on that promise by launching our Pay Later Program! With this program, you get instant credits to spend on interview practice and then pay us once you’ve found a job. And if you get a job through our job board, then you don’t have to pay anything…\nI’m really excited to announce that we raised a $10M Series A, led by the fine people at M13. This round of funding is a long time coming. I don’t know what the average company age is when successfully raising an A, but it took us 6 years to get here. It was a long and windy path, and for a little while, we almost died (more on that below), but we’re still here, and we’re so grateful and excited to finally have the resources to do what we’ve always wanted to do: fix hiring, for real. What does “fixing hiring” mean? We believe that the only way to really effect change, is to make …\n“Hamtips” stands for “Hiring Manager Technical Phone Screen.” This combines two calls: the Technical Phone Screen (TPS), which is a coding exercise that usually happens before the onsite, and the HMS call, which is a call with the Hiring Manager. By combining these two steps you shorten the intro-to-offer by ~1 week and reduce candidate dropoff by 5-10%. It’s also a lot less work for recruiters playing scheduling battleship. Finally, Hiring Managers will, on average, be better at selling working at the company – it’s kind of their job.\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/page/4",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "When you start writing a job description, the first question you should ask yourself is, Am I trying to attract the right people, or am I trying to keep the wrong people out? Then, once you answer it, write for that audience deliberately, because it’s really hard to write for both…\nI’ve been hiring engineers in some capacity for the past decade. Five years ago I founded interviewing.io, a technical recruiting marketplace that provides engineers with anonymous mock interviews and then fast-tracks top performers—regardless of who they are or how they look on paper—at top companies. We’ve hosted close to 100K technical interviews on our platform and have helped thousands of engineers find jobs. For the last year or so, we’ve also been running a Fellowship program specifically for engineers from underrepresented backgrounds. That’s all to say that even though I have developed some strong opinions about “diversity hiring” initiatives, my opinions are based not on anecdotes but on cold, hard data. And the data points …\nI’ve been hiring engineers in some capacity for the past decade, and five years ago I founded interviewing.io, a technical recruiting marketplace that provides engineers with anonymous mock interviews and then fast-tracks top performers—regardless of who they are or how they look on paper—at top companies. We’ve hosted close to 100K technical interviews on our platform and have helped thousands of engineers find jobs. Since last year, we’ve also been running a Fellowship program specifically for engineers from underrepresented backgrounds. All that is to say that even though I have strong opinions about “diversity hiring” initiatives, I’ve acquired them the honest way, through laboratory experience.\nRecently, someone asked us how you know you’re ready to succeed in a Facebook/Amazon/Apple/Netflix/Google (FAANG) interview. It’s an interesting question, and one I’m sure many of you job seekers out there are wondering. Internally, we have our own beliefs, but we wanted to see if we could answer this question more objectively. So we set off on a journey to acquire data to try answering it.\n“The new VP wants us to double engineering’s headcount in the next six months. If we have a chance in hell to hit the hiring target, you seriously need to reconsider how fussy you’ve become.”\nIt’s never good to have a recruiter ask engineers to lower their hiring bar, but he had a point. It can take upwards of 100 engineering hours to hire a single candidate, and we had over 50 engineers to hire. Even with the majority of the team chipping in, engineers would often spend multiple hours a week in interviews. Folks began to complain about interview burnout. Also, fewer people were actually getting offers; the onsite pass rate had fallen by almost a third, from ~40% to under 30%. This meant we needed even more interviews for every hire. Visnu and I were early engineers bothered most by the state of our hiring process. We dug in. Within a few months, the onsite pass rate went back up, and interviewing burnout receded. We didn’t lower the hiring bar, though. There was a better way.\nI recently conducted my 600th interview on interviewing.io (IIO). I’d like to share lessons learned, why I approach interviews the way that I do, and shed some light on common problem areas I see happen in technical interviews. Every interviewer on the platform is different, and so your results may vary. We have some excellent folks helping out on the platform, and have a wonderful community working to better ourselves.\nWhat is the one thing you would look out for if you had to join a company? Sometime between January and February 2020, I wanted to change jobs and was looking to join a new company. This, among other reasons, led me to embark on a marathon of technical interviews – 60+ technical interviews in 30 days. Doing that many number of interviews in such a short time meant I had an interesting mix of experiences from the various companies I interviewed with, each with their unique culture and values that often reflected in the way their interviews were conducted, intentionally or not.\nI started interviewing.io because I was frustrated with how inefficient and unfair hiring was and how much emphasis employers placed on resumes. But the problem is bigger than resumes. We’ve come to learn that interview practice matters just as much. The resume gets you in the door, and your interview performance is what gets you the offer. But, even though technical interviews are hard and scary for everyone — many of our users are senior engineers from FAANG who are terrified of getting back out there and code up the kinds of problems they don’t usually see at work while someone breathes down their neck — interview prep isn’t equitably distributed. This inequity never really …\nI started interviewing.io 5 years ago. After working as both an engineer and a recruiter, my frustration with how inefficient and unfair hiring had reached a boiling point. What made me especially angry was that despite mounting evidence that resumes are poor predictors of aptitude, employers were obsessed with where people had gone to school and worked previously. In my mind, any great engineer, regardless of how they look on paper, should have the opportunity to get their foot in the door wherever they choose. So, we set out to build a better system. On interviewing.io, software engineers can book anonymous mock interviews with senior engineers from companies like Facebook, Google, and others, and if …\nRecursive Cactus has been working as a full-stack engineer at a well-known tech company for the past 5 years, but he’s now considering a career move. Over the past 6 months, Recursive Cactus (that’s his anonymous handle on interviewing.io) has been preparing himself to succeed in future interviews, dedicating as much as 20-30 hours/week plowing through LeetCode exercises, digesting algorithms textbooks, and of course, practicing interviews on our platform to benchmark his progress.\nBut this dedication to interview prep has been taking an emotional toll on him, ...\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/page/5",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anonymous mock interviews with engineers from FAANG and more",
      "content": "interviewing.io is an anonymous technical interviewing platform. We started it because resumes suck and because we believe that anyone regardless of how they look on paper, should have the opportunity to prove their mettle. In the past few months, we’ve amassed over 600 technical interviews along with their associated data and metadata. Interview questions tend to fall into the category of what you’d encounter at a phone screen for a back-end software engineering role at a top company, and interviewers typically come from a mix...\nAbout a year ago, after looking at the resumes of engineers we had interviewed at TrialPay in 2012, I learned that the strongest signal for whether someone would get an offer was the number of typos and grammatical errors on their resume. On the other hand, where people went to school, their GPA, and highest degree earned didn’t matter at all. These results were pretty unexpected, ran counter to how resumes were normally filtered, and left me scratching my head ...\nI ran technical recruiting at TrialPay for a year before going off to start my own agency. Because I used to be an engineer, one part of my job was conducting first-round technical interviews, and between January 2012 and January 2013, I interviewed roughly 300 people for our back-end/full-stack engineer position.\nTrialPay was awesome and gave me ...\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/page/8",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Google Systems Design (Mock Interview)",
      "content": "Interview Transcript\nIntergalactic Avenger: Hello?\nSpace Pheonix: Hi.\nIntergalactic Avenger: Hey, how's it going?\nSpace Pheonix: Good, how are you?\nIntergalactic Avenger: Good, good, doing good. Alright, so if it's okay, I'll just jump right in with a technical question.\nSpace Pheonix: Yes, sure.\nIntergalactic Avenger: Yeah, so I think we'll do some not necessarily coding but more system design question today, just to keep it... I'm sure you've answered enough questions about hash tables for for one day, so let's start with a distributed systems question. So the idea is that you've got a database that you're keeping in MySQL, some some standard off-the-shelf database system like a SQL database and we could even say for this purpose, for simplicity there's just one one table and it's just... You're getting more and more rows in that table and eventually you found there's more rows than can fit in one machine. So you have access to multiple machines and they're all networked together somehow. So can you think of a way to to organize the database just given that you just have access to SQL, you don't have anything like... you know, any automated tools for distributing and... So just kind of generally describe what this is going to look like.\nSpace Pheonix: Okay sure, so the idea is you just have an access to SQL database from multiple machines where I can store the data. Right now it's going to the one machine and it cannot scale for the data that we are getting. I'm just making sure that I understood correct. And somehow we need to partition this database in a way to query in future, so distributed in multiple machines. So let me first ask a couple of questions, like before splitting the data, is it... so there are a few ways. One is like usually like some geographically like if you have some countries related to the database, for example if you have a country code, we could potentially have our country, our region code, like we can split the universe in like a multiple regions, like one is like North America, South America, or Africa and Asia Pacific, kind of probably like a three regions we can split into three different machines to go like at any that are related to the three specific regions, go into specific machine. Probably one layer, one machine where it load balances these things. Somewhere we need to have a component where the data and then decide which machine to go store this data.\nIntergalactic Avenger: So the idea that... so yeah that makes sense that there's going to be a lot of... if you have so much data, it might be coming in from different sources, so would the idea be that country code is just something that's in the database or is that also relative to who's asking for that data? Like do the European users talk to the European data and the North American users talk to the North American data?\nSpace Pheonix: Okay, well...\nIntergalactic Avenger: That kind of brings up the question of, is that is that how you were thinking about it?\nSpace Pheonix: That was probably my next question was, so how the database will be coded in future, whether like a different regions will ask for different region or they will just look for their own region data when they worry, so that's debatable or a clarification question if it's going to be like Asia Pacific people asking for data from Europe, then you're pulling the data from two different machines and then merging and then responding is going to be complicated so we have to think a different way of partitioning this, probably like anything like an old data we can keep it in like in a backup database, like one transaction database where you have only current months data. If anything older, you go to different machine, pull it from there. So depending upon the query pattern, whether always you get quite often you get for last week's, last month, or last six months data that being coded, that can be kept in the main machine where we do the transactional and the rest all can go into like jobs analytics that are... this kind of model I would think of.\nIntergalactic Avenger: Okay, let me just yeah... there's a couple questions back in there so with respect to the geographical regions, so that's definitely a very good way to start. So if this was the kind of system where there were country specific data that was being read from and written to just with respect to that country and that was... and people in that region were the only ones doing it then that's an excellent way to start. But let's say for the purposes of this exercise that that's not the case. Let's say that all the data is stored centrally in one data warehouse that's located in one geographic area, so that's just to cover the first one. So then that was an interesting point with respect to the the recency, so can you just sort of sketch out for me an algorithm of how that would work. So for example, let's say that you know if I'm reading from... as I'm understanding it, there's going to be one machine in the front that is going to take in the query and it's going to look at the time range that you are looking at and based on the time range it will farm that off to different machines. So how then does that work with respect to... so is there going to be... are you going to... so let's say that you are going to have that split into day or I guess you said month, so by month. So is the idea that every month, you would add a new machine for that month so that there's a machine for 2015 December and then for next month you'll need to make a new machine that is going to host the new data or do you migrate the old data backwards?\nSpace Pheonix: Yeah so migration is what I was thinking. I wasn't proposing to add the new machine every month. Yeah since being the transaction database that is the bottleneck where everyone insert an SQL query for the same month that is going to be one machine and the rest all like... a machine can probably can accommodate more than a month data. So requests will go to probably one machine or two machine depending upon the size, whether it can hold in this one machine, then it could be just one machine. Or it could be like more than one machine, depending upon the size of the database. That was what I was thinking.\nIntergalactic Avenger: Okay, I like that idea. So this is the interesting point. So okay, so you have one machine that's kind of the the current ones and then you have maybe multiple machines that are holding the older data. So how do you... how do you split that up? So let's say that you right now maybe you have one machine for December and then one machine for all past data. Then, you're looking at this in the future and you say oh whoops, the machine that right now has all the past data in it is about to be full. So now how do we split up that data?\nSpace Pheonix: Yes, so in that case... not in that case. So we have to design to accommodate this... definitely is going to be full is the one machine for all past that's not going to just hold everything for next 10 years or 20 years so definitely does miss this for adding more machines as and when needed in the design to go get the backup database from multiple machines. So in a way I would rather say probably like to go for like a five years, ten years kind of a database. So these are all like a kind of a parallel partition right? There is completely a new concept for virtual partitioning a table can be like... so I I'm not technically like completely aware how the whole thing works like a for example the big data thing, how do they completely vertically partition the table first off of like probably 20 columns, first ten columns would be stored in one and the remaining ten columns will be stored in different machine. But I don't have the technical depth of knowledge for explaining how that is completely implemented or how the whole thing works, the vertical partitioning.\nIntergalactic Avenger: Let's not worry too much about vertical partitioning. I mean that's certainly one way you could do it, but let's just assume that there's a relatively small number of columns. It's just that there's more and more and more and more and more rows.\nSpace Pheonix: Yeah okay okay so yeah so considering there are a number of backup databases, I would probably suggest like going back like completely like up to five years one machine and complete the past like for more than five years running on more than one machine kind of approaches what I would think of.\nIntergalactic Avenger: So let me see if I have this correct, if I understand the scheme correctly. So you've got some... or I guess the one piece that's unclear for me is how does the data then sort of move and get migrated from how it is now into the past? Like once you've decided that some row is old by some definition of old, maybe it's one month or one year whatever, how do you decide where it goes? And how does the migration sort of work? So my question is when you do that migration, do you go over all the data like in the entire history as you redistribute it or when you redistribute it are you going... you just take the current data and then push it sort of somewhere?\nSpace Pheonix: Right so... yeah so what I would do... let's say this is what my addition, like in the component which decides to go find where to find the data, so that knows which server I need to go find the data. Depending how it knows, the strategy is let's say I have the current machine which does the transactions and everything for the last just one month. That's all I'm going to keep in a different machine.\nIntergalactic Avenger: Just so you know, if you want it, there's a little whiteboard if you want to draw on a little whiteboard and there's also like just the text if you want to draw little boxes in the text, so if that helps you to explain it or to think about it, you have those options open to you.\nSpace Pheonix: Yeah sure, let me try that. This is my second interview, just trying this one.\nIntergalactic Avenger: Yeah there's a little button that has like a pen on it, and that's a little whiteboard so you can you can draw stuff.\nSpace Pheonix: Oh yeah, so yeah. So this is let's call it OLTP this one, like a transaction database. So this is the current data. So even before this, let's say we have a component called the load balancer or whatever, which decides where the data, this should be queries. So all the queries coming in here. The load balancer decides where to go, so this OLTP queries the transactions in the last month, so less than one month old here. And the query here, let's say we get for old data here, so greater than one month old data is going to be stored in this backup server. So in a point where this is going to be filled completely, there should be a way like I said, this is going to be filled up, for example we have for now 10 years of data here. So right now we filled it up and then there is no space in here. At this point, I want to completely split this thing, I think my suggestion would be to just add up one more server where the new data, whatever we backup from this server will get into this machine, like I have one month old here, now I'm in the second month, so just one month old database is that I will fit into this new server. Now I need to find a way where to query from these two machines and then written back somehow that has to be, that has to happen based upon the query in the load balancer. Depending upon the query, I have to find whether just I need to go to backup server or also backup server 1 and backup server two backup server three. Depending upon the quarry I would just add this up, so that probably is what I was thinking out. I wasn't thinking... so there is one other way like I have the backup complete backup of ten years of data. I wasn't thinking of splitting this into like I have four machines now, splitting into all four machines, I wasn't thinking of that.\nIntergalactic Avenger: Yeah that's fine. So let me see if I understand the path here. I guess I'm a little bit confused... so the load balancer at the beginning looks to see if it's within a month or greater than a month and so then it can choose one or the other, but what is this other piece in in the middle, this this one right here? I guess I'm confused as to okay what its role is in the... because it seems like if the data is either split into less than one month or greater than one month... I guess I don't understand what...\nSpace Pheonix: Yeah, yeah so let me clarify that... So this one, let's say for example I am in 2015 now, my first date observer is filled out, so anything older than 2015... anything older than 2015, we get into this machine.\nIntergalactic Avenger: I can help erase the old stuff if we want to erase it.\nSpace Pheonix: Yeah sure. Is there a way?\nIntergalactic Avenger: Yeah, you just have to make the eraser a little bit bigger. It's fine yeah okay.\nSpace Pheonix: Okay so this one contains less than 2015 data. And then anything so now we learn this database is filled... filled up and then we we are adding a new machine and this will contain anything greater than 2015 like greater than or equal to 2016 for example. So going forward from the OLTP machine, I'll just start backing up things every month to get into this database machine two, that's kind of the backup service that we will write it which will run in offline mode. So this load balancer itself could understand the machine 1 and machine 2 and depending upon the query, we can pass... we have to split the query depending upon... let's say someone else, since it is like a pretty recent and if someone asks like a two month of 2015 and one month of 2016, then definitely this load balances really have to pass the query and send to the two machines. So that way we get both the roles and then join and then it sends it back. So that's kind of the load balances job and it can be considerable, we can say ok year 2015 machine one and all that probably you can put it in some xml configuration of something where this strategy kind of easily changeable and stuff so we can add more machines going forward. When we add machine three, we can just say 2017 and beyond, so that can be configured just like that in the configuration file here. So this will be written by program or something like that.\nIntergalactic Avenger: Okay, now that makes sense. Okay so it seems like... so we started off with the idea of it being geographically partitioned and that's good, that will work with some some things. Snd this is partitioned by time, so in what type of scenario is this going to be ideal? Like what kind of query patterns of people querying the database are you going to see that this is optimal for?\nSpace Pheonix: So this is completely for like a transaction database where like it's a Amazon order service, where you get plenty of orders every minute and every day, so probably that's kind of amount of data where later you get it from same country and and you would get a lot of orders that's probably one scenario, where you get like a tons of records every day.\nIntergalactic Avenger: Well, let me put it this way. So for example, let's say we're talking about an Amazon like database. And the things you're storing are things like orders, like who ordered what right? And I could imagine that in this type of situation, people are looking up recent orders more often than they're looking up past orders. They're probably looking up something they just ordered this past week to see its status, but they're probably not looking up very often their old orders. It kinda feels like you're going to get a lot of traffic going to this one machine. Then all of the backup machines are going to be less utilized. So can you think of a way... so let's even just keep going with the this sort of Amazon style database and let's just say that you know after putting this into place you notice that this one machine here gets kind of most of the action and becomes the bottleneck and these older ones, people aren't really querying for it that often and so they are less utilized. Can you think of some way that will sort of better distribute the workload between all of these different machines so that you don't have this one as the bottleneck?\nSpace Pheonix: Yeah, sure definitely. So I think, so the other way to distribute would be probably like going by... since country wasn't a thing because every order is coming from same country let's say for example it was from North America, in that case I would say just go with a last name. Usually like every go by last name, people query by... so the user identification, user ID of course it's not the thing we can do. Probably I would go with last name starting from A to like your let's say P to machine 1, from Q to Z to machine 2 and depending upon number of machines I have, I can split evenly to all the machines. But this scenario I'm thinking about is just the orders, like it can vary the condition that we are trying to... the approach we are trying to split the data between the machines depending upon the data we are getting. For example, right now we are thinking everything is orders, everything is placed by some first name A and last name B. That's the scenario I'm completely talking about. So that way any user come to query something, they go to just one machine. They will never get into multiple machines and there is no question of joining queries and merging the data from two different machines and then solving the users. So that's probably one approach I would go with.\nIntergalactic Avenger: Okay, no that's essentially... because that's definitely going to spread it out so that all of the machines are getting you know the current orders and the past orders so all the machines are kind of spreading them out. Another challenge for you here... so if you split it up by letter, some letters are going to be more popular than others, so there's many more last names that start with the letter T than start with the letter W.\nSpace Pheonix: So I have a strategy coming to it. So I was thinking of see the pattern of orders coming from... we really have to study the pattern last like a few months and see where the number of orders really coming and then that's how we have to decide the number of letters to go on to some machine X and machine Y. There is no way we can really distribute just 4 letters to sorry... like 13 letters to one machine and remaining 13 letters to the other machine. Definitely we have to see the pattern and how the last couple of months went through and depending upon that we have to say it okay probably like five letters, first 5 just to machine 1, remaining 21 letters to machine 2, probably something like that. And one more problem with this again for example since you are storing order and everything here splitted into multiple machines, in the case of like where the same order data database will be accessed by some people like who's fulfilling the orders. In that case, we have to really query, we cannot really query by name or anything, they have to see all orders today and then definitely we run into issues of pulling the data from two different machines and then merging and then assigning everything and then returning all the data, so there is no way we can get around like you're always hitting one machine, that's not high likely... like it is just one side we are solving the problem but the other side we still have the problem of solving coding from multiple machines and unwinding, so yeah.\nIntergalactic Avenger: That's a very good point, it's a good point. So just going back to that last issue like if you said that you wanted to find all the orders... so let's say we're going into the way you said before with all the last names and so that's now distributing the data a little bit better, but now the dates are are not distributed very essentially centrally. So now you want to issue a query that says you know, show me all of the orders today. Where is the bottleneck going to be in that case?\nSpace Pheonix: It's all going to be the load balancer, where... so the load balancer is the one that will get all the requests. Now it has to decide where to go pick the data. Now machine one, machine two, machine three if for example if you want everything from today, it has to go to all the machines and you got all the data from all the machines, you have the job of joining everything, and then you like union all the results and then returning to the client so the load balancer kind of becoming a bottleneck yeah.\nIntergalactic Avenger: So that's certainly true if you're doing some aggregation of all the data. So let's say that you wanted to sort all of today's orders, then certainly you're right that the the load balancer becomes the bottleneck because it would have to aggregate all of them and then sort them. But what happens if they just ask \"give me all of today's purchases in any order, I'm not concerned about the order.\"\nSpace Pheonix: Okay, so in that case, so there could be one more possibility where you get the client requests and I know the load balancer knows where all the data is and we could potentially return the results directly from machine 1, machine 2, machine 3 to the client possibly. The way is you get only if the load balancer is probably act like a probably like a velocity server where the client will get the data, the information where to go pick actual data. So I will return back machine 1, machine 2, machine 3 to the client and then client will query on more like a three parallel queries or whatever kind of the way, it can just go query directly from those machines so the balance that the load completely is between all the machines.\nIntergalactic Avenger: That's an idea, I like that. Okay, so last one. So we're... these are all excellent ideas... so let's just dig a little bit deeper into the last name issue. So you're right, I really like that idea of looking over some past data like usage patterns to sort of see who are the types of users that use it more often and that kind of thing and that's certainly something you do dynamically, but let's try to think of something that you can do more statically without looking at the usage patterns to try to clear up this issue of you know more people have last names with the letter T than have the last names letter W. So is there some way that you can distribute the records so that so that even if... so let's just say for example that you have you know 100 machines and hypothetically this would mean you would put four letters on each machine because there's basically 25 letters in the alphabet but...\nSpace Pheonix: You mean each letter in four different machines.\nIntergalactic Avenger: Yeah so you would put like the first the first quarter of the letter A would go in one machine and the order of A gets in the second machine set. So that's the sort of one way to do it but it turns out that if you put like you could fit all of the complete letter Z in one machine and actually all of letter Y too, because there's not very many people with last name Y. So two people can actually fit in Y but the letter T needs ten machines. So I mean one way you could do it is you could just sort of keep a table of each individual row with... So I mean one sort of simple way of doing it would be to create a table with each individual row in which machine is going on or you could create like a range you could say well this person to that person is on this one machine but there's kind of a lot of bookkeeping to do there. Can you think sort of a simpler way so that when a query comes into this load balancer, it knows exactly where to go very quickly and easily for which machine is holding that person's data and you don't need to keep any type of like bookkeeping around. So the bookkeeping is fine except that you know let's say you wanted to add someone to the database or you want to add an order, well you would kind of be constantly shifting around how they're all migrated if you wanted to optimize it. So can you think of a way that is going to distribute all of these people in a way that each machine is not overloaded, that all of the machines have roughly the same number of records and that you don't need to do any type of like heavy duty bookkeeping or shifting around data as say more people come online or the orders are made.\nSpace Pheonix: Okay so I was just quickly thinking of just putting the machine and mapping the machine with the user table where each record will say okay this user always goes to this machine blah, but that's easy in a way to just to return the machine or whatever the detail we want to store the data, but in a way it becomes complicated, let's say what happens if I have to bring one machine down? I have to really go back, find all the users assigned to that machine and then update with some new machine. Those are the things we have to really think about but let me think about a little more... so what I was thinking was giving some weightage, but again that sounded like a heavy duty bookkeeping kind where I say starting letter A gives some weightage 1, so a T with a lot of who orders with a weightage 10, something like... so giving weightage for the letter again I think kind of a high bookkeeping, I wouldn't suggest.\nIntergalactic Avenger: How would you pick the weight? It's the idea that the weight is the number of users with that letter, so like the wait for the letter P is how many users last names start with the letter P? That kind of thing? Well there's something to that, that's an interesting one, I hadn't thought of that one before, but that makes some sense. So then what would you do with that weight?\nSpace Pheonix: Yeah so the weight tells you... let's say you have 100 machines, it will just split up with... that weight will tell you how many machines, what is the percentage of machines that you need for each letter, so you just sum up and then find the weighted percentage for each letter and then depending upon number of machines you can just have those many machines for that specific letter, but that's again another bookkeeping. The other approach I was thinking was since we evenly need to distribute every order comes in... so let's say we want to like a very highly distributed model where you get order one go machine one, order two machine two, order three machine three, and an order n go to machine n, and order n plus 1 goes to mention one again.\nIntergalactic Avenger: I like that idea.\nSpace Pheonix: Yeah but how we really achieve that is what really becomes more of questionable where let's say if I have order one, order two, order three, I get from one user, let's say if I go to machine one and I say okay machine one order one from user 1 is always machine one I could assign the user one from then on go to always machine one and the next order goes from user 2, goes to machine 2. I will assign that users for the machine two. But again that becomes static afterwards, that's not more of dynamic anymore, so there should be a better way of distributing always all the machines used is like equally that's what I'm what...\nIntergalactic Avenger: Actually let's explore this latest idea that you had, which I actually think is quite elegant because of its simplicity that you'll have the load balancer as you're writing new things will just have a counter that will roll over, super simple to to figure out where it's going to go. And so then the only question is how do you retrieve it?\nSpace Pheonix: Yeah, so the reporting again becomes complicated there...\nIntergalactic Avenger: Um well maybe not. I mean so if you think about it so let's say that you say well give me all the orders from today for some certain user? That's what you want to query right? What can the load balancer do to find that information, given that it is totally forgotten where it put that person. Because maybe it saw that person a million transactions ago and it didn't keep track of where it put that person. So how do you get at the, you know, so how do you get that the answer to that query of you know how many purchases did that person make today right?\nSpace Pheonix: So one... these are all reporting afterwards we could potentially... I'm just thinking of these sources. There are two things right? One is OLTP and the other one is the analytics server, which is just for used to file a reporting server. Quite possibly that we can have all these machines data and the transaction data gets duplicated or are pushed to some reporting servers where this load balancer always can go query the data from... so that's... let me think, so let's say we have 100 machines here. The main reason we are distributing is because users are being online and we need to serve them quicker and faster, that's the main reason that we are distributing all these transactions during the insertion. But the reporting usually can like a couple of seconds can take, can take couple of seconds more. We could potentially have the reporting servers separate where all the data gets synced to the reporting servers, always it is the load balancer notice. If any query falls for just coding the data always pointing to the reporting servers, that is one possibility, but let's think of if there is any other way that we can always pull this data from the same machines therein. So I don't see because we lost the pattern as you said the load balancer forgot where the data is and there is no way that load balancer is keeping this mapping between the machines and the pattern of queries. Let me think a bit more.\nIntergalactic Avenger: So one thing that you're optimizing for, which is which is generally a good thing, is that you're trying not to ask more machines than necessary. So for example with this first you know description that you have here where it's charted by time, you have the less than one month and then 2016, 2015, you have the the load balancers up at the front that decides I'm going to ask only one of these machines and that saves CPU cycles obviously because you're only asking the one proper machine where it is, but that's not necessarily a restriction. You could asked more than one machine.\nSpace Pheonix: Yeah definitely, so in case of let's say we have hundred machines, we store the data like evenly from the load balancer, now the query is to select something. I could go ask more machines, but whether... but my worry is that would slow down things when someone wants the report of today's orders or last weeks orders or whatever, querying more machines will slow down things if it is just from the load balancer.\nIntergalactic Avenger: Well, actually if you think about it, so if you are the reporting server and you are trying to get the all the days orders, you still have to ask every single machine because you know, somebody with the last of the name with the letter P is going to have an order and someone with the last name of the letter Q is going to have an order, so you have to still ask all the machines when you're reporting, so that's I think that's actually not a big problem. I don't think it slows down the reporting aspect of it.\nSpace Pheonix: Okay um yeah, so could be so that's again that load balancer probably let's say if it is just a select query, then we could have and so probably we need to distribute the load balancer now. The problem is all the insertion going through the load balancer on single servers balancing everything and if it find something select query or the report query, it should just give it back to the client, go find the other load balancer or something on that machine and the other load balancer is just mainly for the reporting load balancer and this is probably just the transaction load balancer. So the second load balancer where all the reporting code will go in and that would probably easily to query from all machines and then respond, serve the user. So that way we could just split the load between the load balancers potentially. But I would not really suggest just this machine coding all the machines for the reporting purpose and as well as the same load balancer doing all the insertions to all different machines. That will really become a bottleneck I think.\nIntergalactic Avenger: So other question is I wonder starting this iteration, there's going to be multiple load balancers and each one of them is going to query all of the machines or is going to query some subset of machines? I guess I don't understand the multiple levels of load balancing. And then the other question is why can't the original load balancer just ask all of the machines in parallel what all the results are?\nSpace Pheonix: It can, it can. I'm just worried whether it will become a bottleneck for responding the queries because it's doing all the insertion as we are thinking about, we are talking all the data like Amazon sites, like this all the orders coming through this load balancer and as soon as you are doing the reporting through the same load balancer which is querying all different machines, I am really worried that will become really a bottleneck and slow down things. So what I was proposing was if whenever this load balancer gets a reporting query, I know ok this is just a report, go back to the client saying okay this is just reporting. Go to the other load balancer, so now the client hits this load balancer too, this knows okay I deal with just the reporting part of it, that will still query all the machine, but not the same load balancer. So this load balancer one will just do the insertions and stuff like that, all reporting will go through the load balancer two, which will finally query from all the machines and then serve the user. Does it make sense?\nIntergalactic Avenger: Okay yeah, so I mean if I'm understanding that, so the... it would sort of be introducing like a priority or a tier for the different load balancers and depending on what they were doing, they would sort of have a higher/lower priority to use up the resources, that's very smart yeah because you're right, that the usage of the database is not going to be the same so the... you know a user who's just logging into the site, is going to want to see a small number of records very quickly whereas the reporting server is looking at a very large number of records, but can see them more slowly. So that's great, that make sense. Yeah that's kind of all I had. I know it's a very open-ended question, but I was just curious, wanted to just talk with you about that. I don't know if you've ever done any thinking about this, it seems like you must have thought about this some because yeah you have all this ideas about load balancing and OLTPs and usages and charting, it sounds like you know all of the concepts very well, so do you do this in your in your work already? I know that I normally don't see people that have this much background in this and all the varying context.\nSpace Pheonix: Sure, I did some amount of this work in the past, so I was working really the same kind of ordering platform enough, with like a million users kind of database I was dealing with, so we ran into similar kinds of issues when we were trying to do like multiple computing things like this and exploring it was all again learning and settling down things. There is no just one best solution for everything. So that's why I was trying understand these patterns a little bit and then making sure we balance things like evenly, is really important. But did you have any other better ideas, just in case?\nIntergalactic Avenger: So I do like the one idea of the just having a round robin where you'd put each record, just over that kind of thing. The other way to do it by the way is with respect to the names. If you wanted to do it based on names, what you could do is instead of it being based on the first letter, you could just take a hash of the entire name or the entire user ID or something like that, so then what that hash will do is say you know take some space of you know a hundred thousand, a million, two million users and break it down into a number between you know one and however many machines you have, so just design your hash function so that it takes whatever your identifier is, be it their name or their ID or something like that, and remap it into a space that is exactly how many machines you have, so that way you avoid the problem of querying too many machines and and there's sort of a lot of network traffic that's excessive, but what you could do is you could do is just hash the persons identifier and then you know that that identifier will go exactly to that one machine, and that way as you add more and more users, they just get a randomly assigned according to that hash function. As you said, there's no one right answer. You know, the the practical nature of your data will will pick whatever the right one is and I thought you had a lot of really good ideas, so that's great.\nSpace Pheonix: Alright, yeah. That's good thinking of doing the hash function, that's yeah. That's something new I learned today.\nIntergalactic Avenger: Good, great. Alright, so you have a good day.\nSpace Pheonix: Thank you so much, you too. Bye-bye.\nIntergalactic Avenger: Take care, bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/google-system-design-distributed-databases",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Java Mock Interview (Google Engineer)",
      "content": "Interview Transcript\nIntergalactic Avenger: Hello?\nSupersonic Taco: Hi!\nIntergalactic Avenger: How's it going?\nSupersonic Taco: Good, how are you?\nIntergalactic Avenger: Doing good, doing good. Yeah sorry, couldn't hear you for a second so I just wrote this on the screen there. Have you ever used the platform before?\nSupersonic Taco: Yes, a couple times.\nIntergalactic Avenger: Okay so then I guess you're familiar with how it all works, so I'm just going to jump straight into a coding question.\nSupersonic Taco: Alright.\nIntergalactic Avenger: So the first question is: are you familiar with the concept of order statistics. Have you heard that term before?\nSupersonic Taco: No\nIntergalactic Avenger: It's actually a very simple thing with an overly complicated name. So, given an unordered set of numbers like what I've written here: 1, 6, 3, 9, 8, 5, the order statistics are like the nth element in the list if it were sorted. So, the first smallest number in this list would be 1, and the second smallest number is 2, and basically the nth order statistic is then the nth smallest. That make sense?\nSupersonic Taco: Yeah\nIntergalactic Avenger: Alright so we're just going to have some algorithmic questions about finding some of these nth order statistics. Just to get started as sort of a warm-up problem: how about you write a function that, given a list of numbers that are out of order, you just find the smallest. So basically the first order statistic.\nSupersonic Taco: Okay sounds good.\nSupersonic Taco\nSupersonic Taco: So I'll just declare it here: public static int is the return and I'll just call it min, and this takes an int I'll call it n.\nIntergalactic Avenger: So this should be like an array.\nSupersonic Taco: Yeah, sorry. So then I'll loop through the array, and the for each of those iterations I'll compare it against a min that I've already set up. So I'll set the min to be arr[0], and so what should I return if the array is null, or if there's no value?\nIntergalactic Avenger: Don't worry about that case. We'll just assume it'll always have some values in it.\nSupersonic Taco: Okay, sounds good. So then we'll set the min to the first one. So then moving through the array, if the element at the index of i is less than min then we make that the new min. And at the very end of the for loop you return. So just to test it to make sure, I'll write a litte test here: int[] input = {2, 3, 0, 6} should give us 0.\nIntergalactic Avenger: Yup, sounds good.\nSupersonic Taco: And let's try that then. Alright there we go: it returned 0.\nIntergalactic Avenger: Perfect, and what's the runtime of this algorithm?\nSupersonic Taco: O(n)\nIntergalactic Avenger: And is there any faster way for you to do it?\nSupersonic Taco: For an unsorted array that I know of, no.\nIntergalactic Avenger: Correct. Okay, so now you get the idea, let's make this a little harder, a little trickier. How about you give me the second smallest number?\nSupersonic Taco\nSupersonic Taco: Okay, so for the second smallest number, then I think what we would need to do is maintain two variables and check accross both of them to see...like a larger min and a smaller min so we can check if there's a number that's smaller than both of them then we would put it into the smaller min, and if it's only smaller than the larger one then we can put it into the larger min. So once again are we assuming that the array's length is two or greater?\nIntergalactic Avenger: Yep\nSupersonic Taco: Okay, then I'll just call this min2 and we'll put this at the second element of the arr[], and if the arr[] is greater than the min then it's the very smallest one so the min becomes arr[1]. min2 should be set to min and min is set to the new minimum. And then otherwise, if arr[i] is less than min2 whereas it's still greater than min then this means min2 becomes the arr[i] and instead min becomes min2.\nIntergalactic Avenger: min2 becomes arr[i], but what happened to min then?\nSupersonic Taco: Oh sorry yeah, this is maintained the same I think, because if it's less than min2 then min is still the smallest so it should stay the same, but min2 gets updated\nIntergalactic Avenger: Okay, let's run this.\nSupersonic Taco: I have to return min2 this time. Okay this should give me 2. There, it gave me 2.\nIntergalactic Avenger: Perfect. Okay, I'm trying to think if there is a corner case here. What if these were the numbers here: {3, 2, 5, 6}. It should actually be 3, because 3 is the second smallest.\nSupersonic Taco: Yeah, it returns 3.\nIntergalactic Avenger: What if...Oh because you start back at 0 again, then you flip it all around, I got it. Alright, yeah perfect. And what's the runtime of this one?\nSupersonic Taco: This one is still O(n).\nIntergalactic Avenger: Okay, so we're going to want to move this and turn it into n. So we're going to want to add another parameter here that says I want to find the nth smallest. One way you could do it is you could just expand on this idea and you could just create a list of all of the mins up to n.\nSupersonic Taco: Right.\nIntergalactic Avenger: Now, what would the runtime of that algorithm be?\nSupersonic Taco: Well if we're storing them all, then we need to check across each of them each time which would become O(n^2) because we're running through all of the previous values every time we look through the array.\nIntergalactic Avenger: Yep, so to get the 1st, it just took O(n). To get 2 it took O(n). But now if you expand this in that same sort of pattern it actually becomes O(n^2). So is there a way you can improve on that O(n^2) time?\nSupersonic Taco: Alright let's see. One way to improve would just be to sort the array and that would make it O(nlogn) immediately and then all we have to do is find the nth index in the sorted array.\nIntergalactic Avenger: Okay perfect. Now here's the real challenge. Can we do better than O(nlogn) for any arbitrary m we're trying to find? So we saw that when m is 1, we can do it in O(n) time. When m is 2, we can still do it in O(n) time. You think there's a way that you could extrapolate on that sort of patter and say: oh, I can always do it in O(n) time, no matter which of these I'm trying to find.\nSupersonic Taco: Right. So the reason that we could do it in O(n) time for this m = 1 is because we could just go through and compare them all and see which one is smallest. For m = 2, we had to compare it with each of them and also the previous minimum. Without having to compare it to all the previous minimums I'm trying to think if there's a way to figure out the nth smallest.\nSupersonic Taco: Maybe if we delete for an object but then that wouldn't help either because if we go through…\nIntergalactic Avenger: But if you delete? So certainly it's tricky. If you get stuck, I have some hints for you.\nSupersonic Taco: Yes, I'd appreciate a hint.\nIntergalactic Avenger: Okay so, you mentioned the O(nlogn) case of sorting and then picking the mth item in the list. So in that sense, once we sort this input, you have: [2, 3, 5, 6]. And then let's say m = 3, you go straight for the 5, and you know that 5 is in the correct place, that everything of the left is below it and everything to the right is above it, and it's in position number 3. So that means it is necessarily correct. If we expand this out a little bit more [2, 3, 5, 6, 10, 15, 21], what you can see is that number 5 is in the correct position, but also every single other number is in the correct position. So you've also done work to make sure the 3 is the 2nd position and the 2 is in the 1st position and the 10 is in the 5th position and you've put them all in the right places even though at the end of the all you really cared about is that the 5 is in the right place. Because whatever order any of these other ones are in, it doesn't really matter, you don't really care because you're only really interested in this one.\nSupersonic Taco: Right, okay. So basically we're looking for a way to ensure that a certain value is in a certain spot but all the other values don't have to be sorted.\nIntergalactic Avenger: Correct.\nSupersonic Taco: And the one we want to be in the right place is at the m index.\nIntergalactic Avenger: Right.\nSupersonic Taco: So if we did this for the first minimum then basically we would have to go through each of the elements and then put all the ones that are larger than a certain minimum to the right of it if so that is would be at the beginning. So basically we would have to go through and figure out how many numbers are lower than that number and how many numbers are larger than that number.\nIntergalactic Avenger: Right.\nSupersonic Taco: So what if we do that then. So say we want m to be 2 like in this case where the index is 2 that means we want two numbers to be less than the one at m, and four numbers to be to the right. Somehow there should be a way that we can go through and figure out and make it balanced so that it's like equal on both sides even though those aren't sorted. But we would need to know what the number 5 already is in order to go through and actually put that in the right spot. So there needs to be a way where we can figure that out without already knowing 5.\nIntergalactic Avenger: Right.\nSupersonic Taco: Yeah and if we just chose a random number or when one by one like we did here then it wouldn't work because then we would still go back to being O(n^2). We just still have to go through all the numbers to see which one was right.\nIntergalactic Avenger: But let's take a look at example. You could have described this process where you take this input array, you take the first number you found, and you made sure it went in the right spot. So you described a process of saying: take this number 3, and put it (just that one number) where it goes. So everything to the left is less than it, and everything to the right is greater than it.\nSupersonic Taco: A binary search tree?\nIntergalactic Avenger: Yeah. That's kind of a part of it. So describe how you might do that. You don't really much information about this array coming into it, because it's unsorted, in any order. So you might as well just start with the first number you find and say: I'm just going to put the first one where it belongs and I'll tackle the rest of the problem after that. For example, you can think of what it would look like afterwards: [2, 3, 5, 6, 10, 21, 15]. If you can imagine that this might be what the array would look like after you found the first place. So 3 goes in this spot and everything to the left is less than 3 and everything to the right is greater than 3, and you don't really know what's going on on either side and you haven't really sorted it altogether, but you do know that 3 is in the right spot.\nIntergalactic Avenger: So does this then give you some additional information in terms of how you would proceed from here? So keep in mind we're still looking for the third largest number and you just figured out that the number 3 goes in position number 1.\nSupersonic Taco: So then I know that the number 3 is the second largest number and at this point I would have enough information to find the third largest number using the technique that I just did before where I find the previous minimum then I just have to run through the array one more time to find the next minimum.\nIntergalactic Avenger: Right, that's true. And which part of that array would you run that algorithm on? The whole thing, or a part of it?\nSupersonic Taco: The right, because the right is unsorted.\nIntergalactic Avenger: Well, in a sense the left is also unsorted kind of. Because we don't really have any guarantees about what's going on to the left. In this case you do because there's only one element so there's not really much sorting to do. But what else is an interesting property? So now that you have this 3 in the right spot, in term of what you're looking for are you interested in anything on the left, or are you interested in anything on the right, or are you interested in anything on both sides?\nSupersonic Taco: Well, right now looking at this array, I would be interested in the right because the 3 is only at index 1 and we're looking for index 3. But the 2 could be the 5 too, like what if there was a 5 here instead of the 2.\nIntergalactic Avenger: It couldn't be. It couldn't be because you've split this array up. Let me start by rearranging this more: {10, 2, 5, 6, 11, 3, 15}.So you start with this 10 and you first make sure that everything on your left is less than 10 and everything on your right is greater than 10. So this might look like this: [2, 5, 6, 3, 10, 15, 11]. So you've shifted things around but you've shifted them around in a way so that everything on the left is less than 10 and everything on the right is greater than 10. So it's not just that you've found the one right place for it, but you've done a little bit extra to make sure that you split the array in two pieces.\nSupersonic Taco: Yeah, so then this is actually pretty helpful. If the 10 is over here and this is in the 4th index and m has to be to the left of it, so we don't really need to worry to the right any more because those are greater than 10 anyways.\nIntergalactic Avenger: Exactly. So then when you repeat this and you go for another iteration of it, you're only going to be looking at the left side, right?\nSupersonic Taco: Yeah.\nIntergalactic Avenger: Okay so, does that give you some ideas about how this algorithm might work?\nSupersonic Taco: Yeah it does. Because then in the first time around I'd be iterating through all the numbers to find where it belongs and the second time around I'm only iterating through the left side. So this kind of reminds me a little bit of binary search so the runtime might get a little better than O(n^2) when we do it this way.\nIntergalactic Avenger: Okay\nSupersonic Taco: Alright so, should I start implementing it then?\nIntergalactic Avenger: Yeah let's see what happens.\nSupersonic Taco\nSupersonic Taco: Alright so we're outputting just the number, and this is NthSmallest(). I'm just going to write the code for the first time and we can probably iterate through and make that repeat. So the first time around I'll have to go through the entire array. So if I look at the first one, I'll have to put it in the right spot so then I'll take int index = 0 before this loop. We're going through them and if we say: if(arr[index] > arr[i]) then we need to move it to the right, or swap it. Yeah so if the arr[] at index is greater than the arr[] at i then we need to do some swapping here. So should I just abbreviate it and just write swap here, or do you want me to write the whole swap?\nIntergalactic Avenger: You can just write swap.\nSupersonic Taco: Okay. Well actually I'm going to need to test it later so I might as well just do it now. So then we'll write int temp = arr[i] and then arr[i] = arr[index] and arr[index] = temp. So this switches them around if its greater than, but if it's less than, then essentially we need to keep moving so we don't need to do anything there. But if they're equal to each other then we stop. So we start with index = 0, oh there's a problem here because if it's starting with first one then it'll just stop immediately because it's the same one. So then we'll start at the first one, then index = 0 and the first element is 10, and then it checks to see arr[1] which is 2 and 10 > 2 so then it swaps and now it's 2 and then 10 and then it compares it again, 5: 10 > 5 so it swaps, 6: 6 > 5 so it swaps and it looks at 11. This breaks now because it'll stop since it's greater than, but it needs to continue and look for that 3.\nIntergalactic Avenger: Wait, if those numbers don't equal each other…\nSupersonic Taco: Yeah it wouldn't stop but it still needs to...yeah it would stay there and then it would go through and check against 3 and now that it's less than 3 it'll swap with that one instead and 10 will be where the 3 was and then it'll check against 15, which is greater than so it'll stay there.\nIntergalactic Avenger: So that would actually work for this specific input but think about what would happen if the input was something like this: [10, 2, 5, 6, 11, 3, 0]. First you swap the 10 with the 2 so that's right, and then you swap the 10 with the 5 which is totally right then you swap the 10 with the 6 then you leave that. Then you swap the 3 with the 10, so that's cool, and then you swap the 0 with the 10.\nSupersonic Taco: Yeah that's not right.\nIntergalactic Avenger: Not quite right because when you skipped over the 11 now you have something on the left that is bigger than it should be.\nSupersonic Taco: So then I think maybe we have to move the 11 along with the 10 every time, so maybe we can swap the 11 with whatever's next to it so it keeps moving away.\nIntergalactic Avenger: So you had this point with the 10 and the 0 like this, then what were you going to do? Move up the 0 and the 11?\nSupersonic Taco: No it was like the 10 was here: [2, 5, 6, 10, 11, 3, 0] and then you would check the 10 and the 11, and since the 11 is greater you could swap it away. Yeah you could actually just swap it with the end of the array so this becomes 0 and this becomes 11. And then here we check against the 0 is greater than and it swaps, and then it checks the 10 and the 3 is greater so it swaps.\nIntergalactic Avenger: Okay.\nSupersonic Taco: And that would put it in the right place.\nIntergalactic Avenger: So then presumably if there was another number that was greater than 10 you would swap it so like...we had it here that was like: [2, 5, 6, 10, 11, 3, 15].\nSupersonic Taco: So then it would first compare the 10 and the 11. Okay, now I see what you're saying: if it swaps there it would skip over and it wouldn't work.\nIntergalactic Avenger: But you're definitely on the right track. This is definitely the kind of manipulating that you're going to want to be doing in this kind of array. And you're definitely on the right track with respect to looking at each one of these numbers as you're going up and as long as it's less than then you're keeping it to the left and as long as its greater than you're keeping it to the right. So that's kind of how you're kind of scanning this list of numbers. So you're getting into this one sort of problematic case that when you start to have multiple numbers that are bigger it gets kind of tough with how do you deal with the bookkeeping of where does it go and who can you swap it with.\nSupersonic Taco: Yeah I can think of one way to solve that which would be to create another array and then if it's less than whatever we want we put it into the beginning of the array and hold two counters for where the beginning of the array is and then where the end of the array is and if the number is larger we add it to the end until there's only one spot left and then that's where the 10 has to go.\nIntergalactic Avenger: That's a good way to do it.\nSupersonic Taco: Alright so then I'll try to implement that instead.\nSupersonic Taco\nSupersonic Taco: Okay so then we have now two counters int start = 0 and int end = arr.length and then we loop through and so we know the number that we're looking for I'll put that in as index again and that'll start at 0 this time. So basically if the number that we're looking at right now which is arr[i] is less than the arr[index] then we put it to the right. So then we have this new array that we have to create that's the same length. And then if the arr[i] < arr[index] then it should go in the beginning so we do newArray[start] = arr[index] and start++ to show that we've added an element.\nIntergalactic Avenger: So in this line here you set newArray[start] = arr[index] is it arr[index] or arr[i]?\nSupersonic Taco: Oh sorry, yeah that's completely different thing. And are there going to be duplicates in this array or no?\nIntergalactic Avenger: Let's just say no for now.\nSupersonic Taco: Okay so if there's no duplicates then any other element we look at cannot be the one we're searching for so then we can just do an else here and this basically says that the arr[i] is greater than what we're looking for so it needs to go to the right. So it goes to newArray[end] = arr[i]. And then do end-- and this loop has to end whenever start and end are one apart from each other, because then that means we've found our index. So if end - start == 1 we return start+1. Alright so I think this should work just for the first one to place it in the right spot. So let's try it.\nIntergalactic Avenger: So I see you're returning the number right away but I'm wondering...so this is going to return not the nth smallest, but some smallest that the...you're returning which condition the first element will have gone to.\nSupersonic Taco: Yes, yes. I just wanted to break down the problem\nIntergalactic Avenger: Got it. Okay.\nSupersonic Taco: Okay, in this specific array...Oh I'm missing a return statement.\nIntergalactic Avenger: Here's an interesting question: so when will end - start == 1? When will this be true?\nSupersonic Taco: end - start will be 1 when we've gone through all the elements in the array and now we're looking at that one empty space where the element should go.\nIntergalactic Avenger: Okay, so if that's goign to happen once you're already completed with this array will this ever be see?\nSupersonic Taco: Yeah you're right. We can just recognize those and return start+1.\nIntergalactic Avenger: IndexOfOfBounds?\nSupersonic Taco: Oh end has to be arr.length-1.\nIntergalactic Avenger: Okay. I think actually because you incremented start right here, you don't need to increment start there. I think that's what's going on.\nSupersonic Taco: Alright and let me try it with another m just to make sure. If we deleted one of these, it should become 3 I believe.\nIntergalactic Avenger: Yep.\nSupersonic Taco: Okay, alright.\nIntergalactic Avenger: So now I have the functionality for figuring out the spot where one specific element should go but I have to repeat until I find wherever the element at the mth index is. So essentially this whole start...if start is m then we know that we've found our element.\nSupersonic Taco: Right.\nIntergalactic Avenger: But the thing is this index has to change every time. So I'm thinking maybe we could do this like a binary search where we choose the middle number in each half and we try to put that where it belongs, and if m is greater than the index there then we run it on the right half and if m is less than then we run it on the left half.\nSupersonic Taco: Okay so then we'll start with, instead of 0, index = start + end/2 and then looking at the end….\nIntergalactic Avenger: The index is representative of the index of the number you're comparing everything with. In that sense index represented this number 10 here. Does it get you anything to pick the number in the middle? This number here is the number in the middle, does it really matter that you take index = 0 or index=start+end/2? It's going to be 50-50 right? It's not going to be exactly in the middle there. There's kind of no way to tell how well this number you're picking at random is going to split this array in tWo. I mean you can do that, but I think that starting at index=0 is an totally reasonable way to go because at this point it's just a random array, there's no order. You might as well pick anything and then go from there.\nSupersonic Taco: Yeah, I think that's fine, we can use 0 then. We can actually make this recursive to do a little less work where once we find where the spot that index should go, we'll determine if m is in the right or left and then we will again do it. But actually that might be….yeah I think that might be one way of implementing because we can always keep index at 0 because the array that we're looking at is now a subarray so the index will always be 0. Or a way we could do this is just have index at start and then move through and then kind of keep doing it with a new start and end and that would be another way of doing it. Or we could just make new parameters here for start and end and implement it as recursive.\nIntergalactic Avenger: So I like your recursive idea because it's definitely going to make the code a little simpler. Do you actually need to add more parameters here if you do is as a recursive algorithm?\nSupersonic Taco: No, I don't have to. If I change the array then I don't have to. I was just wondering like that would still take up more memory because technically I would have to somehow cut off the array...We'll just keep it like this for now and turn it into a subarray.\nSupersonic Taco: Okay so then we're using index = 0 and we're returning start which ends up being the index of whatever element is at 0. So what we need to do is determine if m is greater than or less than start. If m is greater than start, we need to redo this on the right side of the array, so we should perform NthSmallest() on...I actually forgot the method for sub-arrays in Java.\nIntergalactic Avenger: I think there's a thing called range? Subset? Fill? I mean, you could just use copy of range if you wanted to.\nSupersonic Taco: I think I got it, there's a code completion on here and it says that it's a method so I'll just use that then. So then the original would be arr[] and I'm assuming the from is inclusive so we'd use start+1 because start we've already looked at and that's the one we've already found and the end would just still be end. And here it would just be the other way around so if we have NthSmallest() then it would be arr[] and instead of start+1 this would be 0 and this would be just start. And else that means that m = start which means we've found the element at the index we want so we just return start.\nIntergalactic Avenger: Okay, so NthSmallest() actually takes two parameters.\nSupersonic Taco: Oh right, so m minus needs to be add in.\nIntergalactic Avenger: Is it m? Because that's relative to the entire…\nSupersonic Taco: Right so if the m that we're looking for is greater than start then it would need to be m-start and if the element that we're looking for is....so if m < start then now we're looking for still m.\nIntergalactic Avenger: Right.\nSupersonic Taco: I'm going to test this now to see if there's any issues. Let's just see if we get 0 as m then we should still get back 10.\nIntergalactic Avenger: We should get 3. So 3 is the smallest one.\nSupersonic Taco: Oh yeah yeah. So it should give back 3.\nIntergalactic Avenger: We need to import ArrayLists? Or is it Arrays. Oh it's a lowercase c\nSupersonic Taco: Oh okay, let's see what happens now? I'm missing a return statement?\nIntergalactic Avenger: You don't have return in these ones. Wait which ones are they looking at?\nIntergalactic Avenger: So 52 and 54, you're calculating it without returning it.\nSupersonic Taco: Got it, alright. Now it's giving me 0, which that's not even in the input array. Oh I returned the index, I never returned the element.\nSupersonic Taco: Oh that's still not right. Alright, let's see.\nIntergalactic Avenger: So definitely the logic looks right, I'm guessing there must be some off by 1 bug. So we already figured out that with this list when you go the first time, start equals...oh wait start was 3 before, so it should have put it in the...So maybe there's some need to do some debugging with some print statements to see...because yeah the logic here is definitely looking solid.\nSupersonic Taco: Maybe here I'll just print out newArray[]. Okay.\nIntergalactic Avenger: Interesting that you have the 10 in there. So in that sense you want your newArray[] to be one element smaller. So if you see what's happening here is you started with index 0, and you're also checking index 0 again. The size is going to be 1 less because you're kind of taking one out then sort of partitioning it after you've taken that one out. So then now that you've reduced the size by a little bit you have to make up for that when you make this copy.\nSupersonic Taco: Well that wouldn't be affected by the newArray[] would it?\nIntergalactic Avenger: Well now the end actually has to be an array of length-2. Because the end is actually the end of newArray[].length-1.\nSupersonic Taco: Right. Well it's the initial array minus one so it's like the ending, but in the newArray[] it's not…\nIntergalactic Avenger: In the new array, you're copying these values over into the newArray[] so the newArray[] has to…\nSupersonic Taco: Yeah, all I had to do was arr[].length here because the end is not actually the end.\nIntergalactic Avenger: I'm looking at line 38 here.\nSupersonic Taco: Oh yeah.\nIntergalactic Avenger: So that end is actually the end of newArray[].length-1, which is the original arr[].length-2.\nSupersonic Taco: Oh okay.\nIntergalactic Avenger: And then in this one, you're not actually copying the original arr[], you want to copy the newArray[] because the original array is totally out of order and the newArray[] is the one...and you'd need the newArray[].length.\nSupersonic Taco: Okay, I get it and newArray[] has to be smaller. Yeah it should be 1 smaller....\nIntergalactic Avenger: Right, so in this one, you just want to copy to newArray[].length.\nSupersonic Taco: Well newArray[].length would include the values above it wouldnt it?\nIntergalactic Avenger: Well newArray[].length is the end of the new array, and you're trying to copy from your position all the way to the end.\nSupersonic Taco: And here there's still something wrong with the size of newArray[].\nIntergalactic Avenger: Wait can you try running again? What's wrong with the size of newArray[]? Line 46. Oh this one here: line 38, you had just changed this.\nSupersonic Taco: So this should be at minus 2?\nIntergalactic Avenger: Or you could just send end underneath the newArray[] or you could move this one up and just say end = newArray[].length-1. Either way it's the same number.\nSupersonic Taco: Oh okay, and this is still arr[].length-1. Okay now 3, okay now that's actually right.\nIntergalactic Avenger: There it is, not bad.\nSupersonic Taco: Now let's try it for some other other numbers too. So if we tried like 1, then that should give us 5. No..\nIntergalactic Avenger: Close. All right yeah, I think there must be some...I'm guessing there's an off by one in either in this m-start or this m here or the zero to start or what. I'm guessing there's a tiny little off by one bug here. So not a big deal, just because we're running a little short on time. So you did all this work and now you're inspecting smaller and smaller pieces of the array as you recurse into it, what is the runtime of this algorithm? So the question is that you did all this work, or there's all this extra code to be careful not to do any more work than you need to so the question is has this actually sped it up or is it still O(nlogn) or is it even greater than O(nlogn).\nSupersonic Taco: Well I think it depends on the case. Say for example this array was sorted in backwards order. Then the first one we'd look at would be the end and then the next one would be the end again. Say our m was 0 then we'd have to keep going through that array over and over and so we'd basically be looking at the entire array...which in the end still comes out to O(n^2). So I think the worst case our algorithm is still O(n^2).\nIntergalactic Avenger: Okay. But what about the average case. What if you randomized...That's sort of a common thing people do with these sort of divide and conquer algorithms is that if there is kind of a poisonous input then you just kind of randomize it to make sure that it's just in this big old jumbled order. So what can we expect sort of on the average case? You're totally right that there is a worst case input that makes it O(n^2), but what can we generally expect this to be in the average case.\nSupersonic Taco: I think this is still O(nlogn) then. Wait actually, in the average case it would be like we're looking at half the array since then it wouldn't be too much or too little. Wait no we're only looking at half, we'd look at 6 then 3 then 1 which is like O(nlogn).\nIntergalactic Avenger: Close. Can you see me typing up above the NthSmallest()? So the first time you run through this in the first iteration you have n elements that you're going over. Then like you said, you break it down by half and the nex time you just go over the n/2 and the next time is n/4 and n/8 et cetera. So what is that going to add up to?\nSupersonic Taco: O(logn)?\nIntergalactic Avenger: Is it?\nSupersonic Taco: Oh no it's just O(n).\nIntergalactic Avenger: Right, exactly.\nSupersonic Taco: Yeah it just becomes O(n)\nIntergalactic Avenger: Yep! So you did it. You got it down from O(nlogn) to O(n). And the trick is when you do the sort you have this halving you do each tie but you keep doing more and more work. Yeah so when you do a sort, you split it in half and then you do both sides, and so even though it's getting smaller and smaller you have more and more of them that you have to deal with, and so the length of this is logn. So like the number of iterations is logn so that's why it becomes O(nlogn). But in your case you don't have this ever increasing coefficient in front of it, so it just adds up to 2n and it's bounded.\nIntergalactic Avenger: So you got it! Very good.\nSupersonic Taco: Alright, thank you. This is a very interesting problem.\nIntergalactic Avenger: I'm glad you liked it. So I'll leave some comments on the platform but just before we go if you have any questions for me about interviewing or anything else I'd be happy to answer them.\nSupersonic Taco: I think I'm all set.\nIntergalactic Avenger: Okay awesome, then you have a good night and good luck with all your future practice rounds.\nSupersonic Taco: Thank you. Have a good night.\nIntergalactic Avenger: Okay. Bye bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/google-java-order-statistic-of-an-unsorted-array",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Java Interview with a LinkedIn Engineer (Reverse Word in String)",
      "content": "Interview Transcript\nIce Gyro: Yeah can you hear me?\nSpace Dragon: Yeah I can hear you now, thank you.\nIce Gyro: Yeah I can hear you. Thanks for the skype invitation.\nSpace Dragon: Let's jump in the question right away. Just one quick question: are you actively interviewing right now? How much are you prepared?\nIce Gyro: I'm not very prepared. I'm not actively interviewing right now. I work as a programer. I'd like to get better. This is my first every time doing interviewing.io\nSpace Dragon: Okay cool. What programming language are you most comfortable with?\nIce Gyro: Java.\nSpace Dragon: Okay cool, I'll just write the question on top here. So you basically have an array and it has something like this….So here is the array: [ 'p', 'e', 'r', 'f', 'e', 'c', 't', ' ', 'm', 'a', 'k', 'e', 's', ' ', 'p', 'r', 'a', 'c', 't', 'i', 'c', 'e' ] If you notice there is a space character and another space character later on as well. We want to convert this array into “practice makes perfect.”\nIce Gyro: So it's moving the letters around is what you want to do.\nSpace Dragon: Yeah, but what's important is that we have an array of characters and spaces in between. This whole list basically has words in reverse order, you know? So this array is basically: “perfect makes practice” and you convert it to “practice makes perfect.”\nIce Gyro: Yeah I think I understand.\nSpace Dragon: And the only thing that is given is that there can be one or more space characters between two words. So you have to make such a string into this, but it has to be in-place, you cannot use any extra anything.\nIce Gyro: Oh, in-place. I was thinking to make a brand new array.\nSpace Dragon: Do it in-place. Maybe before even writing the code we can discuss how you plan to do it?\nIce Gyro: Yeah so. If it was not in-place. I would allocate a brand new array, find where the spaces are and read them with indexOf() and copy the words into the spot. But since I don't have an extra array to work with that makes it a bit more tricky especially because I'm assuming the length of the words are not going to be the same. I'm not counting but the last word of the list might be shorter or longer than the first word in the list.\nSpace Dragon: Exactly. That is true.\nIce Gyro: And when you say swap it in place I'm thinking that I can't use any kind of temporary array. The most I could use is a single character array. So I need to basically move the first letter of the first word and swap it with the first letter of the last word and then the second letter of the first word with the second letter of the last word and so on. And when I do that one of the problems I think might happen is: suppose the first word is quite a bit longer than the last word, then I'm going to have all these blanks and in order to make everything fit, I wonder if I'm going end up sliding over the letters and stuff. So the requirement that it be done in-place seems to make the problem more difficult.\nSpace Dragon: Yeah exactly.\nIce Gyro: Yeah I don't mind, I'm here to get better. And if this first word is very very short. Like if this first word is just “g o,” then I would have to move things over quite a bit before I was able to put in this eight letter word. I would have to swap the first two letters, then go “golly I'm out of space,” and move things over a little bit. One of the things I'm not good at yet is recursive solutions and I kind of think this is perhaps is a thing that a recursive solution would be really good for, but even though I can kind of smell the recursion, I don't think I could do that in the half an hour we have.\nSpace Dragon: Maybe think about this. This is a relatively easier question once you know how to do it. There's something over there if you could think about that. Just think what strategies are there to make the last word in the beginning.\nIce Gyro: So just start with the last word in the beginning, is that it?\nSpace Dragon: So basically you can do some interplay of words here. I mean you can just look at the list and….There's one small thing that will make the whole question solved in that aspect, so a hint would be giving you an answer, but if you just look at the structure of the array, then you can think about how you could iteratively think about how you can get the last word in the beginning and the second last word in the second place and so one.\nIce Gyro: By pasting it down here and reformatting it a little bit I'm hoping I'll see the thing that will help. Not very familiar with the editor but in eclipse this is the trick for telling it not to format. So I wonder if I can take advantage of the letter being the same like: the first letters are both “p”s I don't have to move it, then I swap the e and the r then I swap the r and then swap the f and the c the e and the t the c and the i the c and the t and the space and the e. And then there actually I don't want to swap a space with anything. If I get a space then I just put a space here so we can have multiple spaces around things. So I could try that, but I still don't think that's the answer because if this were a very short word up front….\nSpace Dragon: Let me put it like this: what if the input array was something like this: ['a', ' ', 'b', ' ', 'c']. How would we approach this sort of input?\nIce Gyro: Right so, here I would want to swap a and c. I wonder if what I should do is have something like front is where the a....\nSpace Dragon: Try to build the algorithm first. If you know this sort of input the output would have been like: ['c', ' ', 'b', ' ', 'a'].\nIce Gyro: Right, that's correct.\nSpace Dragon: So for this input we have the reverse of output. This is the reverse of input.\nIce Gyro: So you don't have to be aware of where the words are at, you can just swap things sometimes.\nSpace Dragon: Yeah, if word is just one character, you could simply reverse the whole array. What if word is more than a character? What would happen then?\nIce Gyro: Then instead of reversing the whole thing you would want to treat the sequence of characters as one unit.\nSpace Dragon: Exactly, exactly. One is to do that even if you don't do that, what will happen is something like this: if you had a and say, b together and then we had space c and space d together ['a', 'b', ' ', 'c', ' ', 'd'] this would return something like ['d', ' ', 'c', ' ', 'b', 'a'] right?\nIce Gyro: Yeah, yes yes.\nSpace Dragon: But this is not something you're looking for. d is fine, c is fine, but this word is reversed right?\nIce Gyro: Yeah that should be “'a', 'b'”\nSpace Dragon: Yeah, so how can you fix that then.\nIce Gyro: I could go through and find the individual words and then just reverse them in place. I think I see it now: you reverse the entire string, then you reverse each word in place.\nSpace Dragon: Or: you reverse each word in place, and then reverse the entire string. That is also fine.\nIce Gyro: Very nice, thank you! That's an absolutely delightful problem, I like it very much.\nSpace Dragon: Yeah that's the problem with this: if you start helping the person it's very easy that you just tell the whole solution. Anyways let's start the coding.\nIce Gyro\nIce Gyro: Sure sure sure. So, code it up?\nSpace Dragon: Yeah. Let's do it.\nIce Gyro: Alright, good.\nIce Gyro\nIce Gyro: Alright, so it seems to me that there might be two cases: one where it's an odd number and one where it's an even number but I'm not sure about that. So I'm just going to have front and tail and…\nSpace Dragon: Can you use the function reverseTheWords() in the reverseWholeString()? Oh sorry my bad my bad.\nIce Gyro: Oh no worries, I appreciate your suggestions. You're a very good teaching interviewer, it's very nice.\nSpace Dragon: Okay so that looks okay to me and if I were at my desk in my old friend Eclipse I'd do this inside of some unit tests and have some asserts, but that's not the style of interviews just yet. So that's okay. current is going to just start there, and we're going to say while current spot in the array, word front is equal to the current and word tail is equal to....So if it was a string it would have an indexOf() but since it's a character array it doesn't have an indexOf(). And we're going to look for space, so we find the first space and now we know where the word is, so it's time to reverse the string there. I think I can reuse this reverse the string business by passing in the front and the tail. This version's going to take a start and stop and this one's just going to call the version with start and stop being set to 0 and the length.\nIce Gyro: Yeah.\nSpace Dragon: And then here this front and tail are really the badly named variables, but in the interest of time I'm not going to change their names. Alright so, reverseWholeString(), and once that's done then we need to move current up to the tail plus one and that looks reasonable to me. Then we're going to have this indexOf() guy, and it's going to go and look for a particular character.\nIce Gyro: Maybe one more thing you want to put in indexOf(): from where to start looking for.\nSpace Dragon: Oh that's a great idea, thanks.\nIce Gyro: Okay so, makes lots of sense. Off the top of my head, it looks pretty good. What I would do if I was just doing this for fun to learn is I'd do it as J in it, but since I don't think I have that, I'm just going to output the input array. Is it okay if I run it?\nIce Gyro\nSpace Dragon: Okay yeah we have some errors that you can address. One more thing that you did is while reversing the string….Here is main, from here we go to reverseTheWords(), reverseTheWords() calls reverseWholeString() then reverseTheWords(). Your small string is basically just reverseWholeString() with this input and reverseTheWords() I would create from current is less than this thing. w start is correct your t is the end….So basically on line sixty when you pass reverseWholeString(), maybe you're looking to pass wt minus one.\nIce Gyro: On line 60? Yes yes, you're absolutely correct.\nSpace Dragon: And then the current word increment by plus one and next you enter the loop, here are just wf and wt and in reverseWholeString() while f is less than t, we get the f element out, you're not implementing f here, in this while loop. While loop at 47.\nIce Gyro: Yes, that is a big problem.\nSpace Dragon: And I like the thing you did at line 60 where you wrote -1 before wt. Oh so this is a problem: so if current is length then it breaks right? Here you just need t--? No no, you set temp as the element at f, you put inputArray[f] as inputArray[t], and inputArray[t] is temp now. So at 51, f should go up and t should come down right?\nIce Gyro: Okay, yeah that makes sense.\nSpace Dragon: Yeah exactly. It's fine to me now.\nIce Gyro: Let's just try it.\nSpace Dragon: On line 43, reverseWholeString()….Yeah you also need to pass in the initial word. You have to pass in the array as well.\nIce Gyro: Okay let's try that.\nSpace Dragon: At line 61 there's another error. It cannot find inputArray? inputArray is misspelled here.\nIce Gyro: Okay, I'll fix that.\nSpace Dragon: Yeah I guess it's fine can you run it again?\nIce Gyro: Yeah let's try it. Okay one more: on line 61. And do you think twenty two is the value? Oh I don't think that IndexOutOfBoundsException give you the value.\nSpace Dragon: Probably we are looping something wrong. We are sending f in?\nIce Gyro: Yeah.\nSpace Dragon: So what is f?\nIce Gyro: So little off, way to high. So line 43 is calling it. Ah here we go: like that.\nSpace Dragon: Yeah so the last one is wrong here: “perfect.” So we never entered the loop for the last one right? So we can address that very easily.\nIce Gyro: So here's where we're reversing the individual words in place.\nSpace Dragon: The last word didn't.\nIce Gyro: Oh right here, what if we just say...and instead of wt we're just going to do the length of the inputArray.\nSpace Dragon: Yeah.\nIce Gyro: That was really fun, what a good time.\nSpace Dragon: Yeah someone asked me and never gave me any clue and took me like thirty minutes to think how to do it. Yeah you did good, you created a function and used those functions and that's very nice because that isn't something that comes to mind intuitively. So yeah, it was great work here.\nIce Gyro\nSpace Dragon: And can you tell me the asymptotic bounds on it? What would be the runtime of this?\nIce Gyro: So we loop through the entire array and we do that a couple of times so I think if the size of the input is the length of the character array I think this is a linear time complexity: O(n). And in space complexity I think it's O(1), actually it's really fuzzy in space complexity because you're going to need that input array. So space complexity is either constant O(1), or O(n).\nSpace Dragon: It isn't O(n). It's always constant right because we're not building any extra space anywhere so it will always remain constant, apart from the array that was given to us. That's why it's in-place right. And as the runtime is concerned you inverted a string once, O(n) and plus you invert each word again and that at most is O(n). So O(n) plus O(n) is O(n).\nIce Gyro: Yeah yeah I agree and you're saying in space complexity it's constant O(1).\nSpace Dragon: Yeah because we aren't creating any extra anything at all. Yeah that question you solve in 35 minutes yeah, less than that maybe.\nIce Gyro: Well thanks, thank you very much. This was really fun I'd like to do this again. It was really nice practice.\nSpace Dragon: Which languages do you general program in?\nIce Gyro: I just Java day to day. There's JavaScript in my shop as well. I'd like to learn JavaScript and start interviewing in JavaScript. There's some Scala in my shop, and so I'm taking the Coursera Scala class right now. And I like Ruby on Rails even though I'm working on my first Ruby on Rails project for fun and so I'd like to do Ruby as well. I think Go is very interested but one thing at a time. I think my highest priority is the JavaScript.\nSpace Dragon: And how many years have you been programming?\nIce Gyro: I've been programming for….I think I got my first programming job in 1988.\nSpace Dragon: Oh okay, okay. Your experience is my age.\nIce Gyro: That's alright. I'm used to that kind of thing. I have a lot of co-workers in their twenties and thirties.\nSpace Dragon: So where are you based. Are you based in Bay Area or are you based somewhere else?\nIce Gyro: Well, I kind of like the anonymity so I'll just say I'm based somewhere else is that alright?\nSpace Dragon: Yeah that's fine. I'm just asking because in Bay Area usually don't see people with this much experience, mostly younger people. Yeah I'm surprised. Yeah it was nice working with you.\nIce Gyro: Yeah you too, you too. So my understanding of how this works is we each fill out some feedback and since this is my very first interview I probably won't see your feedback until I interview several more times….\nSpace Dragon: No no, so you will see my feedback when you give me feedback and I give you feedback, then we can see each other's feedback.\nIce Gyro: Oh good. Well I plan to do that and I'd really like to do an interview once a week or something, cause I really do want to get better, and I think gone are the days of just talking to someone for forty minutes and getting a job. I think you have to do the interviews like this.\nSpace Dragon: Yeah yeah.\nIce Gyro: I really like your interviewing style I think you did a great job, and I'll write up the feedback in the next few minutes and maybe we'll talk to each other again sometime.\nSpace Dragon: Great, thank you. See you man, see you. Good luck.\nIce Gyro: Thanks, bye bye.\nSpace Dragon: Yeah, definitely\nIce Gyro: Have a great day! Bye!\nSpace Dragon: Bye!",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/linked-in-java-reverse-word-in-string",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Python Mock Interview",
      "content": "Interview Transcript\nThe Legendary Artichoke: Hello?\nMammoth Avenger: Hello?\nThe Legendary Artichoke: Hey can you hear me?\nMammoth Avenger: Yeah I can hear you pretty well.\nThe Legendary Artichoke: Okay perfect, so why don't you go ahead and pick whatever language you want to work in?\nMammoth Avenger: Okay it's going to be python.\nThe Legendary Artichoke: Okay cool. Alright so let's start with a quick little warm-up. So why don't you write me a function that reverses a string?\nMammoth Avenger: Okay, this is my first time doing interviewing.io so...So like the cheeky python answer is that you can just return a reversed() string for the input.\nThe Legendary Artichoke: Yeah, you could do that...although I'd prefer if you did the reversing yourself.\nMammoth Avenger: I expected. I just changed the variable name there because input is actually a built-in python function. So we could do...start with an empty string. For character in our input we would just prepend it to our output. And I think you can just add characters to a string like that. Should I go ahead and run it?\nThe Legendary Artichoke: Yeah go ahead and run it, let's see if it works.\nMammoth Avenger: Yep that seems to work.\nThe Legendary Artichoke: Yeah that looks like it works.\nMammoth Avenger: I was going to take a look at some edge cases usually as well make sure it handles non-string input like NaN stuff like that which it wouldn't do so great right now.\nThe Legendary Artichoke: I wouldn't worry about non-string inputs, we can assume that if it's not a string that numPy isn't blowing up. So what would be the time and space complexity here of your reverse() function?\nMammoth Avenger: Time is going to be O(n), basically looking at every character once which I don't think you could do better than...you could do it in half the passes if you did it in place and swapped characters but you're still going to be O(n). And space complexity: we're adding another variable output here of the same size, so we could reduce that to O(1) by doing it in-place in the same string. So actually you cannot do that because strings are not mutable.\nThe Legendary Artichoke: Correct, so there's no way to do this in O(1) space in python because you cannot mutate a string. So you are correct on that O(n) is the best you can do on space. But you're actually not correct about the time complexity.\nMammoth Avenger: Okay so...interesting. So I would have thought we looked at every character once.\nThe Legendary Artichoke: So you're correct: you look at every character once, but it's not the only thing you're doing.\nMammoth Avenger: Right, of course, yeah. So this isn't actually O(n) I think correctly that we cannot get better than O(n), so the concatenation right here is probably another O(n) actually because it's adding the whole string that we've created character by character to create a new copy of output.\nThe Legendary Artichoke: Correct: again because strings are immutable.\nMammoth Avenger: So one opportunity we could...yeah python is weird for string based interview questions but we could treat it as a array and swap each character in the correct index as we work our way either forwards or backwards. And we can get the length of the string in O(n) so then we can do it in O(n) that way? Do you want me to code it up?\nThe Legendary Artichoke: Yeah, why don't you go ahead an code that up?\nMammoth Avenger: Okay so treating it as a character array makes sense to you?\nThe Legendary Artichoke: Yeah I think that's probably a better approach.\nMammoth Avenger: So basically as we look at each character we're going to put it into the string starting from the back. So output\\_index = len(x) -1 and then output[output\\_index] = c and output\\_index -= 1. That should do it, I'll just run it see what that does. Okay off by one errors are usually the things that sneak in here so in the case length of x is 4, output\\_index is starting at 3. Right, I think we...yeah so we need to initiate this to make it like an empty array. Let's see if that works. Then we just want to join this back to a string at the end. Okay so I think that should do it, we have O(n) for the length and similar for creating the new output array and we're just doing a single character assignment per loop so I think this whole thing should be O(n) now.\nThe Legendary Artichoke: And what would happen if you just had an empty string?\nMammoth Avenger: I think empty string would return here.\nThe Legendary Artichoke: Okay cool.\nMammoth Avenger: Still this works. Yeah the whole array complication thing is a little not straightforward.\nThe Legendary Artichoke: Okay yeah, that was good. Let me go ahead and give you the meatier problem that we're going to work on. So I want you to write a function and you're function is going to be called find\\_missing() and it's going to take two arguments: the first argument is going to be an array that has some elements in it [4, 12, 9, 5, 6]. You can assume they're all unique to make the problem simpler. And it's going to take a second array that's going to contain the elements in the first array but with one element missing. And what I want this function to return is the missing element which in this case is 5.\nMammoth Avenger: And you said that we can assume they're all unique.\nThe Legendary Artichoke: Yes you can assume they're all unique.\nMammoth Avenger: So my first instinct here is to go to hash tables although we could also use sets in python I believe. So let's see...So I think if we, there's probably a very easy python way to do this where we could actually just make a set of the first array and then I think it's just like subtraction. We can just try that and we can also do it manually as well. Yeah so I'm going to say that's the super easy version which is…missing\\_items = set(full\\_set) - set(partial\\_set). And we assert(len(missing\\_items) == 1) and we return missing\\_items[0].\nThe Legendary Artichoke: I don't think you can index into a set? I take it python has a weird api for sets?\nMammoth Avenger: There's probably a way to pop things out of there but casting to a list is probably the easiest thing for now. So that will work pretty like just putting the work in python. So I can also do it with a hash table?\nThe Legendary Artichoke: No I mean this solution is good. So what would be the time and space complexities of this solution here?\nMammoth Avenger: So converting to a set assume it's going to take linear time because you're basically just populating a hash table I assume it's similar to how python implements it. So if you have m and n as the sizes of the two arrays, so they're both going to be linear and finding the difference should also be a linear operation.\nThe Legendary Artichoke: Why do you say that?\nMammoth Avenger: So at least to do this specific problem if we were doing it ourselves we would basically just be walking through the second array and removing things from the first when they match and because it's a hash table it's constant operation finding and removing them. So I don't know for sure what the full python set difference would take because you might have to walk through both of them but I think it would be linear.\nThe Legendary Artichoke: Yeah I mean let's give python the benefit of the doubt and that it's not doing this in a totally stupid way for set subtraction. So I think you can say pretty safely that this is going to be linear. Cool, and how much space would this take?\nMammoth Avenger: Right so we're going to be creating another full copy of m and n and basically just a hash table version but on that order of size and then the missing\\_items is just going to be one extra thing assuming that our input matches our criteria. So it would on the order of O(m + n) or it might be O(m) + O(n) I don't remember what the specific different between those two are.\nThe Legendary Artichoke: Well there'd be no difference between those two but what is m in this case?\nMammoth Avenger: I guess m and n are only one off so they're basically the same so we're talking linear on the size of either set really.\nThe Legendary Artichoke: Yeah, exactly. Yeah that sounds correct, you are correct. So is there any way you think I could do better than linear time here?\nMammoth Avenger: Let's see....so the only way to do better than linear time would be to not look at every item and the case where that could happen is if we...well missing item is by definition a number in the first set but not in the second. I'm trying to figure out if there's a way we can short circuit the check from looking in either array. So in the case the 5 is missing, so we're looking at the second array we don't know until the very end until we've looked at all the items we don't know for sure that there's no 5 in there. Actually that's not true we could sort it.\nThe Legendary Artichoke: If we sort it, how long would it take to sort?\nMammoth Avenger: Oh but that's O(nlogn), that's longer. So that doesn't work. So if it's not sorted then we can't know for sure until we get to the very last element that there isn't a 5 in the second one and if we go through the first one we can't know looking at any item that it's not in the second set until we've gone through so I'd say you can't do better than linear.\nThe Legendary Artichoke: Yep, you are correct and your argument is sound. There's no way to do better than linear time, because if there's at least one element we haven't looked at, that could be the missing element if we don't have any guarantee on order which we don't. Okay so linear time is the best we can do here, but let's say we want to trade off time for space. I'm very space constrained and I don't have enough memory to create a whole copy of my dataset. How would you lower the amount of space that this solution takes?\nMammoth Avenger: So if we don't care about time at all, one option is we sort both arrays and then you can just walk through them one by one you sort them in place so it takes the same amount of space, walk through them index by index and as soon as you find a difference in two elements you've found the missing item.\nThe Legendary Artichoke: Yeah, and what sorting algorithm would you use for that?\nMammoth Avenger: Just, we don't have any expectation given on the the specific kind of data that we're working with so probably just go with Quicksort or general data sanity, I think that's what python uses by default to sort data or it might be some slightly modified version of Quicksort.\nThe Legendary Artichoke: Yeah I'm pretty sure it uses a modified Quicksort and what would the be the space complexity if we used Quicksort?\nMammoth Avenger: My sorting algorithms are a little bit rusty but I did forget that it can add extra space complexity as well so that might be an issue. But I think that Quicksort is a variant of Mergesort I believe which picks a pivot and is just swapping items around. Oh but it's recursive, so it's probably bad for the space complexity. So if we really didn't care about the time complexity we could just do a Bubble sort or something that doesn't take any extra space but I think there are also better sorts that don't take any extra space.\nThe Legendary Artichoke: Yeah, you are correct. In particular there are a number of sorts that are O(nlogn) time while O(1) space such as Heapsort which you may vaguely remember.\nMammoth Avenger: Yep, okay.\nThe Legendary Artichoke: So if you use a sort like Heapsort, you could get it in O(1) space. Quicksort would be O(logn) for the reason you just mentioned which is because its recursive we need stack writes. But yeah okay you could go look up a sort that's O(1) space and if you needed to bite that bullet you could get O(nlogn) time and O(1) space. So that's good it gives us different ways to approach this problem. Let's say we need O(n) time, like O(nlogn) is not the trade off I'm willing to make. Do you think there's a way we can improve the space from O(n) to being less than O(n)?\nMammoth Avenger: This require the constraints to be fairly specific but if we're guaranteed that they're integers and they're all unique then we can just sum up the first list and subtract the sum of the second list and that should give us the missing item? And that's a very simply algorithm and that would be linear time and constant space.\nThe Legendary Artichoke: That would work. Why would you say it's constant space?\nMammoth Avenger: Because we're just doing two sums and then a subtraction?\nThe Legendary Artichoke: That's true but that doesn't guarantee that it's constant space. Do you know why?\nMammoth Avenger: I guess because we don't know how big the sum is going to be?\nThe Legendary Artichoke: Correct.\nMammoth Avenger: Gotcha, so if we're dealing with very large integers.\nThe Legendary Artichoke: Right if we're dealing with very large integers or just sufficiently many integers then clearly the size of the sum we're going to store is, in some way, going to scale with the size of the input right?\nMammoth Avenger: Yeah, is this one of the things where you could use an XOR?\nThe Legendary Artichoke: How would you use an XOR? How would you do that?\nMammoth Avenger: I think if you just XOR a series of integers and then….how does this work? I'm just going to..is it okay if I just look up what the python XOR function is and just play with it in the console for a bit?\nThe Legendary Artichoke: Yeah it's the ^, I'm fairly certain.\nMammoth Avenger: So we do 4 ^ 12, then I think it's like if you XOR with the same number again it gets you back to….basically if you have any number and you XOR it with an integer and you XOR with that integer again it undoes the effect. Yeah which is like topological because it's just flipping the bit. So I believe we would just XOR all of the integers in both lists. It feels kind of strange because you're treating the two lists differently but I believe the end result should end up with 5, and that one is actually constant space because it's only an integer at any point.\nThe Legendary Artichoke: Yeah, that sounds perfect, why don't you go ahead and write that up real quick?\nMammoth Avenger: Alright. I don't know what you would call this but XOR\\_sum seems close enough. That's it.\nThe Legendary Artichoke: Yeah let's give that a quick run and make sure that works.\nMammoth Avenger: That looks good. Don't know if that would handle negative numbers. Interesting…\nThe Legendary Artichoke: No it does because negative numbers, because the XOR is going to respect the negative bit.\nMammoth Avenger: You could use this on any binary datatype like find a missing object from a list of binary objects.\nThe Legendary Artichoke: Yeah as long as you only have one of the them right? Otherwise you would just get the XOR as the two objects. But yeah you pretty much got it, it was perfect. I don't have anything else for you so: well done.\nMammoth Avenger: Thank you. How does this work from here? Do you have a feedback form afterwards, or do we just chat about it for a bit?\nThe Legendary Artichoke: It's up to you we can chat about it if you want. We both get feedback forms and we send them to each other and then we can mutually read the feedback. If you have any questions I'm happy to answer them.\nMammoth Avenger: Yeah I'm just back on the job scene after a couple years of running my own startup so it's been a long time since I've done technical interviews any constructive criticism or things that I could do better or work on would be appreciated.\nThe Legendary Artichoke: Yeah my feedback is honestly you pretty much knocked this one out of the park and you're probably the fastest person I've seen solve this and get to the optimal solution. And you're coding is clearly strong. You're familiar with python you're pretty comfortable I can tell. The only thing that was a slight irk was calling variables x like that's just a peeve of mine, but different interviewers aren't going to care so that's totally and idiosyncrasy that doesn't matter in the long run.\nMammoth Avenger: I always struggle with variable naming in interview questions, I always seem to be vary ambiguous quantities. Any suggestions on what to call a variable for like a string input for like the reverse() function for example?\nThe Legendary Artichoke: Usually I just call it str for string. As long as there's nothing descriptive of it other than its datatype then I would just name it by its datatype. But again this is not nearly egregious enough for me to mark you down for it. Like I've done interviews where people are writing a fairly complicated function and they're calling things x and y and g and things like that or they call a function f() you know, that sort of thing. So honestly calling the input to a reverse function x is not enough of a violation that I care.\nMammoth Avenger: Cool\nThe Legendary Artichoke: Overall I'd say you solved this strongly.\nMammoth Avenger: Alright, thank you very much.\nThe Legendary Artichoke: Cool yeah, no problem take care.\nMammoth Avenger: You too, bye.\nThe Legendary Artichoke: Bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/airbnb-python-missing-item-list-difference",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Golang Mock Interview (Microsoft Engineer)",
      "content": "Interview Transcript\nIndelible Raven: Can you hear me?\nMassively Parallel Llama: Hi I can hear you, I'm on the phone.\nIndelible Raven: Awesome, yeah it's been having problems all day, for a while. So have you done this before?\nMassively Parallel Llama: I have done one before, yes.\nIndelible Raven: On here?\nMassively Parallel Llama: On here, yeah.\nIndelible Raven: Awesome, I do it just a little bit different. I do the same interview, like 35 minutes. But also at the end I can give you some feedback verbally as well. I do that with most people. So if you want to hear it just let me know. Other than that, let's see where you're at in your career.\nMassively Parallel Llama: In my career I'm about 2 or 3 years in experience.\nIndelible Raven: Alright, so I used to work at Google, but I don't know Go, and I feel bad for that.\nMassively Parallel Llama: That's okay, it's a language you'll be able to understand.\nIndelible Raven: No it's just like: if you work at Google, you really should know Go. It's like their language. Awesome well I'll just start you out with something, and ideally we'll get into a second part of the same question, so just keep that in mind.\nMassively Parallel Llama\nIndelible Raven: I'm going to give you a bunch of points on a 2 dimensional graph. It can either give its own class or do a pair. So it would just be [x,y]. It would be a list. Point[] of points, where it's something like [[1,2], [3,-1], [2,1], [2,3]], right? And then I'll give you a point, the vertex, so in this case it's not going to be [0,0], it's going to be [2,2] or anything I give. And I'm going to give you int k = 2. So what I want you to do is take the list of points on the graph and find the closest ones that are around the vertex and I want you to return the k closest.\nMassively Parallel Llama: Okay so let me just reiterate the problem so I have an understanding of it. You're going to give me a list of [x,y] coordinates and you'll give me a vertex, some ideal [x,y] coordinate and you need me to return the k closest [x,y] coordinate in the original point[].\nIndelible Raven: Yes, to the vertex\nMassively Parallel Llama: Okay, what would you define as the closet?\nIndelible Raven: Distance wise, so kind of the general Euclidean distance.\nMassively Parallel Llama: Cool. And these points, they're not in any sorted order are they?\nIndelible Raven: No.\nMassively Parallel Llama: No. Okay. So, my first intuition to this problem is to go over the [x,y] coordinates and for every single [x,y] coordinate compute the distance to the vertex and store that in some sort of...via min heap. And then once we have all of the elements stored in the min heap, we can pop out the top k from the heap and that will be the answer.\nIndelible Raven: Okay.\nMassively Parallel Llama: Does that make sense?\nIndelible Raven: Yeah that sounds reasonable.\nMassively Parallel Llama\nMassively Parallel Llama: So let me try to code this up. At the same time, before I start, maybe we can just discuss time complexity. Before I start coding maybe I'll think of something better? So the first step is to compute all distances to the vertex and that is going to take O(n) because we have to visit every single element and once we computed, we're pushing it onto the heap. Now when you insert something into a heap, we need to make sure that the heap....so inserting into a heap is actually constant, we don't need to worry about that yet. And then we need to perform k pops from the heap, and when you do a pop from the heap we need to figure out the next minimum element from the heap, so that's going to be O(k), because we need to pop k times and the bubble up operation can be performed in O(klog(n)) because heap has n elements. Yeah so that's one solution so if we just look at the worst case it's still O(n), that's out dominant time complexity right there. And of course we'll have to use space, our space is going to be our heap which is also O(n). Yeah so we could have another solution if we didn't have access to space, we just had to do it without using any extra memory, you could just sort of do a O(n)....that would be O(n^2) solution or….I can't think of a way where….\nIndelible Raven: So you're worried about space right?\nMassively Parallel Llama: Yes.\nIndelible Raven: How much space are you using?\nMassively Parallel Llama: O(n)\nIndelible Raven: Right, so how many points do I want to return?\nMassively Parallel Llama: Oh yes, so it could just be k. We need to only keep a heap of size k, everything else larger than k we can just throw out.\nIndelible Raven: Yeah, so how does that change the complexity overall?\nMassively Parallel Llama: Space complexity goes to O(k). And time complexity becomes O(klog(k)) for the pop.\nIndelible Raven: I'm not entirely sure your complexity is right. It is for pop, but not the push. Every time you insert it needs to keep track of something which means it re-heapifies, that's O(log(n)) so it should be O(nlog(k)).\nMassively Parallel Llama: Right, so if you already have a heap and you're pushing onto a heap you have to figure out what the next minimum element is so you would have to heapify. So yes this would also be O(klog(k)). Every time you're inserting or removing from the heap you have to find the next minimum so it would both be O(klog(k)).\nIndelible Raven: No it's actually O(log(k)) but's it's n times that.\nMassively Parallel Llama: Right, so for the push right, the push will be...we're going to do that n times and it's O(log(k)) right. But for pop we don't actually need to do anything here because we already have the k minimum elements and we can just return so this just goes away. So if that's the case our dominant time complexity will be the push.\nIndelible Raven: Try it out\nMassively Parallel Llama\nMassively Parallel Llama: Sure let's try it out. Okay so let's call this...for the points I'm just going to define a structure...it's going to have 2 elements and our input is going to be Points and we're also going to be given…\nIndelible Raven: Wait really, it works right to left in this case? That's weird\nMassively Parallel Llama: Yeah, it takes a while. And let's say we're going to return a list of a []points of of k closest points. So I guess while I was checking this another obvious way of doing this was compute all distances and just sort and once you sort you have your k closest element sorted already. I guess another clarification: would you like the original point or do you just want the distance?\nIndelible Raven: I don't want the vertex in the output but if there is a point on the vertex then that could be returned. So if that []point had [2,2] in it then yes.\nMassively Parallel Llama: Okay so just a special case if it's exactly the vertex then you want to return the point otherwise the distances is fine?\nIndelible Raven: No I want all the points.\nMassively Parallel Llama: Oh okay, you want all the points.\nIndelible Raven: Obviously a point on the vertex would be 0 distance so it would be the closest.\nMassively Parallel Llama: No I was wondering if the return should just be list of distances or the actual points.\nIndelible Raven: No, points.\nMassively Parallel Llama: Okay. So if that's the case I'm just going to add an extra element to our point struct and this could definitely be an option element that just has the distance.\nIndelible Raven: Actually I want you to leave the point class alone.\nMassively Parallel Llama: Okay let's just figure it out as we move forward then. How we can figure out which point to return after we have our heap. Alright let's just figure out how to compute the distances first, we're going to go through all the points. And for each point we're going to want to calculate the distance. So let's just assume we have a function that can do that for us. Once we have the distance we want to push it on to some sort of heap. We need some sort of heap, in Go, if you want to use a heap you have to use a priority queue and you have to write out the interface for it, so is it okay if I assume that I have a heap?\nIndelible Raven: No, I want to see the priority queue. It's that way in most languages.\nMassively Parallel Llama: You have to implement all of the interfaces for it.\nIndelible Raven: What do you mean?\nMassively Parallel Llama: The priority queue is offered as an interface and you have to implement the pop and the push based on the struct and how you want to compare each element on the heap.\nIndelible Raven: That's interesting. Then assume you can, but come up with...I don't know if Go has something like a comparative function, like a lambda function for it.\nMassively Parallel Llama: We don't really need a priority queue for this, a priority queue is more involved than a heap. We could write one.\nIndelible Raven: Just assume you have it.\nMassively Parallel Llama: So we have to initialize it somehow, and once we have that we can actually give it a size. We only want k elements in the heap and over here we can just do heap.push()\nIndelible Raven: No, I want you to handle the k yourself.\nMassively Parallel Llama: You want me to handle the k myself?\nIndelible Raven: Like I don't want it to limit the k, I want you to do that.\nMassively Parallel Llama: Okay. So if that's the case we need to figure out what the size of the heap is, assuming we can get the size of the heap by looking at the length of it. If this is the case then we need to find the element that's the largest in the heap.\nIndelible Raven: So is there a data structure that will let you find it in O(1)?\nMassively Parallel Llama: That will let you find the largest?\nIndelible Raven: Data structure or algorithm.\nMassively Parallel Llama: So let's assume our heap is represented as an array. If it is, we can actually keep track of each index in a map.\nIndelible Raven: I don't want to do it that way. Assume your heap works with push and pop and stuff, think about what the heap really is. What kind of heap is this?\nMassively Parallel Llama: It's a min heap? Actually it doesn't have to be a min heap, since we're only storing the k element that we're going to return, it could actually be a max heap and if it's a max heap we can just find the largest element.\nIndelible Raven: There you go.\nMassively Parallel Llama: Yeah so if our heap is a size k, then what we need to do is a heap.pop() and that will get rid the largest element and then we can just push()….even if it is full and we turn directly to a pop(). So let's assume we have some sort of peek() function so we can see what the largest element is and if its larger than our current distance, then only we need to do a heap.pop() and we need to push() our new element. So that's sort of our special case and if it's not then we don't have to worry about the dist, we can just continue and we just need to have an else here to take care of the case when our heap isn't full yet to go ahead and just push.\nIndelible Raven: So your heap is just distances, right?\nMassively Parallel Llama: Right now yes, it's just the distances.\nIndelible Raven: So how are you going to get the k closest out of that?\nMassively Parallel Llama: Right so I think it's best to define the new object or struct heapNode, and in this heapNode we can actually have a Dist and we can have a Point and for our comparative function for our heap, we don't care about the point we're just worried about the distance when we do the pop() and push(). Which means we just directly insert the distance and we should put it in this struct here. Okay so now that we have our heap, we should have k elements and I guess how you kind of write a while loop in Go, there's no while loops so you just write a for instead. So while our length of heap is not equal to 0, we keep pop() to our ans, and storing the point and returning it. And you mentioned a little bit earlier in the conversation that you want the vertex to be the first element in our answer?\nIndelible Raven: No, I literally just want the k closest.\nMassively Parallel Llama: Cool so we just append this to our list, and we don't care about the distances anymore we just want the point?\nIndelible Raven: Just the point.\nMassively Parallel Llama: And after this is done we'll have the k element and we can return our answer.\nIndelible Raven: Okay, there's more to this but I want to stop here and I want to take this to a different approach. This obviously works for k if I give you a list of points. What if my list is roughly a petabyte worth of points?\nMassively Parallel Llama: So our list of points is huge? If that's the case can we assume that the list of points coming in to program or function is element by element and not just as a giant list?\nIndelible Raven: You could. That would work.\nMassively Parallel Llama: That's a big assumption right. But this function would potentially work.\nIndelible Raven: I mean it generally would work, but it's a petabyte of points. I know Go is suppose to be fast but how long would that take?\nMassively Parallel Llama: So if its a petabyte of points just computing of every distance in our list is going to take some time. So if our point array is too big, we can just throw more resources at it and divide up the point[] to a more manageable chunks and send it to multiple machines I guess. And after they've all figured out their k lowest, we can do a merge operation to find out the k lowest afterwards.\nIndelible Raven: Sorry could you repeat that?\nMassively Parallel Llama: Yeah so my first thought is if it's too many points we divide up the points to manageable chunks and we divide up the work to multiple machines that hey here's a set of points, find the k closest and once every machine has done its work we have a merge operation to find what the actual k closest is at the end. That's my initial thought process if the points[] is too big.\nIndelible Raven: I mean that makes sense but what is that?\nMassively Parallel Llama: What is that? Like just a term for it? It kind of reminds of MapReduce a little bit?\nIndelible Raven: There you go, MapReduce.\nMassively Parallel Llama: Yeah you have a bunch of workers that are parsing various chunks and combining it afterwards once their done.\nIndelible Raven: So that's kind of what I'm looking for and how you would set up the MapReduce and stuff like that.\nMassively Parallel Llama\nIndelible Raven: Let's stop here that way I can give you your feedback if you want.\nMassively Parallel Llama: Sure sure.\nIndelible Raven: Usually I evaluate people's ability to code, especially when it comes to style guide. But truth be told I still don't really know how Go works or what style guide would look like. But based on general style guide it looks good. Still confusing but….\nMassively Parallel Llama: Just to touch on Go a bit. Go actually forces you to follow style. If you look at every codebase it'll look identical no sort of tabs versus spaces. So for example if I had line 48 on line 49 this actually won't compile. So it has to look like this, Go sort of forces the same sort of standards on everybody.\nIndelible Raven: I really wish you got those semicolons, drives me nuts that there aren't semicolons.\nMassively Parallel Llama: I think in Go they are optional, you can use them if you want.\nIndelible Raven: I really wish you had your edge cases. Say hey, what happens when k is less than 0 or if k is greater than the number of points. And actually wrote out test cases and error checking in the code. That's something I look for. Your algorithm design is pretty good, you're able to come up with a semi-optimal solution and I gave you a very very subtle hint and you were able to come up with a much more optimal solution as a result. I would have liked to see you go faster, time is not your solution in an interview. Ideally when we come up with these questions we plan for us to solve it in 15 minutes and since we know these questions it's going to take longer for the person but I still would have liked to see if go a little bit faster that way we could spend a little more time talking about MapReduce and what the Map would look like and how you would Reduce it. So I used to work at Google and I work at Microsoft. There's a different mentally when you work with an excessive amount of data. You don't think about how it works in one program you don't think about how it works linearly. Your brain automatically switches to: how do I spread this out to thousands of machines. I wish you went there first, instead of saying: hey we're just going to use a datastream and it'll work perfectly fine. When I switch to that, when I come up with something new the obvious answer is not the right answer. It may use some of the same code but it's not going to use the exact same code, so your first thought should not have been that. I kind of wish you started talking about MapReduce instead of the general concept of one. It kind of gives me the impression that you never really use one right?\nMassively Parallel Llama: I honestly haven't.\nIndelible Raven: The reason I bring this up is, at the two companies I worked for, it's big there. If you're interviewing for me there, I kind of expect that. If you're not interviewing there then that feedback is kind of pointless but take it as your want. Overall I think you did well, I would have liked to see you go faster and talk a little more but I think you did well. Took you a little while to figure out to use a max heap for sure. It's really all I have, you did pretty good. Do you have any questions?\nMassively Parallel Llama: In terms of coding fluency, I need to just solve more problems and get faster before I actually go into the real interviews.\nIndelible Raven: Not even faster the speed at which you're coding is fine. You need to come up with a way to make it fluid, make one step into the next into next to the end. I know that doesn't make sense in real life coding, but it has to be a very fluid operation and if it is, you're going to go fast. You don't need to speed up how you're coding, you just need to speed up your fluidity.\nMassively Parallel Llama: Yeah that definitely makes sense.\nIndelible Raven: Yeah so you talked a little about the scale. Do you think, when we started off with the problem, maybe I should have asked you how big the points array could be?\nMassively Parallel Llama: I would have told you it would have fit in an array. I wanted this answer first because this teaches me how well you code. MapReduce and this are two different things. So you would have still ended up with this but then I would have shifted to MapReduce. What I wanted to see was your mindset shift once you knew what the data was. It's always good to ask how much data there is, but I would have not told you a petabyte at the beginning.\nIndelible Raven: Yeah I don't think I have anything. This was great. This was a great experience looking back.\nMassively Parallel Llama: Thanks for interviewing with me. I think you did well. I would have definitely moved you on-site, I might have even said yes to a hire. So I have feedback, some is negative but that's just other stuff you can improve on.\nIndelible Raven: I'm going to jump off, write your feedback. It's probably not going to be much because you did well. Just going to hit on the speed part. That's all I have so I wish you the best in the future and good luck!\nMassively Parallel Llama: Yeah thanks man, thanks a lot. Bye\nIndelible Raven: Bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/microsoft-go-vertex-distance-order-statistic",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Java Interview Questions & Tips for Senior Engineers",
      "content": "Java Interview Questions & Tips\nJava Interview Stats\nWe've hosted over 100k interviews on our platform. Java was the language of choice in those interviews 29% of the time. Java also had the highest success rates – engineers who chose Java as their interview language passed their interviews 51% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nJava Idioms & Idiosyncrasies\nJava is a popular choice in software development for its portability, simplicity, and its robust, object-oriented capabilities. It's a high-level language that has a great emphasis on readability and simplicity.\nAs a seasoned and commonly used language, Java boasts a vast feature set and numerous libraries. It’s a language that enforces strict typing and has an extensive standard library. It’s a language and culture with a significant amount of formalism, especially regarding object-oriented programming and type systems.\nMost candidates and interviewers will be familiar with Java’s class structure, inheritance rules, and other internals. Focus on the core parts of what make Java great and express your solutions in with good Object-Oriented styles.\n- Classes and Objects: Java is a fully object-oriented language. Ensure you're comfortable with classes, objects, inheritance, polymorphism, and encapsulation.\n- Exception Handling: Java has a robust exception handling mechanism with try, catch, finally, and throw blocks. Understand the difference between checked and unchecked exceptions.\n- Java Collections Framework: Java provides a rich set of prepackaged data structures and algorithms called the Java Collections Framework. Be comfortable with common collections like List, Set, Map, Queue, etc.\n- Generics: Generics provide compile-time type safety that allows programmers to catch invalid types at compile time.\n- Concurrency: Understand the basics of multi-threading, synchronization, and the Java concurrency utilities from the java.util.concurrent package.\n- Stream API: Java 8 introduced the Stream API for functional-style operations on streams of elements. It is beneficial to understand how to use streams for operations like filtering, mapping, or collecting elements to a result container.\n- Java Memory Model: Understand how memory allocation works in Java, including the role of the garbage collector.\nCommon Java Interview Mistakes\nWhen interviewing in Java, there are a few common pitfalls to avoid.\nIgnoring Exceptions\nJava's exception handling capabilities are one of its strong points, offering developers a structured way to predict, catch, and handle errors during the execution of the program. These mechanisms consist of try, catch, and finally blocks, as well as throws clauses. Yet, despite the robustness of these features, mishandling exceptions can lead to code that is not only faulty but also difficult to debug and maintain.\nOne common mistake is ignoring or \"swallowing\" exceptions. This refers to the practice of catching an exception but not handling it appropriately, typically leaving the catch block empty. This can be problematic as it hides error symptoms that could be critical for diagnosing issues. Swallowing exceptions is especially perilous when it's done at the system's higher levels, which could result in an entire chain of operations failing silently.\nFor instance, consider the following piece of code:\ntry {\nint result = 10 / 0; // This line will throw an ArithmeticException\n} catch (ArithmeticException e) {\n// This is an example of swallowing an exception\n}\n1try {\n2 int result = 10 / 0; // This line will throw an ArithmeticException\n3} catch (ArithmeticException e) {\n4 // This is an example of swallowing an exception\n5}\nIn the above example, an ArithmeticException is thrown due to division by zero, but the exception is swallowed in the catch block, leading to a silent failure. This kind of error can be incredibly difficult to track down in a larger codebase because it leaves no trace.\nA better practice would be to at least log the exception, giving you a chance to diagnose the problem if something goes wrong. Here's how you might handle the exception more effectively:\ntry {\nint result = 10 / 0; // This line will throw an ArithmeticException\n} catch (ArithmeticException e) {\nSystem.err.println(\"An arithmetic error occurred: \" + e.getMessage());\n}\n1try {\n2 int result = 10 / 0; // This line will throw an ArithmeticException\n3} catch (ArithmeticException e) {\n4 System.err.println(\"An arithmetic error occurred: \" + e.getMessage());\n5}\nBy appropriately logging the exception, you will get a message in your error log indicating what went wrong, making it easier to debug and fix the issue. In real-world applications, you'd likely use a logging framework like Log4j or SLF4Jinstead of System.err.println, but the principle remains the same.\nRemember, ignoring exceptions may result in unpredictable behavior, while proper exception handling leads to more robust, reliable, and maintainable software.\nNeglecting Null Checks\nJava's object-oriented paradigm permits the use of null references, i.e., references that do not point to any object. While null references can be handy, they also pose a common pitfall: a NullPointerException\n(NPE). This exception is thrown when a program attempts to use an object reference that has the null value. These include calling an instance method on the object referred to by the null reference or trying to access a field of the object. Forgetting to check for null before accessing object methods or properties is a common oversight that can lead to such crashes.\nTake, for example, the following code:\nString myString = null;\nint length = myString.length(); // This will throw a NullPointerException\n1String myString = null;\n2int length = myString.length(); // This will throw a NullPointerException\nIn this scenario, myString\nis null\n, and calling length()\non it results in a NullPointerException\n. This mistake can be easy to overlook in complex codebases or when dealing with returned values from methods, or objects that have many fields in them, leading to program failure.\nA good defensive programming practice is to make null checks before accessing methods or properties of an object. Modifying the previous example, we would have:\nString myString = null;\nint length = 0;\nif (myString != null) {\nlength = myString.length(); // Safe!\n}\n1String myString = null;\n2int length = 0;\n3if (myString != null) {\n4 length = myString.length(); // Safe!\n5}\nIn this case, we only attempt to call the length()\nmethod if myString\nis not null\n, thereby avoiding the potential for a NullPointerException\n.\nMoreover, as of Java 8, the Optional\nclass was introduced to help deal with null references in a more explicit and safer manner. Using Optional\ncan help you design more robust APIs by making the potential absence of a value explicit in your method signatures and forcing the caller to consider the null case. Here's an example of that :\nOptional myOptionalString = Optional.ofNullable(null);\nint length = myOptionalString.map(String::length).orElse(0);\n1Optional myOptionalString = Optional.ofNullable(null);\n2int length = myOptionalString.map(String::length).orElse(0);\nIn this example, we wrap the potentially null string in an Optional\n. Optional.ofNullable\nis used to create an Optional\nthat will either hold a non-null value or be empty if the provided value is null. Then, we use the map function to apply the length method only if the Optional\nis not empty. If the Optional\nis empty, which means the original string was null\n, the orElse\nmethod will be used to provide a default value of 0\n.\nWhile null references cannot always be avoided, careful checks, liberal use of Optional\n, and thoughtful API design can prevent many common NullPointerExceptions\n, leading to more robust and error-resilient programs.\nImproper Usage of equals() and hashCode()\nJava's Object class, from which all other classes inherit, includes equals()\nand hashCode()\nmethods. When you create custom classes in Java, you may need to override these methods, particularly if you're going to use instances of these classes as keys in a HashMap\nor inside a Set\n. Not doing so may lead to unexpected results.\nThe equals()\nmethod checks if two objects are equal at a logical level. By default, this method checks for reference equality, meaning it returns true only if the two references being compared point to the same object in memory. In many cases, you'll want to change this behavior to check for logical equality instead.\nFor example, consider a Interviewer\nclass where equality should be determined by a interviewer's unique ID:\npublic class Interviewer {\nprivate String id;\nprivate String name;\npublic Interviewer(String id, String name) {\nthis.id = id;\nthis.name = name;\n}\n// Incorrect: uses reference equality, not logical equality\n// This equals method is inherited from the Object class\n// // public boolean equals(Object obj) {\n// return this == obj;\n// }\n// Correct: checks for logical equality using the unique ID\n@Override\npublic boolean equals(Object obj) {\nif (this == obj)\nreturn true;\nif (obj == null || getClass() != obj.getClass())\nreturn false;\nInterviewer interviewer = (Interviewer) obj;\nreturn id.equals(interviewer.id);\n}\n}\n1public class Interviewer {\n2 private String id;\n3 private String name;\n4\n5 public Interviewer(String id, String name) {\n6 this.id = id;\n7 this.name = name;\n8 }\n9\n10 // Incorrect: uses reference equality, not logical equality\n11 // This equals method is inherited from the Object class\n12 // // public boolean equals(Object obj) {\n13 // return this == obj;\n14 // }\n15\n16 // Correct: checks for logical equality using the unique ID\n17 @Override\n18 public boolean equals(Object obj) {\n19 if (this == obj)\n20 return true;\n21 if (obj == null || getClass() != obj.getClass())\n22 return false;\n23 Interviewer interviewer = (Interviewer) obj;\n24 return id.equals(interviewer.id);\n25 }\n26}\nThe hashCode()\nmethod, on the other hand, is used in collections like HashMap\nand HashSet\nfor efficient data access. It should be overridden in such a way that if two objects are equal according to the equals()\nmethod, their hashCode()\nmethod should return the same value. If it doesn't, this can lead to unexpected and incorrect behavior when using these objects in collections.\nContinuing the Interviewer class example:\n// Incorrect: does not override hashCode(), so it\n// uses the default one from Object class\n// which is not consistent with the overridden equals method\n// @Override\n// public int hashCode() {\n// return super.hashCode();\n// }\n// Correct: hashCode() is consistent with equals()\n@Override\npublic int hashCode() {\nreturn id.hashCode();\n}\n1 // Incorrect: does not override hashCode(), so it\n2 // uses the default one from Object class\n3 // which is not consistent with the overridden equals method\n4 // @Override\n5 // public int hashCode() {\n6 // return super.hashCode();\n7 // }\n8\n9 // Correct: hashCode() is consistent with equals()\n10 @Override\n11 public int hashCode() {\n12 return id.hashCode();\n13 }\nBy properly overriding equals()\nand hashCode()\n, you can ensure that your custom objects behave as expected when used in collections or when compared using equals()\n. Remember, when overriding one, you should override both. Otherwise, you might end up with hard-to-detect bugs and unexpected behavior.\nOvercomplicating Solutions\nJava offers various features, such as streams and optional. However, overuse can lead to unnecessarily complicated and hard-to-read code. In interviews, prioritize simplicity and readability over clever, complex solutions.\nFor example, a complex chain of stream operations might seem like a clever way to solve a problem in a single line. Still, it could also end up being confusing to the interviewer who's trying to follow your logic. Similarly, while we discuss the usefulness of Optional\nin the point above, excessive usage of Optional\nmight clutter your code, making it harder to understand and maintain.\nIn a coding interview, your primary goal is to convey your problem-solving skills effectively. Your solutions should be easy to understand, correct, and efficient. Prioritize simplicity and readability over using advanced language features to create clever but complicated solutions. An interviewer will be more impressed by your ability to write clean, straightforward code that solves the problem efficiently, rather than a convoluted solution that makes heavy use of advanced language features.\nTherefore, while it's beneficial to be familiar with advanced features in Java, it's crucial to use them judiciously and in a way that enhances, not obscures, your code's readability and simplicity.\nHow to Demonstrate Java Expertise in Interviews\nTo show off your Java expertise, you could delve deep into some of the core ideas behind the Java language, such as the JVM and memory management, or discuss the latest features in the recent JDK releases. Mention garbage collection where appropriate and be sure to use Java slang like describing objects as POJOs (Plain Old Java Objects).\nTalk about how Java has evolved over the years and how the introduction of new features like lambda expressions, the Stream API, and the module system have changed the way you code in Java. If you've adopted a more functional style with these features or even have dabbled with Kotlin then it could be worth mentioning.\nRemember to also follow Java best practices, such as preferring immutability, avoiding raw type usage, leveraging the enhanced for loop and try-with-resources statement, and properly overriding equals and hashCode when necessary.\nDemonstrating your understanding of Java best practices and idioms is crucial to succeed in Java interviews. Don't get lost in niche Java trivia and focus on showing that you can code and not how to solve a problem without involving a whole ton of extra bells and whistles.\nJava Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in Java. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose Java as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/java-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Python Interview Questions & Tips for Senior Engineers",
      "content": "Python Interview Questions & Tips\nWhat Makes Python Unique?\nPython is an interpreted, object-oriented general-purpose programming language. It is beloved by many developers and one of the most popular languages in the world, ranking second to JavaScript in the 2022 Stack Overflow Developer survey.\nWhile few aspects of Python are unique to the language, a variety of attributes that developers love and a deep toolbox of features make it an exceptional choice for a wide range of applications and projects:\nReadability: Python is one of the most readable programming languages, frequently using English or understandable keywords (continue\n, pass\n, def\n, local\n, finally\n, etc). It also requires consistent spacing in order to run without errors and largely avoids the usage of symbols, which both improve readability.\nA robust standard library: From json\nto datetime\nto io\n, Python has a deep collection of standard library modules that enables the development of a variety of application types out of the box.\nAn even-deeper ecosystem of non-standard modules: NumPy (used for scientific computing and mathematics) and Pandas (used for data analysis and manipulation) lead an incredibly deep set of non-standard-library modules, followed by other libraries such as collections\n, Flask, Django and TensorFlow. All of these libraries contribute to Python’s versatility, a major aspect of its popularity.\nExcellent documentation: The official Python documentation, as well as many top libraries, have comprehensive and easy-to-understand documentation, which is appreciated by Python engineers of all levels.\nList comprehensions and dict comprehensions: Python also has an easy, approachable and compact syntax for iterating and mapping over lists. For example, in another language you may have to write something like this in order to iterate over a list of integers and multiply them by 3:\nnums = [2, 7, 12, 32]\nnewlist = []\nfor x in nums:\nnewlist.append(x \\* 3)\nprint(newlist) # [6, 21, 36, 96)\n1nums = [2, 7, 12, 32]\n2newlist = []\n3\n4for x in nums:\n5 newlist.append(x \\* 3)\n6\n7print(newlist) # [6, 21, 36, 96)\n8\nHowever, in Python this code can be done in one line using a list comprehension:\n```\nnums = [2, 7, 12, 32]\nnewlist = [x\\*3 for x in nums]\nprint(newlist) # [6, 21, 36, 96)\n```\n1```\n2nums = [2, 7, 12, 32]\n3newlist = [x\\*3 for x in nums]\n4print(newlist) # [6, 21, 36, 96)\n5```\n6\nYou can even nest list comprehensions and add if\nstatements, though doing so can make the code slightly more difficult to read and quickly comprehend:\ncapital\\_tuples = [['Colorado', 'Denver'], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\ncities\\_and\\_states\\_starting\\_with\\_m = [\ncity\\_or\\_state\nfor city\\_state\\_tuple in capital\\_tuples\nfor city\\_or\\_state in city\\_state\\_tuple\nif city\\_or\\_state[0] == 'M'\n]\nprint(cities\\_and\\_states\\_starting\\_with\\_m) # ['Minnesota', 'Massachusetts']\n1capital\\_tuples = [['Colorado', 'Denver'], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\n2cities\\_and\\_states\\_starting\\_with\\_m = [\n3 city\\_or\\_state\n4 for city\\_state\\_tuple in capital\\_tuples\n5 for city\\_or\\_state in city\\_state\\_tuple\n6 if city\\_or\\_state[0] == 'M'\n7]\n8print(cities\\_and\\_states\\_starting\\_with\\_m) # ['Minnesota', 'Massachusetts']\n9\nSimilarly, you can use construct dictionaries using dict comprehensions:\ncapital\\_tuples = [[\"Colorado\", \"Denver\"], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\ncapital\\_dict = {state: capital for state, capital in capital\\_tuples}\nprint(capital\\_dict) # { 'Colorado': 'Denver', 'Minnesota': 'St. Paul', 'Massachusetts': ‘Boston' }\n1capital\\_tuples = [[\"Colorado\", \"Denver\"], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\n2capital\\_dict = {state: capital for state, capital in capital\\_tuples}\n3print(capital\\_dict) # { 'Colorado': 'Denver', 'Minnesota': 'St. Paul', 'Massachusetts': ‘Boston' }\n4\nLambda expressions / lambda functions: Lambda expressions are anonymous, simple functions in Python often used within high-order functions such as filter\nor map\n. They are syntactically restricted to a single expression and semantically they are simply syntactic sugar for a normal function definition.\nnums = [2, 7, 12, 17, 23]\nodd\\_nums = list(filter(lambda x: x % 2 != 0, nums))\nprint(odd\\_nums)\nnums\\_squared = list(map(lambda x: x\\*\\*2, nums))\nprint(nums\\_squared)\n1nums = [2, 7, 12, 17, 23]\n2odd\\_nums = list(filter(lambda x: x % 2 != 0, nums))\n3print(odd\\_nums)\n4\n5nums\\_squared = list(map(lambda x: x\\*\\*2, nums))\n6print(nums\\_squared)\n7\nPython Interview Stats\nWe've hosted over 100k interviews on our platform. Python was the language of choice in those interviews 40% of the time, and engineers who interviewed in Python passed their interviews 56% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nCommon Python Interview Mistakes\nThough Python is known for being easy to understand, debug and reason about, there are a handful of quirks that may throw off newer developers or developers coming from other languages:\nSpacing matters: While strict spacing rules makes Python code more readable, it also won’t run properly without consistent spacing. For example, many languages use brackets ({\nand }\n) to denote the beginning and ending of code blocks or functions, but Python relies on indentation and colons.\nScope and closures: In many languages you can automatically reference variables in the enclosing scope (or other outer scopes), but in Python you can only reference local variables. In order to access variables in an outer scope the nonlocal\nkeyword is required, and in order to reference variables in the global scope the (you guessed it) global\nkeyword is required.\n# Global variable\nglobal\\_var = 10\ndef outer\\_function():\n# Outer function variable\nouter\\_var = 20\ndef inner\\_function():\n# Local variable\ninner\\_var = 30\nprint(\"Local variable:\", inner\\_var) # 30\nnonlocal outer\\_var\nouter\\_var = 40\nprint(\"Nonlocal variable:\", outer\\_var) # 40\nglobal global\\_var\nglobal\\_var = 50\nprint(\"Global variable:\", global\\_var) # 50\nprint(\"Outer variable:\", outer\\_var) # 20\ninner\\_function()\nouter\\_function()\n1# Global variable\n2global\\_var = 10\n3\n4def outer\\_function():\n5 # Outer function variable\n6 outer\\_var = 20\n7\n8 def inner\\_function():\n9 # Local variable\n10 inner\\_var = 30\n11\n12 print(\"Local variable:\", inner\\_var) # 30\n13 nonlocal outer\\_var\n14 outer\\_var = 40\n15 print(\"Nonlocal variable:\", outer\\_var) # 40\n16 global global\\_var\n17 global\\_var = 50\n18 print(\"Global variable:\", global\\_var) # 50\n19\n20 print(\"Outer variable:\", outer\\_var) # 20\n21 inner\\_function()\n22\n23outer\\_function()\n24\nInterpreted: Python is an interpreted language, meaning errors surface at run-time; as opposed to compiled languages such as Java, where errors surface at compile time.\nPython Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in Python. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose Python as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/python-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "JavaScript Interview Questions & Tips for Senior Engineers",
      "content": "How is JavaScript Used in Technical Interviews?\nJavaScript Interview Stats\nThe selection of a programming language can often be a decisive factor in the arena of technical interviews. Based on the data collected from over 100k interviews on our platform, JavaScript emerged as the third most popular language of choice, being used in 12% of all technical interviews. JavaScript ranks just below popular programming languages like Python and Java, yet, when chosen, JavaScript delivers a pass rate of 42% in the interviews, showcasing its significance and effectiveness.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews by language.\nOne of the reasons for JavaScript's popularity is its versatility. It works on both the backend and frontend, making it a valuable tool for full-stack developers. Using a single language across multiple layers of an application can enhance productivity and improve workflow.\nOf course, it wouldn't be a discussion about JavaScript without acknowledging the love-hate relationship it enjoys with programmers. JavaScript can be likened to that old friend you may sometimes find eccentric and unpredictable, yet they always surprise you with their resourcefulness and charm. No matter how you feel about it, one thing is sure — you can't ignore JavaScript.\nWhy JavaScript is Important for Technical Interviews\nUnique Qualities of JavaScript\nJavaScript stands out due to its adaptability and prevalence in web development. It's a flexible tool that handles both object-oriented and functional programming styles, making it ideal for showcasing diverse problem-solving skills in interviews. Its role as the sole native language of web browsers puts it front and center in web development, offering a clear edge during interviews. Its use in front-end and back-end development, thanks to tools like Node.js and frameworks like React, makes it a full-stack developer's dream.\nIndustry Significance of JavaScript\nJavaScript's importance goes beyond its technical merits—it's also a leading language in the industry. The 2023 Stack Overflow Developer Survey marks it as the most commonly used language for the eleventh year in a row. GitHub's Octoverse Report 2022 also attests to the same fact, with JavaScript being the most used language on GitHub. This sustained industry demand ensures that JavaScript expertise remains highly valued in technical interviews.\nJavaScript Idioms & Idiosyncrasies\nJavaScript was developed by Brendan Eich in just ten days in the year 1995 while he was working at Netscape Communications. Over the years, JavaScript has undergone numerous changes and enhancements. ECMAScript (ES), the standardized language specification, has overseen these transformations. One of the most significant shifts came with the release of ES6 (also known as ES2015) in June 2015, which introduced new syntax and powerful features that transformed the way JavaScript code was written. Since then, new versions of the specification have been released yearly, with the latest being ES2023.\nWhile the specifications have evolved, JavaScript's core principles have remained unchanged. It's a dynamic, weakly typed, prototype-based language that supports object-oriented, imperative, and declarative programming styles. Additionally, it's a single-threaded, non-blocking, asynchronous language that uses an event loop to handle concurrency. In recent years, the emergence of TypeScript - a statically typed superset of JavaScript - highlights the evolving nature of JavaScript, offering type safety and improved tooling. In this section we'll learn about JavaScript's idioms and idiosyncrasies, that make it special.\nSingle Threaded Event Loop & Asynchronous Behavior\nJavaScript is single-threaded, meaning it can process one operation at a time in a single sequence, or thread, of operations. While this might seem limiting, especially considering that many programming languages use multi-threading, JavaScript leverages this single-threaded nature using an event loop mechanism to handle asynchronous operations efficiently.\nJavaScript's single-threaded nature helps it avoid the complexities of multithreading while manipulating DOM tree, making it easier to learn and use. But since it can only process one operation at a time, a long-running operation can block the thread and hang the system, causing what is known as a \"blocking\" operation.\nTo overcome this, JavaScript uses an event-driven, non-blocking I/O model. It utilizes an event loop and a callback queue. When an asynchronous operation is encountered, it's offloaded to the browser's Web APIs, freeing up the main thread to continue executing other operations. The associated callback function is pushed into a task queue when the asynchronous operation is completed. The event loop continually checks this queue and pushes any waiting callbacks back onto the main thread for execution as soon as it's free.\nThis unique design allows JavaScript to handle high I/O workloads efficiently without the complexity and potential issues of multi-threading, making it particularly well-suited for web development, where asynchronous operations like network requests, user interactions, and timers are common.\nconsole.log(\"Fetching data...\");\nsetTimeout(function() {\nconsole.log(\"Data fetch complete!\");\n}, 2000);\nconsole.log(\"Waiting for data...\");\n// Output:\n// Fetching data...\n// Waiting for data...\n// Data fetch complete!\n1console.log(\"Fetching data...\");\n2\n3setTimeout(function() {\n4 console.log(\"Data fetch complete!\");\n5}, 2000);\n6\n7console.log(\"Waiting for data...\");\n8\n9// Output:\n10// Fetching data...\n11// Waiting for data...\n12// Data fetch complete!\n13\nJavaScript Execution Environment\nThe environments in which JavaScript runs, such as web browsers (Chrome, Safari, Firefox, etc.) or servers (Node.js, Deno, Bun, etc.), each provide unique features and behaviors. Although ECMAScript defines the standard specifications for JavaScript, not all environments implement these uniformly, leading to environment-specific quirks. For instance, a feature like the Fetch API, widely supported in modern web browsers, wasn't natively supported in Node.js until version 17.5 (with experimental flag). Therefore, understanding your JavaScript execution environment and its specific features is crucial for creating robust, cross-compatible code.\nType Coercion\nAs a weakly typed language, JavaScript can automatically convert values from one type to another, a behavior known as type coercion.\nconsole.log(4 + \"2\"); // Output: \"42\"\nlet numStr = \"42\";\nlet num = +numStr; // '+' operator triggers type coercion.\nconsole.log(num); // Output: 42 (a number, not a string)\n1console.log(4 + \"2\"); // Output: \"42\"\n2\n3let numStr = \"42\";\n4let num = +numStr; // '+' operator triggers type coercion.\n5console.log(num); // Output: 42 (a number, not a string)\n6\nThis behavior of JavaScript may remind you of type casting seen in other languages. The key difference is that type casting (or type conversion) is explicitly done by the programmer, while type coercion is performed implicitly by the language. In JavaScript, it's important to understand when and how type coercion occurs to prevent unexpected outcomes.\nFunction Expressions\nJavaScript treats functions as first-class objects so that they can be assigned to variables, stored in data structures, passed as arguments to other functions, and returned from other functions.\n// function gets assigned to a variable\nlet calculateArea = function(radius) {\nreturn Math.PI \\* radius \\* radius;\n};\n1// function gets assigned to a variable\n2let calculateArea = function(radius) {\n3 return Math.PI \\* radius \\* radius;\n4};\nHoisting\nHoisting is a unique behavior of JavaScript where variable and function declarations are moved to the top of their containing scope during the compilation phase before the code has been executed.\ngreet(); // Output: Hello, Interviewing.io!\n// Function declaration\nfunction greet() {\nconsole.log('Hello, Interviewing.io!');\n}\n1greet(); // Output: Hello, Interviewing.io!\n2\n3// Function declaration\n4function greet() {\n5 console.log('Hello, Interviewing.io!');\n6}\nClosure\nA closure is a function that has access to the variables of its outer function, even after the outer function has returned. This is possible because the inner function has access to the outer function's scope, even after the outer function has finished executing. This helps create private variables and function factories.\nfunction outerFunc() {\nlet outerVar = 'I am outside!';\nfunction innerFunc() {\nconsole.log(outerVar);\n}\nreturn innerFunc;\n}\nlet inner = outerFunc();\ninner(); // Output: I am outside!\n1function outerFunc() {\n2 let outerVar = 'I am outside!';\n3 function innerFunc() {\n4 console.log(outerVar);\n5 }\n6 return innerFunc;\n7}\n8let inner = outerFunc();\n9inner(); // Output: I am outside!\nThe this\nKeyword\nIn JavaScript, this\nis a special keyword that refers to the context in which a function is called. This can vary depending on how and where the function is invoked. In a method of an object, this\nrefers to the object itself. In a simple function call, this\nrefers to the global object (in non-strict mode) or is undefined\n(in strict mode).\nconst myObj = {\nvalue: 'Hello, World!',\nprintValue: function() {\nconsole.log(this.value);\n}\n};\nmyObj.printValue(); // Output: Hello, World!\n1const myObj = {\n2 value: 'Hello, World!',\n3 printValue: function() {\n4 console.log(this.value);\n5 }\n6};\n7\n8myObj.printValue(); // Output: Hello, World!\nContrast this with Python, where the object context is passed explicitly as a parameter (self\n) to an instance method, and with Java, where this\nalways refers to the current instance of the class.\nUnderstanding the this\nkeyword, and its context-dependent nature, is crucial for writing and debugging JavaScript code. It’s also a source of frequent mistakes. We'll learn more about that in the next section.\nDestructuring\nIntroduced in ES6, destructuring allows for quickly unpacking values from arrays or properties from objects. This can help simplify code and make it more readable.\nlet candidate = {\nname: \"Alice\",\nlanguage: \"JavaScript\",\nexperience: \"3 years\",\n};\nlet { name, experience } = candidate;\nconsole.log(name, experience); // Output: Alice, 3 years\n1let candidate = {\n2 name: \"Alice\",\n3 language: \"JavaScript\",\n4 experience: \"3 years\",\n5};\n6\n7let { name, experience } = candidate;\n8console.log(name, experience); // Output: Alice, 3 years\nRest and Spread Operators\nThese operators provide convenient ways to handle collections of items and can often simplify the code written in an interview.\nSpread: While destructuring 'unpacks' elements from an array or properties from an object, the spread operator takes it further by allowing you to expand or 'spread out' these elements or properties in a new context. It's helpful when you want to combine arrays or to use an array's values as function arguments.\nlet candidate = {\nname: \"Alice\",\nbasicSkills: [\"HTML\", \"CSS\"]\n};\nlet updatedCandidate = {\n...candidate, // Using spread operator to copy properties from candidate object\nadvancedSkills: [\"JavaScript\", \"React\"]\n};\nconsole.log(updatedCandidate);\n/\\* Output:\n{\nname: \"Alice\",\nbasicSkills: [\"HTML\", \"CSS\"],\nadvancedSkills: [\"JavaScript\", \"React\"]\n}\n\\*/\n1let candidate = {\n2 name: \"Alice\",\n3 basicSkills: [\"HTML\", \"CSS\"]\n4};\n5\n6let updatedCandidate = {\n7 ...candidate, // Using spread operator to copy properties from candidate object\n8 advancedSkills: [\"JavaScript\", \"React\"]\n9};\n10\n11console.log(updatedCandidate);\n12/\\* Output:\n13{\n14 name: \"Alice\",\n15 basicSkills: [\"HTML\", \"CSS\"],\n16 advancedSkills: [\"JavaScript\", \"React\"]\n17}\n18\\*/\nRest: The Rest operator collects multiple elements and condenses them into a single array. It's used in function arguments to allow the function to accept any number of parameters.\nfunction getCandidateDetails({ name, ...skills }) {\nconsole.log(`Candidate ${name} has the following skills:`);\nconsole.log(`Basic: ${skills.basicSkills}`);\nconsole.log(`Advanced: ${skills.advancedSkills}`);\n}\ngetCandidateDetails(updatedCandidate);\n/\\* Output:\nCandidate Alice has the following skills:\nBasic: HTML,CSS\nAdvanced: JavaScript,React\n\\*/\n1function getCandidateDetails({ name, ...skills }) {\n2 console.log(`Candidate ${name} has the following skills:`);\n3 console.log(`Basic: ${skills.basicSkills}`);\n4 console.log(`Advanced: ${skills.advancedSkills}`);\n5}\n6\n7getCandidateDetails(updatedCandidate);\n8/\\* Output:\n9Candidate Alice has the following skills:\n10Basic: HTML,CSS\n11Advanced: JavaScript,React\n12\\*/\nCommon JavaScript Interview Mistakes\nIn the context of interviews, a deep understanding of JavaScript is critical. There are some common pitfalls that candidates often fall into. Recognizing these mistakes can greatly enhance your interview performance and overall coding skills.\nImproper Use of 'this' Keyword\nThe this\nkeyword in JavaScript can be tricky, as its context depends on how and where it's called. Let's consider an example where you are iterating over an array of numbers to calculate their sum:\nclass ArraySum {\nconstructor(numbers) {\nthis.numbers = numbers;\nthis.sum = 0;\n}\ncalculateSum() {\nthis.numbers.forEach(function(num) {\nthis.sum += num;\n});\n}\n}\nlet obj = new ArraySum([1, 2, 3]);\nobj.calculateSum();\nconsole.log(obj.sum); // NaN\n1class ArraySum {\n2 constructor(numbers) {\n3 this.numbers = numbers;\n4 this.sum = 0;\n5 }\n6\n7 calculateSum() {\n8 this.numbers.forEach(function(num) {\n9 this.sum += num;\n10 });\n11 }\n12}\n13\n14let obj = new ArraySum([1, 2, 3]);\n15obj.calculateSum();\n16console.log(obj.sum); // NaN\n17\nHere, this inside the forEach\ncallback doesn't refer to the ArraySum\ninstance, but to the global object (undefined\nin strict mode). This results in NaN\nbecause undefined\n+ number in JavaScript is NaN\n.\nThe issue can be fixed using an arrow function:\nclass ArraySum {\nconstructor(numbers) {\nthis.numbers = numbers;\nthis.sum = 0;\n}\ncalculateSum() {\nthis.numbers.forEach(num => {\nthis.sum += num;\n});\n}\n}\nlet obj = new ArraySum([1, 2, 3]);\nobj.calculateSum();\nconsole.log(obj.sum); // 6\n1class ArraySum {\n2 constructor(numbers) {\n3 this.numbers = numbers;\n4 this.sum = 0;\n5 }\n6\n7 calculateSum() {\n8 this.numbers.forEach(num => {\n9 this.sum += num;\n10 });\n11 }\n12}\n13\n14let obj = new ArraySum([1, 2, 3]);\n15obj.calculateSum();\n16console.log(obj.sum); // 6\nThe arrow function doesn't have its own this\ncontext, it inherits it from the surrounding code. Now this\nwithin the forEach\ncallback correctly refers to the ArraySum\ninstance, leading to the correct sum of numbers.\nUsing Array as a Queue without Time Complexity Considerations\nJavaScript has no built-in queue data structure. Using an array as a queue is common during data structure and algorithm questions. However, it can be computationally expensive. Suppose you're implementing a Breadth-First Search (BFS) on a graph in an interview; you might use an array as a queue to hold nodes:\nfunction bfs(graph, startNode) {\nlet queue = [];\n// enqueue operation\nqueue.push(startNode);\nwhile(queue.length > 0) {\n// dequeue operation, O(n)\nlet node = queue.shift();\nconsole.log(node.value);\nfor(let child of node.children) {\nqueue.push(child);\n}\n}\n}\n1function bfs(graph, startNode) {\n2 let queue = [];\n3 // enqueue operation\n4 queue.push(startNode);\n5\n6 while(queue.length > 0) {\n7 // dequeue operation, O(n)\n8 let node = queue.shift();\n9 console.log(node.value);\n10\n11 for(let child of node.children) {\n12 queue.push(child);\n13 }\n14 }\n15}\nArray.prototype.shift()\nhas a time complexity of O(n)\nbecause it re-indexes every remaining element in the array. This can be a major inefficiency for large arrays.\nYou should always let your interviewer know you know this limitation. If the interviewer insists, you should be able to implement it using a linked list. This will give you a time complexity of O(1)\nfor both enqueue and dequeue operations.\nMistakes with Type Coercion and Equality (== and ===)\nUnderstanding JavaScript's type coercion in comparison operations is crucial, especially when dealing with different data types. Let's look at a simple but confusing example:\nlet a = '0';\nlet b = 0;\nconsole.log(a == b); // true\nconsole.log(a === b); // false\n1let a = '0';\n2let b = 0;\n3\n4console.log(a == b); // true\n5console.log(a === b); // false\nIn the first log statement, JavaScript coerces the string '0' to a number due to the ==\noperator, resulting in true. In the second log statement, the ===\noperator checks both value and type, hence '0' (string) and 0 (number) are not considered equal.\nAs a best practice, it is always recommended to use the ===\noperator.\nNot Writing Idiomatic JavaScript\nIdiomatic JavaScript means writing code that aligns with the community's accepted best practices and conventions. The following table shows some common mistakes that are not idiomatic JavaScript and how to fix them:\n| Non-idiomatic JavaScript | Idiomatic JavaScript | Explanation |\n|---|---|---|\nlet x = new Array(); | let x = []; | Use literal notation to initialize arrays. |\nlet y = new Object(); | let y = {}; | Use literal notation to initialize objects. |\nfor (let i = 0; i < array.length; i++) { console.log(array[i]); } | array.forEach(element => console.log(element)); | Use forEach for array iteration. |\nif (a !== null && a !== undefined) {...} | if (a) {...} | JavaScript treats null , undefined , 0 , NaN , \"\" as falsy. Just use if (a) to check for these. |\nlet z; if (x) { z = y; } else { z = w; } | let z = x ? y : w; | Use the ternary operator for simple conditional assignment. |\narr.indexOf(el) === -1 | !arr.includes(el) | Use includes to check if an array contains a specific element. |\nfor (let i = 0; i < users.length; i++) { if (users[i].age > 21) { adults.push(users[i]); }} | let adults = users.filter(user => user.age > 21); | Use filter for creating a new array with all elements that pass a test. |\nUnintentionally Mutating Array or Objects\nJavaScript is a language where arrays and objects are mutable and are passed by reference. Therefore, any changes to the array or object inside a function will reflect outside the function as well, leading to unintentional side effects.\nLet's consider a simple array-based DFS approach where you're not properly managing mutations:\nlet graph = {\n'A': ['B', 'C'],\n'B': ['A'],\n'C': ['A', 'B', 'D', 'E'],\n'D': ['C', 'E', 'F'],\n'E': ['C', 'D'],\n'F': ['D']\n};\nlet visited = [];\nfunction dfs(node) {\nvisited.push(node);\nfor (let neighbor of graph[node]) {\nif (!visited.includes(neighbor)) {\ndfs(neighbor);\n}\n}\nreturn visited;\n}\nlet pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\nlet pathFromB = dfs('B'); // ['A', 'B', 'C', 'D', 'E', 'F']\n1let graph = {\n2 'A': ['B', 'C'],\n3 'B': ['A'],\n4 'C': ['A', 'B', 'D', 'E'],\n5 'D': ['C', 'E', 'F'],\n6 'E': ['C', 'D'],\n7 'F': ['D']\n8};\n9\n10let visited = [];\n11\n12function dfs(node) {\n13 visited.push(node);\n14 for (let neighbor of graph[node]) {\n15 if (!visited.includes(neighbor)) {\n16 dfs(neighbor);\n17 }\n18 }\n19 return visited;\n20}\n21\n22let pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\n23let pathFromB = dfs('B'); // ['A', 'B', 'C', 'D', 'E', 'F']\nIn the above code, we expect pathFromA\nand pathFromB\nto be different, but since visited\nis shared and gets mutated during each DFS\nrun, pathFromB\ndoesn't give us the expected result.\nTo fix this, we need to initialize visited\nwithin the function itself:\nfunction dfs(node, visited = []) {\nvisited.push(node);\nfor (let neighbor of graph[node]) {\nif (!visited.includes(neighbor)) {\ndfs(neighbor, visited);\n}\n}\nreturn visited;\n}\nlet pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\nlet pathFromB = dfs('B'); // ['B', 'A', 'C', 'D', 'E', 'F']\n1function dfs(node, visited = []) {\n2 visited.push(node);\n3 for (let neighbor of graph[node]) {\n4 if (!visited.includes(neighbor)) {\n5 dfs(neighbor, visited);\n6 }\n7 }\n8 return visited;\n9}\n10\n11let pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\n12let pathFromB = dfs('B'); // ['B', 'A', 'C', 'D', 'E', 'F']\nNow, pathFromA\nand pathFromB\nare different as expected. Understanding and managing mutations properly is crucial in JavaScript, particularly in tricky algorithms such as DFS.\nNot Understanding the Sort() Method\nJavaScript's built-in Array.prototype.sort()\nmethod can be a source of confusion, especially when sorting numerical arrays. If no compare function is supplied, sort()\nwill convert items to strings and sort them in lexicographic (alphabetical) order, which can lead to unexpected results when dealing with numbers.\nFor instance, let's say you're working on a coding problem where you're given an array of integers, and you need to sort them in ascending order. You might think you could simply use sort()\n:\nlet arr = [10, 21, 4, 15];\narr.sort();\nconsole.log(arr); // Outputs: [10, 15, 21, 4]\n1let arr = [10, 21, 4, 15];\n2arr.sort();\n3console.log(arr); // Outputs: [10, 15, 21, 4]\nThis output isn't what you'd expect if you wanted to sort numerically. It's because sort()\nconverts the numbers to strings, and '10' is lexicographically less than '4'.\nTo correctly sort numbers in JavaScript, you need to supply a comparator function:\nlet arr = [10, 21, 4, 15];\n// sort method is passed a comparator function\n// if comparator(a, b) returns a negative number, a comes before b\n// if comparator(a, b) returns a positive number, b comes before a\n// if comparator(a, b) returns 0, a and b are unchanged with respect to each other\narr.sort((a, b) => a - b);\nconsole.log(arr); // Outputs: [4, 10, 15, 21]\n1let arr = [10, 21, 4, 15];\n2\n3// sort method is passed a comparator function\n4// if comparator(a, b) returns a negative number, a comes before b\n5// if comparator(a, b) returns a positive number, b comes before a\n6// if comparator(a, b) returns 0, a and b are unchanged with respect to each other\n7arr.sort((a, b) => a - b);\n8\n9console.log(arr); // Outputs: [4, 10, 15, 21]\n10\nUsing 'var' instead of 'let' or 'const'\nThe use of var\nis considered outdated in modern JavaScript (ES6 and later). Instead, let\nand const\nare preferred because they provide block scoping, reducing potential bugs and making the code easier to predict and understand.\nThe general rule of thumb is:\n-\nUse\nconst\nwhen the variable should not be reassigned. This is often true for function declarations, imported modules, and configuration variables. Usingconst\ncan help you catch errors where you accidentally try to reassign a variable. -\nUse\nlet\nwhen the variable will be reassigned. This is common in loops (for instance, counters), and in some algorithm implementations.\nChoosing let\nor const\nappropriately in your code makes it more predictable and signals to other developers (and interviewers) that you understand the variable's purpose and lifecycle. This can make your code easier to read and maintain.\nIt's also important to note that const\ndoes not make the entire variable immutable, only the assignment. For instance, if you declare an object or an array with const\n, you can still modify the elements in the array or the object's properties. This can lead to unintentional behavior if not fully understood.\nconst obj = {};\nobj.property = 'value'; // This is allowed\nconst arr = [];\narr.push(1); // This is allowed\n1const obj = {};\n2obj.property = 'value'; // This is allowed\n3\n4const arr = [];\n5arr.push(1); // This is allowed\n6\nJavaScript Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in JavaScript. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose JavaScript as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/javascript-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Amazon Interviews + Questions",
      "content": "All human organizations operate as a metaphor. Amazon isn’t a sports team or a family; they’re a motley crew of Terminators. They’re a different breed with notoriously high standards. They reward aggression. And they want to take over the market (or the earth, depending on who you ask)...\nAmazon’s process is not centralized, and you can interview with multiple teams concurrently. To up your odds, interview with as many teams as you have the appetite for.\nAmazon really loves their Leadership Principles (LPs). Amazon interviewers may sandwich LP questions anywhere and everywhere throughout your interview rounds: coding rounds, system design rounds, all rounds. In short, at an Amazon interview, be prepared for Leadership Principles questions anywhere, anytime.\nFinally, Amazon has one of the more-structured interviewing cultures. They’re the only FAANG where interviewers exist in a formal hierarchy, and Amazon openly encourages and rewards interviewers who reach the top rung in that hierarchy.\nIn this guide we’ve compiled a comprehensive Amazon job interview prep guide based on in-depth discussions with Amazon interviewers and interviewees. Our guide includes a detailed walkthrough of the interview process, common questions and solutions, interview tips, video replays of mock Amazon interviews, and more.\nWant to know if you’re ready to interview at Amazon? Do anonymous mock interviews with real Amazon interviewers, and see exactly where you stack up.\nSee available timesAmazon’s interview process consists of the following steps:\nWe walk through each of these steps in detail below.\nWhether you start with an online assessment or an Amazon recruiter call depends on a few factors:\nIf you answered yes to any of these questions, then you will likely not have to do an online assessment, and your first step will be a recruiter call. That said, we’ve gotten some conflicting reports from Amazonians, and it may be that Amazon has more recently started using online assessments to test the competencies of more senior engineers as well.\nIf you do the online assessment, here’s how it works. It’s a timed, asynchronous test consisting of several coding problems, conducted via HackerRank. These are usually data structures and algorithm problems of easy to medium-level difficulty, as well as some multiple choice system design questions where you have to select the design option that’s ideal in a given situation. If you do well in the online assessment, you can skip the second step, which is the technical phone screen.\nIf you end up skipping the online assessment, the first step in your process will be a recruiter call. Please see the section above called “A note about recruiter calls.”\nAmazon’s technical phone interview is a coding interview that tends to focus exclusively on data structures and algorithms. Despite the focus on speed, Amazon interview questions may require a lot of code, and the time allowed is usually 30-40 minutes, which means you’ll usually get one question, as opposed to Facebook, where you might get multiple questions.\nFor these screens, Amazon uses an internal tool called Livecode, which has syntax highlighting for popular languages but does NOT have the ability to run the code. In fact, no code is ever compiled or run in Amazon technical interviews.\nFinally, there’s a 50% chance that your interviewer will throw in 1 or 2 Leadership Principles questions into the phone screen. They’re not guaranteed, but they’ll definitely come up during the onsite.\nThere’s some variance, but the typical Amazon onsite, or in-person interview, for technical roles, will consist of:\nAmazon has a special type of interviewer that they include in onsite loops: the Bar Raiser. These are typically senior-level Amazon employees at the top of the formal interviewer hierarchy, and they’re the toughest and most-trained interviewers at Amazon. They serve as an independent and objective evaluator, asking follow-up questions, and ensuring that hiring decisions are not influenced solely by the candidate's immediate team or department.\n“Being a Bar Raiser makes an impact on your promotion packet. Every L5 nearing promotion at Amazon, is encouraged to do the Bar Raiser training. It’s a big input to get to L6 or L7. Part of the promotion packet is: how are you demonstrating some of the Leadership Principles. And “Hire and Develop the Best” is one of the LPs. There’s a lot of work to do in hiring to become a Bar Raiser: you have to do a lot of training and a ton of interviews. Being a Bar Raiser carries a lot of weight at Amazon if you want to get promoted.”\nAt Amazon, Bar Raisers and hiring managers are the only interviewers who have the formal authority to veto a hiring decision. You can recognize them because they are the only interviewer in your onsite loop who has nothing to do with the team you’re interviewing for. Bar Raiser rounds can be super intense, but don’t shrink when you feel a Bar Raiser throw flames your way; embrace the fire.\nThere are three main types of interviews you’ll face as a software engineer interviewing at Amazon. These are coding, behavioral, and system design interviews.\nYou will have to do coding interviews in the phone screen and in the onsite. Coding rounds at the onsite are very similar to technical phone screen rounds, except that in the technical phone screen you might get Leadership Principles questions, whereas in the onsite coding portion, you definitely will.\nAmazon asks mostly medium-difficulty LeetCode-style coding questions and avoids hard questions. The idea is to let candidates demonstrate how quickly they get to the optimal result, all in the service of hiring engineers who can churn out new features quickly.\nDespite the focus on speed, Amazon questions may be a complex problem that requires a lot of code, and the time allowed is usually 30-40 minutes, which means you’ll usually get one question, as opposed to Facebook, where you might get multiple questions.\nAmazon’s coding rounds test the following technical skills:\nAlthough your performance in technical interviews matters (if you fail the technical, you usually will not move forward), it’s not as important as the outcome of the behavioral interview, and coding interviews during the onsite at Amazon actually feature Leadership Principles questions.\n“Because no code is ever run on an editor, the approach, speed, and testing are most important. Code syntax, typos, variable naming, and edge cases are less important.”\nGraph questions are among the most popular types of questions asked at Amazon, as well as tree questions that require BFS or DFS. Classic questions like LRU cache, meeting rooms, word break, word search, word ladder, and so on may also come up.\nWe’ve heard from Amazon interviewers that all of the data structures and algorithms questions in Amazon’s official question bank are actually on LeetCode. That said, Amazon interviewers are allowed to ask whatever they want in coding rounds, and some will deviate from the question bank to ask more practical questions such as, “Implement a function with some behavior with the help of these two APIs…””\nFinally, like Facebook, Amazon shies away from dynamic programming questions (though they’re not banned outright).\nFor everything you need to prepare for Amazon’s coding interview, check out the section called \"Amazon coding interview preparation resources\" below.\nThe behavioral interview is one of, along with coding interviews at the onsite, the most important in terms of leading to an offer.\n“I’ve done over a hundred interviews at Amazon. The behavioral interview is most likely to get someone pushed over the line if they were borderline in their technical interviews. The opposite is not true: if they don’t meet the behavioral bar, we don’t care how they did in technicals, we aren’t hiring them.”\nBehavioral is an extremely important part of the Amazon interview process – Amazon is more likely to downlevel or reject you solely based on behavioral – and their behavioral round might be the most well-thought-out interview in all of big tech. It also might be the easiest to fail if you don’t specifically prepare for it. There’s no flavor like the flavor of an Amazonian behavioral interviewer; if you’ve never encountered it before and don’t expect it, it can be jarring.\nOne of the most common mistakes our users make is not taking this interview seriously because at most other companies, behavioral interviews tend to be more lip service than a meaningful part of the process. The bottom line is, if you want an Amazon job at a senior level or above, you have to seriously prepare for the behavioral interview questions.\nNot all Leadership Principles are created equal. Customer Obsession is the 👑one Leadership Principle to rule them all. When in doubt, demonstrate Customer Obsession. If you get a curveball, give an answer that shows you’re deeply committed to making things customers love.\n“If you have a bad LP round, or if LPs are problematic in the debrief, it’s almost always a ‘no hire.’ But if you have great LPs then there is a conversation where we try to see if the candidate can be hired even if the technical rounds weren't at the bar. But not the other way around. But if there’s anything ‘at the bar’ or ‘below the bar’ for LP, then you fail.”\n“If a candidate does not do that well on the technical round but they do well on LPs, there is always a possibility of recycling the candidate because they’re a good fit for Amazon but not good for the team. So sometimes we’ll help them interview with other teams, and they don’t have to do a full onsite: they just need to do 1-2 more rounds as a follow up. But if they’re below the bar for LPs, then they’re not a fit for Amazon so Amazon wouldn’t help set them up to other teams with shortened onsites.”\nIn this round, expect questions from all 5 of these categories:\nHonestly, the best place to find a detailed question list for Amazon’s behavioral interview, as well as a bunch of other interview preparation resources, is our Senior Engineer's Guide to the Amazon Leadership Principles Interview.\nSystem design and coding aren’t the be-all and end-all at Amazon – of course, you still have to pass them, but if your performance is borderline, doing well on behavioral Leadership Principles questions will take you over the finish line. In fact, interviewers will likely ask you 1-2 Leadership Principles questions in your system design interviews. Try to be efficient when answering LP questions in system design rounds. LPs come first. Finish them early so that you have more time for the technical question.\n“In many debriefs, I hear the hiring manager say that we can extend the L5 offer with the understanding that system design is not their strength, but it's coachable. At the L6 level, the system design bar is comparable to Facebook or Google.”\nIf you’re in a system design round at Amazon, and you don’t know what to talk about, talk about performance. They want Amazon to be the number one customer of AWS. And they love to find engineers who understand and are passionate about fine tuning performance in the cloud.\nAmazon is more likely to ask you practical system design questions. For example, if you’re interviewing with a team who controls Amazon’s inventory management, they might ask you to design a piece of an inventory management system.\nOther common system design questions include:\nThe design questions are most likely about designing well-known features, as opposed to a complete system from scratch like Design Facebook or Twitter.\nAmazon interviewers are allowed to ask whatever they want in system design, but a lot of interviewers fall back on reusing questions from Amazon’s question bank.\nFor tooling in system design interviews, candidates can usually choose any type of drawing tool. Excalidraw is most popular, followed by Miro.\nAmazon has one of the more well-structured decision-making processes in tech: teams typically do a pre-brief (live meeting before the onsite), submit asynchronous feedback, and also do a debrief (live meeting after the onsite). They rely heavily on live discussion to make decisions. Notably, though some interviewers might be able to tell an outlier story of a time a regular interviewer out-argued a Bar Raiser, most of the time the interviewers go along with what the Bar Raiser says.\nAmazon interviewer’s grade on a 5-point scale: Strongly Inclined, Inclined, Neutral, Not Inclined, Strongly Not Inclined.\nThe two most important interviewers at the onsite are the Bar Raiser and the hiring manager. At Amazon, all of the other team members involved in the interview could vote to hire, but if the Bar Raiser or the hiring manager aren’t on board, that candidate is likely getting rejected.\nAt Amazon, identify the Bar Raiser (the only person whose work has nothing to do with the team for which you’re interviewing) and the hiring manager (if you don’t know who it is, ask the recruiter before the onsite or an interviewer if during the onsite). Most of your energy should go towards impressing these two people – since Amazon relies so heavily on live discussions to make hiring decisions, impression management is more impactful here.\nWe’ve aggregated a bunch of useful Amazon content for you! We have replays of candidates doing mock interviews with Amazon interviewers, long-form solutions to common Amazon questions, and deep dives into technical topics that tend to come up in Amazon interviews.\nBelow are a series of mock interview replays, conducted by Amazon interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Amazon ask on our platform as well as sample answers. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Amazon interviews, we did two things. First, we spoke to a bunch of Amazon interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Amazon. Based on all of the above, here are the technical topics you’re likely to encounter:\nWant to know if you’re ready to interview at Amazon? Do anonymous mock interviews with real Amazon interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/amazon",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Google Interviews + Questions",
      "content": "Google’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Google? Do anonymous mock interviews with real Google interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Google’s job interview process, evaluation criteria, and interviewers.\nAll human organizations behave like a metaphor; Google isn’t a sports team, or a family, or an army. It’s a cool grad school. Larry and Sergey set up their offices based on the model of a Stanford campus on purpose. They wanted to create an environment and company culture where people can feel chill enough to talk about anything. In general, Google interviewers tend to be more collaborative than other FAANG interviewers. At Google, the slower you go, the faster you get there.\nGoogle has one big, centralized interview process that’s completely divorced from which team you might end up on, which means that you will NOT, however, be interviewing with your future team members – Google has a horde of interchangeable technical interviewers who have all been trained on the same process. If you do well, there will be a team matching component at the end.\nAt Google, because the process is centralized, you cannot interview with multiple teams concurrently, which means you don’t get multiple shots on goal. Not only that, but Google has a limit for how many chances they’ll give you before you’re blocked from interviewing again.\n“You can interview three times in 5 years. If you fail all three times then you can’t interview at Google again: you’re blocked.”\nNote that recently, there have been rumblings of Google changing their process to something more decentralized, where a hiring manager chooses you for a team before you interview, nullifying the need for post-onsite team matching. As far as we know, this new model is being tried out right now, but the change hasn’t been adopted company-wide.\nGoogle also has rules for candidates who pass their interviews:\n“If you pass Google’s onsite, and end up not taking the offer, your “passing of the onsite '' is good for about a year. And if you choose to re-engage in that time, the process varies widely. Usually you can skip the phone interview. Most times you have to do the full or partial onsite. If you choose to re-engage, tell their recruiters ‘I already passed the onsite’ and push to get as many steps skipped as you can.”\nGoogle is not results-oriented. They’re process oriented. In other words, they care more about the “How” than the “What”. You’ve heard it before, and it’s true – they don’t need you to get to the optimal solution, but they do need to be impressed by your thought process. Because of this, Google is more attracted to comfort with ambiguity than speed.\nOddly, in spite of using a centralized interview process, Google doesn’t have in-depth training for its interviewers; it may surprise some candidates that there’s a larger-than-expected number of bad interviewers at Google.\n“There is one thing that always bothered me about the Google interview process. And it's something that a lot of candidates don’t realize. There are a lot of bad interviewers at Google. Mostly because there are a lot of highly talented people who think they know everything.\nI was the interviewer for the third interview round at in-person onsite. And I saw the candidate was there by himself; the second interviewer wasn’t there. The candidate was alone because the second interviewer got frustrated – they thought the candidate wasn’t worth the time for an onsite, so they left early.”\n“Google is more likely than Facebook to design questions on purpose to be tricky. At Google, sometimes this is intentionally disguising technical questions to look like X but they’re really Y. And other times at Google, it’s designing a technical question such that if a candidate doesn’t ask a particular question they likely won’t get the answer.”\nPlease see the section above called “A note about recruiter calls”\nGoogle’s technical phone screen is a coding interview that focuses exclusively on data structures and algorithms questions. Your interviewer will ask you to write code to solve a specific problem.\nOne idiosyncratic aspect of Google’s process is their insistence on using Google docs for writing code (versus other companies which tend to use tools like CoderPad). This can be a bit jarring for those of us who are used to writing code in an IDE that does things like auto-indentation, auto-complete, syntax highlighting, adding missing parentheses or brackets etc. Despite not using an IDE, your interviewer will expect you to produce syntactically correct code. This is really hard.\nBefore your Google interview, you should practice in Google docs so you don’t forget to close parentheses or indent your code.\nThat said, more recently, Google has started interviewing using an internal tool with syntax highlighting, indentation and brackets completion. Whether you get to use it or not depends on your geography.\nThe second phone screen happens only if the first one did not produce enough signal to move forward. Perhaps you didn’t communicate your thought process well enough, your code wasn’t of good enough quality, or you weren’t fast enough – but it’ll be only one of these – if you struggled with two or all three, most likely you aren’t moving forward.\nIf you do get scheduled for a second phone screen, push your recruiter to give you detailed feedback so you can do better the second time – nothing beats knowing exactly where you need to improve. You probably won’t get a response, but if you do it’s a large boost to your prep.\nIf you get a second phone screen it will be very similar to the first in terms of structure and content.\nThe Google onsite usually includes 4-6 rounds. Recently, there have been some internal experiments with the format, but generally the rounds are primarily coding, and secondarily system design. Some candidates get a single behavioral round, and others get to skip it.\nThe more experience you have, the higher proportion of system design and domain-specific questions you can expect to be asked.\nAs we mentioned above, Google is process-oriented rather than results-oriented. As such, communication during coding and system design rounds is more important at Google than the end result.\nThe most important rounds at Google are coding. In fact, Google is the only FAANG company that considers coding to be more important than system design. Google’s coding rounds are about complexity more than speed. Their interviewers are allowed to ask anything they want, so it's more likely you might get a question you’ve never practiced before.\nGoogle interviewers are more likely than any other FAANG company to purposefully design a question so it tricks candidates. For example, they’ll disguise a question to look like it’s Three Sum, but that’s a red herring – it’s not a Three Sum problem. It just looks like one.\nA lot of what you’ll see in the onsite coding mirrors what you saw in the technical phone screen. During the onsite, you may see your interviewer layer more complexity on top of questions – they’ll design a question where they plan for you to get to the solution, then when you do they’ll move the goalposts and say something like: “Remember that assumption we made earlier about [X thing]? Let’s remove that. How would that change your approach?”\n“At Google, I’ve passed more people that arrive at the optimal solution without coding it than I do people who arrive at the optimal solution and code it. The actual code you write is less important than the thought process.”\n“Google is highly unstructured. Everyone can ask whatever they want.”\nEven though they can ask whatever they want, Google interviewers have a question bank too, but the bank is much much bigger than Facebook’s bank and, like Facebook’s bank, it’s community maintained. Some interviewers never deviate from the bank, and others don’t touch it, preferring instead to formulate their own unique questions..\nThis speaks to Google rewarding the “how” (aka “how a candidate got there”) or their thought processes. It also speaks to Google rewarding comfort with ambiguity. Other FAANGs have specific niche topics they love hearing and talking about (such as “performance” at Amazon), but Google is more abstract. Google might love speaking about and asking about ambiguity more than any other FAANG.\nFinally, Google’s coding questions are never practical. They are always theoretical. They will never ask you to pull up your own environment and write a program. They will also never ask you to take a solution to a coding problem and apply it to a real world scenario. When prepping for Google, only practice theoretical questions.\nFor everything you need to prepare for Google’s coding interview, check out the section called \"Google coding interview preparation resources\" below.\nThe second most important onsite interview type at Google is system design. Again, they are allowed to ask anything they want, so don’t be scared off if you get a question you’ve never practiced before.\nHigh-level and low-level system design questions are both likely. Some examples include:\nGoogle system design interviewers also tend to design problems that include linchpin questions. These are questions where if you don’t ask about a specific aspect of the problem, you can’t really solve it. For example, an older system design question at Google asked you to set up a service in some foreign country, and in the prompt, the interviewer mentioned that you have a dependency on some third party service.\nThe linchpin question to ask: “What’s the service level agreement for that 3rd party service?” If you didn’t ask that (or something like it), then you wouldn’t be able to effectively reason about availability, which you’d need to do in order to do well on the question.\nTo avoid getting tricked, ask even more questions in Google system design rounds than you normally would.\nThe least important round at Google is the behavioral round. They have the easiest behavioral screen in FAANG. Plus, you might complete an onsite at Google without a behavioral round because they’re optional. It’s not clear which candidates get them and which don’t. This is another reason to not prep too hard for their behavioral round.\nIf you do get some behavioral questions, they might be one of the following:\nGoogle is also more likely to ask you reflective questions. Most other FAANGs stick to situational questions such as, “Tell me of a time when…”. Those situational questions ask you to describe a past circumstance or scenario you’ve actually experienced and are fairly straightforward to answer. Reflective questions, on the other hand, can be tricky because they’re asking you to reflect on, or speak to, something less concrete, e.g., “What do you think about setting goals?”\nThe smart way to answer a reflective question is to re-formulate it, and then answer as if it’s a situational question. So, “What do you think about setting goals” instead becomes,”Talk about a time you used goal-setting as a time management strategy”, which you can now more-easily answer by describing a real experience and outcome, “The last time I set goals…etc”, as opposed to wading into theories about personal agency. “I think goals are cool and important…” might not get high marks.\n“To be honest, there was some cultural backlash at Google when they announced that we had to do these behavioral interviews. What that means is you may get an interviewer who has very little interest in conducting this type of interview. Which could go very good or very bad. I have some peers who think this should not be a part of the interview process. So they give everyone the highest marks, pretty much just to eliminate this category from the interview. Google is primarily engineers, and most of the engineers think that this is a bunch of HR BS. So they either just won’t accept any calendar invites they get or they'll just check the boxes.”\nMost of the time, the post-interview feedback process at Google is completely asynchronous, and interviewers don’t meet live to discuss hiring decisions. That’s one reason why interviewing at Google isn’t like interviewing with humans: it’s more akin to interviewing with a machine.\nEach interviewer rates candidates on the following seven-point scale: Strong No-Hire, No Hire, Leaning No-Hire, On The Fence, Leaning Hire, Hire, and Strong Hire.\nHow this affects candidates is simple: a Strong Hire can get you an offer, but it can also buy you a second chance. If you don’t get an offer, but you get a Strong Hire from one of your interviewers, you might be offered one bonus interview round to decide whether you get an offer or not.\nThat said, you don’t need to get a “Strong Hire” to get a second chance. Overall, if you showed enough signal to not-fail but not enough to pass, sometimes they will ask you to do an additional round.\nIf you get lucky enough to get a round where you are really excelling, don’t quit while you’re ahead. Keep going. In that round, don’t just strive to win; strive for total domination.\nA “Strong No-Hire” bars you from interviewing at Google for some time. Reports vary here, but one of our Google interviewers told us that if you get a Strong No-Hire, you might be frozen out for several years.\nIf you passed overall then you will move on to the hiring committee phase.\nGoogle’s hiring committee consists of four to five engineers and engineering managers who have not interviewed you, with the intent of making hiring decisions as objective as possible.\nGoing into the hiring committee review, your recruiter will prepare a packet that consists of your resume, any notes from the person who referred you (if you were referred), your recruiter’s notes from their call with you, and all the feedback from your interviewers, from the technical phone screen to the onsite.\nIf you’re told you’ve passed the onsite, ask if you can submit a more recent copy of your resume. Some Google recruiters will let your new resume be the only resume the Hiring Committee sees. Your resume you submitted for the online application probably wasn’t customized for Google, but what you submit to the hiring committee can be.\nWhen the committee meets, they evaluate all the data on you holistically, and they need a consensus in order to decide to make a hire.\nOther than hire/no-hire decisions, the hiring committee will also decide on leveling. Ever since COVID and the rise of remote interviewing, we’ve gotten more and more reports from users that they’re being down-leveled at Google. Apparently the rationale is that Google doesn’t feel like they get as much signal from remote interviews as they did from in-person ones, and as such, when they don’t get enough of a signal for a hire but too much good signal for a rejection: they downlevel – when you want to reduce the probability of a false positives for L5… offer L4!\nEngineers who are downleveled at Google accept the lower level offer a lot of the time, especially in the current climate. In some extreme cases, we’ve seen engineering managers with 10+ YoE accept an L3 (basically a new grad) offer.\nOnce you get past the hiring committee, you will move on to team matching. The team matching process is a bit like speed dating. In the ideal case, your recruiter will propose a few teams that are actively looking for someone with your skills, and then you’ll meet with the hiring manager from each team to gauge cultural fit and chemistry. In order to move forward, both of you have to opt in.\nThat said, there are rare instances where a candidate will get past the hiring committee but then not find a team that they gel with.\n“Getting five scores of ‘Leaning Hire’ is most likely to result in a ‘No Hire’ decision. I have seen many cases where the candidates got five scores of ‘Leaning Hire’, and the recruiter gave them positive feedback too, but the candidate got rejected. In these cases, every person the candidate dealt with directly (the interviewers) were positive, yet the hiring committee (the only people in the process who dealt with the candidate indirectly) rejected the candidate.”\nHere are some tips for preparing for your Google coding interview:\nIn addition, we’ve aggregated a bunch of useful Google content for you! We have replays of candidates doing mock interviews with Google interviewers, long-form solutions to common Google questions, and deep dives into technical topics that tend to come up in Google interviews.\nBelow are a series of mock interview replays, conducted by Google interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Google ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Google interviews, we did two things. First, we spoke to a bunch of Google interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Google. Based on all of the above, here are the technical topics you’re likely to encounter:\nWant to know if you’re ready to interview at Google? Do anonymous mock interviews with real Google interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/google",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Meta Interviews + Questions",
      "content": "Before you interview with Meta, read our guide on negotiating with them. They’ve gotten very aggressive, and if you don’t know the rules, you will fail.\nMeta’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Meta? Do anonymous mock interviews with real Meta interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Meta’s hiring process, evaluation criteria, and interviewers.\nMeta interviewers are guided by the company’s current motto: move fast. All human groups have a metaphor they operate from. Meta isn’t a family or an army. They’re a well-structured Formula 1 team; they spend a lot of effort to put safeguards in place, and then they go pedal to the metal. At Meta, speed wins.\nAt Meta, because the process is centralized, you cannot interview with multiple teams concurrently like you can at some other tech companies. You get one shot on goal every ~3 to 6 months, depending on performance.\n“If you pass Meta’s onsite, but don’t take the offer your status of ‘passed onsite’ is valid for a year. If you don’t take their offer and then choose to re-engage within that year, tell their recruiter ‘I already passed the onsite’ and push to get steps skipped because you usually can.”\nWhen interviewing at Meta, listen closely to the subtle clues and hints your interviewer gives you. Meta is the only FAANG where you can’t become an interviewer unless you give good hints.\nPlease see the previous section called “A note about recruiter calls”. Also read our guide to negotiating with Meta. It starts at the recruiter call.\nMeta's technical phone screen is a 45-minute coding interview that focuses on data structures and algorithms.\nAt the beginning of the interview, your interviewer will ask you a question or two about your resume and recent work that you've done. This portion will take 5 minutes, and how you answer these questions doesn't meaningfully factor into the interview's outcome - they are just meant to break the ice and get you talking. The part that matters is the technical portion.\nAfter the intro portion, your interviewer will ask you two coding questions, and they expect you to get through both in 35 minutes. These questions will be LeetCode easy or medium difficulty.\nMeta’s technical phone screens are conducted in CoderPad. If you've never used it, you may want to play around in their sandbox and get familiar with their environment before your real interview. One specific thing about Meta's way of using CoderPad is that during the interview, they'll have code execution turned off - if you've used it before and are accustomed to testing your code during the interview by running it, you'll need to practice not being able to.\nThe typical Meta onsite will consist of the following:\nThe process for E6 engineers, as outlined in the diagram above, is slightly different. There will be a Leadership Assessment interview after the Technical Screen. In this interview, the following topics might be covered:\nThe onsite for E6 engineers will also be different. You should only get one coding round, one architecture round, one design round and then a behavioral round.\nThere are four main types of interviews you’re going to encounter when you apply for an engineering job at Meta – coding interviews, behavioral interviews, and either a system design or product design interview. Here’s what to expect during each of these rounds of interviews.\nMeta's process is highly standardized, so coding interview questions and themes tend to repeat. Coding questions are pre-approved, but that doesn’t mean the interviewers have no freedom.\n“Meta gives you the questions to ask or modify. But they don't tell you the answers in their interviewing wiki. And they let you design the path of the question: you get to ask your own twists and turns.”\n“There’s some variance with the interviewer, but usually there are 20 mins per question, and the questions are simple. They want you to get the algorithm fast, and implement the basic solution. The kind of bugs that can be acceptable are empty input, and out of scope inputs like empty array/null. But an incomplete algorithm at Meta usually doesn’t cut it. They want you to get to it and get to it quickly, and you can sacrifice making a little bit of a mess along the way.”\n“I think there is a rule that during the programming interview, interviewers have to ask two questions. And the questions have to be balanced. The first is more like a juicy question testing problem solving skills and you as the interviewer can permit some bugs in the implementation. The second will be easy from the algorithmic point of view but the goal is to assess how much the candidate can write debugless code and test this code perfectly. And if a candidate fails to solve both problems, even if they somewhat shine during one problem: it will be ‘No Hire’.”\nIt's not that bugs are encouraged, it’s that they're the only company that's top-down directive is: sometimes, in certain rounds, bugs are okay. No other company does that. Meta relaxes the need for bug-free code so that candidates can code faster.\nFinally, Meta doesn’t ask dynamic programming questions and, in fact, those questions are banned.\nFor everything you need to prepare for Meta’s coding interview, check out the section called \"Meta coding interview preparation resources\" below.\nMeta hires two types (on paper) of backend engineers: System Generalists and Product Generalists. System generalists get a system design interview, and product generalists get the confusingly named product design interview (in most other contexts, product design refers to UI/UX).\nWhich of these interviews you get is determined by your recruiter, based on your experience. If you have worked on a lot of product features, then you get a product design interview. If you have worked on high-scale distributed systems, then you get system design.\nThe product design interview at Meta is similar to the system design interview but with some key differences:\nTake a look at this video, by Meta, about the difference between these two interview types:\n“Product design is less databases, more data flow, more time spent on details of the API (e.g. parameters that will pass). System design is more databases, less API details, and more about scaling.”\n“Many people think Meta only asks high level system design questions like ‘Design Twitter’ or ‘Design Meta Feed.’ But that’s not the case. They also ask low level questions. In E6 or above interviews, you will most likely be asked ‘Design Redis’, or ‘Design Kafka’, or ‘Design Memcached.’ I’d even seen rare occasions where E5 candidates would be asked low-level system design questions; low-level questions are less common in rounds for E5 and below.”\n“You have to ask about back of the envelope estimations. A lot of senior engineers hate to do that. I hate to do that as well. It’s a waste of time. When I do the ‘There is a rule that I have to do this. But there is no point in doing this. Let’s spend 5 minutes talking about real system design. Let’s assume we have to scale our system from 0 to Google level and therefore estimations are just a waste of time.’”\nAsk your interviewer: “Do you want to spend a few minutes on estimations? I’m okay with skipping it, but if you need to see it, then let’s do it. If we skipped it, one thing that might be a more interesting conversation would be spending a few minutes on how to scale this system.’”\nIf you don’t know what to talk about in a E5 Meta system design round, talk about user experience. Go on about two choices you could make, then explain in depth the one preferred because it’d be a better user experience.\nIt’s also common for Meta interviewers to ask you to walk them through a system you’ve worked on in the past, which is known as a reverse system design interview.\nUnlike technical questions, behavioral questions at Meta are not standardized: interviewers can ask you whatever they want. Behavioral rounds are of medium/low importance at Meta; they’re less important than technical interview rounds, but they do carry some weight. For the best summary of what to expect in a Meta behavioral interview, read this blog post by a former Meta engineering manager – in it he describes exactly how behavioral interviews at Meta are evaluated and also includes a bunch of sample questions.\nHere is a list of questions to get you started. Read the post to get examples of good answers (split out by the candidate’s seniority level!)\nFinally, if you are applying for E5 and above make sure to have a couple of projects that lasted longer than one quarter – if all your examples are of smaller initiatives, your interviewer may walk away with the impression that you can’t handle complex projects. Also, remember to quantify the impact that you made by sharing specific metrics.\nMeta’s candidate review and feedback process is usually completely asynchronous. Sometimes, they’ll do a live debrief but it’s rare. This means there’s a low likelihood for an interviewer to “fight” for a candidate. Socially influencing interviewers won’t go very far here.\nMeta is also the only FAANG that asks interviewers for a confidence score when filling out post-onsite feedback forms. As a result, the process at Meta can be more forgiving on failed rounds because a lower confidence score means a failed round carries less weight. Also, Meta is the only FAANG that directly asks interviewers about downleveling.\n“Coding is used to decide ‘Should we hire this person?’ System and product design is used to decide ‘How should we level this person?’\nFor coding interviews, the interviewer says a binary score first: ‘Hire’ or ‘No Hire’. Then in the comments, they say how confident they are in that binary score. The ‘Hire’ or ‘No Hire’ is an official metric, but the confidence score is not.\nFor system/product design, the interviewer gives the ‘Hire’ or ‘No Hire’ first. Then they say if the candidate should be considered for another level.\nSo the final decision could be like: ‘No Hire’ for E5 with low confidence. ‘Hire’ for E4 with high confidence.\"\nIn cases where the hiring panel is hung, it’s possible they may request one more follow-up interview to help them get more signal.\n“Interview feedback is discussed primarily by the system design and behavioral interviewers, and those are the interviewers who have the most say regarding both the hire decision and a candidate’s level. If interviewers don’t feel like they got enough signal and the candidate ends up being on the fence, the recruiter will push for an additional round. Indicative hint: If you have an additional follow-up interview, your interviewers were probably split.\"\n“At Staff level and above, it’s a mandate that candidates can’t get hired if they don’t pass both system design rounds.”\n“For E6 and above candidates, if you fail one system design round but do well in the other rounds, you can get a mulligan. They can let you retake one system design round. But the same isn’t true for behavioral: if you fail there’s no mulligan. If you fail the behavioral round, it will be ‘No Hire.’”\nMeta made some changes to their process in 2023. Before, unlike at other FAANGs, you'd generally accept an offer before knowing with which team you'd end up on. Then you'd do a 6 week “Bootcamp”, where you'd be trained on Meta's engineering infrastructure and systems. After the bootcamp, there would be a 2 week team-matching period.\nNow, after you finish the onsite, you jump straight to the team matching process. Team matching now happens BEFORE you get an offer, and offers are contingent on team matching completely successfully.\nYou'll talk with hiring managers from a number of teams to gauge fit and chemistry: we've heard that sometimes it's a handful, and sometimes it's over 10.\nAfter your team matching conversations, your recruiter will ask you to choose a team. In order to move forward, both you and the hiring manager have to opt in.\nOnce you make your choice, your recruiter will officially make an offer, and you'll usually have just a few days to make your decision. We hope this will change in the future, but recently Meta has been very aggressive with both offer timelines and with negotiations - they will not negotiate unless you can share competitive offer details from another top-tier company.\nOne other key difference between Meta's new process and the old one is what happens during Bootcamp. Historically, Bootcamp took 6 weeks, and in addition to training new hires on Meta's engineering infrastructure and systems, there'd be a multi-week “speed dating”-esque team matching component.\nBootcamp still exists, but now it's much shorter - 2-4 weeks, and the focus is getting new engineers ramped up on generic tools. After that, new engineers will continue to ramp up on their specific teams.\nThe team matching process is a bit like speed dating. You meet with hiring managers to gauge fit and chemistry. In order to move forward, both of you have to opt in.\n“When the market is good, you can talk to 20 different teams at the same time.”\nThere are exceptions – some people with niche skills may get hired for a specific team before they start Bootcamp, but they still have to do the bootcamp period, just not the team-matching part afterwards.\nWe’ve aggregated a bunch of useful Meta content for you! We have replays of candidates doing mock interviews with Meta interviewers, long-form solutions to common Meta questions, and deep dives into technical topics that tend to come up in Meta interviews.\nBelow are a series of mock interview replays, conducted by Meta interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Meta ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics might come up in your Meta interviews, we did a few things. First, we spoke to a bunch of Meta interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data, the LeetCode question list above, AND our own data-set of mock interviews in the style of Meta. Based on all of the above, here are the technical topics you’re likely to encounter.\nThe following interview guides and resources can help you better understand Meta’s recruitment process and support your interview prep so you impress the hiring committee.\nWant to know if you’re ready to interview at Meta? Do anonymous mock interviews with real Meta interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/meta-facebook",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Apple Interviews + Questions",
      "content": "Apple’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Apple? Do anonymous mock interviews with real Apple interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Apple’s hiring process, evaluation criteria, and interview experience.\nHumans in groups act out a chosen metaphor; Apple isn’t a sports team. They’re an army. Their army is made up of people obsessed with making great products. And they look to hire people who’ve embedded Apple products into their lives. Armies reward loyalty more than sports teams. Apple also has the longest tenured employees in FAANG (we're including Microsoft with FAANG for the purposes of this guide).\nApple is decentralized and lets candidates interview with different teams concurrently; if you want to maximize your odds interview with as many teams as you have the appetite for.\n“I interviewed with like 12 teams. I got 2 offers. Along the way, I told one of the Apple recruiter’s I was interviewing for another Apple team and they shrugged it off; they didn’t care.”\nApple’s interview process is more like what you might see at a startup than any other FAANG – from assigning which questions to ask to interviewer training to how hiring decisions get made. Significant inter-team variance is the norm, with each team essentially acting like a startup that’s coming up with its own way of conducting interviews.\nAt Apple, there’s no formal interviewer training. It’s very ad hoc. Every team is different. There is literally no process. What each of the teams does is rely on one of their very senior engineers or someone very experienced. Apple has a lot of people with long tenures, like 15 years. One of my colleagues had been there for 22 years. At Apple, the more senior you get the more the team trusts you to come up with your own questions. So what the interviewers at Apple typically do: you come up with a question that's not online, and you make sure it’s relevant to what your team is doing. Then you pitch it to your manager or tech lead. Then you run with it.\n“One thing not enough candidates know about is this: there’s no such thing as an Apple interview. You apply for a team. Not the company. When people ask me “How to prepare for an Apple interview?” I say ask the recruiter. Because they usually know what types of questions are asked. The recruiter spends 30 minutes or an hour per debrief where engineers are talking about the details about the code. So if the recruiter is paying attention or is at least a little bit technical, they should have a clue whether it’s LeetCode-style questions or embedded style questions. So ask your Apple recruiter a forced-choice question like, ‘Is this interview more X or more Y?’”\n“I was one of the people to come up with a take-home assignment for candidates. Which was my favorite part of the process at Apple. We were hiring people for full-stack but not just any full-stack – we wanted people who were coding in Python on the back-end and a particular framework on the front-end. We cooked up a take-home which was a scaled down version of what they’d be doing on the job: an internal tool built in those exact technologies. We gave them that take home and had them work on it for a week. Then we discussed it at the onsite where we’d live-debug it and talk about architecture. I really liked this ‘Try before you buy’ style process. Because Apple really wants you to be productive in week 2, if not at the end of week 1.”\nApple is the most likely to shock you; they’re more likely to ask you something you didn’t prepare for. Out of all the FAANGs, they’re the ones you can expect to do something unexpected, and some of their tactics can seem mercenary. Apple is the only FAANG which sometimes has a process to cut interviews short if the candidate clearly isn’t meeting the bar – if you don't perform above the bar for the first half of the interview, they’ll cancel the rest.\n“If by the fourth round, the hiring manager has gotten consistent feedback that doesn’t meet the bar, then they’d end the onsite early and reject the candidate.”\nApple is not results or process oriented. They’re motivation oriented. In other words, they care more about the “Why” than the “What” or the “How”, and as such, they value behavioral interviews more than coding.\nApple employees are obsessed with privacy. It’s not just marketing lip service. When asked if “privacy” is a buzzword at Apple, our interviewers said…\n“Privacy isn't just a buzzword. We are obsessed with it. To drive that part home. Because it’s so important. And as I mentioned, I was a part of a group focused on gathering user data - users here being Apple internal employees – to inform future products.\nEven at Apple, when we’re just getting data from internal employees, we anonymized the data. Just to practice what we preach. Privacy is huge. Another example to illustrate that is that people get fired for torrenting music.”\n“Unless you’re interviewing for a security role, very rarely. Technical people at Apple are hired to do what they do best. They have a whole army of compliance folks and lawyers to take care of that stuff. They also have an internal police force called “InfoSec”, which is the team which takes care of the secrecy stuff. Engineers are needed to do what they were hired to do: engineering.”\nPlease see the section above called “A note about recruiter calls” for what to expect. We do encourage you to ask your recruiter what to expect for the rest of the process because as you’ll see, there is a lot of variance from team to team.\n“Ask your Apple recruiter forced choice questions with two options, such as, ‘Is this coding round more of a typical LeetCode round, or more of a domain-specific open ended deep dive into a specific technology?’”\nLike everything else at Apple, the format and technical questions presented in Apple phone screens can vary a ton. Verify this by asking your recruiter!\nTechnical phone screens are coding interviews that range from 30 minutes to an hour. This tech interview may be between you and a single interviewer or sometimes a panel of interviewers. It may even be a hiring manager screen with a mix of behavioral questions and coding.\nIn any case, the general format is a shared coding environment where the interviewer(s) can assess your ability to utilize basic data structures and algorithms concepts. Being able to provide a solution for coding questions and quickly analyze the runtime complexity of your solution are key skills to have going into this interview.\nThe tooling used in Apple’s technical interview rounds depends on the team you’re interviewing with, but we’ve heard that some teams use CoderPad.\nSome teams give candidates a take-home assignment. They can give this around the same time they schedule a phone screen. The hiring manager is usually the person to decide whether or not candidates get one.\nThere will be roughly six to eight in-person rounds of interviews, each of which will be with your future teammates. Each round will have least one, or possibly two, interviewers.\nNote that an onsite loop with one team at Apple will look very different than an onsite loop with another.\nInterviewers can ask whatever behavioral, coding, or system design questions they want; there is no standardization for Apple interview questions. However, before an interview loop takes place, some teams will do a quick, informal assignment of what kinds of questions each interviewer is supposed to ask so that they don’t all end up asking the same things.\nMoreover, Apple interviewers are untrained, and as soon as a senior engineer is hired they can start conducting interviews.\nApple’s unpredictable nature makes it so some of their interview rounds can’t be categorized into behavioral, coding, or system design. Is a philosophical question about products a behavioral question? Not really. But they might ask one in a behavioral round. Are rapid fire infrastructure-focused open-ended trivia questions more system design or coding? It depends.\nFor example, here’s how one Apple interviewer describes the behind-the-scenes top-down directive before an upcoming onsite. “Go find a question that would be a good one to ask for our team.” That interviewer then ran it up the chain to an engineer above them. Then, that question immediately got asked in the next interview.\nAt Apple, each interview loop is specific to the needs of individual hiring managers – there is no canonical “Apple interview”, and everything is “made to order” for each specific team. That makes it difficult for candidates to prepare.\nSome teams at Apple prefer practical rounds. Sometimes, they’ll have you write a program on your own laptop and IDE. Other times, they’ll spend the whole round deep diving into a specific technology/use case that’s relevant for their team. For example, a team that wrote in Java and did a lot of work with concurrency had a whole round focused on concurrency in Java!\nOther teams do medium-ish LeetCode-style questions.\nAt the end of the day, these interviews vary so widely it’s hard to give a specific directive, other than: ask your recruiter. For senior and above candidates, it’s more about demonstrating competence rather than needing to ace the question.\nFor everything you need to prepare for Apple’s coding interview, check out the section called \"Apple coding interview preparation resources\" below.\nApple interviewers tend to ask questions relevant to a specific team’s work. For instance, a team focused on building web services will tend to ask questions about that, while front-end teams may ask UI-related questions. It may be good to try to get a feel for the day-to-day work from the recruiter/hiring manager, as the job descriptions are not always the most helpful (remember: privacy!).\nIn system design rounds, Apple interviewers love to hear about reliability. If you don’t know what else to talk about, dig into reliability.\nApple’s most important round is usually behavioral or system design. Behavioral rounds are more important than coding rounds.\n“In behavioral, you gotta be a rockstar. You gotta be a leader. If you’re abrasive, or if you’re not a cultural fit, how are you going to lead the juniors? And system design is going to weigh a little more than behavioral. If you can’t code or if you’re a little rusty –if you’re good at system design and behavioral–we’ll forgive the subpar coding rounds.”\nAn interesting paradox at Apple is: they highly value behavioral rounds but they don’t have a standardized way to assess candidates in those interviews\n“Towards the end of my career at Apple, we had a huge need for mobile developers. People who were able to do iOS apps. I was part of an R&D team. We mainly built web products in the beginning, but towards the end of my career we started doing more mobile stuff. We didn't want to hire someone who could only do mobile. We wanted someone who would be half as good at mobile stuff and half as good at web stuff, so they could plug themselves in anywhere.\nIf the interview process was standardized across the whole company - you can imagine how hard that would be to test specifically for the niche skill set we needed. Within two days we cooked up a whole new homework assignment just for the ios candidates, we cooked up a whole new set of interview questions. We kept the behavioral part the same. But the technical part - we flipped it over just like that. And it was really good. We changed the way we graded, we were able to filter candidates based on the new set of questions. It was just fast. We didn't get any pushback from HR. We didn't have to work with compliance. We just did it. Really fast. Really nimble.”\nBecause Apple doesn’t standardize their interviews, they’re particularly prone to bias. Sometimes the top down guidance to Apple interviewers is something like: “In the behavioral round, just see if you like them. See if you’d like to get a beer with them.”\n“[Interviews are never standardized.] And i’ll tell you why. Apple is a very secretive company. Everything is on a need to know basis. Also, it's a hugely political place. It was good for me because I understood the game. I didn’t blame the players I played the game. For those who understand the intricacies of politics, and simply accept the fact that it will happen when you have all Type-A people being paid a tremendous amount of money to do shitty little things, it's bound to happen. You have to accept it or you’re not going to play the game. Everything at Apple is very siloed. Even when it comes down to the cost center. Everything is super independent of one another. That's actually one of the strengths and weaknesses of Apple. We double effort for sure. But that doesn't matter to Tim Cook. They have billions of dollars to afford this – not a problem. I also really liked how it was siloed because teams and their priorities change, leadership changes, a lot of things change. Being able to decouple from the greater company enabled them to become one of the biggest, if not the biggest tech company in the world.”\nEven if rounds aren’t standardized, you will definitely be asked “Why Apple?”, and your answer needs to be on point. Some interviewers reject candidates solely for not having a good answer to this question. “Why Apple?” isn’t always a single question; they can spread this out into multiple questions and drill down on this for a good portion of a behavioral round. You can also expect other motivation-based (or “why”) questions.\n“A common red flag is giving generic answers to the ‘Why Apple?’ questions. If I didn't feel their passion or if they’re just treating Apple as another job, that’s usually a red flag for me regardless of their technical competence. They really have to somehow convince me – and this is an emotional response they have to bring out of me – they really have to convince me they really want to work at Apple, they really want to roll up their sleeves, and they really believe in our values: delighting the customer, sweating the details. Making awesome products… We only care about that. We don't care about anything else. That emotional response has to be drawn from me and if they don’t then I’m likely to say, ‘They were good but meh.’”\n“I can tell you about a great answer one candidate had for ‘Why Apple?”. He said something like… His wife and him were university students dating across two continents. This person said they shared a recent feature – I think it was like when you facetime and you can watch video in sync – he shared how that changed his life. His wife and him went through the whole international relationship because of that. That significantly helped their relationship.”\nApple wants to hire candidates whose lives have integrated with the Apple products. And the reverse is true too. It's a fatal flaw to say, “I've never used an iPhone or a Macbook or an iPad” because those people clearly haven’t integrated Apple products deeply in their lives.\nApple knows what they like, and they like their products! That doesn’t mean all you have to do is gush about the products to pass the behavioral round. It means you have to tell a genuine story which connects you and Apple products or services. Ideally, a story they will remember.\nAnother behavioral factor debated among Apple interviewers is whether or not they agree with the idea that Apple is “cult-ish.”\n“Apple cares most about the ‘Why’. You see that rooted deeply in every apple person's DNA. ‘Why Apple?’ Right? I guess this is where people get this notion of Apple being a ‘cult-ish’ company. Much like Tesla, actually. They have a huge customer following, but you also see the same pattern with their employees. Actually, I totally subscribe to this ideology. Because you want a person you work with day in and day out to have that same passion. Sometimes you're going to have to work overtime. You're not going to get paid extra for that. Sometimes you're going to work weekends. Sometimes shit’s gonna hit the fan. You don't want to work with someone who whines about it.\nOur theory is that Apple is more likely to reward employees (and candidates) who act like the leader. If you listen to 1:00:36 - 1:02:05 in an interview with Steve Jobs, you’ll see some stark similarities to how Apple interviewers talk about the organization. In this clip, he says, “You know how many committees we have? None. We are organized like a startup.” He then describes the benefits of silos and dividing things up.\nPrivacy and politics are the natural consequence of a place intentionally designed to be siloed and divided up and kept separate. It’s a cost that Apple accepts because the gain is increased productivity. Put people in closed systems (teams and orgs that don’t talk to other teams and orgs) and watch them get more done. This system works like blinders on a racehorse: it keeps vision focused down the track, on the goal, minimizing peripheral distraction. That’s all they need to see and they run/work faster because of it.\nOne final aspect of Apple’s behavioral rounds is that they will ask you specific questions about relevant skills. For example, if a team works with big data, they will ask specifically about a time you have worked with large-scale distributed systems in the context of your answer. If you don’t have direct experience with the field, they will try to get as close as possible, like asking you for what tradeoffs you’ve made when choosing a storage system. These behavioral interview questions serve two purposes: showing you have had relevant experience in the context of what the team is hiring for and trying to get you to talk about a particular behavioral skill (e.g., leadership, conflict resolution).\nAs evidenced by the highest chaos score, Apple doesn’t do many things in hiring consistently, across the whole company. One trend is that Apple teams rely on post-interview live discussions to make hiring decisions. This varies from somewhat informal (compared to the rest of FAANG) to laughably informal.\n“Post-onsite feedback for my org was 100% live discussions. At Apple I never had to write feedback. Which made me do more interviews. We made the decision on the same day. Everyone had to make a decision at the end of the day. Do an onsite, then at 5pm, we gather in a single meeting room, we do on the count of three: thumbs up, down, or in the middle. Then we talk after seeing the thumbs. And try to convince the people on the other side. If there’s less than 5 thumbs-up, then that might be an instant rejection. If there’s 6 or 7 or more thumbs up, the ‘thumbs up’ people try to convince the other side. Or in that same situation, the 3 or 4 thumbs down will try to convince the other side.”\nBecause of the informal decision-making process and reliance on live discussion, managing the impressions of your interviewers is more important at Apple than at other FAANG. In these decision-making meetings, if there’s dissent, they strive for consensus. The people on one side try to convince the other side. This process can last 15-30 minutes on average; all FAANG companies say interviewers fight for candidates, but Apple tends to fight more than most of them.\nBecause of their patterns of live-discussions and striving for consensus, Apple interviewers are more likely to fight for or against you (if your performance was on the fence) than any other FAANG, except maybe Netflix.\nUltimately, the hiring manager for that particular role has the most say, which means that that’s the person you should be working to impress the most.\n“My manager wanted to hire this person. But he failed my interview so badly. I didn't want to argue with my manager but at the same time I didn't want to work with this person. Because we are hiring people we’d work with on a daily basis. So arguments happen a lot. And in this case, I was the only ‘no’ on the board and the candidate got rejected.”\nWe’ve aggregated a bunch of useful Apple content for you! We have replays of candidates doing mock interviews with Apple interviewers, long-form solutions to common Apple questions, and deep dives into technical topics that tend to come up in Apple interviews.\nBelow are a series of mock interview replays, conducted by Apple interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Apple ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Apple interviews, we did two things. First, we spoke to a bunch of Apple interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Apple. Based on all of the above, here are the technical topics you’re likely to encounter:\nFor more in-depth information on Apple and their hiring process, or to learn more about Apple’s company culture, be sure to check out the resources listed below. These documents will help you better prepare for software developer and software engineer interviews.\nWant to know if you’re ready to interview at Apple? Do anonymous mock interviews with real Apple interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/apple",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Netflix Interviews + Questions",
      "content": "Netflix’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Netflix? Do anonymous mock interviews with real Netflix interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Netflix’s process, evaluation criteria, and interviewers.\nEvery human organization views themselves as a metaphor; Netflix doesn’t view themselves as a family like some other tech companies, they view themselves as a high-caliber sports team (in fact, Netflix calls their employees a “dream team”). They explain this metaphor themselves in their infamous culture memo.\nFinally, Netflix’s interview process is decentralized and team-dependent. Moreover, you can interview with multiple teams at Netflix concurrently, which can help you increase your odds of securing a job offer.\nPlease see the section above called “A note about recruiter calls”\nThis is a 30 minute call. A former Netflix employee called this round “Very chill, especially compared to the onsite.” This round consists of bidirectional surface-level questions.\nThe hiring manager will also be selling you on Netflix. Hiring managers doing selling is business as usual, but in this case, it serves an additional purpose – because their onsite is by far the most intense, they have to sell harder upfront because the onsite is a bigger commitment for the candidates.\nThe Netflix technical phone screen is a coding interview that typically lasts 45-60 minutes. There is significant inter-team variation on what these interviews cover, and the tooling you use during these interviews also varies by team,\nOnsite interview structure varies from team to team, but you’ll have roughly 8 interviews focused primarily on system design, then behavioral, and then coding.\nDepending on the length of the onsite, Netflix recruiting may ask you if you’d prefer to split the onsite over two days, and we recommend that you proactively ask to do that, given how taxing the behavioral and system design portions are!\nNetflix is the only FAANG that routinely includes 1-2 directors in their onsite loops. If your loop has two, it’ll be one director will be from your org and another from a partner org. Netflix does this to reduce bias. One director may do a system design interview, and the other will do a behavioral interview.\n“Don’t be thrown off by having to talk to directors. Just stick to the principles: when you speak about technical stuff you’ve worked on, focus on scale, availability, and security. When you speak about behavioral stuff: use shared ideas from their culture deck, take accountability for your wins and failures, and demonstrate metrics and impact.”\n“The HRBP [which is basically a very senior recruiting function] and the director would typically focus on behavioral rounds. I have also seen directors spending time (30 mins) just letting candidates ask and clarify any questions that they might have regarding the team, Netflix culture, career growth path or any other aspects. So, a strong recommendation would be to be ready with your genuine questions list and get things clarified in such interviews. Candid conversation is one of the key values at Netflix and asking genuine concerns if any is seen through good lenses, as that establishes candidates' seriousness about the role to some extent.”\nThe technical questions Netflix asks vary from team to team. Some teams don’t ask LeetCode questions. Other teams will ask medium-difficulty LeetCode-style coding questions with a creative/practical twist.\nThese rounds are going to change team by team, but the pattern we’ve noticed is that Netflix coding questions often come in two parts.\nTypically there is one question and, in scenarios where edge cases and tests are done early, say within 45 minutes, the interviewer may choose to spend some time discussing general large scale engineering concepts and distributed systems (like microservices, scalability, etc.). For instance, some expansions could be:\nThis is the most important round at Netflix. Coding carries the least weight, behavioral carries a lot, and system design has the most.\nNetflix system design rounds are highly unique and highly challenging. Netflix is to system design as Google is to coding; these technical interview rounds include the most difficult and bespoke questions.\nSimilar to how Amazon loves Leadership Principles, Netflix loves system design so much they even throw it into coding rounds sometimes – first, you solve a LeetCode-style problem. Then they ask you to apply it to a real-world use case.\nThat said, Netflix system design rounds are easier to prepare for if you know the patterns: Netflix loves scale. Netflix never wants to go down, and Netflix hates when things aren’t secure. Availability is super important to them; they want to ask and hear about tactics to scale systems, keep systems highly available, and maintain secure systems.\nAt Netflix, you’re likely to see unique questions that you won’t get anywhere else, and the system design round is the part of the process that Netflix interviewers take the most pride in, so they make up hard, one-of-a-kind questions from scratch. Thematically, their questions are more likely to be focused on scaling. They also like to ask about security and availability.\nIn fact, Netflix is more likely than the rest of FAANG to give you a system design round focused solely on security. For instance, you might get asked what you would do during a DDoS attack, and the entirety of the session will be spent drilling down into the details. And because they’re also obsessed with availability, you might get questions around backups and what to do if a service goes down.\nMoreover, as with their coding rounds, Netflix prefers questions with a practical application, and they’re likely to ask you about something they’re working on right now. If you research the hell out of their architecture – specifically the service that particular team is in charge of – and the other services this service interacts with, you’ll be in good shape.\nYou’re also likely to see a “reverse system design” round, where your interviewer will ask you pointed questions about the systems you’ve worked on before, e.g., the largest scale system you’ve worked on, how did you manage it, how did you scale it, etc.\nQuestions they most likely won’t ask are product-focused questions, such as “Design Spotify”.\nLearn about Netflix’s overall architecture so you can a) speak their language, and b) build or speak of something similar (in the interview) that Netflix has already built but simpler.\nFor the team you interview with: what’s their tech stack? What open source stuff do they do? With which other services might their service interact? That last question is most critical. If you can put forethought into how their current system works, you’ll have a huge leg up; then all you’ll need to do is discuss what you learned about their system to score a bunch of points with any of their interviewers.\nWhat tooling you use in these interviews depends on the team you’re interviewing with.\nAnswers to behavioral questions are almost as important as system design at Netflix. You’ll get rejected if you fail the behavioral screen.\nThese interviews have a heavy emphasis on the candidate being a cultural fit, being able to work in a team, having curiosity, and being product minded, highly motivated individuals capable of driving products forward.\nA unique part of Netflix’s behavioral interview is the “Dream Team” interview. This is a slightly more intense behavioral round conducted by a director. The \"volume\" is turned up on all of the things you might see in a typical behavioral round at Netflix (scale, accountability, open communication about concerns, high risk and high reward.)\n“Netflix doesn’t hire as much as other FAANGs, so they want to make sure you're a star. That’s what the ‘Dream Team’ interview is about.”\nOne key thing you need to do before your Netflix behavioral interview is read their culture memo. Our interviewers tell us that if you don’t do this, you will fail the behavioral round.\n“The culture illustrated in the culture memo is sort of accurate to how the culture at Netflix actually is, but the actual culture is less intense. Team members tend to get along really well. You don’t compete with others in your performance review like it is at companies like Facebook. We’re not ranked against peers, so people are more willing to help each other out.”\nNetflix will ask about impressive things you’ve done, as well as dig into your motivation (your “why”). This round will feel like you’re doing self-promotion. Typical questions will ask about your favorite project, latest project, and most significant project, as well as open-ended questions about what you’re looking for in your next role and why you’re interested in Netflix.\nPromote yourself early and often in Netflix behavioral rounds. Promote yourself proactively. Metrics and impact statements are effective ways to promote yourself because they convey a sense of scale and complexity.\nIt can be nerve-wracking to talk to a director for 45-60 minutes. It’s more nerve-wracking when, out the gate, they ask you to describe the biggest thing you’ve ever worked on. When talking to a director, it’s more important to have metrics and impact statements.\nNetflix interviewers are untrained, their questions are unstandardized, their interviews are team-dependent, and their decision-making north star is “Why”. You can interview with multiple teams concurrently, effectively giving you multiple shots on goal.\nThere’s also no specific company-wide scale for performance at Netflix. This is different from, say, Google, where all candidates are graded on the same “Strong Hire, Hire, Neutral, No Hire, Strong No-Hire” scale. Different teams have different processes, but most decisions are made based on live post-onsite discussions.\n“Netflix hiring decisions are black and white: pass or fail. And then you discuss if you'd be open to changing your mind. The only difference between Apple and Netflix was how they defined cultural fit. Besides that the hiring decisions were made in the same way: informal, mainly based on live discussions, binary decisions, and striving for consensus.”\nImpression management is more powerful at companies that do live feedback discussions. To learn more about impression management, check out the resources to prepare for Netflix later in this section.\nWe’ve aggregated a bunch of useful Netflix content for you! We have replays of candidates doing mock interviews with Netflix interviewers, long-form solutions to common Netflix questions, and deep dives into technical topics that tend to come up in Netflix interviews.\nBelow are a series of mock interview replays, conducted by Netflix interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Netflix ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Netflix interviews, we did two things. First, we spoke to a bunch of Netflix interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Netflix. Based on all of the above, here are the technical topics you’re likely to encounter:\nThe resources listed below are designed to help with various aspects of Netflix interview prep, from technical problem-solving to understanding the company’s core values.\nSince Netflix has the most difficult system design screen (and their version of this round has a lot of overlap with other FAANGs), if you prep for Netflix, you’re also upskilling for system design rounds at all FAANGs. We recommend the following resources to all engineers interviewing at FAANG:\nThese resources will help you “learn their language.” Then, when you communicate with Netflix, speak their language.\nWant to know if you’re ready to interview at Netflix? Do anonymous mock interviews with real Netflix interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/netflix",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Microsoft Interviews + Questions",
      "content": "Microsoft’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Microsoft? Do anonymous mock interviews with real Microsoft interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Microsoft’s process, evaluation criteria, and interviewers.\nMicrosoft lets you interview with different teams at the same time; if you want to maximize your chances interview with several of them simultaneously.\nMicrosoft’s process is mainly (though not fully!) team-dependent. That means that while you interview for a specific team, you may not necessarily be interviewing just with people on that team. For example, sometimes you might interview with the hiring manager for a specific team, and your other interviewers will be individual contributors from other teams.\nEach team runs their own processes, which can vary quite a bit from team to team as well. Sometimes Microsoft bakes a quasi-team-matching activity into an interview process: where a candidate can meet multiple hiring managers in the same loop. Another variation is some candidates’ first round screens are with a hiring manager instead of a recruiter.\nPlease see the section above called “A note about recruiter calls”\nMicrosoft’s technical phone screen is a traditional LeetCode-style coding interview, with technical questions ranging from easy to medium. Interviewers aren’t given a rubric. Some of them get training, others don’t. They have freedom to ask whatever they want and judge your technical skills however they want in this round.\nIf you end up getting the asynchronous Codility quiz instead, you sign on and have to answer several algorithmic questions in a short amount of time. In some ways, this is harder than the technical phone screen with the human because if you don’t pass the test cases, you get filtered out. You’re judged on several factors including: test cases, correctness, and code quality.\nThe onsite format can vary per org, but it typically includes the following round of interviews:\nThis is the most important round at Microsoft.\n“Since most engineers at Microsoft use C#, if you can, you should use C#, Java, or Python in the technical rounds. This way, your interviewer will be able to understand your code better and may even be able to help.”\nMicrosoft usually asks LeetCode-style medium-difficulty questions in coding rounds. Interviewers get to pick their own coding questions, but, according to interviewers, Microsoft favors the following topics (in no particular order):\nLeetCode’s Top Questions for Microsoft is also a helpful resource.\n“Tree questions are most popular, e.g., various types of tree sum, tree traversals of certain orders, subtrees, etc.”\nDynamic programming used to basically never happen, but now it’s a little more common. When you do get dynamic programming problems, it’s usually the classic ones like coin change, stair steps, edit distance, and various types of counting problems.\nTooling for coding interviews is at the team’s discretion, but many teams use Codility.\nFor everything you need to prepare for Microsoft’s coding interview, check out the section called \"Microsoft coding interview preparation resources\" below.\nSystem design is tied for the second most important round at Microsoft, and it’s sometimes conducted by a hiring manager. One idiosyncratic aspect of Microsoft’s process is their penchant for asking questions about compliance-related topics.\n“My Microsoft interview was insanely easy. I tried to step it up when I started being an interviewer at Microsoft. But then I realized that's how it has to be. Technical is like 25% of it. It’s not a generic FAANG interview. It’s more about three things: a) ‘How well does this candidate know this system they’re going to be working on?’, b) ‘How do they meet the exact needs we have on this team?’, and c) ‘Do they understand the little things we value? Like compliance, manipulating data, data pipelines, EU data processing, etc.’”\n“Microsoft is obsessed with the details of compliance. I don’t think I have seen a system that is as set up for auditing as Microsoft. Employees are asked to log so much. There’s a centralized grid system which is built into Azure. All logs are to be routed into that. This allows for centralized log spanning and auditing. Which I have not seen anywhere else.”\nOutside of compliance-related questions, here are examples of other system design questions you might encounter:\nTooling for system design interviews is at the team’s discretion, but many Microsoft employees use Codility Canvas or Excalidraw.\nThe domain-specific round is tied for the second most important round at Microsoft. Microsoft is more likely to do these types of rounds than other FAANGs, and these rounds can feel similar to system design but involve some coding.\nUsually, domain-specific rounds are customized to the domain a given team works on and dives deep into that technology. So, whatever area this team is in (cloud networking, big data, etc.), that’s what they’ll ask you about.\nOn some occasions, Microsoft customizes a round to the candidate’s skills. For example, if you’re a backend engineer, they might ask you to design an API or design a database. They also may ask you open ended trivia questions about the programming language you are most familiar with.\n“Another thing that happens in these rounds is they’ll ask you to discuss a complicated problem you have solved at your job. It's good for candidates to prepare to discuss 2-3 projects in detail: how did they implement caching, deal with scaling issues, and so on.”\nFinally, you may get a scenario question that’s commensurate with your skill set. For instance, if you’re a back-end engineer, you may get a question like, “Imagine you're in a team and we're building a credit card registration system. And it's used by different firms. How do you build the interface?”\nThis is the least important round at Microsoft: the lowest effort way to pass is to not blame your teammates, not show red flags, and stay positive.\nMicrosoft doesn’t have a specific set of traits they’re looking for. You can expect the usual questions about your strengths and weaknesses, failure, conflicts with colleagues, projects, and lessons you’ve learned from past experiences in your career.\n“A lot of people struggle with ‘What are your top 2 strengths and weaknesses?’ probably because they are trying to make up an answer on the spot. Good to prep answers to typical behavioral questions in advance.”\nUltimately, they are screening for three soft skills: positivity, ownership, and communication. They want to hire friendly people who can do the work and not blame others. This is not Apple or Netflix, where they want a particular flavor of personality, or where they ask interviewers to hire candidates they’d like to befriend. It’s more neutral.\nBehavioral rounds can sometimes have a coding component as well. When this happens, it might be an easy/medium-difficulty 20-min LeetCode-style problem.\nInterviewers grade candidates on different scales, depending on the team.\nSome orgs have an asynchronous feedback process, other orgs rely on live discussion, and still-other orgs do both. Some orgs have rubrics, and others don’t. Here’s how a rubric looks at one org:\nHere are a few more interview tips and resources to help you prep for a software developer or software engineer interview at Microsoft.\nIn addition, we’ve aggregated a bunch of useful Microsoft content for you! We have replays of candidates doing mock interviews with Microsoft interviewers, long-form solutions to common Microsoft questions, and deep dives into technical topics that tend to come up in Microsoft interviews.\nBelow are a series of mock interview replays, conducted by Microsoft interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Microsoft ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Microsoft interviews, we did two things. First, we spoke to a bunch of Microsoft interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Microsoft. Based on all of the above, here are the technical topics you’re likely to encounter:\nWant to know if you’re ready to interview at Microsoft? Do anonymous mock interviews with real Microsoft interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/microsoft",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to Reverse a String [Interview Question + Solution]",
      "content": "How to Reverse a String (With Solutions in Python, Java & JavaScript)\nHow to Reverse a String: Problem Overview\nHow to Reverse a String: Problem Overview\nThe Reverse String problem involves taking a given string of characters and reversing the order of the characters. This problem, despite its simplicity, invites many advanced approaches, such iteration, recursion, or multiple pointers, each presenting a unique time and space complexity tradeoff.\nAn Example of the Reverse String Problem\nAn Example of the Reverse String Problem\nWrite a program to reverse the given string. The program's output would be a string with all characters in reverse order.\nInput: \"hello world\" Output: \"dlrow olleh\"\nInput: \"aba\" Output: \"aba\"\nInput: \"ab\" Output: \"ba\"\nInput: \"\" Output: \"\"\nConstraints\nThe number of characters in the string would be in the range [0, 100000].\nHow to Reverse a String : 4 Approaches in Python, Java & JavaScript\nHow to Reverse a String : 4 Approaches in Python, Java & JavaScript\nThe most straightforward answer is to use an inbuilt library-provided function that is usually available in most languages. But the interviewer is probably not interested in our knowledge of library functions. This means the ideal solution would be similar to how a library would implement a reverse\nfunction (i.e., Python, JavaScript, Ruby). There are several approaches, and we'll discuss some of them here.\nApproach 1: Build String Iteratively (Brute Force)\nThe original string's first character turns into the reverse string's last character. The second character of the original string becomes the second last character of the reversed string. And so on.\nWe can loop through each character of the original string and build the reversed string iteratively. We start with an empty string and append the characters to it as we loop across the original string. Please note that we are appending the characters to the beginning of the string. By doing so, we ensure that the characters appearing later in the original string appear earlier in the reversed string.\nAlgorithm\n- Initialize an empty string\nreversed\\_string\n. - Loop through each character of the original string.\n- Append the character at the beginning of\nreversed\\_string\n. - Return the\nreversed\\_string\n.\nReverse String JavaScript, Python and Java Solutions - Brute Force\nfunction reverseString(string) {\nlet reversedString = \"\";\nfor (char of string) {\nreversedString = char + reversedString;\n}\nreturn reversedString;\n}\n1function reverseString(string) {\n2 let reversedString = \"\";\n3 for (char of string) {\n4 reversedString = char + reversedString;\n5 }\n6 return reversedString;\n7}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n²)\n. A common mistake is to think of the time complexity of this approach asO(n)\n, but this is not the case. The time complexity isO(n²)\nbecause each time we append a character to the end of the string, we end up creating a new string. This new string then gets assigned to the variablereversed\\_string\n. This is anO(n)\noperation, and we are doing this for each character in the string. So the total time complexity isO(n \\* n) = O(n²)\n.If we are coding in a language that support string mutability, then appending a character would be a constant time operation. So the time complexity would be\nO(n)\n. -\nSpace Complexity:\nO(n)\n. We are creating a new string of lengthn\n, which is the only memory space we use.\nApproach 2: Build String Iteratively (Linear Time)\nIn the previous approach, we noted that it was not the optimal solution because we were creating a new string each time we added a character to the end of the string, which is an O(n)\noperation. Can we find a way to bring this operation down to O(1)\n?\nInstead of creating a new string every time we need to find a data structure that we can append individual characters to in constant time, and to this we can use a stack. A stack is a data structure that follows the LIFO principle. In this approach, we push all the characters of the original string onto the stack and then pop them one by one in order to build the reversed string.\nAdditionally, while building the reversed string, we use a dynamic array to store the characters. By using a dynamic array, we avoid creating a new string every time we append a character to the end of the string, making the operation O(1)\ninstead of O(n)\n.\nAlgorithm\n- Initialize an empty stack\nstack\n. - Loop through each character of the original string.\n- Push the character to the stack.\n- Initialize an empty dynamic array\nreversed\\_string\n. - Loop until the stack is empty.\n- Pop the top character from the stack. Append it to the end of\nreversed\\_string\n. - Create a string from the dynamic array\nreversed\\_string\nand return it.\nReverse String Javascript, Python and Java Solutions - Using a Stack\nfunction reverseString(string) {\nlet stack = [];\nfor (char of string) {\nstack.push(char);\n}\nlet reversedString = [];\nwhile (stack.length > 0) {\nreversedString.push(stack.pop());\n}\nreturn reversedString.join(\"\");\n}\n1function reverseString(string) {\n2 let stack = [];\n3 for (char of string) {\n4 stack.push(char);\n5 }\n6 let reversedString = [];\n7 while (stack.length > 0) {\n8 reversedString.push(stack.pop());\n9 }\n10 return reversedString.join(\"\");\n11}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n)\n. We are looping through the original string once and pushing the characters to the stack. Then we loop across the string again and pop all the characters from the stack. Finally, we join all the characters of reversed\\_string, so the total time complexity isO(n + n + n) = O(3n) = O(n)\nPlease note that an algorithm that takes3n\ntime is classified withO(n)\ntime complexity. Big-O notation is a measure of how an algorithm scales as the size of the input grows. As the size ofn\nincreases, the constant factor3\nbecomes insignificant. -\nSpace Complexity:\nO(n)\n, as we use a stack that storesn\ncharacters.\nApproach 3: In Place Reversal (Two Pointers)\nWhen a string is reversed, the last character becomes the first character, and the first character becomes the last character. Similarly, the second last character becomes the second character, and the second character becomes the second last character. And so on. In other words, characters at the same position relative to the start and the end of the string are swapped.\nWe iterated from one end of the string to the other in the previous approaches. It is also possible to iterate from both ends of the string simultaneously. Let's have two pointers, one pointing at the start of the string and the other at the end of the string. We can swap the characters at these two pointers. Then we can move the pointers toward the middle of the string. We can keep doing this until the two pointers meet each other.\nIn most languages, a string is immutable. This means that we cannot change the characters of the string. We can only create a new string. So we need to convert the string to a character array. Then we can swap the characters at the two pointers. After swapping all the characters, we can transform the character array back to a string.\nIf the language supports mutable strings (e.g., Ruby, PHP, Swift), we can directly swap the characters at the two pointers. Some languages don't support mutability directly, but might have a class or a standard library that provides a mutable string. For example, there is StringBuilder in Java.\nAlgorithm\n- Convert the string to a character array\nchar\\_array\n. - Initialize two pointers,\nstart\nandend\n, to point at the start and the end of the string, respectively. - Loop until\nstart\nis less thanend\n. - Swap the characters at\nstart\nandend\n. - Increment\nstart\nand decrementend\n. - Convert the character array back to a string and return it.\nReverse String Javascript, Python and Java Solutions - Using In Place Reversal\nfunction reverseString(string) {\nlet charArray = string.split(\"\");\nlet start = 0;\nlet end = charArray.length - 1;\nwhile (start < end) {\nswap(charArray, start, end);\nstart += 1;\nend -= 1;\n}\nreturn charArray.join(\"\");\n}\nfunction swap(charArray, start, end) {\n// using destructuring assignment to swap the characters\n[charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n}\n1function reverseString(string) {\n2 let charArray = string.split(\"\");\n3 let start = 0;\n4 let end = charArray.length - 1;\n5 while (start < end) {\n6 swap(charArray, start, end);\n7 start += 1;\n8 end -= 1;\n9 }\n10 return charArray.join(\"\");\n11}\n12\n13function swap(charArray, start, end) {\n14 // using destructuring assignment to swap the characters\n15 [charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n16}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n)\n. Both pointers traverse the string from opposite ends until they merge. So every character is processed once in this process. Swapping two characters takes constant amount of time. So the overall time complexity isO(n)\n. -\nSpace Complexity:\nO(n)\n. We are using a character array to store the characters of the string. So the space complexity isO(n)\n. If the input to the function is a character array itself or the language supports string mutability, then the space complexity would beO(1)\n, because the algorithm does an in-place reversal of the character array / string.\nApproach 4: In Place Reversal (Recursion)\nNote: While recursion will work for this problem, it overcomplicates the problem without added benefit and as such many interviewers will prefer one of the non-recursive approaches above. We have included the recursive solution here for completeness.\nIn the previous approach, we iterated two pointers toward the middle of the string and used them to swap the characters at the index of each pointer. While this method works well, we want to present a similar approach that uses recursion.\nWe define a recursive function that receives the character array and pointers for start and end as input. The function swaps the characters at the start and end pointers. Then it calls itself with the start pointer incremented by 1 and the end pointer decremented by 1. This way, the function keeps swapping the characters at the start and end pointers until the start pointer is greater than the end pointer. The function returns when the start pointer is greater than the end pointer. This way, we can reverse the string in place.\nIn the end, we convert the character array to a string and return it.\nAlgorithm\n- Convert the string to a character array\nchar\\_array\n. - Call the recursive function\nreverseStringHelper\nwithchar\\_array\n,0\nandchar\\_array.length - 1\nas input. - Convert the character array back to a string and return it.\nRecursive function reverseStringHelper\n:\n- Base case: If\nstart\nis greater thanend\n, return. - Swap the characters at\nstart\nandend\n. - Call the recursive function\nreverseStringHelper\nwithchar\\_array\n,start + 1\nandend - 1\nas input.\nReverse String Javascript, Python and Java Solutions - Using In Place Reversal with Recursion\nfunction reverseString(string) {\nlet charArray = string.split(\"\");\nreverseStringHelper(charArray, 0, charArray.length - 1);\nreturn charArray.join(\"\");\n}\nfunction reverseStringHelper(charArray, start, end) {\nif (start > end) {\nreturn;\n}\nswap(charArray, start, end);\nreverseStringHelper(charArray, start + 1, end - 1);\n}\nfunction swap(charArray, start, end) {\n// using destructuring assignment to swap the characters\n[charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n}\n1function reverseString(string) {\n2 let charArray = string.split(\"\");\n3 reverseStringHelper(charArray, 0, charArray.length - 1);\n4 return charArray.join(\"\");\n5}\n6\n7function reverseStringHelper(charArray, start, end) {\n8 if (start > end) {\n9 return;\n10 }\n11 swap(charArray, start, end);\n12 reverseStringHelper(charArray, start + 1, end - 1);\n13}\n14\n15function swap(charArray, start, end) {\n16 // using destructuring assignment to swap the characters\n17 [charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n18}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n)\n. Both pointers traverse the string from opposite ends until they merge. We swap two characters in the main body of recursion, which is a constant time operation. So the overall time complexity isO(n)\n. -\nSpace Complexity:\nO(n)\n. We are using a character array to store the characters of the string. On top of that, we are using the call stack to store the function calls. We maken/2\nfunction calls, which isO(n)\n. So, the space complexity isO(n)\n.\nPractice the Reverse String Problem With Our AI Interviewer\nPractice the Reverse String Problem With Our AI Interviewer\nReverse String Frequently Asked Questions (FAQ)\nReverse String Frequently Asked Questions (FAQ)\nWhy can’t you just use reverse() when reversing a string?\nIn real life, you probably would. However, in an interview, you’ll want to demonstrate to your interviewer that you understand what programming languages do under the hood when they call a function like reverse(). That’s why it’s important to be able to implement it from scratch. It’s also an opportunity to demonstrate to your interviewer that you know if strings are mutable or immutable in your language of choice.\nHow do you reverse a string in place?\nTo reverse a string in place means to modify the original string directly without using any additional memory. There are two ways to do this: the first is iterative, and the second uses recursion. Note that the recursive approach isn’t as efficient and overcomplicates the problem needlessly.\nWith the iterative approach, you’d use two pointers to swap characters symmetrically from both ends of the string: the first with the last, the 2nd with the 2nd to last, and so on. We’d repeat this approach until the two pointers met each other. Depending on whether strings are mutable or not in your programming language of choice, you might have to convert the string to a character array before doing the swaps.\nWith the recursive approach, we convert our string to a character array, and then pass it into the recursive function, along with pointers for the start and end. The function swaps the characters at the start and end pointers. Then it calls itself with the start pointer incremented by 1 and the end pointer decremented by 1. The function returns when the start pointer is greater than the end pointer.\nWhat’s the difference between reversing a string and reversing an array of integers?\nHow different these are depends on whether strings are mutable or not in your language of choice.\nWhen reversing a string, you are dealing with a sequence of characters. Strings are typically treated as immutable in many programming languages, including Python, which means you cannot modify them directly. To reverse a string in place, you need to convert it into a mutable data structure (like an array) first, perform the reversal, and then convert it back to a string.\nOn the other hand, when reversing an array of integers, you are working with a collection of numeric values. Arrays of integers are mutable data structures in most programming languages, allowing direct modification. You can reverse the order of elements in an array by swapping elements at symmetric positions, without needing to convert the array into a different data type.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/reverse-string",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Longest Substring Without Repeating Characters (Solved)",
      "content": "How to Solve Longest Substring Without Repeating Characters\nWhat is the Longest Substring Without Repeating Characters Problem?\nWhat is the Longest Substring Without Repeating Characters Problem?\nThe Longest Substring Without Repeating Characters problem involves searching through a given string and identifying the longest sequence of non-repeating characters. This problem can be solved with a brute force search approach, or with a more advanced and efficient sliding window technique.\nLongest Non-repeating Substring Example Inputs and Outputs\nLongest Non-repeating Substring Example Inputs and Outputs\nGiven a string s\n, find the length of the longest substring without repeating characters.\nExample 1\nInput: \"abcabcbb\"\nOutput: 3\nThe longest substrings without repeating characters are abc\n, bca\n, and cab\n, all with length 3.\nExample 2\nInput: \"bbbbb\"\nOutput: 1\nThe longest substring without repeating characters is b\n, with length 1.\nExample 3\nInput: = \"pwwkew\"\nOutput: 3\nThe longest substring without repeating characters is wke\n, with length 3.\nConstraints\n- 0 <= s.length <= 1000000\n- The character set for\ns\nis ASCII.\nSolution to the Longest Substring Without Repeating Characters Interview Question\nSolution to the Longest Substring Without Repeating Characters Interview Question\nThere are three ways to approach the longest substring problem. Before we talk about them in detail, note that when asked to explore a \"subsection\" of an array or string, you should always confirm your understanding of the search space. Remember that a substring is a contiguous slice of characters taken from a string (similar to a subarray), as opposed to a subsequence which can skip characters, or a permutation which can be out of order. With this knowledge, we can rule out any need for backtracking, and instead start to think more greedy.\nAnother important thing to confirm with your interviewer when handling strings is the character set, as this will help us define the space complexity of the problem. A safe assumption is that our solution will implement ASCII (128 characters) or Extended ASCII (256 characters).\nNow, here are the three approaches you can take.\n1. Brute Force\nWith the search space defined, a naïve approach becomes fairly straightforward: generate each substring from the input string, check if there are any repeating characters for each, and use a standard-library function (such as math.max()\nin Java) to record the max length found for valid substrings.\nWe can separate this work into two subproblems. First, we need a helper function to determine if a given string has any repeating characters - this can be done by scanning a given range and counting character occurrences with a hash map.\nNext, to generate each substring from the input string s\n, we can enumerate all substrings with two nested loops. Given i\nand j\nas all possible start and end indices for a substring of s\n, we have 0 <= i <= j <= n\n, where n\nis the length of the input string.\nLongest Substring Without Repeating Characters Python and JavaScript Solutions - Brute Force\nclass Solution:\ndef is\\_unique\\_within\\_range(start: int, end: int) -> bool:\nchars = set()\nfor i in range(start, end + 1):\nchar = s[i]\nif char in chars:\nreturn False\nchars.add(char)\nreturn True\ndef length\\_of\\_longest\\_substring(s: str) -> int:\nresult = 0\nfor i in range(len(s)):\nfor j in range(i, len(s)):\nif (self.is\\_unique\\_within\\_range(i, j)):\nresult = max(result, j - i + 1)\nreturn result\n1class Solution:\n2 def is\\_unique\\_within\\_range(start: int, end: int) -> bool:\n3 chars = set()\n4 for i in range(start, end + 1):\n5 char = s[i]\n6 if char in chars:\n7 return False\n8 chars.add(char)\n9 return True\n10 def length\\_of\\_longest\\_substring(s: str) -> int:\n11 result = 0\n12 for i in range(len(s)):\n13 for j in range(i, len(s)):\n14 if (self.is\\_unique\\_within\\_range(i, j)):\n15 result = max(result, j - i + 1)\n16 return result\nTime/Space Complexity Analysis\n- Time Complexity: O(n³). Two nested loops is O(n²), and the helper function makes an additional nested loop.\n- Space Complexity: O(min(n, m)), where\nn\nis the length of the strings\nandm\nis the size of the character set.\n2. Sliding Window\nTo optimize the naïve approach, let's see where duplicate work is being performed.\nConsider this example: if the string \"abc\" has no repeating characters, and we append a new character \"d\" at the end to make the string \"abcd\", do we need to re-check if \"abc\" has repeating characters? Our two nested loops are doing just that - repeatedly checking sections of the string that have already been evaluated - and our helper function is re-checking for repeat characters without using information from overlapping checks.\nInstead of naively enumerating each substring, how can we intelligently skip substrings that we already know to be invalid? Let's use the string “kadbakf” as an example.\nkadb\nis a valid candidate for longest substring since it has no repeating characters.\nIf j\nmoves to index 4 though, the new substring kadba\nwould be invalid. So, we can deduce that with i\nat position 0, all subsequent iterations of j\nwill be invalid, since they will contain this invalid substring. We can confidently stop iterating j\nat this point.\nSo, let's iterate i\nand begin considering new candidate substrings, since we've already seen the longest possible substring with i\nat index 0. But adba\nis also invalid, so any iteration on j\nwill remain invalid.\nLet's increment i\nuntil the substring in the range i\nto j\nis valid again. Here, once i\nis at index 2, there is only one a\ncharacter in the substring, so we can again try to increase the length by iterating j\nanew.\nThis technique is known as a sliding window, and it is approach applicable to a wide variety of leetcode / algorithms problems. The window represents a candidate substring bounded by a start and an end pointer, which expands and contracts based on what we're looking for. Sliding windows are commonly used when searching for an optimal range in an iterable data structure like a string or an array. This is because the algorithm will first search for a possible answer before then expanding (or contracting, whichever is the priority) to try to optimize. For example, if we were searching for the shortest substring that contains the letters a\nand b\n, we would only contract our window if those letters existed in the current substring (valid condition), otherwise we're adding characters until the condition is met.\nConversely, when looking for the maximum possible length, as in the problem at hand, we can only expand the window when the current substring is valid (otherwise, we must first arrive at a valid state by removing characters from the left). Looking back at the example above, j\nonly iterates forward while the condition is satisfied - in this case, all characters between i\nand j\nare unique - and i\nonly iterates forward while the condition is not satisfied.\nHaving made this insight on our substring enumeration, we can further improve the way we check for substrings with unique characters. Remember that a sliding window allows us to take advantage of overlapping subproblems - so, instead of re-checking each window for distinct characters, let's track the current character count of the window and evaluate the new state when a single character is added or removed.\nMore formally, if we know that a substring in the range i\nto j\nhas no repeating characters, then when adding the next character at j+1\n, we simply need to check if that character already exists in the previous range. And because we established the character set at the beginning of our solution, this can be determined in constant time using an array of length 128 to represent character occurrence in a substring.\nNote that, although there are still two nested loops in our code, the time complexity of the iteration is now linear, as i\nand j\nwill only iterate over each character once. Unlike our naïve implementation, the two pointers are not dependent on one another, and instead iterate based on the state of the range between them, which can be determined in constant time and space.\nLongest Substring Without Repeating Characters Python and JavaScript Solutions - Sliding Window\nclass Solution:\ndef length\\_of\\_longest\\_substr(s: str) -> int:\n# List representing ASCII characters to track occurences\nchars = [0] \\* 128\nresult = 0\ni = 0\nj = 0\nwhile j < len(s):\nright\\_char = s[j]\nchars[right\\_char] += 1\nwhile chars[right\\_char] > 1:\nleft\\_char = s[i]\nchars[left\\_char] -= 1\ni += 1\nresult = max(result, i - j + 1)\nreturn result\n1class Solution:\n2 def length\\_of\\_longest\\_substr(s: str) -> int:\n3 # List representing ASCII characters to track occurences\n4 chars = [0] \\* 128\n5 result = 0\n6 i = 0\n7 j = 0\n8 while j < len(s):\n9 right\\_char = s[j]\n10 chars[right\\_char] += 1\n11 while chars[right\\_char] > 1:\n12 left\\_char = s[i]\n13 chars[left\\_char] -= 1\n14 i += 1\n15 result = max(result, i - j + 1)\n16 return result\nTime/Space Complexity Analysis\n- Time Complexity: O(n). At worst, the two pointers both perform linear scans of the string, which would be O(2n). This can be interpreted as O(n) in Big-O notation, since constants are ignored when determining order of magnitude.\n- Space Complexity: O(1). Limited to 128 ASCII characters, space is constant.\n3. Sliding Window Optimized\nAs a marginal optimization, we can avoid two passes with our pointers by improving how we cache character occurrences and update our pointers.\nRemember what we determined in the previous approach: once a duplicate character is found in a given window, this candidate substring will remain invalid until one of the dupes is removed. Seeing that we need to arrive at a valid state before we can continue iterating our right pointer, can we improve how we iterate the left pointer? Indeed! Instead of iteratively searching for the next valid position, we can deduce where it would necessarily be: the index directly after the first occurring duplicate's index in the substring. Moving i\nto this position effectively removes the duplicate from the substring.\nTracking character counts in our hash map won't serve us anymore - instead, let's record the last index at which each character was encountered, so the left pointer can be updated in constant time. Thus when the right pointer finds a repeat, we simply update the left pointer to the position of the last occuring repeat (plus 1).\nLongest Substring Without Repeating Characters Python and JavaScript Solutions - Sliding Window Optimized\nclass Solution:\ndef length\\_of\\_longest\\_substr(s: str) -> int:\nresult = 0\nhash\\_map = {}\ni = 0\nj = 0\nwhile j < len(s):\nchar = s[j]\n# If a duplicate is found, update i to our stored next valid position\nif char in hash\\_map:\ni = max(hash\\_map[char], i)\nresult = max(result, j - i + 1)\n# Store the next index for this character, as this will be the next valid position to de-duplicate\nhash\\_map[char] = j + 1\nreturn result\n1class Solution:\n2 def length\\_of\\_longest\\_substr(s: str) -> int:\n3 result = 0\n4 hash\\_map = {}\n5 i = 0\n6 j = 0\n7 while j < len(s):\n8 char = s[j]\n9 # If a duplicate is found, update i to our stored next valid position\n10 if char in hash\\_map:\n11 i = max(hash\\_map[char], i)\n12 result = max(result, j - i + 1)\n13 # Store the next index for this character, as this will be the next valid position to de-duplicate\n14 hash\\_map[char] = j + 1\n15 return result\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(1)\nPractice the Longest Substring Without Repeating Characters Problem With Our AI Interviewer\nPractice the Longest Substring Without Repeating Characters Problem With Our AI Interviewer\nLongest Substring Without Repeating Characters Frequently Asked Questions (FAQ)\nLongest Substring Without Repeating Characters Frequently Asked Questions (FAQ)\nHow do you find the longest substring without repeating characters?\nThere are three ways to solve this problem. First, there’s the brute force approach, where you generate each substring from the input string, check if there are any repeating characters for each, and record the max length found for valid substrings. This approach runs in O(n³)\ntime. A more efficient way to do it is with a sliding window approach, where you look at substrings bounded by a start and an end pointer, which expand and contract. To start, you create a new set where you track what characters you’ve seen. If the next character is not already in the set, you add it to the set and expand your window by moving the end pointer to the right. If the next character is already in the set, you remove the character at the beginning of the window from the set and contract the window by moving the start pointer to the right. At each step, you calculate the length of the current window and compare it to the previous maximum length. This approach runs in O(n)\ntime. Finally, there’s the optimized sliding window approach, where you can avoid two passes by improving on how you cache character occurrences and update your pointers. This approach also runs in linear time.\nWhat’s the most efficient way to find the longest substring without repeating characters?\nThe most efficient solution to this problem is an optimized sliding window approach.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/longest-substring-without-repeating-characters",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Longest Common Subsequence (Problem & Solution)",
      "content": "Longest Common Subsequence (With Solutions in Python, Java & JavaScript)\nWhat is the Longest Common Subsequence Problem?\nWhat is the Longest Common Subsequence Problem?\nThe Longest Common Subsequence (LCS) problem is a common technical interview question where you're asked to find the longest sequence of characters present in two strings. Variations of this problem are commonly found in real-world applications such as bioinformatics, natural language processing, and text comparison. This problem can be solved using dynamic programming techniques, which involve breaking down the problem into smaller subproblems and then solving them iteratively.\nExamples of the Longest Common Subsequence Problem\nExamples of the Longest Common Subsequence Problem\nGiven two strings, return the longest common subsequence between the two strings. A subsequence of a string is a string that contains characters from the original string in the same order as the original, but may have characters deleted.\nExample 1\nInput: s1 = \"abccba\", s2 = \"abddba\" Output: \"abba\"\nExample 2\nInput: s1 = \"zfadeg\", s2 = \"cdfsdg\" Output: \"fdg\"\nExample 3\nInput: s1 = \"abd\", s2 = \"badc\" Output: \"ad\" (or \"bd\")\nConstraints\n-\n1 <= s1.length, s2.length <= 1000\n-\nThere may be multiple valid answers, but they'll all have the same length.\nHow to Solve the Longest Common Subsequence Problem\nHow to Solve the Longest Common Subsequence Problem\nTo solve the longest common subsequence problem (also known as longest common substring), it is helpful to first consider a couple of important properties of the lcs\nfunction. Firstly, if two strings s1, s2\nend in the same substring then their lcs\nis the lcs\nof the two strings without their common substring concatenated with said substring. For example, lcs(\"abccba\", \"abddba\") = lcs(\"abcc\", \"abdd\") + \"ba\"\n, since the length of the longest common subsequence between the two input strings is at minimum the length of the common consecutive string they share.\nSecondly, if two strings do not have a common ending substring, the lcs\nof the two strings will be the same as the lcs\nresulting from removing the ending of one of the strings. Put another way, lcs(s1, s2)\nis one of two recursive possibilities:\nlcs(s1[:-1], s2)\nlcs(s1, s2[:-1])\nwhere s1[:-1]\nis a string with the last character removed. For example, suppose s1=\"abcd\", s2=\"zdef\"\n, then lcs(s1, s2) = lcs(\"abcd\", \"zde\") = lcs(\"abcd\", \"zd\") = \"d\"\n. But note in this example that lcs(\"abcd\", \"zde\")\nis clearly not equal to lcs(\"abc\", \"zde\")\n.\nRecursive Approach\nLeveraging the above two properties, we can use a recursive solution to approach a longest common subsequence algorithm and solve this using backtracking.\nStarting at the end of the two strings:\n- If the characters at the end are the same, we can return\nlcs(s1[:-1], s2[:-1]) + s1[-1]\n. - If the characters are not the same, we must compute both\nlcs(s1[:-1], s2)\nandlcs(s1, s2[:-1])\n, and return the longer given sequence.\ndef solution(s1, s2):\nif len(s1) is 0 or len(s2) is 0:\nreturn ''\nelif s1[-1] == s2[-1]:\nreturn solution(s1[:-1], s2[:-1]) + s1[-1]\nelse:\nsub1 = solution(s1[:-1], s2)\nsub2 = solution(s1, s2[:-1])\nreturn sub1 if len(sub1) > len(sub2) else sub2\n1def solution(s1, s2):\n2 if len(s1) is 0 or len(s2) is 0:\n3 return ''\n4 elif s1[-1] == s2[-1]:\n5 return solution(s1[:-1], s2[:-1]) + s1[-1]\n6 else:\n7 sub1 = solution(s1[:-1], s2)\n8 sub2 = solution(s1, s2[:-1])\n9 return sub1 if len(sub1) > len(sub2) else sub2\nTime/Space Complexity\nLet m\nand n\nbe the length of the two strings.\n- Time Complexity:\nO(2^m \\* 2^n)\nin the worst case. This algorithm computes all possible subsequences for both strings, resulting in time complexity of2^(len(s))\nfor a string, but it also computes all possible subsequences per subsequence of the other string, hence the product. - Space Complexity:\nO(max(m,n))\n. The space complexity is due to the height of the recursion call stack being the maximum length between the two strings.\nRecursive Solution With Memoization\nWhen implementing a recursive algorithm, one optimization to always look out for is to address repeated work. For example, if we employ the above algorithm on a string that includes the substring \"abc\" in three different locations we will effectively be calling lcs(abc)\nthree different times within the recursion tree. How can we avoid this and improve the time complexity? By storing the lcs\ncomputations in a lookup table, otherwise known as memoization.\ndef solution(s1, s2):\nreturn solution\\_recur(s1, s2, {})\ndef solution\\_recur(s1, s2, solutions):\n# use a frozenset here because (1) frozenset is hashable, so can be\n# used for a key, and (2) order of the inputs does not matter for this function.\ninputs = frozenset([s1, s2])\nsolved = solutions.get(inputs, None)\nif solved is not None:\nreturn solved\nif len(s1) == 0 or len(s2) == 0:\nsolved = ''\nelif s1[-1] == s2[-1]:\nsolved = solution\\_recur(s1[:-1], s2[:-1], solutions) + s1[-1]\nelse:\nsub1 = solution\\_recur(s1[:-1], s2, solutions)\nsub2 = solution\\_recur(s1, s2[:-1], solutions)\nsolved = sub1 if len(sub1) > len(sub2) else sub2\nsolutions[inputs] = solved\nreturn solved\n1def solution(s1, s2):\n2 return solution\\_recur(s1, s2, {})\n3def solution\\_recur(s1, s2, solutions):\n4 # use a frozenset here because (1) frozenset is hashable, so can be\n5 # used for a key, and (2) order of the inputs does not matter for this function.\n6 inputs = frozenset([s1, s2])\n7 solved = solutions.get(inputs, None)\n8 if solved is not None:\n9 return solved\n10 if len(s1) == 0 or len(s2) == 0:\n11 solved = ''\n12 elif s1[-1] == s2[-1]:\n13 solved = solution\\_recur(s1[:-1], s2[:-1], solutions) + s1[-1]\n14 else:\n15 sub1 = solution\\_recur(s1[:-1], s2, solutions)\n16 sub2 = solution\\_recur(s1, s2[:-1], solutions)\n17 solved = sub1 if len(sub1) > len(sub2) else sub2\n18 solutions[inputs] = solved\n19 return solved\nTime/Space Complexity\nDue to how the recursive function is formulated, the lcs\nof (m + 1) \\* (n + 1)\ndifferent input pairs will be computed. Since this solution caches those results, it has:\n- Time Complexity:\nO(m \\* n)\n- Space Complexity:\nO(m \\* n)\nDynamic Programming Approach\nNotice that in the previous approaches, we relied on the fact that the problem being solved had very similar subproblems which were used to ultimately solve the original problem. Of course, these types of situations can be tackled using memoization as seen above. However, an even more powerful approach can be used to tackle overlapping subproblems: dynamic programming.\nTo solve this using a dynamic programming approach, this solution will construct a table of results, and then trace back through the table from the bottom up to construct the longest subsequence. Letting s1=\"abd\"\nand s2=\"badc\"\n, the initial table would look like:\nNotice that the table has been augmented with a row and column for no characters in a string. The added row and column serve as a base case upon which to fill out the rest of the table.\nThe table can be constructed row by row (or column by column). At each cell the character of the row is compared with the character of the column, and based on the result the following items are stored:\n- The length of the longest subsequence between the two substrings up to and including the characters at the current cell. The value will be one plus the \"previous\" cell's value if the characters match; otherwise it will be the \"previous\" cell's value.\n- The direction of the cell \"prior\" to the current cell which has the largest value. If the characters match, then the \"previous\" cell is up one and to the left one. Otherwise it is whichever cell has the larger value between the cell to the left and the cell above.\nContinuing with the example, to fill in the first row the following would occur:\n- 'a', 'b': unequal; above and to the left are 0; so store 0 with direction of \"both\"\n- 'a', 'a': equal; upper left is 0; so store 1 with direction of \"up-left\"\n- 'a', 'd': unequal; above is 0, but left is 1, so store 1 with direction of \"left\"\n- 'a', 'c': unequal; above is 0, but left is 1, so store 1 with direction of \"left\"\nNext we fill in the second row via:\n- 'b', 'b': equal; upper left is 0, so store 1 with direction of \"up-left\"\n- 'b', 'a': unequal; above and to the left are both 1; so store 1 with direction of \"both\"\n- 'b', 'd': unequal; above and to the left are both 1; so store 1 with direction of \"both\"\n- 'b', 'c': unequal; above and to the left are both 1; so store 1 with direction of \"both\"\nFinally, the last row:\n- 'd', 'b': unequal; above and to the left are 0, so store 0 with direction of \"both\"\n- 'd', 'a': unequal; above is 1 while to the left is 0; so store 1 with direction of \"up\"\n- 'd', 'd': equal; upper left is 1; so store 2 with direction \"up-left\"\n- 'd', 'c': unequal; above is 1, while to the left is 2; so store 2 with direction 'left'\nNow that the table is completed we can trace back through the table to construct the lcs\n. To do so, we start in the bottom right corner of the table, which will have the largest number. At each cell, check the direction. If the direction is \"up-left\", then the character at the current cell is part of the lcs\n, so prepend it to the result (since the traceback goes through the table in reverse). Whether the character is part of the lcs\nor not, follow the direction encoded in the cell to navigate the table until the value of the cell is zero.\nUsing the example above, the traceback would proceed as follows:\n- Start in the bottom right corner, where the value stored is 2. This indicates any\nlcs\nhas a length of 2. As the direction isleft\n, move to the cell(d,d)\n- In the cell\n(d,d)\n, the direction isup-left\n, so'd'\nis the last character in anlcs\n. Prepend'd'\nto the result, which is then just\"d\"\nso far, and move to the cell(b,a)\n. - In the cell\n(b,a)\n, the direction isboth\n, and the algorithm could choose to go either to theleft\norup\n(with different resulting strings). For this example, the canonical direction isup\n, so navigate to the cell(a,a)\n. - In cell\n(a,a)\n, the direction isup-left\n, so'a'\nis the penultimate character in anlcs\n. Prepend'a'\nto the result to end up with a string of\"ad\"\nso far, and move to the cell('',b)\n. - In the cell\n('',b)\n, the value stored is 0, so the algorithm stops, and thelcs\nis\"ad\"\n.\nNote 1: In step 3, had the algorithm gone to the left\ninstead of up\n, the lcs\nwould have been \"bd\"\ninstead of \"ad\"\n.\nNote 2: It is possible to store the actual subsequences inside each cell, but such a solution would need to include all subsequences that could be arrived at in each cell, which would add to the space complexity.\nclass SolutionNode:\ndef \\_\\_init\\_\\_(self, direction=\"sink\", value=0):\n# valid directions are: sink, up, left, up-left, or both\nself.direction = direction\nself.value = value\ndef solution(s1, s2):\nif len(s1) == 0 or len(s2) == 0:\nreturn ''\n# building the table with the extra row and column\nlcs = [[SolutionNode() for x in range(len(s2)+1)]\nfor y in range(len(s1)+1)]\n# skip first row; it is supposed to be all zeros anyway\nfor i, row in enumerate(lcs[1:], 1):\n# skip first row; it is supposed to be all zeros anyway\nfor j, cell in enumerate(row[1:], 1):\nif s1[i-1] == s2[j-1]:\ncell.value = lcs[i-1][j-1].value + 1\ncell.direction = 'up-left'\nelif lcs[i][j-1].value == lcs[i-1][j].value:\ncell.direction = 'both'\ncell.value = lcs[i][j-1].value\nelif lcs[i][j-1].value > lcs[i-1][j].value:\ncell.direction = 'left'\ncell.value = lcs[i][j-1].value\nelse:\ncell.direction = 'up'\ncell.value = lcs[i-1][j].value\n# The table is built; now to traceback\ni = len(s1)\nj = len(s2)\nnode = lcs[i][j]\nval = node.value\nresult = ''\nwhile val > 0:\n# Could instead go 'left' on 'both'\nif node.direction == 'up' or node.direction == 'both':\ni -= 1\nelif node.direction == 'left':\nj -= 1\nelse:\ni -= 1\nj -= 1\n# need to prepend since this constructs the lcs in reverse\nresult = s1[i] + result\nnode = lcs[i][j]\nval = node.value\nreturn result\n1class SolutionNode:\n2 def \\_\\_init\\_\\_(self, direction=\"sink\", value=0):\n3 # valid directions are: sink, up, left, up-left, or both\n4 self.direction = direction\n5 self.value = value\n6def solution(s1, s2):\n7 if len(s1) == 0 or len(s2) == 0:\n8 return ''\n9 # building the table with the extra row and column\n10 lcs = [[SolutionNode() for x in range(len(s2)+1)]\n11 for y in range(len(s1)+1)]\n12 # skip first row; it is supposed to be all zeros anyway\n13 for i, row in enumerate(lcs[1:], 1):\n14 # skip first row; it is supposed to be all zeros anyway\n15 for j, cell in enumerate(row[1:], 1):\n16 if s1[i-1] == s2[j-1]:\n17 cell.value = lcs[i-1][j-1].value + 1\n18 cell.direction = 'up-left'\n19 elif lcs[i][j-1].value == lcs[i-1][j].value:\n20 cell.direction = 'both'\n21 cell.value = lcs[i][j-1].value\n22 elif lcs[i][j-1].value > lcs[i-1][j].value:\n23 cell.direction = 'left'\n24 cell.value = lcs[i][j-1].value\n25 else:\n26 cell.direction = 'up'\n27 cell.value = lcs[i-1][j].value\n28 # The table is built; now to traceback\n29 i = len(s1)\n30 j = len(s2)\n31 node = lcs[i][j]\n32 val = node.value\n33 result = ''\n34 while val > 0:\n35 # Could instead go 'left' on 'both'\n36 if node.direction == 'up' or node.direction == 'both':\n37 i -= 1\n38 elif node.direction == 'left':\n39 j -= 1\n40 else:\n41 i -= 1\n42 j -= 1\n43 # need to prepend since this constructs the lcs in reverse\n44 result = s1[i] + result\n45 node = lcs[i][j]\n46 val = node.value\n47 return result\nTime/Space Complexity\n- Time Complexity:\nO(m \\* n)\n. - Space Complexity:\nO(m \\* n)\n.\nAdditional Reading\nThe final solution can be further improved. One such way is the Hunt-Szymanski Algorithm.\nPractice the Longest Common Subsequence Problem With Our AI Interviewer\nPractice the Longest Common Subsequence Problem With Our AI Interviewer\nLongest Common Subsequence Frequently Asked Questions (FAQ)\nLongest Common Subsequence Frequently Asked Questions (FAQ)\nWhich approach to solving longest common subsequence is the most efficient?\nThe optimal time complexity of the longest common subsequence (LCS) algorithm is O(m \\* n)\n, where m\nand n\nare the lengths of the input strings. This is typically implemented using dynamic programming, where we create a matrix of size (m+1) x (n+1) to store the prefix lengths and fill the matrix iteratively, requiring examining each cell, which takes constant time. Another way to achieve this time complexity is using recursion with memoization, where we ensure no duplicate computations are made when visiting each node in the resursive tree. As a result, the overall time complexity is determined by the number of cells in the matrix or nodes in the recursive tree.\nWhat is the brute force approach to solving the longest common sequence problem?\nThe longest common subsequence (LCS) algorithm can be solved naively with recursion - the algorithm exhaustively explores all possible combinations of characters in both strings and returns the longest length. Without cacheing, this results in a large number of redundant computations, which leads to an exponential time complexity - O(2^(m + n))\n, where m and n are the lengths of the input strings. This inefficiency makes the brute force recursive approach impractical for larger input sizes.\nCan there be more than one longest common subsequence?\nNo, by definition, there can only be one longest common subsequence (LCS) between two strings. The LCS is defined as the longest subsequence that is common to both strings, meaning it appears in both strings in the same order but not necessarily consecutively.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/longest-common-subsequence",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Container With Most Water (Interview Solution)",
      "content": "What Is The Container With Most Water Problem?\nWhat Is The Container With Most Water Problem?\nContainer With the Most Water is a coding problem that involves finding the largest possible area that can be formed by two vertical lines on a graph, bound by the height of the shorter line. This problem can be solved using a two-pointer approach, which involves traversing the array from both sides and keeping track of the maximum area found so far.\nAn Example of the Container With the Most Water Problem\nAn Example of the Container With the Most Water Problem\nGiven n\nnon-negative integers a0, a1, a2, ..., a[n-1]\n, where each represents a point at coordinate (i, a[i])\n, n\nvertical lines are drawn such that the two endpoints of the line i\nis at (i, 0)\nand (i, ai)\n. Find two lines that, together with the x-axis, form a container that can hold the most amount of water possible.\nExample\n- Input:\nheights\n= [3, 9, 4, 8, 2, 6, 1] - Output: 24\nConstraints\n- number of integers n: [2, 10,000]\n- each integer a[i]: [0, 1,000]\nTwo Ways to Solve the Container With the Most Water Problem\nTwo Ways to Solve the Container With the Most Water Problem\nThere are two ways to approach the Container With the Most Water technical interview question: brute force or two pointers.\nApproach 1: Brute Force\nIn the context of this problem, the size of the 2D container is determined by multiplying its width by its height. The brute force approach is to use nested for loops to calculate all possible containers to find the largest one.\nTo accomplish this, we can iterate over the heights with an outer loop, and form a container with every other height to its right using an inner loop. Each subarray that we generate this way is a possible container - the container's size will be the lower of the two heights, multiplied by the distance between the heights.\nWe can track the max container size as we go and return the max container size at the end of our iteration.\nContainer With the Most Water Python, Javascript and Java Solution - Brute Force\ndef max\\_water(heights: list[int]) -> int:\nln = len(heights)\nmax\\_area = 0\nfor left\\_index in range(ln):\nleft\\_height = heights[left\\_index]\nfor right\\_index in range(left\\_index + 1, ln):\nright\\_height = heights[right\\_index]\nwidth = right\\_index - left\\_index\nheight = min(left\\_height, right\\_height)\narea = width \\* height\nmax\\_area = max(area, max\\_area)\nreturn max\\_area\n1def max\\_water(heights: list[int]) -> int:\n2 ln = len(heights)\n3 max\\_area = 0\n4 for left\\_index in range(ln):\n5 left\\_height = heights[left\\_index]\n6 for right\\_index in range(left\\_index + 1, ln):\n7 right\\_height = heights[right\\_index]\n8 width = right\\_index - left\\_index\n9 height = min(left\\_height, right\\_height)\n10 area = width \\* height\n11 max\\_area = max(area, max\\_area)\n12 return max\\_area\nTime / Space Complexity\n- Time complexity:\nO(n²)\n- Space complexity:\nO(1)\n. No need for extra space, since we’re just iterating over the matrix.\nThe nested loops produce O(n²)\ntime complexity.\nApproach 2 (Optimal): Two Pointers\nAlthough the brute force approach does not repeat any calculations, it ignores useful information that can help eliminate unnecessary calculations. For example, if a container has sides a[i]\nand a[j]\nsuch that a[i] < a[j]\n, all containers with sides a[i]\nto a[i+1], ... a[j-1]\nwill have a maximum height of a[i]\nwith a smaller width than j - i\n, producing less area than the original container. Thus, these possibilities do not need to be considered when we're looking for maximum area.\nInstead of trying every combination, we start the 2 pointers at opposite ends (indexes 0\nand n-1\n) to represent the sides of the container. After computing the area using the lower height and distance between the pointers, the options are to increment the left pointer or decrement the right pointer.\nBecause we want to maximize the water contained, move the pointer with the lower height toward the other pointer. If the heights are equal, we can update either pointer because any potential increase in the next height is limited by one of the equal existing heights. The process is repeated until the pointers meet.\nContainer With the Most Water Python, JavaScript and Java Solution - Two Pointers\ndef max\\_water(heights):\nleft\\_index = 0\nright\\_index = len(heights) - 1\nmax\\_area = 0\nwhile left\\_index < right\\_index:\nwidth = right\\_index - left\\_index\nleft\\_height = heights[left\\_index]\nright\\_height = heights[right\\_index]\nmin\\_height = min(left\\_height, right\\_height)\narea = width \\* min\\_height\nmax\\_area = max(area, max\\_area)\nif left\\_height <= right\\_height:\nleft\\_index += 1\nelse:\nright\\_index -= 1\nreturn max\\_area\n1def max\\_water(heights):\n2 left\\_index = 0\n3 right\\_index = len(heights) - 1\n4 max\\_area = 0\n5 while left\\_index < right\\_index:\n6 width = right\\_index - left\\_index\n7 left\\_height = heights[left\\_index]\n8 right\\_height = heights[right\\_index]\n9 min\\_height = min(left\\_height, right\\_height)\n10 area = width \\* min\\_height\n11 max\\_area = max(area, max\\_area)\n12 if left\\_height <= right\\_height:\n13 left\\_index += 1\n14 else:\n15 right\\_index -= 1\n16 return max\\_area\n17\nTime / Space Complexity\n- Time complexity:\nO(n)\n- Space complexity:\nO(1)\nBecause the left or right pointer is moved toward the other in each iteration until they meet, the list of integers is traversed once.\nPractice the Container With the Most Water Problem With Our AI Interviewer\nPractice the Container With the Most Water Problem With Our AI Interviewer\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/container-with-most-water",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to Reverse a Linked List (Python, Java + more)",
      "content": "How to Solve Reverse a Linked List\nWhat is the Reverse Linked List Problem?\nWhat is the Reverse Linked List Problem?\nThe Reverse Linked List problem involves reversing the order of elements in a linked list, a data structure where each node is connected to the subsequent node with a pointer. The goal of this problem is to traverse the linked list while reversing the order of the pointers that link the nodes together.\nReverse Linked List Examples\nReverse Linked List Examples\nGiven the head of a linked list, reverse the list and return the new head.\nExample 1\nInput: [1,2,3,4,5]\nOutput: [5,4,3,2,1]\nExample 2\nInput: [1,2]\nOutput: [2,1]\nExample 3\nInput: [1]\nOutput: [1]\nConstraints\n- The number of nodes in the list is in the range [0, 5000].\n- -5000 <= Node.value <= 5000\nSolution to the Reverse a Linked List Interview Question\nSolution to the Reverse a Linked List Interview Question\nBefore we can reverse a linked list, let’s start our approach with a concrete understanding of how a singly linked list works. After all, this interview question is an opportunity to demonstrate your familiarity with the data structure. Unlike an array, a linked list is a recursive data structure - each node points to another node - which means we don't have random access to its members. Instead, for a singly linked list we're given a head node with a next property that points to the subsequent node in the list. For a doubly linked list, we would also have a prev\nproperty that points to the previous node on the list. Here's an example of a linked list with two listnodes:\nclass Node:\ndef \\_init\\_(self, value=None):\nself.value = value\nself.next = None\nn1 = Node(1)\nn2 = Node(2)\nn1.next = n2\nIn this original linked list, the first node (n1\n) points to the second node (n2\n) with the next\nproperty.\nIf this list were to be reversed, its clear that n2\nwould point to n1\n. But what would n1\npoint to? Recall that while n2\ndoes not have a child because it is at the end of the list, the node's next\nproperty still exists - it simply points to null\n. And while there is no node pointing to n1\n, we can imagine that its parent is null\n. So n1\nwould point to null\n.\nWe can imagine a null\nnode at the head and the tail of the list.\nAt minimum, reversing a given linked list will require updating each node's next\npointer to reference its parent. Since we'll need to visit each node at least once, our solution space is limited to a linear traversal.\nLet's explore how we can update each linked list node in-place with a linear traversal. A linked list can be traversed both recursively and iteratively - in both approaches, we maintain a reference to the current node, its parent, and its child, and re-assign the next\nreference for each node.\n1. Recursive Approach\nSince a linked list is an inherently recursive data structure, it makes sense that we can employ a recursive approach. Let’s consider a post-order recursive traversal to reverse the list. Why \"post-order\"? The key here is to recurse on each subsequent node until the last node is reached, and then update the next\npointers as each execution pops off the call stack.\nEach call to the recursive function reverse\\_list\nis passed in a reference to the current node's child, which adds a new execution frame to the call stack.\nOnce a null\nnode is reached (our base case), we begin the reassignment process. As each context is popped off the stack, we assign the current node's child's next\npointer to the current node, effectively reversing its reference. Then return the reversed list so far.\nWe also set the current node's next\npointer to null\n- this will be overwritten once the subsequent recursive call is resolved, except for the original head which is now the tail and therefore has no next\nnode.\nReverse Linked List Python and JavaScript Recursive Solutions\nclass Solution:\ndef reverse\\_list(curr\\_node: Node) -> Node:\nif not curr\\_node or not curr\\_node.next:\nreturn curr\\_node\nprev = self.reverse\\_list(curr\\_node.next)\ncurr\\_node.next.next = curr\\_node\ncurr\\_node.next = None\nreturn prev\n1class Solution:\n2 def reverse\\_list(curr\\_node: Node) -> Node:\n3 if not curr\\_node or not curr\\_node.next:\n4 return curr\\_node\n5 prev = self.reverse\\_list(curr\\_node.next)\n6 curr\\_node.next.next = curr\\_node\n7 curr\\_node.next = None\n8 return prev\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(n)\nAlthough we are not constructing a new linked list, recursion requires linear space on the call stack to maintain a reference to each execution context.\n2. Iterative Approach\nReversing a linked list with an iterative approach is more space efficient than the recursive solution, and tends to be more easy to grasp. The task of any iterative traversal is managing pointers across iterations.\nFirst, let's set up our state-of-the-world for the head (input) node.\nprev\npoints to null\n(the head has no parent), curr\npoints to the current node (the head), and, if there is indeed a current node, temp\\_next\npoints to the current node's child.\nAt each iteration, we assign the current node's next\npointer to the node at prev\n(reversing the reference). We then iterate forward by pointing prev\nto the current node and curr\nto the original next\nnode.\nWe continue this process until a null\nchild is reached - at which point we can return the most recent prev\nnode which is our new head.\nReverse Linked List Python and JavaScript Solutions - Iterative\nclass Solution:\ndef reverse\\_list(self, node: Node) -> Node:\nprev = None\ncurr = node\nwhile curr:\ntemp\\_next = curr.next\ncurr.next = prev\nprev = curr\ncurr = temp\\_next\nreturn prev\n1class Solution:\n2 def reverse\\_list(self, node: Node) -> Node:\n3 prev = None\n4 curr = node\n5 while curr:\n6 temp\\_next = curr.next\n7 curr.next = prev\n8 prev = curr\n9 curr = temp\\_next\n10 return prev\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(1)\nPractice the Reverse a Linked List Problem With Our AI Interviewer\nPractice the Reverse a Linked List Problem With Our AI Interviewer\nReverse a Linked List Frequently Asked Questions (FAQ)\nReverse a Linked List Frequently Asked Questions (FAQ)\nWhat is a linked list?\nA linked list is a data structure that consists of a sequence of nodes, each of which contains two parts: a data element and a reference to the next node in the sequence. The nodes are linked together, forming a chain. Unlike an array, a linked list is a recursive data structure - each node points to another node - which means we don't have random access to its members. Instead, we're given a head node with a next property that points to the subsequent node in the list.\nWhy do you reverse a linked list?\nSince a singly linked list is a directional data structure, the list nodes can only be accessed in a fixed, linear order. There are a few reasons why a software engineer may need to reverse a linked list.\n- Performance optimization: if performing a search operation on a sorted linked list and you're looking for a value at the end of the list.\n- User experience: when displaying a list of messages, you may want the user to be able to reverse the sort order.\n- Traversal: if we are storing something like browser or operation history in a linked list and we want to traverse backward along the same path.\nWhat is the fastest way to reverse a linked list?\nYou can reverse a linked list with either a recursive or iterative approach. Both approaches run in linear time, O(n)\n. The recursive approach requires constant space, and the iterative approach requires O(n)\nspace.\nHow do you reverse a linked list without using recursion?\nYou can use an iterative approach! Reversing a linked list iteratively is more space efficient than recursion and tends to be more easy to grasp. The task of any iterative traversal is managing pointers across iterations. To do this, you’ll need 3 pointers: prev\n, curr\n, and temp\\_next\n. prev\nstarts out pointing to null (the head has no parent), curr\npoints to the current node (the head), and, if there is indeed a current node, temp\\_next\npoints to the current node's child. At each iteration, we assign the current node's next pointer to the node at prev\n(reversing the reference). We then iterate forward by pointing prev\nto the current node and curr\nto the original next node. We continue this process until a null child is reached - at which point we can return the most recent prev\nnode which is our new head.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/reverse-linked-list",
      "author": "",
      "user_id": ""
    },
    {
      "title": "K Closest Points To Origin (Interview Question and Solution)",
      "content": "How to Solve K Closest Points To Origin\nK Closest Points To Origin Introduction\nK Closest Points To Origin Introduction\nThe K Closest Points To Origin problem involves comparing the distance of points plotted on a graph. This is a common problem in data analysis, most often found in the context of generating nearest neighbor sets. Similar to other k-selection algorithms, this problem can be solved with a variety of sorting techniques and challenges us to use a heap data structure to improve time complexity. Before viewing the problem and solution, below are some short video snippets from real mock interviews to help prepare you for some common pitfalls that interviewees stumble into.\n• Problem\n• Solution\n• Interview Analysis: Snippets from Real Interviews 🔥\n-\nCommon Mistakes: Forgetting Data Structures\nEven if you do a good job otherwise, forgetting what a certain data structure looks like could be grounds for failure. Watch this example to see what a real interviewer thinks when this happens. -\nCommon Mistakes: Syntax Errors\nInterviewees often know more than one programming language. Before you interview, you should familiarize yourself with the language you will be interviewing in, especially if it differs from the one you use at work. -\nCommon Mistakes: Variable Names and Data Types\nVariables and data types are foundational concepts, but experienced engineers still make these simple mistakes. -\nSenior Level Extension Question\nSee what separates a senior engineer from a junior/mid-level. -\nPossible Approach: Checking Distance\nFind out how a senior engineer recommends checking distance in this question. It'll surprise you. -\nOptimization: Size Efficiency\nYou've heard the phrase \"Size isn't everything, it's how you use it.\" That couldn't be more true for this question!\nK Closest Points To Origin Problem\nK Closest Points To Origin Problem\nGiven a list of tuples that represent (X, Y) coordinates on an XY plane and an integer K, return a list of the K-closest points to the origin (0, 0).\nExample Inputs and Outputs\nExample 1\nInput:\npoints = [[5, 5], [3, 3], [4, 4]], k = 2\nOutput:\n[[3, 3], [4, 4]] or [[4, 4], [3, 3]]\nExample 2\nInput:\npoints = [[-1, 4], [5, 3], [-1, -1], [8, -6], [1, 2]], k = 2\nOutput:\n[[-1, -1], [1, 2]] or [[1, 2], [-1, -1]]\nConstraints\nThe number of nodes in the list is in the range [0, 5000]\nK is >= 0 and <= the length of the input list\nK Closest Points To Origin Solutions\nK Closest Points To Origin Solutions\nReading through the problem a few ideas immediately jump out:\n- We need to calculate the distance of each point from the origin (or at a minimum convert the coordinate tuple to a numerical value)\n- Once the distance has been calculated we need to determine the K-closest points\nTo solve this problem we will need to do some basic algebra. We have a right triangle and we need to calculate the length of the hypotenuse, and we can do so using the Pythagorean theorem:\nA^2 + B^2 = C^2\nAs a quick aside, we don't actually need to calculate C\n(the hypotenuse, or distance from origin), as simply calculating A^2 + B^2\nfor each coordinate will allow us to order the points from closest to furthest from origin without actually determining the exact distance.\nNow that we know how to calculate the distances, let's explore different ways to find the k-closest points.\n1. Sorting\nGiven we need to find the K\nclosest points to origin, the naive approach should hopefully become clear relatively quickly. If we calculate the distance for each coordinate pair, we can then sort the coordinates by distance and finally slice the list from 0 to K\nin order to return the K\nclosest points to the origin.\nK Closest Points to Origin Python and JavaScript Solutions - Sorting\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n# Note: Sorting the input list mutates the input\n# -> whether the input should be mutated (as opposed to copied and then sorted)\n# -> can be decided collaboratively with the interviewer\npoints.sort(key=lambda xy\\_tuple: xy\\_tuple[0]\\*\\*2 + xy\\_tuple[1]\\*\\*2)\nreturn points[:k]\n1def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n2 # Note: Sorting the input list mutates the input\n3 # -> whether the input should be mutated (as opposed to copied and then sorted)\n4 # -> can be decided collaboratively with the interviewer\n5 points.sort(key=lambda xy\\_tuple: xy\\_tuple[0]\\*\\*2 + xy\\_tuple[1]\\*\\*2)\n6 return points[:k]\nTime/Space Complexity Analysis\n- Time Complexity:\nO(n \\* log(n))\n- Space Complexity:\nO(k)\n, as we are sorting in place and returning a new list withK\npoints\n2. Using a Heap\nGiven we have found a somewhat-obvious, naive solution that runs in O(n\\*log(n))\ntime, we should start thinking about how we can use different approaches or data structures in order to optimize the time complexity of our algorithm. In order to improve our time complexity we will need to avoid fully sorting the input, and if we aren't sorting the input we will need to repeatedly select the point with the smallest distance from the origin.\nIt is here that alarm bells should start to go off in our head. What data structure can be used to efficiently, repeatedly select the smallest (or largest) item in a collection? And the answer is... a heap!\nTo give a quick refresher, heaps are an ordered (but not fully sorted) data structure often backed by an array. They can be created in linear time and they ensure selection of the smallest or largest element at any given time, but they are not fully in order. Read more about how heaps are constructed and used here.\nBack to our problem, we can iterate over the list, calculate the distance from the origin for each coordinate and convert it to a heap in place. From there, in order to find the K\nclosest points to the origin we will need to pop\nfrom the heap K\ntimes, which is often a method exposed via heap library code in a given language.\nK Closest Points to Origin Python and JavaScript Solutions - Using a Heap\nimport heapq\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n# O(n)\ndistance\\_coordinate\\_tuples = [(x\\*x + y\\*y, [x, y]) for x, y in points]\n# O(n)\nheapq.heapify(distance\\_coordinate\\_tuples)\n# O(k\\*log(n))\nk\\_smallest = heapq.nsmallest(k, distance\\_coordinate\\_tuples)\n# O(k)\nreturn [coordinate for distance, coordinate in k\\_smallest]\n# same as above as a one-liner\ndef kClosest(self, points, k):\nreturn heapq.nsmallest(k, points, key=lambda p: p[0]\\*\\*2 + p[1]\\*\\*2)\n1import heapq\n2def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n3 # O(n)\n4 distance\\_coordinate\\_tuples = [(x\\*x + y\\*y, [x, y]) for x, y in points]\n5 # O(n)\n6 heapq.heapify(distance\\_coordinate\\_tuples)\n7 # O(k\\*log(n))\n8 k\\_smallest = heapq.nsmallest(k, distance\\_coordinate\\_tuples)\n9 # O(k)\n10 return [coordinate for distance, coordinate in k\\_smallest]\n11# same as above as a one-liner\n12def kClosest(self, points, k):\n13 return heapq.nsmallest(k, points, key=lambda p: p[0]\\*\\*2 + p[1]\\*\\*2)\nTime/Space Complexity Analysis\n- Time Complexity:\nO(n) + O(k\\*log(n))\n- Space Complexity:\nO(1)\n(orO(n)\nif you mutate the input)\nPractice the K Closest Points To Origin Problem With Our AI Interviewer\nPractice the K Closest Points To Origin Problem With Our AI Interviewer\nK Closest Points To Origin Analysis\nK Closest Points To Origin Analysis\nCommon Mistakes: Forgetting Data Structures\nOften candidates may have a great understanding of programming and problem solving skills. However if you haven't practised in a while, you may find you have forgotten what some data structures look like or how to fully implement them. In this snippet the interviewer notes that the candidate has a good understanding of algorithms and data structures but struggles with mapping those concepts onto the STL libraries. Noting the fact that the candidate had to look up what a priority queue looked like. In a real interview, this can definitely hinder your chances of passing even though you certainly have the knowledge and capabilities. Practise makes perfect, so ensure you brush up before you interview!\nCommon Mistakes: Syntax Errors\nProspective candidates will often be knowledgeable in more than one programming language. During mock technical interviews, it is important to practise and familiarize yourself with the language you will be interviewing in, especially if it differs from the native language you code in at your current job. In this snippet the the candidate notes that they more comfortable with C++ even though they mainly work with Java on the job. The interviewer points out some syntax errors in the candidate's code, specifically with creating a vector, and suggests a simpler solution. The interviewer speculates that the candidate may be trying to apply Java syntax to their C++ code.\nCommon Mistakes: Variable Names and Data Types\nWhen calculating distance in this question, it is important to use the double data type as opposed to int. This snippet shows the importance of looking out for small mistakes in variable data types and names that can lead to errors when running code.\nSenior Level Extension Question\nMany solutions to the K closest points question do not take into account what would happen if given a large data set of points or a near infinite stream of points. A MapReduce is one solution to this problem. At a mid to senior level there is an expectation that candidates understand how to use a MapReduce. In this example after much deliberation and guidance, the candidate suggests using a MapReduce, but was unsure of the specifics and unable to implement one. The interviewer noted that the candidate's lack of experience with MapReduce could be a concern for a mid-level position, emphasizing the importance of distributed systems in handling large amounts of data. This scenario highlights the practical challenges of scaling algorithms to real-world data and the need for senior-level expertise in handling such issues.\nPossible Approach: Checking Distance\nIn this snippet the interviewer suggests checking if it's the first k instead of checking if the distance is less than the minimum. This is a key tip when tackling similar problems - Often candidates rush into creating a loop and forget to add code to check if you have K.\nOptimization: Size Efficiency\nIn this snippet the candidate suggests optimizing the comparator function by using a map to store distance-to-pair values, rather than recalculating distances each time. The interviewer discuss the potential challenges of working with larger data sets and to explore ways to keep the data size efficient, such as storing only the distance and index of the original point.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/k-closest-points-to-origin",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Kth Smallest Element (Interview Solution)",
      "content": "How to Solve Kth Smallest Element\nWhat is the Kth Smallest Element Problem?\nWhat is the Kth Smallest Element Problem?\nThe Kth Smallest Element in an Array problem that involves searching through an array of integers and finding the k'th smallest element. Although on the surface this task is trivial, the challenge is in applying advanced sorting algorithms and data structures, such as a heap, recursion, and quickselect, and communicating tradeoffs in time complexity.\nKth Smallest Element in an Unsorted Array Examples\nKth Smallest Element in an Unsorted Array Examples\nGiven an integer array nums\nand an integer k\n, return the kth\nsmallest element in the array.\nExample 1\nInput: nums = [1,5,7,6,4,3,2], k = 3 Output: 3\nExample 2\nInput: nums = [1,1,1,2,2,3], k = 3 Output: 1\nExample 3\nInput: nums = [1], k = 1 Output: 1\nConstraints\n- 1 <= nums.length <= 100000\n- -10000 <= nums[i] <= 10000\nSolution to the Kth Smallest Element Interview Question\nSolution to the Kth Smallest Element Interview Question\nThere are three strategies you can use to solve the kth smallest element in an unsorted array problem — Brute Force, Heap, and Quickselect.\n1. Brute Force\nThe naïve approach to solving the problem would be to:\n- sort the array in increasing order and then,\n- pick the kth element of the array\nHowever, sorting the array would take O(n log(n))\nworst-case time complexity here, where n\nis the size of the array.\nDuring the interview, try not to spend more than 5 minutes discussing the brute force solution. The interviewer will be more interested in the optimal solution(s).\nTime/Space Complexity\n- Time Complexity:\nO(n log(n))\n, wheren\nis the number of elements in nums. - Space Complexity:\nO(1)\n, no additional data structure used.\n2. Heap Approach\nBy using the brute force sorting technique, we are unnecessarily sorting the entire array of n\nelements. Since we are interested only in the kth\nelement in sorted order, we could possibly restrict the sorting/re-arrangement to k\nelements, which would limit the sorted array to a length of k\n. The heap data structure helps us to achieve this optimization.\nHeap Approach Steps\n- Create a max heap of size\nk\n. - Insert each element into the heap - with each insert, we “heapify”, which means we re-sort the elements to satisfy the heap property.\n- If the size of the heap exceeds\nk\n, pop the top element of the heap. - After traversing all the elements of the array, return the top element of the heap.\nNote that if we were looking for the kth largest element, we would perform the same above steps with a min-heap.\nReplacing the top element of the heap of size k\ntakes logk\ntime. So in the worst case, it would be done n\ntimes and effectively, the time taken would be O(nlogk)\n.\nKth Smallest Element Python and Java Solutions - Heap\nimport heapq\nclass Solution:\ndef findKthSmallest(self, nums: List[int], k: int) -> int:\n# 1: Create max heap (simulated by negative values)\nmax\\_heap = []\nfor element in nums:\n# 2: Insert each element to the heap\nheappush(max\\_heap, -element)\n# 3: If the size of the heap exceeds k, pop the element at the top\nif len(max\\_heap) > k:\nheappop(max\\_heap)\n# 4: return top element of max heap\nreturn -heappop(max\\_heap)\n1import heapq\n2class Solution:\n3 def findKthSmallest(self, nums: List[int], k: int) -> int:\n4 # 1: Create max heap (simulated by negative values)\n5 max\\_heap = []\n6\n7 for element in nums:\n8\n9 # 2: Insert each element to the heap\n10 heappush(max\\_heap, -element)\n11 # 3: If the size of the heap exceeds k, pop the element at the top\n12 if len(max\\_heap) > k:\n13 heappop(max\\_heap)\n14\n15 # 4: return top element of max heap\n16 return -heappop(max\\_heap)\nTime/Space Complexity\n- Time Complexity:\nO(n log(k))\n, wheren\nis the number of elements in nums andk\nis the heap size. - Space Complexity:\nO(k)\n, for the heap.\n3. Quickselect Approach\nQuickselect algorithm is an algorithm quite similar to quicksort algorithm where you repeatedly partition a given array based on a pivot element, repeating the process until you have a subarray of length of one. Elements less than the pivot are moved to the left, and elements greater than the pivot are moved to the right. After each partition step, the pivot element is at the correct position in the ordered list. Since we are interested in the kth\nelement, we would have derived that when the pivot element index in the array becomes k-1\n. If the pivot index is greater than target index k-1\n, continue partitioning on the left side; if the pivot index is smaller than target index k-1\n, then partition on the right side. In a particular iteration, if the pivot element index becomes k-1\n, we can return the pivot element itself.\nThe average case time complexity of quickselect algorithm is O(n)\n. However, in the worst case, the time complexity is O(n²)\n— this could be the case when you have lot of repeated elements. Make sure to discuss this with the interviewer before moving on to coding!\nKth Smallest Element Python and Java Solutions - Quickselect\nclass Solution:\ndef partition(self, left: int, right: int, nums: list[int]):\n# get random pivot index\npivot\\_index = random.randint(left, right)\npivot\\_value = nums[pivot\\_index]\n# move pivot element to the end\nnums[pivot\\_index], nums[right] = nums[right], nums[pivot\\_index]\n# when we find an element less than pivot\\_value, move it left of pivot\\_index and increment the swap position\ni = left\nfor j in range(left, right):\nif nums[j] < pivot\\_value:\nnums[i], nums[j] = nums[j], nums[i]\ni += 1\n# move pivot to its final place\nnums[right], nums[i] = nums[i], nums[right]\nreturn i\ndef quickselect(self, left: int, right: int, k\\_target\\_index: int, nums: list[int]):\nif left == right:\nreturn nums[left]\n# find the pivot's correct position\npivot\\_index = self.partition(left, right, nums)\n# if the pivot index is equal to our target, we're done\nif k\\_target\\_index == pivot\\_index:\nreturn nums[pivot\\_index]\nelif k\\_target\\_index < pivot\\_index:\nreturn self.quickselect(left, pivot\\_index - 1, k\\_target\\_index, nums)\nelse:\nreturn self.quickselect(pivot\\_index + 1, right, k\\_target\\_index, nums)\ndef findKthSmallest(self, nums: List[int], k: int) -> int:\nn = len(nums)\nreturn self.quickselect(0, n - 1, k - 1, nums)\n1class Solution:\n2 def partition(self, left: int, right: int, nums: list[int]):\n3 # get random pivot index\n4 pivot\\_index = random.randint(left, right)\n5 pivot\\_value = nums[pivot\\_index]\n6 # move pivot element to the end\n7 nums[pivot\\_index], nums[right] = nums[right], nums[pivot\\_index]\n8 # when we find an element less than pivot\\_value, move it left of pivot\\_index and increment the swap position\n9 i = left\n10 for j in range(left, right):\n11 if nums[j] < pivot\\_value:\n12 nums[i], nums[j] = nums[j], nums[i]\n13 i += 1\n14 # move pivot to its final place\n15 nums[right], nums[i] = nums[i], nums[right]\n16 return i\n17\n18 def quickselect(self, left: int, right: int, k\\_target\\_index: int, nums: list[int]):\n19 if left == right:\n20 return nums[left]\n21 # find the pivot's correct position\n22 pivot\\_index = self.partition(left, right, nums)\n23 # if the pivot index is equal to our target, we're done\n24 if k\\_target\\_index == pivot\\_index:\n25 return nums[pivot\\_index]\n26 elif k\\_target\\_index < pivot\\_index:\n27 return self.quickselect(left, pivot\\_index - 1, k\\_target\\_index, nums)\n28 else:\n29 return self.quickselect(pivot\\_index + 1, right, k\\_target\\_index, nums)\n30\n31 def findKthSmallest(self, nums: List[int], k: int) -> int:\n32 n = len(nums)\n33 return self.quickselect(0, n - 1, k - 1, nums)\nTime/Space Complexity\n- Time Complexity:\nO(n)\nin average,O(n²)\nin worst-case. - Space Complexity:\nO(1)\nPractice the Kth Smallest Element Problem With Our AI Interviewer\nPractice the Kth Smallest Element Problem With Our AI Interviewer\nKth Smallest Element Frequently Asked Questions (FAQ)\nKth Smallest Element Frequently Asked Questions (FAQ)\nHow do you find the kth smallest element in an array?\nThere are 3 ways to solve this problem: brute force, using a heap, and using quickselect. The brute force approach would be to sort the array, and then pick the kth element in the array. This approach runs in O(n log(n))\ntime because you have to sort. A more efficient approach is to use a heap. To do this, you would create a max heap of size k and insert each element into the heap. If the size of the heap exceeds k, pop the top element of the heap. Finally, after traversing all the elements of the array, return the top element of the heap. This approach runs in O(nlogk)\ntime. Finally, you could use quickselect. The idea behind quickselect is similar to quicksort, but instead of sorting the entire array, quickselect only focuses on the elements that are needed to find the kth smallest element. The average case time complexity of the quickselect algorithm is O(n)\n, but in the worst case the time complexity is O(n²)\n- this could be the case when you have a lot of repeated elements.\nWhat's the most efficient way to find the kth smallest element in an array?\nIt depends. Using a heap will run in O(nlogk)\ntime, and using quickselect will run in O(n)\non average but could go up to O(n²)\nin the worst case.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/kth-smallest-element",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Reverse Words in a String (Python)",
      "content": "What is the Reverse Words in a String Problem?\nWhat is the Reverse Words in a String Problem?\nReverse Words in a String is a programming problem that requires you to take a string of words and return a new string with the order of the words reversed. This problem invites us to use native string and array methods, by looping over the input string in reverse and building a new string to return, and can even be done in-place using languages that permit string mutation.\nAn Example of the Reverse Words in a String Problem\nAn Example of the Reverse Words in a String Problem\nGiven an input string s\n, reverse the order of the words without reversing the words themselves.\nNote that the input string s\nmay contain multiple spaces between any given two words, as well as leading or trailing spaces; however, the return sentence should only have a single space between all words and should not have any leading or trailing space.\nExample 1 Input: s = “This sentence is forwards” Output: “forwards is sentence This”\nInput: s = “ a blue whale rhino Boston arepa heaven “ Output: s = “heaven arepa Boston rhino whale blue a“\nConstraints\n- The string will only contain upper-case and lower-case letters (no punctuation)\n1 <= s.length <= 10,000\nSolutions to the Reverse Words in a String Interview Question\nSolutions to the Reverse Words in a String Interview Question\nThere are two methods for reversing words in a string. One method is splitting on spaces, reversing the list and joining. Alternatively, you can reverse the string in place.\nApproach 1: Split on Spaces, Reverse the List and Join\nThis specific problem can be tackled in a manner similar to how we'd approach it if we were solving manually (remember, in an interview setting you always want to communicate your strategy, especially for multi-step solutions like this):\nIdentify all the individual words at the beginning and end of the string, and then trim/eliminate the unneeded space. Reverse the order of the words and build the string back up to form the result.\nDiving into the code, most modern programming languages provide a standard library method to split a string on a given character, in this case ” “\n.\nReverse Words in a String Python and Ruby Solutions - Split on Spaces, Reverse the List and Join\ns = “ this is a string “\nwords = s.split(“ “)\nprint(words) # ['', 'this', 'is', '', 'a', 'string', '', '']\n1s = “ this is a string “\n2words = s.split(“ “)\n3print(words) # ['', 'this', 'is', '', 'a', 'string', '', '']\nWhen we use this method, note how both trailing and leading spaces end up in the words list as empty strings. We can then filter\nthe words list in order to remove the empty strings:\nwords = s.split(“ “)\nfiltered\\_words = [s for s in words if s != '']\nprint(filtered\\_words) # ['this', 'is', 'a', 'string']\n1words = s.split(“ “)\n2filtered\\_words = [s for s in words if s != '']\n3print(filtered\\_words) # ['this', 'is', 'a', 'string']\n4\nAll we have left to do now is reverse the list and join the words with a space between them, and in the end we have a fairly straightforward algorithm.\nclass Solution:\ndef reverseWords(self, s: str) -> str:\nwords = s.split(' ')\nfiltered\\_words = [s for s in words if s != '']\nreturn ' '.join(filtered\\_words[::-1])\n1class Solution:\n2 def reverseWords(self, s: str) -> str:\n3 words = s.split(' ')\n4 filtered\\_words = [s for s in words if s != '']\n5 return ' '.join(filtered\\_words[::-1])\n6\nTime/Space Complexity\n- Time complexity:\nO(n)\n, as the interpreter iterates over the input string once and the list of words twice. - Space complexity:\nO(n)\n, to store the list of words after splitting by spaces.\nApproach 2: In-place\nLet’s pretend that you find yourself in an interview and your interviewer has asked a follow up question: “Is it possible to solve this problem and be more efficient from a space complexity standpoint?”\nWe already know our first solution is O(n)\n, leaving O(log(n))\nand O(1)\nas the two most common ways to improve. A log(n)\nalgorithm is most often related to dividing and conquering or binary search, and neither of those concepts apply here. So how can we make our solution constant space? We aren’t allowed extra memory, so the only way to do so is by mutating the string in place.\nDepending on the coding language being used, strings are either mutable or immutable. If a given language has immutable strings this means that the string can't be edited in-place without creating a new string in memory (which is a O(n)\noperation, with n\nbeing the length of the string). Conversely, if a given language has mutable strings that means the string can be edited in-place, similar to an array/list.\nFor example, in Ruby:\ns = ‘0123456789’ # note this is a string\ns[1..8] = s[1..8].reverse\n# the ruby version of print() or console.log()\nputs s # ‘0876543219’, as ‘12345678’ has been reversed in-place\n1s = ‘0123456789’ # note this is a string\n2s[1..8] = s[1..8].reverse\n3\n4# the ruby version of print() or console.log()\n5puts s # ‘0876543219’, as ‘12345678’ has been reversed in-place\n6\nTo read more about mutable vs immutable strings, check out this article on the topic by MIT.\nIf coding in a language with immutable strings (Python, Javascript, Java, etc.) mutating the string will not work, however there may be classes or libraries (such as Stringbuilder in Java) that would allow you to employ a similar approach - an interviewer may let you just assume you have one of these imported.\nTo mutate the string in place the algorithm can again be broken down into multiple steps:\n- Identify the distinct words by iterating over the string looking for spaces\n- Reverse the words in place one word at a time, trimming/skipping extra spaces while iterating\n- Trim any unneeded space from the end of the string\nReverse Words in a String Ruby Solution - In-place String Mutation\ndef reverse\\_words(s)\ns.reverse!\nl = 0\nr = 0\ni = 0\nn = s.length\nwhile i < n\n# find the next space\nwhile i < n and s[i] != ' '\ns[r] = s[i]\nr += 1\ni += 1\nend\nif l < r\n# reverse the current word\ns[l..r-1] = s[l..r-1].reverse\ns[r] = ' '\nr += 1\nl = r\nend\ni += 1\nend\n# trim end of string since we have shuffled string to the left\ns.slice!(r..s.length)\ns.strip!\nreturn s\nend\n1def reverse\\_words(s)\n2 s.reverse!\n3\n4 l = 0\n5 r = 0\n6 i = 0\n7 n = s.length\n8\n9 while i < n\n10\n11 # find the next space\n12 while i < n and s[i] != ' '\n13 s[r] = s[i]\n14 r += 1\n15 i += 1\n16 end\n17\n18 if l < r\n19 # reverse the current word\n20 s[l..r-1] = s[l..r-1].reverse\n21\n22 s[r] = ' '\n23 r += 1\n24 l = r\n25 end\n26\n27 i += 1\n28 end\n29\n30 # trim end of string since we have shuffled string to the left\n31 s.slice!(r..s.length)\n32\n33 s.strip!\n34\n35 return s\n36\n37end\n38\nTime/Space Complexity\n- Time complexity:\nO(n)\n, as we iterate over the string with multiple pointers but only do one iteration of each pointer. - Space complexity:\nO(1)\nPractice the Reverse Words in a String Problem With Our AI Interviewer\nPractice the Reverse Words in a String Problem With Our AI Interviewer\nReverse Words in a String Frequently Asked Questions (FAQ)\nReverse Words in a String Frequently Asked Questions (FAQ)\nHow do you reverse each word in a string?\nThere are two approaches you can take. The first is to split the string on spaces, reverse each word individually (see our in-depth solution to “reverse a string”), and then join them back. This approach runs in O(n)\ntime and requires O(n)\nspace.\nA more space-efficient solution is to reverse the entire sentence in place. Note that this approach only works in languages where strings are mutable. To mutate the string in place, you would identify words by iterating over the string looking for spaces. Then you’d reverse the words in place one word at a time. Finally you’d trim any unneeded spaces from the end of the string.\nThis solution still runs in linear time but requires only constant space.\nWhy can’t I just use the reverse() function to solve this problem?\nYou can… if you’re implementing sentence reversal in the real world. In an interview, however, you need to show your interviewer that you know how built-in functions work under the hood – that’s part of why interviewers ask questions like this.\nHow do you reverse each word in a string in Python?\nBecause strings are immutable in Python, you wouldn’t be able to reverse the string in place. As such, you can use the approach where you split the string on spaces, reverse each word, and then join them back, like so:\ndef reverseWords(self, s: str) -> str:\n3 words = s.split(' ')\n4 filtered\\_words = [s for s in words if s != '']\n5 return ' '.join(filtered\\_words[::-1])\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/reverse-words-in-a-string",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Amazon Leadership Principles Interview (questions + tips)",
      "content": "Before we dive into specific interview questions, it’s important to understand what the Amazon Leadership Principles are and what they mean for Amazon employees and team members.\nBelow we list the 16 Leadership Principles developed by Jeff Bezos and give a brief overview of each. We’ll also tell you how that value impacts the work environment and share some Leadership Principles questions which could probe for each LP. You’ll notice some of the questions seem irrelevant to the LP they’re listed under; that’s because some Amazonians intentionally design tricky questions. Don’t use these as a way to guess which LP a question is aimed at. For now, use them to start building a model in your head of what these interviews actually look like.\n1. Customer Obsession\nCustomer obsession is about giving the customer what they want before they know they want it. It’s a business-driver; engineers who are obsessed with delighting customers will churn out new features faster. Since Amazonians are encouraged to find ways to delight the customer before they know they’d like to be delighted, this promotes repeat business, effectiveness, and innovation.\nExample “Customer Obsession” questions:\n- Tell me about a time when you strongly disagreed with your manager or peer on something you considered very important to the business.\n- To try to meet the high expectations of our customers, we sometimes promise more than we can deliver. Tell me about a time when you overcommitted yourself or your company.\n2. Invent and Simplify\nAmazon rewards risk-taking. They push the bounds of what’s possible from cloud to e-commerce. They want big ideaters with business savvy; engineers at Amazon are encouraged to innovate as well as cut costs. As big as they grow, they still keep it simple: AWS is the biggest cloud provider in the world, yet Amazon.com strives to be their number one client. That’s an example of a simple solution to a complex problem, which is what this Leadership principle is all about.\nExample “Invent and Simplify” questions:\n- Tell me about a time when you didn’t meet customer’s needs.\n- Give me an example of a complex problem you solved with a simple solution.\n3. Learn and Be Curious\nVirtually every tech company’s marketing about their culture will include something like this. Curiosity drives learning. Amazon wants smart people who are never satisfied; they want you to always be learning. They promote taking big swings even if you end up missing. You can’t learn from your mistakes without curiosity.\nExample “Learn and Be Curious” questions:\n- Give me an example of a mission or goal you didn’t think was achievable. We all have things about ourselves we'd like to improve on at work. Give me an example of something that you've worked on to improve your overall work effectiveness.\n4. Insist on the Highest Standards\nOver the years, Jeff Bezos has repeated the mantra “Every day is day one.” He wants employees who approach every day as if they haven’t accomplished anything yet. That is a very high standard. Another reflection of Amazon’s high standards is how challenging and rewarding it is to become one of their most trusted interviewers, which is called a “Bar Raiser”. A good portion of those who apply don’t make the cut and if you make it your promotion packet gets a big boost. A Bar Raiser can veto the votes of all other interviewers in an onsite round. Those are high standards.\nExample “Insist on the Highest Standards” questions:\n- Tell me about a time when you had to work with a difficult customer or user.\n- Tell me about a time when you used external trends to improve your own company's products or services.\n5. Deliver Results\nAmazon aims for market domination. This is a company which values the “what” over the “why” and the “how”; they don’t care about how you get there or why you get there as much as they care about you getting there. You get there. In their interviews, they expect candidates to move quickly and without any hints, and they have coding questions on the easier side because they want to get to the optimal outcome as soon as possible.\nExample “Deliver Results” questions:\n- Could you tell me about a time where you were working on a project where you were working with another person. Over time, that person lessened their involvement in the project and you had to take on more responsibility.\n- Tell me about a strategic decision you had to make without clear data or benchmarks.\n6. Strive to be the Earth’s Best Employer\nIf you’re a software engineer, you won’t get asked about this.\n7. Dive Deep\nLike most tech companies, Amazon wants decisions to be made based on data; to implement an idea, you’ll need to show data. Where Amazon is different is this gritty mentality of “get the fricking job done”. Diving deep is essentially pulling yourself up by the bootstraps and making it happen. It’s also about developing a cultural attitude of people who are willing to get their hands dirty in order to win.\nExample “Dive Deep” questions:\n- Tell me about a time when you had to communicate a change in direction that you anticipated people would have concerns with.\n- Tell me about a time where you were thrown into a project where you had no experience in.\n8. Have Backbone; Disagree and Commit\nThis is the most misunderstood Leadership Principle. What it doesn’t mean is “I’ll stand up for myself. Then do it my way regardless of what you say.” What it actually means is “I verbalize the things I disagree on. Then I commit to taking action. Whether it was the action you or I proposed doesn’t matter: I’ll commit to following through on something.” This is also probably the most infamous LP, and it seems to be part of the reason for Amazonian interviewers' higher than normal level of intensity.\nExample “Have Backbone; Disagree and Commit” questions:\n- Often, we must make decisions as a group. Give me an example of a time you committed to a group decision even though you disagreed.\n- Tell me about a time where you disagreed with a coworker or PM or manager because you believed the decision they wanted to make was wrong for the customer.\n9. Success and Scale Bring Broad Responsibility\nUsually only eng managers get asked about this one, so we’ll skip it.\n10. Ownership\nTake accountability. Do all of, if not more than, what the job requires. The intention is to stimulate taking risks, having pride, and sacrificing for the business. Amazon wants folks who take big bets, hold themself to high expectations, and put in the hard work. This is one of the reasons they place a higher value on focusing on their individual contribution when answering Leadership Principles questions.\nExample “Ownership” questions:\n- Describe a time when you took on work outside of your comfort area.\n- Describe a situation where you made an important business decision without consulting your manager.\n11. Are Right, A Lot\nThis is another value that adds to the energy of a Leadership Principles interview: this is about competition. You have to know your stuff if you’re right, a lot. You also have to be willing to assert your point and back it up with all that data you dove deep for. This LP doesn’t mean Amazonians can’t mess up. They openly encourage candidates to describe times they were wrong, especially when they were wrong on a big gamble. Their ethical decision tree would look something like: Step 1: Dominate. Step 2: Did you dominate? If yes, proceed to success. If not, you better have risked enough to learn if and how domination is possible.\nExample “Are Right, A Lot” questions:\n- Tell me about a time when you did not effectively manage your projects and something did not get completed on time.\n- Tell me about a time you wouldn’t compromise on achieving a great outcome when others felt something was good enough.\n12. Hire and Develop the Best\nDomination requires finding great players and weeding out the subpar players. They’re the only FAANG company that has a formal title for their “best” interviewers: Bar Raisers. Not only does Amazon compete against other tech companies to find the “best” talent but\nthey also compete with themselves. You can interview with multiple teams simultaneously; it’s a dog-eat-dog world at Amazon and that includes dogs in the same pack.\nExample “Hire and Develop the Best” questions:\n- Tell me about a time when you received negative feedback.\n- Describe a time when you improved morale and productivity on your team.\n13. Think Big\nAmazon has a proven track record with huge ambition, large bets, and rapid expansion to new markets. Going to the moon, for one. Knowing your destination is one thing. It’s another level for your destination to be in the clouds (not an AWS joke, we swear). It’s about having a grand vision of the future so they can achieve those high standards.\nExample “Think Big” questions:\n- Give an example of a creative idea you had that proved really difficult to implement.\n- Tell me about a time when you encouraged a team member or organization to take a big risk.\n14. Bias for Action\nYou can’t take over the world if you don’t act. You might have the best idea to refactor the codebase in your head, but if it never moves towards implementation, it’s worthless. A straightforward way to make employees more productive is to openly encourage them to produce. Amazon’s bias against inaction affects their interview style: they’re looking for candidates who move fast without hints, who seek market domination, and who deliver results.\nExample “Bias for Action” questions:\n- Give me an example of a calculated risk that you have taken where speed was critical.\n- Tell me about a time where you were the first one to take action on something.\n15. Frugality\nAmazon is one of the rare companies who openly flaunts being frugal. Since when is “cutting costs” sexy? When it’s said by a group of the terminators who want to dominate the world, that’s when. Amazon wants you to not only figure out how to go to the moon, they want you to cut costs while you do it. One way to impress Amazon in the interview is to talk about the decisions you made in the past which saved the company money. You can learn how to do that in a later section of this guide called “\nHow to practice for Leadership Principles.”\nExample “Frugality” questions:\n- Tell me about a time you pushed back on a deadline.\n- Give me an example of how you have helped save costs or eliminate waste within your role or organization.\n16. Earn Trust\nThis is one of the rare Leadership Principles which is not about competition. It’s about cooperation. If you want to demonstrate cooperation, focus on how you understood the other person’s perspective. A difference of opinion is natural and healthy. This LP is about showing you know how to repair: either reactively after or proactively before a difference of opinion.\nExample “Earn Trust” questions:\n- Tell me about a time when you had a disagreement with a colleague or manager.\n- Describe a time when you needed to influence a peer who had a differing opinion about a shared goal.\nYou can read more about how Amazon defines these LPs\nhere.\nAmazon's interview process involves a)\nbehavioral interview rounds and b)\ntechnical interview rounds with a few behavioral questions thrown in. The behavioral questions will all focus on your work history. Importantly,\nAmazon will decide whether or not to hire you and how much responsibility to give you based partly on how well you demonstrate their Leadership Principles when you discuss your work history.\nWhat Amazon assesses is consistent between interviewers. Each interviewer will be assigned 1-3 LPs to look for when interviewing you. They're searching for signals on whether you: meet the bar, raise the bar, or are below the bar (for their assigned LPs).\nBut\nhow Amazon conducts the behavioral round varies widely. Our research has shown that if you were to observe sessions of 10 different LP interviewers, you would discover that each interviewer has their own way of determining a candidate's fit. One interviewer might ask more questions on fewer topics, while another interviewer may do the opposite. Complicating matters, upon observing the same behavior, different interviewers will likely perceive different signals. Notably,\nthere is no consensus on what makes a good answer good.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/amazon-leadership-principles",
      "author": "",
      "user_id": ""
    },
    {
      "title": "System Design Interview Guide for Senior Engineers",
      "content": "You may be reading this guide because you recently failed a system design interview. Or you watched a YouTube video that made system design seem like an overwhelming topic you’ll never fully grasp. Or perhaps you have years of experience working in the field, yet you struggle to demonstrate your technical prowess in the brief span of a system design interview.\nProfessional experience with distributed systems isn’t needed to pass system design interviews. And even if you do have that experience, keep in mind that many talented distributed systems engineers still struggle with the system design interview format. How you perform in an interview is not a measure of your worth as a software engineer—it is a measure of your ability to do system design interviews. The two are related but not equal; being a good programmer has a surprisingly small role in passing interviews.\nOne of our experts was asked: “As an experienced engineer without any scalable systems experience, how can I go into something like a FAANG system design interview when I have never designed those systems before?” Here’s the expert’s reply:\n\"I worked at Facebook for five and a half years. I learned more about system design from reading the internal interviewing wiki than I ever got from working at Facebook. They've got all kinds of distributed systems knowledge there, and it’s concentrated in a handful of infrastructure teams who build really great libraries and really great backend systems. That means that the rest of us never have to think about distributed systems. We get to say, 'I'm gonna make a new data type, and if I dump a billion records in it tomorrow, it doesn't matter. The systems folks have my back.' I worked at Facebook for a really long time, but I learned almost nothing about designing systems from experience.\"\nYou can pass system design interviews even if you’ve never designed distributed systems before. If you have copied files between machines with drag-and-drop, you are halfway there. If you implemented clients or servers or have opened network connections, you’ve got this. This guide will teach you the most important 20% of information that will appear 80% of the time in system design interviews. By the end of this guide you won’t be an expert, but you’ll be well on your way to being a better engineer and a much better interview candidate.\nWant to know exactly what a FAANG System Design interviewer looks for? Get detailed feedback on your system design skills from our professional interviewers.\nSee available timesIn this excerpt taken from Design Your Life, written by two Stanford professors and engineers, you’ll get a better understanding of how different problems require different approaches. We bolded to emphasize the parts that are most important to note.\n“There’s a difference between design problems and engineering problems... Engineering is a good approach to solving a problem when you can get a great deal of data and you’re sure there is one best solution. Bill [one of the authors] worked on the problem of engineering the hinges on Apple’s first laptops, and the solution he and his team came up with made those laptops some of the most reliable on the market. The solution required many prototypes and lots and lots of testing, similar to the design process, but the goal of creating hinges that would last five years (or opening and closing ten thousand times) was fixed, and his team tested many different mechanical solutions until they met their goal. Once this goal was met, the solution could be reproduced millions of times. It was a good engineering problem.\n“Compare this with the problem of designing the first laptop that had a ‘built in mouse’. Because Apple’s computers relied on the mouse to do almost everything, building a laptop that required you to be wired up to a regular mouse was unacceptable. This was a design problem. There was no precedent to design toward, there was no fixed or predetermined outcome; there were plenty of ideas floating around the lab, and a number of different designs were tested, but nothing was working. Then along came an engineer named Jon Krakower. Jon had been tinkering around with miniaturized trackballs, and had the crazy idea to push the keyboard to the back of the unit, leaving just enough room to squeeze in this tiny pointing device. This turned out to be the big breakthrough everyone had been looking for, and has been part of the signature look of Apple laptops ever since.\n“When you have a desired outcome (a truly portable laptop computer) but no clear solution in sight, that’s when you brainstorm, try crazy stuff, improvise, and keep ‘building your way forward’ until you come up with something that works. You know it when you see it. A great design comes together in a way that can’t be solved with equations and spreadsheets and data analysis. It has a look and feel all of its own - a beautiful aesthetic that speaks to you.”\nThis is one reason engineers new to system design can bomb their first couple of system design interviews spectacularly: They approach a design problem as if it’s an engineering problem. There is not a single “best” solution to a system design problem. There are no predetermined outcomes. The less code you write in a system design interview, the better.\nTo succeed in a system design interview, you want to collaborate with your interviewer, try crazy stuff, and try more crazy stuff until the design “feels right.”\nThe difference between coding and system design is the difference between retrieving and creating.\nInstead of finding (or “retrieving”) a solution, you are creating a solution. In this way, coding is akin to a science, while system design is more like an art.\nHere’s another way to think about it. You aren’t solving a problem—you’re creating a map to help someone else find the solution. Instead of coloring inside some lines, you’ll need to draw the lines for someone else to color in. In a system design interview, there are no correct answers—though there are certainly incorrect ones—so there is nothing to solve. Instead, you’ll ask questions, make stuff, and explain how and why the stuff you made was reasonable.\nDuring the interview, you’ll spend an hour playing the role of a Tech Lead, so just pretend that the interviewer is a junior engineer who will be implementing your design. Juniors will have lots of questions, and since you’re the Tech Lead, you want to welcome these questions.\n“Pretend it’s 1999, so a lot of the stuff we have access to today simply doesn’t exist. You and a group of your schoolmates are in your garage, hoping to make something. You're the most senior one there. You will design it and your friends will code it up, and the thing is: the Minimum Viable Product has to be completed by tomorrow. So, there’s no time to prep and no need to worry about the intricacies of system architecture that you don’t know. Just answer this: How would you design this system so your friends could code it up today, right now? It doesn’t have to be pretty. It doesn’t have to be complicated. It doesn’t have to impress anyone. It just has to get done.”\nThe value of communication in coding interviews is controversial (source). But without communication in a system design interview, nothing happens. By necessity, it’s more conversational in nature than a coding interview and will have more back and forth between interviewer and candidate.\nWith that said, sometimes you’ll have an interviewer who is cold or not very collaborative. Dealing with these interviewers requires practice. The more senior you become, the more important it is to learn how to adjust your communication style to match your audience. We recommend completing mock interviews with a variety of interviewers to help you become a seasoned, fearless veteran of system design interviews.\nThere’s no “right” way to design a system. If two experts designed the same system, you would see two different designs, beautiful and aesthetic in their own way and both as “correct” as the other (and with the accompanying justifications to support them).\nIn part 2, two experts will show you how they would each design the same system, providing you with a practical lesson on this topic.\n“If you want to be a great interview candidate you’ve gotta know… It’s your responsibility to leave breadcrumbs for the interviewer to go where you want them to go. That way you have them walk you down the road where you are at your best. And then the Jedi mind trick is to get them to think it was their idea to get you there.”\nWhat if your measurement of success in an interview isn’t what you say, but instead it’s what you get the interviewer to say? Imagine you say something that engages the interviewer’s curiosity so much that they have no choice but to follow up with a “tell me more about that.” If the areas you get them to dig into the deepest, are things you’re good at: congratulations you are doing the Jedi mind trick.\nA candidate doing a system design interview will usually experience confusion. The interview format is so open-ended, you cannot know about everything they'll ask you. However, there will be opportunities to strut your stuff. There will be moments when they ask you about something you know very well, and when this happens put your shoulders back and flex your muscles on this topic.\nWhen beginning an interview, try to imagine what the interviewer is looking for. What are their goals for the session? How can you help them achieve those goals in a way that persuades them that you’ll be a strong hire?\nPut simply, the interviewer's goal is to find enough data to hire you. Given the limited time available to them, an interviewer has to try to get enough positive signal about your ability so they can justify giving you a “hire” rating. In one hour you have to show your interviewer that you understand the fundamentals of a system (end to end). You also should be able to name and explain (at least at a high level) each part of the system, describe the tradeoffs you make, and find a solution.\nThe best way to accomplish this is to imagine that you’re explaining a design doc to a group of more junior engineers. They will ask you questions about your decisions and want to know what you’re trying to solve. Anticipating these questions and your responses will set you up for success in the interview.\nWant to know exactly what a FAANG System Design interviewer looks for? Get detailed feedback on your system design skills from our professional interviewers.\nSee available timesWith this basic model in mind, let's consider the main elements that system design interviewers look for, and the elements that don’t matter.\nYour interviewer will expect you to have knowledge of a wide range of basic topics, but they won't expect you to be an expert in any of them. For instance, you should understand the difference between SQL and NoSQL databases, their broad performance characteristics, and the types of applications each might be useful for (which we’ll teach you later in this guide). But you would not need to know how the internals of either type of database work at any kind of detailed level.\nIn spite of this, you still might be asked to design those internals! Keep in mind, though, that your answer doesn't need to be optimal or reflect real-world implementations. For example, if an interviewer asks you to design a database/SQL query engine, they're not trying to discern if you're familiar with the academic literature on query engines or discover how much time you've spent working on database internals.\nInstead, they want to see how you would approach the problem based on what you do know, starting from first principles and collaborating with them. Your answer will probably not be anywhere near optimal, and that's OK! The interviewer will focus on the process, not the result.\nInitial prompts to system design problems tend to be intentionally light on detail. Many candidates make a mistake by extrapolating details from the initial prompt and crafting a solution based on those assumptions.\nFor example, imagine that the interviewer instructs you to design a \"photo sharing service\" with some minimally defined capabilities. This may cause some candidates to imagine that they're rebuilding Instagram and start designing around the assumption that all images will be relatively small, not examined closely, and that extensive compression to save storage and bandwidth is acceptable.\nBut the interviewer didn’t tell you to rebuild Instagram, so you’ll need to keep in mind that there are many different types of photo sharing services. The interviewer may have had in mind something like Imgur or Photobucket, sites that cater more to basic image hosting for the web. Or they could be thinking about something like Flickr or 500px, services built for photographers to show off their work in high resolution.\nSo how do you figure out what type of service the interviewer wants you to build? Ask them! A basic prompt leaves room for you to start a conversation with your interviewer about the system you're designing—what type of users does it serve, what type of traffic can it expect, what limits will it have? Demonstrating that you can think critically about the parameters of your service is the first step in any system design interview.\nBe very careful any time you find yourself responding immediately to a prompt in a system design interview. Even aspects of your design that seem insignificant need at least cursory consideration. Let’s use IDs as an example.\nA candidate will often start a discussion of a data model with a statement like, \"I'll use auto incrementing IDs,\" or \"I'll use GUID here\" as kind of a default approach to assigning IDs to data. In many applications, however, the type of ID you assign to your data has practical consequences.\nIs this ID going to be exposed to users? If so, how long does it need to be to avoid collisions? If we auto-increment it, are we worried about the visibility that will give third parties into our traffic patterns or the possibilities of users guessing the IDs to each others' data? If it's intended to be shared, is it convenient to type? If you print it on a business card or a flier, does it contain characters that you could confuse for each other (e.g., “1” and “I”, “0” and “O”)?\nYou don't need to hold an inquiry for every minor detail, but always be sure to give some justification for the decisions you make and let your interviewer know how your decisions would change in different circumstances. System design problems don't have a single definitive answer, so interviewers just want to see that you can justify your answers.\nCoding problems usually have an expected path. Typically you'll begin with an obvious but inefficient solution, and then the interviewer will prompt you for a series of improvements. Those improvements lead you to increasingly efficient solutions until you finally arrive at the optimal implementation.\nSystem design problems, on the other hand, resemble a Choose Your Own Adventure book rather than a linear novel. A complex system contains a multitude of sub-components, each one of which could serve as a design problem on its own. After you've sketched the overall layout of your system, an interviewer may decide to keep your focus on the big picture or dive into a deeper examination of one particular component.\nThe path your interview takes will be steered by your interviewer, but they're likely to take cues from the sub-problems in which you display interest or aptitude. In some cases they may explicitly ask you which part of the problem you'd prefer to focus on.\nEven if you're not choosing directly, you can still influence an interview's direction. As you talk your way through a solution, it’s OK to specifically note the parts that you have experience in and explain when you're making educated guesses. Your interviewer won't expect you to know everything, but giving them a better idea of what you do know will help them steer the interview in ways that reveal your strengths and problem-solving ability.\nWhen faced with a choice in a design interview, it's easy to focus on the technical details, but remember that computer systems serve human users, so you’ll want to anchor your technical decisions to the user experience they enable.\nSuppose, for instance, that the image sharing service you're designing will require users to log in before uploading an image. In technical terms, you might want to avoid login to keep the database schema simpler, or you could introduce login to gather better metrics. An anonymous experience may be best for a public image-hosting site intended for quick turnaround and low interaction, while a logged-in experience offers the possibility of community features like commenting and sharing, personalized metrics, and the ability to restrict an upload to authorized viewers. You may want to take either approach or even both, allowing a limited anonymous experience with extra features for logged-in users.\nThe important thing is to discuss the possible approaches and their consequences for the user experience with your interviewer before making a decision. You can never go wrong by making the end user the driving force in your design.\nThink of red and green flags as signposts you can use to orient yourself in the interview. Green flags indicate that things are going well, that you're engaging with the interviewer and making a positive impression. Red flags warn you that you may be going astray and should try to get the interview back on track.\nFollowing this quote’s advice has steered many interviewees in the wrong direction. There is no game, and talking for the sake of talking is one way to hang yourself with the rope the interviewer gives you. Also, if the goal is to not explode, well, you’re wasting your and your interviewer’s time.\nAs we mentioned earlier, this guide will teach you the basic information that you’ll be asked about in 80% of system design interviews. Although these are great odds, you still may encounter a scenario that’s beyond your level of understanding. If this happens to you, don’t worry! Just engage in an honest dialogue with your interviewer, explaining when you lack certain knowledge or have gaps in your understanding. When you do have a sense of how to proceed, but you’re uncertain, you should communicate from first principles. Later in this guide, we will explain how to overcome that uncertainty and still score points with your interviewer.\nKeep in mind that your interviewers use the same problems over and over again, and they frequently see candidates make the same mistakes. If they try to divert you from a course of action, it's likely because they've seen others flounder when using the same approach. You may be the one candidate in a hundred who finds a unique and better solution—we've had this happen before!—but carefully consider the odds before proceeding with a solution against the interviewer's advice.\nWith that said, there is an art to pushing back against your interviewer when the situation calls for it, and later in this guide we’ll teach you how and when to employ this strategy .\nWhen the interviewer offers feedback, you integrate it into your design. You ask probing questions and receive useful answers about the system you're designing, its users, and its traffic. Try to establish a tone as if you were working through a problem with a coworker rather than proving yourself to an interviewer. In the real world, when you’re assigned a project, you’ll have to ask a variety of people several questions to ensure that you fully understand the problem before making decisions. That’s what interviewers want to see.\nIt's OK to not know things—no one will have every answer—but it's better to admit that to your interviewer than to avoid the questions altogether. Your interviewer may be able to offer you a hint or help you reason about alternatives if they know you're struggling, but if you skip right ahead you'll miss the opportunity to provide them with any positive signal from that portion.\nIf you’re looking for a mid-level position or below, your interviewer should determine the direction and speed of the interview. Given an initial overview of your design, they may ask you for clarification on some aspects of it. They may ask you to produce a more detailed design for one or more components. And they may also change the requirements and ask how you could adapt your solution to accommodate this new view of the world. Wherever they take the interview, follow along and focus on the areas they direct you to.\nIf you’re applying for a senior role (or above), it’s a good sign if you direct more of the interview. In junior system design interviews, the interviewer expects to drive the interview, but as you reach senior levels the expectation shifts to the interviewee.\nBeing overly confident and talking too much might count against a mid-level candidate. Some interviewers (especially off-script ones) love giving candidates more rope to hang themselves with, and then they ask specific questions that focus on what the candidate struggles with.\nIf your goal is to maximize a mid-level offer, not improve your \"average passing rate\" (i.e., if you are comfortable sacrificing some senior-plus chances to increase your mid-level chances), then you might be better off consciously \"giving control away\" to your interviewer.\nSimply put, at the above-senior level an awkward pause will be held against you—that’s basically guaranteed. But at mid-level, most of your attempts to fill in an awkward pause may hurt you more than keeping silent.\nAnother way to think of it: when you are not leading the conversation, you signal that you’re not really far above mid-level. (But if you are comfortable at mid-level, this is not a downside!)\nThe saying, ‘Better to remain silent and be thought a fool than to speak out and remove all doubt’ can be true for mid-level interviews but not for seniors or above-senior.”\nIf you're struggling to provide an answer, give yourself a little bit of time to come up with something. If you're truly stuck, however, you should ask your interviewer for help. They can't tell that you're at an impasse unless you tell them, and you may waste valuable interview time while they debate whether it's been long enough to interrupt you.\nAn interview doesn't need to be a continuous stream of consciousness, and it never hurts to sanity check your ideas before verbalizing them.\nIn Part 4 of this guide, we’ll teach you how to get unstuck and exactly what to say when you’re stuck.\nOften, candidates will say things like: “we could use this type of DB, or this other, or that other, and these are some pros and cons…” and then they move on to another component. It’s a good practice to talk about benefits and tradeoffs, but then you have to make a decision. In the real world you have to make decisions—the same thing applies to the interview. If the interviewer challenges you with some questions, it’s totally fine to change your mind and alter the component (if you think there are better choices).\nWe could use this type of DB, or this other, or that other, and these are some pros and cons…\n\"We could use this type of DB, or this other, or that other, and these are some pros and cons… And based on all these tradeoffs, I’ll use THAT type of DB.\"\nDon’t say things because you think you’re supposed to say them. This often occurs when candidates name specific brands of technologies (e.g., “Kafka” or “Cassandra”). Not being familiar with specific databases or other components is fine. Be smart and don’t say brand names just for the sake of saying them.\nI’m going to use Cassandra...” unless you are VERY familiar with that, because the next question will be: “Why Cassandra and not some\\_other\\_db?\nI’m going to use a NoSQL db because of [insert brief rationale].\nI will use Kafka…” unless you’re prepared to explain how Kafka works. Don’t say “I will use Kafka” unless you are prepared to talk about other types of queues, because they may ask you: “Oh, Kafka, interesting choice. Why that instead of [some other queue]?\nI will use a queue because of [insert brief rationale].\nSay the generic name of the component, not the brand name unless you are very familiar with it. Don’t say Kafka. Instead, say “a queue.\nYou finished Part 1! We hope you gained a basic understanding of the system design interview and learned some tips and tricks you can use to excel in it. As you continue reading Parts 2-4, these “glimmers” of understanding will become more and more the default system of your interviewing skills.\nIn Part 2 we’ll teach you the 15 fundamental system design concepts. You’ll also get to watch our long form video of two system design experts designing the same system. They’re tasked with designing interviewing.io, which in this challenge is actually three systems in one: “Design google docs, a remote compiler, and a recording service… in 30 minutes or less.”\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/system-design-interview",
      "author": "",
      "user_id": ""
    },
    {
      "title": "A Senior Engineer’s Guide to FAANG Interviews",
      "content": "There are lots of guides out there to FAANG interview processes. This one is the most thorough and the most detailed because it’s the only one made by interviewers for candidates – we spent hundreds of hours talking to dozens of current and former FAANG interviewers about their processes. Throughout this guide, you’ll see a bunch of direct quotes from these interviewers, where they describe the idiosyncrasies of each company’s process and bar in their own words. We’re fortunate to have them in the interviewing.io community, and we’re lucky that we can collaborate with them on this type of content. As you can imagine, they all requested to stay anonymous, but we want to thank them here, first and foremost.\nFAANG interviews are a gauntlet, but you can pass them even if you doubt yourself – interviewing is easier once you learn a company’s operating metaphor. George Lakoff (neuroscience and artificial Intelligence researcher) says that every human organization has a metaphor they operate as. If you ask an employee at a FAANG company about their metaphor, you’ll probably receive a blank stare in return. But if you look at the interviewing data of that same FAANG company, the metaphors jump out of the data set like bread out of a toaster.\nThis guide will walk you through all the FAANGs’ metaphors and the unwritten codes of those metaphors: what they reward, what they punish, and what they’re blind to. To show them you’re obviously a part of their tribe, model their metaphors and unwritten codes.\nMetaphors aside, this guide will also walk you through the unglamorous logistics of every FAANG’s interview process so that you know how many steps there are, what those steps entail, and what kinds of questions they ask. Our goal is to have you walk in and be completely unfazed by the proceedings because you’re expecting them.\nOf course, even with all the insider info in the world, if you’re not prepared for technical interviews, you will fail, so we’d be remiss if we didn’t share some useful insights about practice to help you on your journey.\nThere are 3 steps to getting a strong offer at FAANG.\nSteps 1 and 3 are out of scope for this post, which is solely focused on Step 2.\nMoreover, this guide is written for experienced, back-end leaning engineers – interview processes are usually different for juniors, but we won’t be getting into those differences. Finally, we won’t be getting into the differences in process for front-end engineers, SREs, etc. That said, if you’re targeting those roles, you’ll still get value out of this guide.\nIn Part 1 of this guide, we’ll highlight key similarities and differences between the FAANG companies, namely:\nIn Part 2, we’ll go through each company one by one and tell you how each of their processes work and how to prepare for each one.\nIf you’re planning on interviewing with multiple FAANGS, we recommend reading Part 1 first. If you'd prefer to skip straight to a company’s individual guide then just click on it in the table of contents to the left! Individual guides include more detailed information on company-specific coding interviews, behavioral interviews, and anecdotes from actual interview experiences.\nAll of these big tech companies share grueling interview processes, strong initial compensation packages, and above average benefits. They compete with each other for the same engineers. If tech has a food chain, they’re at the top. Most other tech companies copy or are influenced by what FAANG does.\nThere are also a number of myths about FAANG interview processes. Two big ones are that Amazon has the lowest bar, and Google has the highest bar. That’s not true; we have the data. The reality is that all of their bars are different. It’s not a linear comparison. It’s a multidimensional comparison. Because of that, it’s impossible to say something like, “The entire process at Google is harder than the entire process at Amazon.” They’re simply different processes.\n“My friend interviewed at Google and Facebook, and he passed both loops. At Google, he was offered L6. At Facebook, he was offered L4. Speaking about luck: this is the same person with the same experience. And the level of difference– at two of the most trusted names in tech–was two levels of seniority.\nAnd one common idea in big tech is that Google’s process is easier than Facebook’s. But you can see here: it really depends. After all, this person accepted the L4 role at Facebook because the compensation package was bigger than the role at Google for L6.”\nLong story short: it’s complicated. That’s exactly why we wrote this guide: to demystify the differences, to decouple the 6-headed monster, and to demonstrate how to attack each head, one at a time.\nThis is the ultimate insider’s guide to tech interviews at FAANG. However, even with all the insider info in the world, if you’re not prepared for technical interviews, you will fail, so we’d be remiss if we didn’t share some useful insights about practice to help you on your journey. Yes, we know we’re a practice platform, and, look, you don’t have to practice with us. But you should practice! Here’s why.\nThree different startups with robust data sets on software engineering interviews found eerily similar data points about what happens after you do five technical interviews. I worked at all three companies and saw this data myself.\nMind you, these datasets were quite different: Triplebyte skewed towards folks with nontraditional backgrounds, interviewing.io inclined towards senior backend engineers, and Pathrise was mainly junior engineers. Despite that, the number five emerged across these data sets, and it’s clear that something happens after you complete five technical interviews. We can’t explain what yet. But the data is screaming in all caps: there is a there there. One more anecdotal point: these five interviews should ideally mimic the real thing as much as possible. For instance, if you want a FAANG job, but your five interviews are with startups that don’t ask algorithmic questions, you won’t get as much value. The more your practice can simulate the real game, the better.\nIf you’re unprepared for a FAANG interview, ask to reschedule. Not rescheduling is the number one mistake we see our users make! Getting an interview tomorrow (as opposed to 1-3 months from tomorrow) is, in most cases, no different to the company… but very different to you – if you fail, you might get frozen out for months. In the rare cases where rescheduling could hurt your chances because it’s a specific role for a specific team, your recruiter will tell you that. Either way, there’s no harm in asking.\nRecruiter calls don’t differ much from FAANG company to FAANG company, so we decided to put everything about what to expect in a recruiter call in one place. If a recruiter call ever meaningfully deviates from this format, we’ll mention it. Otherwise, expect that it doesn’t.\nA recruiter call is the first step of almost every process. In this call, a recruiter will ask you about your past experience, your salary expectations, and why you’re interested in that particular company. They will also ask you about your timeline (how soon you expect to accept an offer), how far along you are with other companies, whether you have outstanding offers, and so on.\nIn this call, it’s important to be able to succinctly talk about your past few positions, your major contributions at those positions (what did you do individually versus what did your team do) and their impact on the business. Remember that most recruiters don’t have a technical background and they’re not software developers, so it’s important to be able to describe your technical contributions in clear layman’s terms.\nIt’s also really important, at this stage, not to reveal your salary expectations, your salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number. Just don’t do it – when you give out information this early in the process, you’re painting future you into a corner.\nThis section will give you a feel for how these companies’ processes differ. For now, don’t worry about how that translates into interview prep – we’ll cover that later when we describe how to prepare for each company.\nTake a look at the chart below. In it, we rank the FAANGs on their “Chaos Score”. The more points a company has, the more chaotic they are.\nIn this context, we define “chaos” as the level of uncertainty and unpredictability that candidates can expect from the interview process and its outcomes. If a company consistently follows the same process, asks the same questions, and thoroughly trains their interviewers, they are not chaotic. If their process is completely non-standard, non-deterministic and subjective, they are chaotic.\n| Company Name | Chaos Score |\n|---|---|\n| Apple | 20 |\n| Netflix | 20 |\n| Microsoft | 18 |\n| Amazon | 12 |\n| 10 | |\n| Meta | 3 |\nAs you can see, Apple and Netflix win the award for the most chaotic interview processes in FAANG. Microsoft gets 2nd place. Amazon gets 3rd, Google 4th, and Facebook 5th.\nChaos can be pain or pleasure depending on your tolerance for uncertainty. Chaos can also either impose a terrible detriment or prove a huge advantage in interviews specifically. For instance, candidates who have spent a long time grinding on LeetCode might prefer less chaotic companies. More chaotic companies can work for candidates for a few reasons: a) niche skill sets can be an easier match for niche interview processes, b) practical interviews are more likely, and c) the interview process shows them how the team they’d be joining actually operates.\nTo calculate each company’s Chaos Score, we picked four categories and graded each company on a 0 to 5 point scale in each category, where 5 means most chaotic and 0 means least.\nWe added up the points for each company, with a maximum possible Chaos Score of 20.\n| North star | Team dependent process? | Level of training for interviewers? | Level of standardization? | |\n|---|---|---|---|---|\n| Apple | Why (5) | Yes (5) | None (5) | None (5) |\n| Netflix | Why (5) | Yes (5) | None (5) | None (5) |\n| Microsoft | How (3) | Yes (5) | None (5) | None (5) |\n| Amazon | What (1) | Yes (5) | High (2) | Low (4) |\n| How (3) | No (0) | Medium (3) | Low (4) | |\n| What (1) | No (0) | Highest (1) | Highest (1) |\nBy “North star”, we mean what a given company values most. As such, we grouped companies into 3 buckets: companies who primarily care about \"Why\", \"How\", and \"What\".\n“Why” is the most chaotic because judging motivations is the most subjective approach. “How” is the second most chaotic because judging thought processes is the second most subjective. “What” is the least chaotic because judging end results is the least subjective method.\n“Why” companies can’t agree on what a good “why” looks like because it’s a “gut feel / friend test”. Whom you consider to be a friend and who gives you a good gut feeling isn’t quantifiable. It’s completely subjective. “Why” companies are the most prone to bias. If you speak their language and model the behaviors they encourage, you’ll seem like a friend and give them a good gut feel. If you don’t, then you won’t.\nIf chaos is hell, then “Why” companies are raising hell for candidates and themselves.\n“How” companies mainly care about your thought process: Okay, you didn’t get to the optimal solution, but what was the journey like? Google and Microsoft repeat this mantra again and again – they want to know how you think. You might get asked a really hard or specific question, but they don’t necessarily require an optimal answer to pass. They put far more weight on your ability to demonstrate a solid thought process.\n“What” companies mainly care about your results, such as: Did you get to the optimal solution? Facebook and Amazon want you to get there, and fast. “What” is the most straightforward for candidates: simply get results as quickly as possible.\nA Google or Facebook interview doesn’t change depending on the team you’re interviewing for. Both companies have one big, centralized interview process that’s completely divorced from which team you might end up on. If you do well in the team-agnostic process, there will be a team matching component after the onsite. You will NOT, however, be interviewing with your future coworkers.\n(Note: Google is rumored to be changing to a team-dependent process, but we’ll leave that where it is for now.)\nAt Microsoft, Netflix, Apple, and Amazon, the process is team-dependent. You’ll not only be interviewing with the people that you’ll be working with, but there’s more chaos. Each team defines how they do things: the types of questions asked, the types of interview rounds, and even how they make hiring decisions.\nTeam-dependent processes are more challenging in the sense that you're more likely to get blind-sided; because each team has a different process, candidates are more likely to prep for X and get (a significantly different) Y.\nYet, team-independent processes are more challenging because of the machinery. Your interviewers are so far removed from you. That detachment affects how they treat, judge, and talk about you.\nThink of it like this: At Netflix, Apple, Amazon, and Microsoft you’re interviewing with humans. At Google and Facebook, you’re interviewing with a machine.\nFacebook is the least chaotic company in this category because they have the most in-depth interviewer training in FAANG. Their process is rigorous and selective. Though most would-be interviewers pass within 6 months, some people who try never pass the bar to become an interviewer. Facebook is the only FAANG where this is true.\nFacebook and Amazon put interviewer candidates through roughly the same things, but Facebook is more rigorous. For example, both will have similar modules interviewers go through in training. A module at Amazon is more likely to be a box to check: if you do it, you pass. At Facebook, you don’t pass simply for doing it: you pass by meeting a predetermined bar. Also, Facebook modules are more likely to have a rubric.\nGoogle used to have a more in-depth interviewer training process than what they have now. For whatever reason, they began to skimp on their interviewer training roughly sometime in the 2010s. Now, Googlers can get a bit of training, but usually not as much as folks at Facebook or Amazon.\nNetflix, Microsoft, and Apple do not train their interviewers; certain teams may be exceptions but there’s no company-wide required interview training. The day you start, you can start interviewing. That makes them the most chaotic in this category.\nWhat this means for candidates is that the less training they put their interviewers through, the more likely you’ll have a bad interviewer. As the old saying goes: “Prepare for the worst, pray for the best.”\nCompanies that standardize their interview questions give interviewers less free reign; groups with no standardization have more free reign. At all companies, there will be interviewers who go rogue and deviate from the norm. Yet, each company has a norm.\nFacebook wins again for being the least chaotic/most predictable. In behavioral rounds, interviewers at Facebook can ask whatever behavioral questions they want. However, in technical rounds, they can only ask pre-approved coding questions. They can also modify pre-approved coding challenges. That’s it.\nGoogle is tied for the second least chaotic here; their interviewers have free reign in technical rounds. They have a large technical question bank, yet interviewers routinely make up their own ambiguous one-of-a-kind questions. In behavioral rounds, they can only ask or modify pre-approved questions.\nAmazon is tied for second least chaotic, but for a different reason. Technically, there’s no standardization for any round (technical or behavioral). They do, however, tend to repeat questions from their internal question bank (which is not required for interviewers to use.)\nMicrosoft, Apple, and Netflix are the most chaotic companies. Each team decides what to ask. Questions tend to be customized to the hiring manager’s preferences, a senior individual contributor’s diligence, what this team works on day-to-day, or the specific domain this team is in.\nWhether you get one shot or unlimited shots to land an offer changes how you prepare. Here’s the breakdown of which companies let you interview with multiple teams concurrently.\n| Company Name | Can interview with different teams concurrently? |\n|---|---|\n| Apple | Yes |\n| Netflix | Yes |\n| Microsoft | Yes |\n| Amazon | Yes |\n| No | |\n| Meta | No |\nIf you can interview with multiple teams concurrently, then they don’t have a cool down period. So, after you fail, you don’t need to wait at all to reinterview. Two of the biggest players only give you one shot to win, and at the remaining four your chances are unlimited.\nBecause their interview process is centralized, Google and Facebook are the only ones well-organized enough to not let candidates “double dip”.\nIf you really want a job at Netflix, Apple, Amazon, or Microsoft: stack the odds of landing your dream job in your favor and interview with multiple teams. There’s no cool-down period, so if you get rejected from Team A, you can interview with Team B tomorrow.\nIn Part 2, we’ll give you a deeper feel for each company, and we’ll tell you what to do about it. Each company has its own section, and each section is organized into five subsections:\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Gift Interviews",
      "content": "We helped write the sequel to \"Cracking the Coding Interview\".\nRead 9 chapters for free\n→\ninterviewing.io\nOpen menu\nInterview resources\nFor employers\nGift mock interviews\nBlog\nFAQ\nLog in\nGive it a try\nHelp someone get awesome at technical interviews\nGift to\nTheir name\nTheir email\nGift from\nYour name\nYour email\nNumber of interviews\nTotal (15% off for 4 interviews or more)\n$225\nPayment method\nOptional gift message\nPay & send gift\nQuestions? Email\nsupport@interviewing.io\nWe know exactly what to do and say to get the company, title, and salary you want.\nInterview prep and job hunting are chaos and pain. We can help. Really.\nGet started for free",
      "content_type": "blog",
      "source_url": "https://interviewing.io/gift-practice-interviews",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Google Interviews + Questions",
      "content": "Google’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Google? Do anonymous mock interviews with real Google interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Google’s job interview process, evaluation criteria, and interviewers.\nAll human organizations behave like a metaphor; Google isn’t a sports team, or a family, or an army. It’s a cool grad school. Larry and Sergey set up their offices based on the model of a Stanford campus on purpose. They wanted to create an environment and company culture where people can feel chill enough to talk about anything. In general, Google interviewers tend to be more collaborative than other FAANG interviewers. At Google, the slower you go, the faster you get there.\nGoogle has one big, centralized interview process that’s completely divorced from which team you might end up on, which means that you will NOT, however, be interviewing with your future team members – Google has a horde of interchangeable technical interviewers who have all been trained on the same process. If you do well, there will be a team matching component at the end.\nAt Google, because the process is centralized, you cannot interview with multiple teams concurrently, which means you don’t get multiple shots on goal. Not only that, but Google has a limit for how many chances they’ll give you before you’re blocked from interviewing again.\n“You can interview three times in 5 years. If you fail all three times then you can’t interview at Google again: you’re blocked.”\nNote that recently, there have been rumblings of Google changing their process to something more decentralized, where a hiring manager chooses you for a team before you interview, nullifying the need for post-onsite team matching. As far as we know, this new model is being tried out right now, but the change hasn’t been adopted company-wide.\nGoogle also has rules for candidates who pass their interviews:\n“If you pass Google’s onsite, and end up not taking the offer, your “passing of the onsite '' is good for about a year. And if you choose to re-engage in that time, the process varies widely. Usually you can skip the phone interview. Most times you have to do the full or partial onsite. If you choose to re-engage, tell their recruiters ‘I already passed the onsite’ and push to get as many steps skipped as you can.”\nGoogle is not results-oriented. They’re process oriented. In other words, they care more about the “How” than the “What”. You’ve heard it before, and it’s true – they don’t need you to get to the optimal solution, but they do need to be impressed by your thought process. Because of this, Google is more attracted to comfort with ambiguity than speed.\nOddly, in spite of using a centralized interview process, Google doesn’t have in-depth training for its interviewers; it may surprise some candidates that there’s a larger-than-expected number of bad interviewers at Google.\n“There is one thing that always bothered me about the Google interview process. And it's something that a lot of candidates don’t realize. There are a lot of bad interviewers at Google. Mostly because there are a lot of highly talented people who think they know everything.\nI was the interviewer for the third interview round at in-person onsite. And I saw the candidate was there by himself; the second interviewer wasn’t there. The candidate was alone because the second interviewer got frustrated – they thought the candidate wasn’t worth the time for an onsite, so they left early.”\n“Google is more likely than Facebook to design questions on purpose to be tricky. At Google, sometimes this is intentionally disguising technical questions to look like X but they’re really Y. And other times at Google, it’s designing a technical question such that if a candidate doesn’t ask a particular question they likely won’t get the answer.”\nPlease see the section above called “A note about recruiter calls”\nGoogle’s technical phone screen is a coding interview that focuses exclusively on data structures and algorithms questions. Your interviewer will ask you to write code to solve a specific problem.\nOne idiosyncratic aspect of Google’s process is their insistence on using Google docs for writing code (versus other companies which tend to use tools like CoderPad). This can be a bit jarring for those of us who are used to writing code in an IDE that does things like auto-indentation, auto-complete, syntax highlighting, adding missing parentheses or brackets etc. Despite not using an IDE, your interviewer will expect you to produce syntactically correct code. This is really hard.\nBefore your Google interview, you should practice in Google docs so you don’t forget to close parentheses or indent your code.\nThat said, more recently, Google has started interviewing using an internal tool with syntax highlighting, indentation and brackets completion. Whether you get to use it or not depends on your geography.\nThe second phone screen happens only if the first one did not produce enough signal to move forward. Perhaps you didn’t communicate your thought process well enough, your code wasn’t of good enough quality, or you weren’t fast enough – but it’ll be only one of these – if you struggled with two or all three, most likely you aren’t moving forward.\nIf you do get scheduled for a second phone screen, push your recruiter to give you detailed feedback so you can do better the second time – nothing beats knowing exactly where you need to improve. You probably won’t get a response, but if you do it’s a large boost to your prep.\nIf you get a second phone screen it will be very similar to the first in terms of structure and content.\nThe Google onsite usually includes 4-6 rounds. Recently, there have been some internal experiments with the format, but generally the rounds are primarily coding, and secondarily system design. Some candidates get a single behavioral round, and others get to skip it.\nThe more experience you have, the higher proportion of system design and domain-specific questions you can expect to be asked.\nAs we mentioned above, Google is process-oriented rather than results-oriented. As such, communication during coding and system design rounds is more important at Google than the end result.\nThe most important rounds at Google are coding. In fact, Google is the only FAANG company that considers coding to be more important than system design. Google’s coding rounds are about complexity more than speed. Their interviewers are allowed to ask anything they want, so it's more likely you might get a question you’ve never practiced before.\nGoogle interviewers are more likely than any other FAANG company to purposefully design a question so it tricks candidates. For example, they’ll disguise a question to look like it’s Three Sum, but that’s a red herring – it’s not a Three Sum problem. It just looks like one.\nA lot of what you’ll see in the onsite coding mirrors what you saw in the technical phone screen. During the onsite, you may see your interviewer layer more complexity on top of questions – they’ll design a question where they plan for you to get to the solution, then when you do they’ll move the goalposts and say something like: “Remember that assumption we made earlier about [X thing]? Let’s remove that. How would that change your approach?”\n“At Google, I’ve passed more people that arrive at the optimal solution without coding it than I do people who arrive at the optimal solution and code it. The actual code you write is less important than the thought process.”\n“Google is highly unstructured. Everyone can ask whatever they want.”\nEven though they can ask whatever they want, Google interviewers have a question bank too, but the bank is much much bigger than Facebook’s bank and, like Facebook’s bank, it’s community maintained. Some interviewers never deviate from the bank, and others don’t touch it, preferring instead to formulate their own unique questions..\nThis speaks to Google rewarding the “how” (aka “how a candidate got there”) or their thought processes. It also speaks to Google rewarding comfort with ambiguity. Other FAANGs have specific niche topics they love hearing and talking about (such as “performance” at Amazon), but Google is more abstract. Google might love speaking about and asking about ambiguity more than any other FAANG.\nFinally, Google’s coding questions are never practical. They are always theoretical. They will never ask you to pull up your own environment and write a program. They will also never ask you to take a solution to a coding problem and apply it to a real world scenario. When prepping for Google, only practice theoretical questions.\nFor everything you need to prepare for Google’s coding interview, check out the section called \"Google coding interview preparation resources\" below.\nThe second most important onsite interview type at Google is system design. Again, they are allowed to ask anything they want, so don’t be scared off if you get a question you’ve never practiced before.\nHigh-level and low-level system design questions are both likely. Some examples include:\nGoogle system design interviewers also tend to design problems that include linchpin questions. These are questions where if you don’t ask about a specific aspect of the problem, you can’t really solve it. For example, an older system design question at Google asked you to set up a service in some foreign country, and in the prompt, the interviewer mentioned that you have a dependency on some third party service.\nThe linchpin question to ask: “What’s the service level agreement for that 3rd party service?” If you didn’t ask that (or something like it), then you wouldn’t be able to effectively reason about availability, which you’d need to do in order to do well on the question.\nTo avoid getting tricked, ask even more questions in Google system design rounds than you normally would.\nThe least important round at Google is the behavioral round. They have the easiest behavioral screen in FAANG. Plus, you might complete an onsite at Google without a behavioral round because they’re optional. It’s not clear which candidates get them and which don’t. This is another reason to not prep too hard for their behavioral round.\nIf you do get some behavioral questions, they might be one of the following:\nGoogle is also more likely to ask you reflective questions. Most other FAANGs stick to situational questions such as, “Tell me of a time when…”. Those situational questions ask you to describe a past circumstance or scenario you’ve actually experienced and are fairly straightforward to answer. Reflective questions, on the other hand, can be tricky because they’re asking you to reflect on, or speak to, something less concrete, e.g., “What do you think about setting goals?”\nThe smart way to answer a reflective question is to re-formulate it, and then answer as if it’s a situational question. So, “What do you think about setting goals” instead becomes,”Talk about a time you used goal-setting as a time management strategy”, which you can now more-easily answer by describing a real experience and outcome, “The last time I set goals…etc”, as opposed to wading into theories about personal agency. “I think goals are cool and important…” might not get high marks.\n“To be honest, there was some cultural backlash at Google when they announced that we had to do these behavioral interviews. What that means is you may get an interviewer who has very little interest in conducting this type of interview. Which could go very good or very bad. I have some peers who think this should not be a part of the interview process. So they give everyone the highest marks, pretty much just to eliminate this category from the interview. Google is primarily engineers, and most of the engineers think that this is a bunch of HR BS. So they either just won’t accept any calendar invites they get or they'll just check the boxes.”\nMost of the time, the post-interview feedback process at Google is completely asynchronous, and interviewers don’t meet live to discuss hiring decisions. That’s one reason why interviewing at Google isn’t like interviewing with humans: it’s more akin to interviewing with a machine.\nEach interviewer rates candidates on the following seven-point scale: Strong No-Hire, No Hire, Leaning No-Hire, On The Fence, Leaning Hire, Hire, and Strong Hire.\nHow this affects candidates is simple: a Strong Hire can get you an offer, but it can also buy you a second chance. If you don’t get an offer, but you get a Strong Hire from one of your interviewers, you might be offered one bonus interview round to decide whether you get an offer or not.\nThat said, you don’t need to get a “Strong Hire” to get a second chance. Overall, if you showed enough signal to not-fail but not enough to pass, sometimes they will ask you to do an additional round.\nIf you get lucky enough to get a round where you are really excelling, don’t quit while you’re ahead. Keep going. In that round, don’t just strive to win; strive for total domination.\nA “Strong No-Hire” bars you from interviewing at Google for some time. Reports vary here, but one of our Google interviewers told us that if you get a Strong No-Hire, you might be frozen out for several years.\nIf you passed overall then you will move on to the hiring committee phase.\nGoogle’s hiring committee consists of four to five engineers and engineering managers who have not interviewed you, with the intent of making hiring decisions as objective as possible.\nGoing into the hiring committee review, your recruiter will prepare a packet that consists of your resume, any notes from the person who referred you (if you were referred), your recruiter’s notes from their call with you, and all the feedback from your interviewers, from the technical phone screen to the onsite.\nIf you’re told you’ve passed the onsite, ask if you can submit a more recent copy of your resume. Some Google recruiters will let your new resume be the only resume the Hiring Committee sees. Your resume you submitted for the online application probably wasn’t customized for Google, but what you submit to the hiring committee can be.\nWhen the committee meets, they evaluate all the data on you holistically, and they need a consensus in order to decide to make a hire.\nOther than hire/no-hire decisions, the hiring committee will also decide on leveling. Ever since COVID and the rise of remote interviewing, we’ve gotten more and more reports from users that they’re being down-leveled at Google. Apparently the rationale is that Google doesn’t feel like they get as much signal from remote interviews as they did from in-person ones, and as such, when they don’t get enough of a signal for a hire but too much good signal for a rejection: they downlevel – when you want to reduce the probability of a false positives for L5… offer L4!\nEngineers who are downleveled at Google accept the lower level offer a lot of the time, especially in the current climate. In some extreme cases, we’ve seen engineering managers with 10+ YoE accept an L3 (basically a new grad) offer.\nOnce you get past the hiring committee, you will move on to team matching. The team matching process is a bit like speed dating. In the ideal case, your recruiter will propose a few teams that are actively looking for someone with your skills, and then you’ll meet with the hiring manager from each team to gauge cultural fit and chemistry. In order to move forward, both of you have to opt in.\nThat said, there are rare instances where a candidate will get past the hiring committee but then not find a team that they gel with.\n“Getting five scores of ‘Leaning Hire’ is most likely to result in a ‘No Hire’ decision. I have seen many cases where the candidates got five scores of ‘Leaning Hire’, and the recruiter gave them positive feedback too, but the candidate got rejected. In these cases, every person the candidate dealt with directly (the interviewers) were positive, yet the hiring committee (the only people in the process who dealt with the candidate indirectly) rejected the candidate.”\nHere are some tips for preparing for your Google coding interview:\nIn addition, we’ve aggregated a bunch of useful Google content for you! We have replays of candidates doing mock interviews with Google interviewers, long-form solutions to common Google questions, and deep dives into technical topics that tend to come up in Google interviews.\nBelow are a series of mock interview replays, conducted by Google interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Google ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Google interviews, we did two things. First, we spoke to a bunch of Google interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Google. Based on all of the above, here are the technical topics you’re likely to encounter:\nWant to know if you’re ready to interview at Google? Do anonymous mock interviews with real Google interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/google",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Meta Interviews + Questions",
      "content": "Before you interview with Meta, read our guide on negotiating with them. They’ve gotten very aggressive, and if you don’t know the rules, you will fail.\nMeta’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Meta? Do anonymous mock interviews with real Meta interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Meta’s hiring process, evaluation criteria, and interviewers.\nMeta interviewers are guided by the company’s current motto: move fast. All human groups have a metaphor they operate from. Meta isn’t a family or an army. They’re a well-structured Formula 1 team; they spend a lot of effort to put safeguards in place, and then they go pedal to the metal. At Meta, speed wins.\nAt Meta, because the process is centralized, you cannot interview with multiple teams concurrently like you can at some other tech companies. You get one shot on goal every ~3 to 6 months, depending on performance.\n“If you pass Meta’s onsite, but don’t take the offer your status of ‘passed onsite’ is valid for a year. If you don’t take their offer and then choose to re-engage within that year, tell their recruiter ‘I already passed the onsite’ and push to get steps skipped because you usually can.”\nWhen interviewing at Meta, listen closely to the subtle clues and hints your interviewer gives you. Meta is the only FAANG where you can’t become an interviewer unless you give good hints.\nPlease see the previous section called “A note about recruiter calls”. Also read our guide to negotiating with Meta. It starts at the recruiter call.\nMeta's technical phone screen is a 45-minute coding interview that focuses on data structures and algorithms.\nAt the beginning of the interview, your interviewer will ask you a question or two about your resume and recent work that you've done. This portion will take 5 minutes, and how you answer these questions doesn't meaningfully factor into the interview's outcome - they are just meant to break the ice and get you talking. The part that matters is the technical portion.\nAfter the intro portion, your interviewer will ask you two coding questions, and they expect you to get through both in 35 minutes. These questions will be LeetCode easy or medium difficulty.\nMeta’s technical phone screens are conducted in CoderPad. If you've never used it, you may want to play around in their sandbox and get familiar with their environment before your real interview. One specific thing about Meta's way of using CoderPad is that during the interview, they'll have code execution turned off - if you've used it before and are accustomed to testing your code during the interview by running it, you'll need to practice not being able to.\nThe typical Meta onsite will consist of the following:\nThe process for E6 engineers, as outlined in the diagram above, is slightly different. There will be a Leadership Assessment interview after the Technical Screen. In this interview, the following topics might be covered:\nThe onsite for E6 engineers will also be different. You should only get one coding round, one architecture round, one design round and then a behavioral round.\nThere are four main types of interviews you’re going to encounter when you apply for an engineering job at Meta – coding interviews, behavioral interviews, and either a system design or product design interview. Here’s what to expect during each of these rounds of interviews.\nMeta's process is highly standardized, so coding interview questions and themes tend to repeat. Coding questions are pre-approved, but that doesn’t mean the interviewers have no freedom.\n“Meta gives you the questions to ask or modify. But they don't tell you the answers in their interviewing wiki. And they let you design the path of the question: you get to ask your own twists and turns.”\n“There’s some variance with the interviewer, but usually there are 20 mins per question, and the questions are simple. They want you to get the algorithm fast, and implement the basic solution. The kind of bugs that can be acceptable are empty input, and out of scope inputs like empty array/null. But an incomplete algorithm at Meta usually doesn’t cut it. They want you to get to it and get to it quickly, and you can sacrifice making a little bit of a mess along the way.”\n“I think there is a rule that during the programming interview, interviewers have to ask two questions. And the questions have to be balanced. The first is more like a juicy question testing problem solving skills and you as the interviewer can permit some bugs in the implementation. The second will be easy from the algorithmic point of view but the goal is to assess how much the candidate can write debugless code and test this code perfectly. And if a candidate fails to solve both problems, even if they somewhat shine during one problem: it will be ‘No Hire’.”\nIt's not that bugs are encouraged, it’s that they're the only company that's top-down directive is: sometimes, in certain rounds, bugs are okay. No other company does that. Meta relaxes the need for bug-free code so that candidates can code faster.\nFinally, Meta doesn’t ask dynamic programming questions and, in fact, those questions are banned.\nFor everything you need to prepare for Meta’s coding interview, check out the section called \"Meta coding interview preparation resources\" below.\nMeta hires two types (on paper) of backend engineers: System Generalists and Product Generalists. System generalists get a system design interview, and product generalists get the confusingly named product design interview (in most other contexts, product design refers to UI/UX).\nWhich of these interviews you get is determined by your recruiter, based on your experience. If you have worked on a lot of product features, then you get a product design interview. If you have worked on high-scale distributed systems, then you get system design.\nThe product design interview at Meta is similar to the system design interview but with some key differences:\nTake a look at this video, by Meta, about the difference between these two interview types:\n“Product design is less databases, more data flow, more time spent on details of the API (e.g. parameters that will pass). System design is more databases, less API details, and more about scaling.”\n“Many people think Meta only asks high level system design questions like ‘Design Twitter’ or ‘Design Meta Feed.’ But that’s not the case. They also ask low level questions. In E6 or above interviews, you will most likely be asked ‘Design Redis’, or ‘Design Kafka’, or ‘Design Memcached.’ I’d even seen rare occasions where E5 candidates would be asked low-level system design questions; low-level questions are less common in rounds for E5 and below.”\n“You have to ask about back of the envelope estimations. A lot of senior engineers hate to do that. I hate to do that as well. It’s a waste of time. When I do the ‘There is a rule that I have to do this. But there is no point in doing this. Let’s spend 5 minutes talking about real system design. Let’s assume we have to scale our system from 0 to Google level and therefore estimations are just a waste of time.’”\nAsk your interviewer: “Do you want to spend a few minutes on estimations? I’m okay with skipping it, but if you need to see it, then let’s do it. If we skipped it, one thing that might be a more interesting conversation would be spending a few minutes on how to scale this system.’”\nIf you don’t know what to talk about in a E5 Meta system design round, talk about user experience. Go on about two choices you could make, then explain in depth the one preferred because it’d be a better user experience.\nIt’s also common for Meta interviewers to ask you to walk them through a system you’ve worked on in the past, which is known as a reverse system design interview.\nUnlike technical questions, behavioral questions at Meta are not standardized: interviewers can ask you whatever they want. Behavioral rounds are of medium/low importance at Meta; they’re less important than technical interview rounds, but they do carry some weight. For the best summary of what to expect in a Meta behavioral interview, read this blog post by a former Meta engineering manager – in it he describes exactly how behavioral interviews at Meta are evaluated and also includes a bunch of sample questions.\nHere is a list of questions to get you started. Read the post to get examples of good answers (split out by the candidate’s seniority level!)\nFinally, if you are applying for E5 and above make sure to have a couple of projects that lasted longer than one quarter – if all your examples are of smaller initiatives, your interviewer may walk away with the impression that you can’t handle complex projects. Also, remember to quantify the impact that you made by sharing specific metrics.\nMeta’s candidate review and feedback process is usually completely asynchronous. Sometimes, they’ll do a live debrief but it’s rare. This means there’s a low likelihood for an interviewer to “fight” for a candidate. Socially influencing interviewers won’t go very far here.\nMeta is also the only FAANG that asks interviewers for a confidence score when filling out post-onsite feedback forms. As a result, the process at Meta can be more forgiving on failed rounds because a lower confidence score means a failed round carries less weight. Also, Meta is the only FAANG that directly asks interviewers about downleveling.\n“Coding is used to decide ‘Should we hire this person?’ System and product design is used to decide ‘How should we level this person?’\nFor coding interviews, the interviewer says a binary score first: ‘Hire’ or ‘No Hire’. Then in the comments, they say how confident they are in that binary score. The ‘Hire’ or ‘No Hire’ is an official metric, but the confidence score is not.\nFor system/product design, the interviewer gives the ‘Hire’ or ‘No Hire’ first. Then they say if the candidate should be considered for another level.\nSo the final decision could be like: ‘No Hire’ for E5 with low confidence. ‘Hire’ for E4 with high confidence.\"\nIn cases where the hiring panel is hung, it’s possible they may request one more follow-up interview to help them get more signal.\n“Interview feedback is discussed primarily by the system design and behavioral interviewers, and those are the interviewers who have the most say regarding both the hire decision and a candidate’s level. If interviewers don’t feel like they got enough signal and the candidate ends up being on the fence, the recruiter will push for an additional round. Indicative hint: If you have an additional follow-up interview, your interviewers were probably split.\"\n“At Staff level and above, it’s a mandate that candidates can’t get hired if they don’t pass both system design rounds.”\n“For E6 and above candidates, if you fail one system design round but do well in the other rounds, you can get a mulligan. They can let you retake one system design round. But the same isn’t true for behavioral: if you fail there’s no mulligan. If you fail the behavioral round, it will be ‘No Hire.’”\nMeta made some changes to their process in 2023. Before, unlike at other FAANGs, you'd generally accept an offer before knowing with which team you'd end up on. Then you'd do a 6 week “Bootcamp”, where you'd be trained on Meta's engineering infrastructure and systems. After the bootcamp, there would be a 2 week team-matching period.\nNow, after you finish the onsite, you jump straight to the team matching process. Team matching now happens BEFORE you get an offer, and offers are contingent on team matching completely successfully.\nYou'll talk with hiring managers from a number of teams to gauge fit and chemistry: we've heard that sometimes it's a handful, and sometimes it's over 10.\nAfter your team matching conversations, your recruiter will ask you to choose a team. In order to move forward, both you and the hiring manager have to opt in.\nOnce you make your choice, your recruiter will officially make an offer, and you'll usually have just a few days to make your decision. We hope this will change in the future, but recently Meta has been very aggressive with both offer timelines and with negotiations - they will not negotiate unless you can share competitive offer details from another top-tier company.\nOne other key difference between Meta's new process and the old one is what happens during Bootcamp. Historically, Bootcamp took 6 weeks, and in addition to training new hires on Meta's engineering infrastructure and systems, there'd be a multi-week “speed dating”-esque team matching component.\nBootcamp still exists, but now it's much shorter - 2-4 weeks, and the focus is getting new engineers ramped up on generic tools. After that, new engineers will continue to ramp up on their specific teams.\nThe team matching process is a bit like speed dating. You meet with hiring managers to gauge fit and chemistry. In order to move forward, both of you have to opt in.\n“When the market is good, you can talk to 20 different teams at the same time.”\nThere are exceptions – some people with niche skills may get hired for a specific team before they start Bootcamp, but they still have to do the bootcamp period, just not the team-matching part afterwards.\nWe’ve aggregated a bunch of useful Meta content for you! We have replays of candidates doing mock interviews with Meta interviewers, long-form solutions to common Meta questions, and deep dives into technical topics that tend to come up in Meta interviews.\nBelow are a series of mock interview replays, conducted by Meta interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Meta ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics might come up in your Meta interviews, we did a few things. First, we spoke to a bunch of Meta interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data, the LeetCode question list above, AND our own data-set of mock interviews in the style of Meta. Based on all of the above, here are the technical topics you’re likely to encounter.\nThe following interview guides and resources can help you better understand Meta’s recruitment process and support your interview prep so you impress the hiring committee.\nWant to know if you’re ready to interview at Meta? Do anonymous mock interviews with real Meta interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/meta-facebook",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Amazon Interviews + Questions",
      "content": "All human organizations operate as a metaphor. Amazon isn’t a sports team or a family; they’re a motley crew of Terminators. They’re a different breed with notoriously high standards. They reward aggression. And they want to take over the market (or the earth, depending on who you ask)...\nAmazon’s process is not centralized, and you can interview with multiple teams concurrently. To up your odds, interview with as many teams as you have the appetite for.\nAmazon really loves their Leadership Principles (LPs). Amazon interviewers may sandwich LP questions anywhere and everywhere throughout your interview rounds: coding rounds, system design rounds, all rounds. In short, at an Amazon interview, be prepared for Leadership Principles questions anywhere, anytime.\nFinally, Amazon has one of the more-structured interviewing cultures. They’re the only FAANG where interviewers exist in a formal hierarchy, and Amazon openly encourages and rewards interviewers who reach the top rung in that hierarchy.\nIn this guide we’ve compiled a comprehensive Amazon job interview prep guide based on in-depth discussions with Amazon interviewers and interviewees. Our guide includes a detailed walkthrough of the interview process, common questions and solutions, interview tips, video replays of mock Amazon interviews, and more.\nWant to know if you’re ready to interview at Amazon? Do anonymous mock interviews with real Amazon interviewers, and see exactly where you stack up.\nSee available timesAmazon’s interview process consists of the following steps:\nWe walk through each of these steps in detail below.\nWhether you start with an online assessment or an Amazon recruiter call depends on a few factors:\nIf you answered yes to any of these questions, then you will likely not have to do an online assessment, and your first step will be a recruiter call. That said, we’ve gotten some conflicting reports from Amazonians, and it may be that Amazon has more recently started using online assessments to test the competencies of more senior engineers as well.\nIf you do the online assessment, here’s how it works. It’s a timed, asynchronous test consisting of several coding problems, conducted via HackerRank. These are usually data structures and algorithm problems of easy to medium-level difficulty, as well as some multiple choice system design questions where you have to select the design option that’s ideal in a given situation. If you do well in the online assessment, you can skip the second step, which is the technical phone screen.\nIf you end up skipping the online assessment, the first step in your process will be a recruiter call. Please see the section above called “A note about recruiter calls.”\nAmazon’s technical phone interview is a coding interview that tends to focus exclusively on data structures and algorithms. Despite the focus on speed, Amazon interview questions may require a lot of code, and the time allowed is usually 30-40 minutes, which means you’ll usually get one question, as opposed to Facebook, where you might get multiple questions.\nFor these screens, Amazon uses an internal tool called Livecode, which has syntax highlighting for popular languages but does NOT have the ability to run the code. In fact, no code is ever compiled or run in Amazon technical interviews.\nFinally, there’s a 50% chance that your interviewer will throw in 1 or 2 Leadership Principles questions into the phone screen. They’re not guaranteed, but they’ll definitely come up during the onsite.\nThere’s some variance, but the typical Amazon onsite, or in-person interview, for technical roles, will consist of:\nAmazon has a special type of interviewer that they include in onsite loops: the Bar Raiser. These are typically senior-level Amazon employees at the top of the formal interviewer hierarchy, and they’re the toughest and most-trained interviewers at Amazon. They serve as an independent and objective evaluator, asking follow-up questions, and ensuring that hiring decisions are not influenced solely by the candidate's immediate team or department.\n“Being a Bar Raiser makes an impact on your promotion packet. Every L5 nearing promotion at Amazon, is encouraged to do the Bar Raiser training. It’s a big input to get to L6 or L7. Part of the promotion packet is: how are you demonstrating some of the Leadership Principles. And “Hire and Develop the Best” is one of the LPs. There’s a lot of work to do in hiring to become a Bar Raiser: you have to do a lot of training and a ton of interviews. Being a Bar Raiser carries a lot of weight at Amazon if you want to get promoted.”\nAt Amazon, Bar Raisers and hiring managers are the only interviewers who have the formal authority to veto a hiring decision. You can recognize them because they are the only interviewer in your onsite loop who has nothing to do with the team you’re interviewing for. Bar Raiser rounds can be super intense, but don’t shrink when you feel a Bar Raiser throw flames your way; embrace the fire.\nThere are three main types of interviews you’ll face as a software engineer interviewing at Amazon. These are coding, behavioral, and system design interviews.\nYou will have to do coding interviews in the phone screen and in the onsite. Coding rounds at the onsite are very similar to technical phone screen rounds, except that in the technical phone screen you might get Leadership Principles questions, whereas in the onsite coding portion, you definitely will.\nAmazon asks mostly medium-difficulty LeetCode-style coding questions and avoids hard questions. The idea is to let candidates demonstrate how quickly they get to the optimal result, all in the service of hiring engineers who can churn out new features quickly.\nDespite the focus on speed, Amazon questions may be a complex problem that requires a lot of code, and the time allowed is usually 30-40 minutes, which means you’ll usually get one question, as opposed to Facebook, where you might get multiple questions.\nAmazon’s coding rounds test the following technical skills:\nAlthough your performance in technical interviews matters (if you fail the technical, you usually will not move forward), it’s not as important as the outcome of the behavioral interview, and coding interviews during the onsite at Amazon actually feature Leadership Principles questions.\n“Because no code is ever run on an editor, the approach, speed, and testing are most important. Code syntax, typos, variable naming, and edge cases are less important.”\nGraph questions are among the most popular types of questions asked at Amazon, as well as tree questions that require BFS or DFS. Classic questions like LRU cache, meeting rooms, word break, word search, word ladder, and so on may also come up.\nWe’ve heard from Amazon interviewers that all of the data structures and algorithms questions in Amazon’s official question bank are actually on LeetCode. That said, Amazon interviewers are allowed to ask whatever they want in coding rounds, and some will deviate from the question bank to ask more practical questions such as, “Implement a function with some behavior with the help of these two APIs…””\nFinally, like Facebook, Amazon shies away from dynamic programming questions (though they’re not banned outright).\nFor everything you need to prepare for Amazon’s coding interview, check out the section called \"Amazon coding interview preparation resources\" below.\nThe behavioral interview is one of, along with coding interviews at the onsite, the most important in terms of leading to an offer.\n“I’ve done over a hundred interviews at Amazon. The behavioral interview is most likely to get someone pushed over the line if they were borderline in their technical interviews. The opposite is not true: if they don’t meet the behavioral bar, we don’t care how they did in technicals, we aren’t hiring them.”\nBehavioral is an extremely important part of the Amazon interview process – Amazon is more likely to downlevel or reject you solely based on behavioral – and their behavioral round might be the most well-thought-out interview in all of big tech. It also might be the easiest to fail if you don’t specifically prepare for it. There’s no flavor like the flavor of an Amazonian behavioral interviewer; if you’ve never encountered it before and don’t expect it, it can be jarring.\nOne of the most common mistakes our users make is not taking this interview seriously because at most other companies, behavioral interviews tend to be more lip service than a meaningful part of the process. The bottom line is, if you want an Amazon job at a senior level or above, you have to seriously prepare for the behavioral interview questions.\nNot all Leadership Principles are created equal. Customer Obsession is the 👑one Leadership Principle to rule them all. When in doubt, demonstrate Customer Obsession. If you get a curveball, give an answer that shows you’re deeply committed to making things customers love.\n“If you have a bad LP round, or if LPs are problematic in the debrief, it’s almost always a ‘no hire.’ But if you have great LPs then there is a conversation where we try to see if the candidate can be hired even if the technical rounds weren't at the bar. But not the other way around. But if there’s anything ‘at the bar’ or ‘below the bar’ for LP, then you fail.”\n“If a candidate does not do that well on the technical round but they do well on LPs, there is always a possibility of recycling the candidate because they’re a good fit for Amazon but not good for the team. So sometimes we’ll help them interview with other teams, and they don’t have to do a full onsite: they just need to do 1-2 more rounds as a follow up. But if they’re below the bar for LPs, then they’re not a fit for Amazon so Amazon wouldn’t help set them up to other teams with shortened onsites.”\nIn this round, expect questions from all 5 of these categories:\nHonestly, the best place to find a detailed question list for Amazon’s behavioral interview, as well as a bunch of other interview preparation resources, is our Senior Engineer's Guide to the Amazon Leadership Principles Interview.\nSystem design and coding aren’t the be-all and end-all at Amazon – of course, you still have to pass them, but if your performance is borderline, doing well on behavioral Leadership Principles questions will take you over the finish line. In fact, interviewers will likely ask you 1-2 Leadership Principles questions in your system design interviews. Try to be efficient when answering LP questions in system design rounds. LPs come first. Finish them early so that you have more time for the technical question.\n“In many debriefs, I hear the hiring manager say that we can extend the L5 offer with the understanding that system design is not their strength, but it's coachable. At the L6 level, the system design bar is comparable to Facebook or Google.”\nIf you’re in a system design round at Amazon, and you don’t know what to talk about, talk about performance. They want Amazon to be the number one customer of AWS. And they love to find engineers who understand and are passionate about fine tuning performance in the cloud.\nAmazon is more likely to ask you practical system design questions. For example, if you’re interviewing with a team who controls Amazon’s inventory management, they might ask you to design a piece of an inventory management system.\nOther common system design questions include:\nThe design questions are most likely about designing well-known features, as opposed to a complete system from scratch like Design Facebook or Twitter.\nAmazon interviewers are allowed to ask whatever they want in system design, but a lot of interviewers fall back on reusing questions from Amazon’s question bank.\nFor tooling in system design interviews, candidates can usually choose any type of drawing tool. Excalidraw is most popular, followed by Miro.\nAmazon has one of the more well-structured decision-making processes in tech: teams typically do a pre-brief (live meeting before the onsite), submit asynchronous feedback, and also do a debrief (live meeting after the onsite). They rely heavily on live discussion to make decisions. Notably, though some interviewers might be able to tell an outlier story of a time a regular interviewer out-argued a Bar Raiser, most of the time the interviewers go along with what the Bar Raiser says.\nAmazon interviewer’s grade on a 5-point scale: Strongly Inclined, Inclined, Neutral, Not Inclined, Strongly Not Inclined.\nThe two most important interviewers at the onsite are the Bar Raiser and the hiring manager. At Amazon, all of the other team members involved in the interview could vote to hire, but if the Bar Raiser or the hiring manager aren’t on board, that candidate is likely getting rejected.\nAt Amazon, identify the Bar Raiser (the only person whose work has nothing to do with the team for which you’re interviewing) and the hiring manager (if you don’t know who it is, ask the recruiter before the onsite or an interviewer if during the onsite). Most of your energy should go towards impressing these two people – since Amazon relies so heavily on live discussions to make hiring decisions, impression management is more impactful here.\nWe’ve aggregated a bunch of useful Amazon content for you! We have replays of candidates doing mock interviews with Amazon interviewers, long-form solutions to common Amazon questions, and deep dives into technical topics that tend to come up in Amazon interviews.\nBelow are a series of mock interview replays, conducted by Amazon interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Amazon ask on our platform as well as sample answers. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Amazon interviews, we did two things. First, we spoke to a bunch of Amazon interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Amazon. Based on all of the above, here are the technical topics you’re likely to encounter:\nWant to know if you’re ready to interview at Amazon? Do anonymous mock interviews with real Amazon interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/amazon",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Microsoft Interviews + Questions",
      "content": "Microsoft’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Microsoft? Do anonymous mock interviews with real Microsoft interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Microsoft’s process, evaluation criteria, and interviewers.\nMicrosoft lets you interview with different teams at the same time; if you want to maximize your chances interview with several of them simultaneously.\nMicrosoft’s process is mainly (though not fully!) team-dependent. That means that while you interview for a specific team, you may not necessarily be interviewing just with people on that team. For example, sometimes you might interview with the hiring manager for a specific team, and your other interviewers will be individual contributors from other teams.\nEach team runs their own processes, which can vary quite a bit from team to team as well. Sometimes Microsoft bakes a quasi-team-matching activity into an interview process: where a candidate can meet multiple hiring managers in the same loop. Another variation is some candidates’ first round screens are with a hiring manager instead of a recruiter.\nPlease see the section above called “A note about recruiter calls”\nMicrosoft’s technical phone screen is a traditional LeetCode-style coding interview, with technical questions ranging from easy to medium. Interviewers aren’t given a rubric. Some of them get training, others don’t. They have freedom to ask whatever they want and judge your technical skills however they want in this round.\nIf you end up getting the asynchronous Codility quiz instead, you sign on and have to answer several algorithmic questions in a short amount of time. In some ways, this is harder than the technical phone screen with the human because if you don’t pass the test cases, you get filtered out. You’re judged on several factors including: test cases, correctness, and code quality.\nThe onsite format can vary per org, but it typically includes the following round of interviews:\nThis is the most important round at Microsoft.\n“Since most engineers at Microsoft use C#, if you can, you should use C#, Java, or Python in the technical rounds. This way, your interviewer will be able to understand your code better and may even be able to help.”\nMicrosoft usually asks LeetCode-style medium-difficulty questions in coding rounds. Interviewers get to pick their own coding questions, but, according to interviewers, Microsoft favors the following topics (in no particular order):\nLeetCode’s Top Questions for Microsoft is also a helpful resource.\n“Tree questions are most popular, e.g., various types of tree sum, tree traversals of certain orders, subtrees, etc.”\nDynamic programming used to basically never happen, but now it’s a little more common. When you do get dynamic programming problems, it’s usually the classic ones like coin change, stair steps, edit distance, and various types of counting problems.\nTooling for coding interviews is at the team’s discretion, but many teams use Codility.\nFor everything you need to prepare for Microsoft’s coding interview, check out the section called \"Microsoft coding interview preparation resources\" below.\nSystem design is tied for the second most important round at Microsoft, and it’s sometimes conducted by a hiring manager. One idiosyncratic aspect of Microsoft’s process is their penchant for asking questions about compliance-related topics.\n“My Microsoft interview was insanely easy. I tried to step it up when I started being an interviewer at Microsoft. But then I realized that's how it has to be. Technical is like 25% of it. It’s not a generic FAANG interview. It’s more about three things: a) ‘How well does this candidate know this system they’re going to be working on?’, b) ‘How do they meet the exact needs we have on this team?’, and c) ‘Do they understand the little things we value? Like compliance, manipulating data, data pipelines, EU data processing, etc.’”\n“Microsoft is obsessed with the details of compliance. I don’t think I have seen a system that is as set up for auditing as Microsoft. Employees are asked to log so much. There’s a centralized grid system which is built into Azure. All logs are to be routed into that. This allows for centralized log spanning and auditing. Which I have not seen anywhere else.”\nOutside of compliance-related questions, here are examples of other system design questions you might encounter:\nTooling for system design interviews is at the team’s discretion, but many Microsoft employees use Codility Canvas or Excalidraw.\nThe domain-specific round is tied for the second most important round at Microsoft. Microsoft is more likely to do these types of rounds than other FAANGs, and these rounds can feel similar to system design but involve some coding.\nUsually, domain-specific rounds are customized to the domain a given team works on and dives deep into that technology. So, whatever area this team is in (cloud networking, big data, etc.), that’s what they’ll ask you about.\nOn some occasions, Microsoft customizes a round to the candidate’s skills. For example, if you’re a backend engineer, they might ask you to design an API or design a database. They also may ask you open ended trivia questions about the programming language you are most familiar with.\n“Another thing that happens in these rounds is they’ll ask you to discuss a complicated problem you have solved at your job. It's good for candidates to prepare to discuss 2-3 projects in detail: how did they implement caching, deal with scaling issues, and so on.”\nFinally, you may get a scenario question that’s commensurate with your skill set. For instance, if you’re a back-end engineer, you may get a question like, “Imagine you're in a team and we're building a credit card registration system. And it's used by different firms. How do you build the interface?”\nThis is the least important round at Microsoft: the lowest effort way to pass is to not blame your teammates, not show red flags, and stay positive.\nMicrosoft doesn’t have a specific set of traits they’re looking for. You can expect the usual questions about your strengths and weaknesses, failure, conflicts with colleagues, projects, and lessons you’ve learned from past experiences in your career.\n“A lot of people struggle with ‘What are your top 2 strengths and weaknesses?’ probably because they are trying to make up an answer on the spot. Good to prep answers to typical behavioral questions in advance.”\nUltimately, they are screening for three soft skills: positivity, ownership, and communication. They want to hire friendly people who can do the work and not blame others. This is not Apple or Netflix, where they want a particular flavor of personality, or where they ask interviewers to hire candidates they’d like to befriend. It’s more neutral.\nBehavioral rounds can sometimes have a coding component as well. When this happens, it might be an easy/medium-difficulty 20-min LeetCode-style problem.\nInterviewers grade candidates on different scales, depending on the team.\nSome orgs have an asynchronous feedback process, other orgs rely on live discussion, and still-other orgs do both. Some orgs have rubrics, and others don’t. Here’s how a rubric looks at one org:\nHere are a few more interview tips and resources to help you prep for a software developer or software engineer interview at Microsoft.\nIn addition, we’ve aggregated a bunch of useful Microsoft content for you! We have replays of candidates doing mock interviews with Microsoft interviewers, long-form solutions to common Microsoft questions, and deep dives into technical topics that tend to come up in Microsoft interviews.\nBelow are a series of mock interview replays, conducted by Microsoft interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Microsoft ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Microsoft interviews, we did two things. First, we spoke to a bunch of Microsoft interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Microsoft. Based on all of the above, here are the technical topics you’re likely to encounter:\nWant to know if you’re ready to interview at Microsoft? Do anonymous mock interviews with real Microsoft interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/microsoft",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Netflix Interviews + Questions",
      "content": "Netflix’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Netflix? Do anonymous mock interviews with real Netflix interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Netflix’s process, evaluation criteria, and interviewers.\nEvery human organization views themselves as a metaphor; Netflix doesn’t view themselves as a family like some other tech companies, they view themselves as a high-caliber sports team (in fact, Netflix calls their employees a “dream team”). They explain this metaphor themselves in their infamous culture memo.\nFinally, Netflix’s interview process is decentralized and team-dependent. Moreover, you can interview with multiple teams at Netflix concurrently, which can help you increase your odds of securing a job offer.\nPlease see the section above called “A note about recruiter calls”\nThis is a 30 minute call. A former Netflix employee called this round “Very chill, especially compared to the onsite.” This round consists of bidirectional surface-level questions.\nThe hiring manager will also be selling you on Netflix. Hiring managers doing selling is business as usual, but in this case, it serves an additional purpose – because their onsite is by far the most intense, they have to sell harder upfront because the onsite is a bigger commitment for the candidates.\nThe Netflix technical phone screen is a coding interview that typically lasts 45-60 minutes. There is significant inter-team variation on what these interviews cover, and the tooling you use during these interviews also varies by team,\nOnsite interview structure varies from team to team, but you’ll have roughly 8 interviews focused primarily on system design, then behavioral, and then coding.\nDepending on the length of the onsite, Netflix recruiting may ask you if you’d prefer to split the onsite over two days, and we recommend that you proactively ask to do that, given how taxing the behavioral and system design portions are!\nNetflix is the only FAANG that routinely includes 1-2 directors in their onsite loops. If your loop has two, it’ll be one director will be from your org and another from a partner org. Netflix does this to reduce bias. One director may do a system design interview, and the other will do a behavioral interview.\n“Don’t be thrown off by having to talk to directors. Just stick to the principles: when you speak about technical stuff you’ve worked on, focus on scale, availability, and security. When you speak about behavioral stuff: use shared ideas from their culture deck, take accountability for your wins and failures, and demonstrate metrics and impact.”\n“The HRBP [which is basically a very senior recruiting function] and the director would typically focus on behavioral rounds. I have also seen directors spending time (30 mins) just letting candidates ask and clarify any questions that they might have regarding the team, Netflix culture, career growth path or any other aspects. So, a strong recommendation would be to be ready with your genuine questions list and get things clarified in such interviews. Candid conversation is one of the key values at Netflix and asking genuine concerns if any is seen through good lenses, as that establishes candidates' seriousness about the role to some extent.”\nThe technical questions Netflix asks vary from team to team. Some teams don’t ask LeetCode questions. Other teams will ask medium-difficulty LeetCode-style coding questions with a creative/practical twist.\nThese rounds are going to change team by team, but the pattern we’ve noticed is that Netflix coding questions often come in two parts.\nTypically there is one question and, in scenarios where edge cases and tests are done early, say within 45 minutes, the interviewer may choose to spend some time discussing general large scale engineering concepts and distributed systems (like microservices, scalability, etc.). For instance, some expansions could be:\nThis is the most important round at Netflix. Coding carries the least weight, behavioral carries a lot, and system design has the most.\nNetflix system design rounds are highly unique and highly challenging. Netflix is to system design as Google is to coding; these technical interview rounds include the most difficult and bespoke questions.\nSimilar to how Amazon loves Leadership Principles, Netflix loves system design so much they even throw it into coding rounds sometimes – first, you solve a LeetCode-style problem. Then they ask you to apply it to a real-world use case.\nThat said, Netflix system design rounds are easier to prepare for if you know the patterns: Netflix loves scale. Netflix never wants to go down, and Netflix hates when things aren’t secure. Availability is super important to them; they want to ask and hear about tactics to scale systems, keep systems highly available, and maintain secure systems.\nAt Netflix, you’re likely to see unique questions that you won’t get anywhere else, and the system design round is the part of the process that Netflix interviewers take the most pride in, so they make up hard, one-of-a-kind questions from scratch. Thematically, their questions are more likely to be focused on scaling. They also like to ask about security and availability.\nIn fact, Netflix is more likely than the rest of FAANG to give you a system design round focused solely on security. For instance, you might get asked what you would do during a DDoS attack, and the entirety of the session will be spent drilling down into the details. And because they’re also obsessed with availability, you might get questions around backups and what to do if a service goes down.\nMoreover, as with their coding rounds, Netflix prefers questions with a practical application, and they’re likely to ask you about something they’re working on right now. If you research the hell out of their architecture – specifically the service that particular team is in charge of – and the other services this service interacts with, you’ll be in good shape.\nYou’re also likely to see a “reverse system design” round, where your interviewer will ask you pointed questions about the systems you’ve worked on before, e.g., the largest scale system you’ve worked on, how did you manage it, how did you scale it, etc.\nQuestions they most likely won’t ask are product-focused questions, such as “Design Spotify”.\nLearn about Netflix’s overall architecture so you can a) speak their language, and b) build or speak of something similar (in the interview) that Netflix has already built but simpler.\nFor the team you interview with: what’s their tech stack? What open source stuff do they do? With which other services might their service interact? That last question is most critical. If you can put forethought into how their current system works, you’ll have a huge leg up; then all you’ll need to do is discuss what you learned about their system to score a bunch of points with any of their interviewers.\nWhat tooling you use in these interviews depends on the team you’re interviewing with.\nAnswers to behavioral questions are almost as important as system design at Netflix. You’ll get rejected if you fail the behavioral screen.\nThese interviews have a heavy emphasis on the candidate being a cultural fit, being able to work in a team, having curiosity, and being product minded, highly motivated individuals capable of driving products forward.\nA unique part of Netflix’s behavioral interview is the “Dream Team” interview. This is a slightly more intense behavioral round conducted by a director. The \"volume\" is turned up on all of the things you might see in a typical behavioral round at Netflix (scale, accountability, open communication about concerns, high risk and high reward.)\n“Netflix doesn’t hire as much as other FAANGs, so they want to make sure you're a star. That’s what the ‘Dream Team’ interview is about.”\nOne key thing you need to do before your Netflix behavioral interview is read their culture memo. Our interviewers tell us that if you don’t do this, you will fail the behavioral round.\n“The culture illustrated in the culture memo is sort of accurate to how the culture at Netflix actually is, but the actual culture is less intense. Team members tend to get along really well. You don’t compete with others in your performance review like it is at companies like Facebook. We’re not ranked against peers, so people are more willing to help each other out.”\nNetflix will ask about impressive things you’ve done, as well as dig into your motivation (your “why”). This round will feel like you’re doing self-promotion. Typical questions will ask about your favorite project, latest project, and most significant project, as well as open-ended questions about what you’re looking for in your next role and why you’re interested in Netflix.\nPromote yourself early and often in Netflix behavioral rounds. Promote yourself proactively. Metrics and impact statements are effective ways to promote yourself because they convey a sense of scale and complexity.\nIt can be nerve-wracking to talk to a director for 45-60 minutes. It’s more nerve-wracking when, out the gate, they ask you to describe the biggest thing you’ve ever worked on. When talking to a director, it’s more important to have metrics and impact statements.\nNetflix interviewers are untrained, their questions are unstandardized, their interviews are team-dependent, and their decision-making north star is “Why”. You can interview with multiple teams concurrently, effectively giving you multiple shots on goal.\nThere’s also no specific company-wide scale for performance at Netflix. This is different from, say, Google, where all candidates are graded on the same “Strong Hire, Hire, Neutral, No Hire, Strong No-Hire” scale. Different teams have different processes, but most decisions are made based on live post-onsite discussions.\n“Netflix hiring decisions are black and white: pass or fail. And then you discuss if you'd be open to changing your mind. The only difference between Apple and Netflix was how they defined cultural fit. Besides that the hiring decisions were made in the same way: informal, mainly based on live discussions, binary decisions, and striving for consensus.”\nImpression management is more powerful at companies that do live feedback discussions. To learn more about impression management, check out the resources to prepare for Netflix later in this section.\nWe’ve aggregated a bunch of useful Netflix content for you! We have replays of candidates doing mock interviews with Netflix interviewers, long-form solutions to common Netflix questions, and deep dives into technical topics that tend to come up in Netflix interviews.\nBelow are a series of mock interview replays, conducted by Netflix interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Netflix ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Netflix interviews, we did two things. First, we spoke to a bunch of Netflix interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Netflix. Based on all of the above, here are the technical topics you’re likely to encounter:\nThe resources listed below are designed to help with various aspects of Netflix interview prep, from technical problem-solving to understanding the company’s core values.\nSince Netflix has the most difficult system design screen (and their version of this round has a lot of overlap with other FAANGs), if you prep for Netflix, you’re also upskilling for system design rounds at all FAANGs. We recommend the following resources to all engineers interviewing at FAANG:\nThese resources will help you “learn their language.” Then, when you communicate with Netflix, speak their language.\nWant to know if you’re ready to interview at Netflix? Do anonymous mock interviews with real Netflix interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/netflix",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Apple Interviews + Questions",
      "content": "Apple’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Apple? Do anonymous mock interviews with real Apple interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Apple’s hiring process, evaluation criteria, and interview experience.\nHumans in groups act out a chosen metaphor; Apple isn’t a sports team. They’re an army. Their army is made up of people obsessed with making great products. And they look to hire people who’ve embedded Apple products into their lives. Armies reward loyalty more than sports teams. Apple also has the longest tenured employees in FAANG (we're including Microsoft with FAANG for the purposes of this guide).\nApple is decentralized and lets candidates interview with different teams concurrently; if you want to maximize your odds interview with as many teams as you have the appetite for.\n“I interviewed with like 12 teams. I got 2 offers. Along the way, I told one of the Apple recruiter’s I was interviewing for another Apple team and they shrugged it off; they didn’t care.”\nApple’s interview process is more like what you might see at a startup than any other FAANG – from assigning which questions to ask to interviewer training to how hiring decisions get made. Significant inter-team variance is the norm, with each team essentially acting like a startup that’s coming up with its own way of conducting interviews.\nAt Apple, there’s no formal interviewer training. It’s very ad hoc. Every team is different. There is literally no process. What each of the teams does is rely on one of their very senior engineers or someone very experienced. Apple has a lot of people with long tenures, like 15 years. One of my colleagues had been there for 22 years. At Apple, the more senior you get the more the team trusts you to come up with your own questions. So what the interviewers at Apple typically do: you come up with a question that's not online, and you make sure it’s relevant to what your team is doing. Then you pitch it to your manager or tech lead. Then you run with it.\n“One thing not enough candidates know about is this: there’s no such thing as an Apple interview. You apply for a team. Not the company. When people ask me “How to prepare for an Apple interview?” I say ask the recruiter. Because they usually know what types of questions are asked. The recruiter spends 30 minutes or an hour per debrief where engineers are talking about the details about the code. So if the recruiter is paying attention or is at least a little bit technical, they should have a clue whether it’s LeetCode-style questions or embedded style questions. So ask your Apple recruiter a forced-choice question like, ‘Is this interview more X or more Y?’”\n“I was one of the people to come up with a take-home assignment for candidates. Which was my favorite part of the process at Apple. We were hiring people for full-stack but not just any full-stack – we wanted people who were coding in Python on the back-end and a particular framework on the front-end. We cooked up a take-home which was a scaled down version of what they’d be doing on the job: an internal tool built in those exact technologies. We gave them that take home and had them work on it for a week. Then we discussed it at the onsite where we’d live-debug it and talk about architecture. I really liked this ‘Try before you buy’ style process. Because Apple really wants you to be productive in week 2, if not at the end of week 1.”\nApple is the most likely to shock you; they’re more likely to ask you something you didn’t prepare for. Out of all the FAANGs, they’re the ones you can expect to do something unexpected, and some of their tactics can seem mercenary. Apple is the only FAANG which sometimes has a process to cut interviews short if the candidate clearly isn’t meeting the bar – if you don't perform above the bar for the first half of the interview, they’ll cancel the rest.\n“If by the fourth round, the hiring manager has gotten consistent feedback that doesn’t meet the bar, then they’d end the onsite early and reject the candidate.”\nApple is not results or process oriented. They’re motivation oriented. In other words, they care more about the “Why” than the “What” or the “How”, and as such, they value behavioral interviews more than coding.\nApple employees are obsessed with privacy. It’s not just marketing lip service. When asked if “privacy” is a buzzword at Apple, our interviewers said…\n“Privacy isn't just a buzzword. We are obsessed with it. To drive that part home. Because it’s so important. And as I mentioned, I was a part of a group focused on gathering user data - users here being Apple internal employees – to inform future products.\nEven at Apple, when we’re just getting data from internal employees, we anonymized the data. Just to practice what we preach. Privacy is huge. Another example to illustrate that is that people get fired for torrenting music.”\n“Unless you’re interviewing for a security role, very rarely. Technical people at Apple are hired to do what they do best. They have a whole army of compliance folks and lawyers to take care of that stuff. They also have an internal police force called “InfoSec”, which is the team which takes care of the secrecy stuff. Engineers are needed to do what they were hired to do: engineering.”\nPlease see the section above called “A note about recruiter calls” for what to expect. We do encourage you to ask your recruiter what to expect for the rest of the process because as you’ll see, there is a lot of variance from team to team.\n“Ask your Apple recruiter forced choice questions with two options, such as, ‘Is this coding round more of a typical LeetCode round, or more of a domain-specific open ended deep dive into a specific technology?’”\nLike everything else at Apple, the format and technical questions presented in Apple phone screens can vary a ton. Verify this by asking your recruiter!\nTechnical phone screens are coding interviews that range from 30 minutes to an hour. This tech interview may be between you and a single interviewer or sometimes a panel of interviewers. It may even be a hiring manager screen with a mix of behavioral questions and coding.\nIn any case, the general format is a shared coding environment where the interviewer(s) can assess your ability to utilize basic data structures and algorithms concepts. Being able to provide a solution for coding questions and quickly analyze the runtime complexity of your solution are key skills to have going into this interview.\nThe tooling used in Apple’s technical interview rounds depends on the team you’re interviewing with, but we’ve heard that some teams use CoderPad.\nSome teams give candidates a take-home assignment. They can give this around the same time they schedule a phone screen. The hiring manager is usually the person to decide whether or not candidates get one.\nThere will be roughly six to eight in-person rounds of interviews, each of which will be with your future teammates. Each round will have least one, or possibly two, interviewers.\nNote that an onsite loop with one team at Apple will look very different than an onsite loop with another.\nInterviewers can ask whatever behavioral, coding, or system design questions they want; there is no standardization for Apple interview questions. However, before an interview loop takes place, some teams will do a quick, informal assignment of what kinds of questions each interviewer is supposed to ask so that they don’t all end up asking the same things.\nMoreover, Apple interviewers are untrained, and as soon as a senior engineer is hired they can start conducting interviews.\nApple’s unpredictable nature makes it so some of their interview rounds can’t be categorized into behavioral, coding, or system design. Is a philosophical question about products a behavioral question? Not really. But they might ask one in a behavioral round. Are rapid fire infrastructure-focused open-ended trivia questions more system design or coding? It depends.\nFor example, here’s how one Apple interviewer describes the behind-the-scenes top-down directive before an upcoming onsite. “Go find a question that would be a good one to ask for our team.” That interviewer then ran it up the chain to an engineer above them. Then, that question immediately got asked in the next interview.\nAt Apple, each interview loop is specific to the needs of individual hiring managers – there is no canonical “Apple interview”, and everything is “made to order” for each specific team. That makes it difficult for candidates to prepare.\nSome teams at Apple prefer practical rounds. Sometimes, they’ll have you write a program on your own laptop and IDE. Other times, they’ll spend the whole round deep diving into a specific technology/use case that’s relevant for their team. For example, a team that wrote in Java and did a lot of work with concurrency had a whole round focused on concurrency in Java!\nOther teams do medium-ish LeetCode-style questions.\nAt the end of the day, these interviews vary so widely it’s hard to give a specific directive, other than: ask your recruiter. For senior and above candidates, it’s more about demonstrating competence rather than needing to ace the question.\nFor everything you need to prepare for Apple’s coding interview, check out the section called \"Apple coding interview preparation resources\" below.\nApple interviewers tend to ask questions relevant to a specific team’s work. For instance, a team focused on building web services will tend to ask questions about that, while front-end teams may ask UI-related questions. It may be good to try to get a feel for the day-to-day work from the recruiter/hiring manager, as the job descriptions are not always the most helpful (remember: privacy!).\nIn system design rounds, Apple interviewers love to hear about reliability. If you don’t know what else to talk about, dig into reliability.\nApple’s most important round is usually behavioral or system design. Behavioral rounds are more important than coding rounds.\n“In behavioral, you gotta be a rockstar. You gotta be a leader. If you’re abrasive, or if you’re not a cultural fit, how are you going to lead the juniors? And system design is going to weigh a little more than behavioral. If you can’t code or if you’re a little rusty –if you’re good at system design and behavioral–we’ll forgive the subpar coding rounds.”\nAn interesting paradox at Apple is: they highly value behavioral rounds but they don’t have a standardized way to assess candidates in those interviews\n“Towards the end of my career at Apple, we had a huge need for mobile developers. People who were able to do iOS apps. I was part of an R&D team. We mainly built web products in the beginning, but towards the end of my career we started doing more mobile stuff. We didn't want to hire someone who could only do mobile. We wanted someone who would be half as good at mobile stuff and half as good at web stuff, so they could plug themselves in anywhere.\nIf the interview process was standardized across the whole company - you can imagine how hard that would be to test specifically for the niche skill set we needed. Within two days we cooked up a whole new homework assignment just for the ios candidates, we cooked up a whole new set of interview questions. We kept the behavioral part the same. But the technical part - we flipped it over just like that. And it was really good. We changed the way we graded, we were able to filter candidates based on the new set of questions. It was just fast. We didn't get any pushback from HR. We didn't have to work with compliance. We just did it. Really fast. Really nimble.”\nBecause Apple doesn’t standardize their interviews, they’re particularly prone to bias. Sometimes the top down guidance to Apple interviewers is something like: “In the behavioral round, just see if you like them. See if you’d like to get a beer with them.”\n“[Interviews are never standardized.] And i’ll tell you why. Apple is a very secretive company. Everything is on a need to know basis. Also, it's a hugely political place. It was good for me because I understood the game. I didn’t blame the players I played the game. For those who understand the intricacies of politics, and simply accept the fact that it will happen when you have all Type-A people being paid a tremendous amount of money to do shitty little things, it's bound to happen. You have to accept it or you’re not going to play the game. Everything at Apple is very siloed. Even when it comes down to the cost center. Everything is super independent of one another. That's actually one of the strengths and weaknesses of Apple. We double effort for sure. But that doesn't matter to Tim Cook. They have billions of dollars to afford this – not a problem. I also really liked how it was siloed because teams and their priorities change, leadership changes, a lot of things change. Being able to decouple from the greater company enabled them to become one of the biggest, if not the biggest tech company in the world.”\nEven if rounds aren’t standardized, you will definitely be asked “Why Apple?”, and your answer needs to be on point. Some interviewers reject candidates solely for not having a good answer to this question. “Why Apple?” isn’t always a single question; they can spread this out into multiple questions and drill down on this for a good portion of a behavioral round. You can also expect other motivation-based (or “why”) questions.\n“A common red flag is giving generic answers to the ‘Why Apple?’ questions. If I didn't feel their passion or if they’re just treating Apple as another job, that’s usually a red flag for me regardless of their technical competence. They really have to somehow convince me – and this is an emotional response they have to bring out of me – they really have to convince me they really want to work at Apple, they really want to roll up their sleeves, and they really believe in our values: delighting the customer, sweating the details. Making awesome products… We only care about that. We don't care about anything else. That emotional response has to be drawn from me and if they don’t then I’m likely to say, ‘They were good but meh.’”\n“I can tell you about a great answer one candidate had for ‘Why Apple?”. He said something like… His wife and him were university students dating across two continents. This person said they shared a recent feature – I think it was like when you facetime and you can watch video in sync – he shared how that changed his life. His wife and him went through the whole international relationship because of that. That significantly helped their relationship.”\nApple wants to hire candidates whose lives have integrated with the Apple products. And the reverse is true too. It's a fatal flaw to say, “I've never used an iPhone or a Macbook or an iPad” because those people clearly haven’t integrated Apple products deeply in their lives.\nApple knows what they like, and they like their products! That doesn’t mean all you have to do is gush about the products to pass the behavioral round. It means you have to tell a genuine story which connects you and Apple products or services. Ideally, a story they will remember.\nAnother behavioral factor debated among Apple interviewers is whether or not they agree with the idea that Apple is “cult-ish.”\n“Apple cares most about the ‘Why’. You see that rooted deeply in every apple person's DNA. ‘Why Apple?’ Right? I guess this is where people get this notion of Apple being a ‘cult-ish’ company. Much like Tesla, actually. They have a huge customer following, but you also see the same pattern with their employees. Actually, I totally subscribe to this ideology. Because you want a person you work with day in and day out to have that same passion. Sometimes you're going to have to work overtime. You're not going to get paid extra for that. Sometimes you're going to work weekends. Sometimes shit’s gonna hit the fan. You don't want to work with someone who whines about it.\nOur theory is that Apple is more likely to reward employees (and candidates) who act like the leader. If you listen to 1:00:36 - 1:02:05 in an interview with Steve Jobs, you’ll see some stark similarities to how Apple interviewers talk about the organization. In this clip, he says, “You know how many committees we have? None. We are organized like a startup.” He then describes the benefits of silos and dividing things up.\nPrivacy and politics are the natural consequence of a place intentionally designed to be siloed and divided up and kept separate. It’s a cost that Apple accepts because the gain is increased productivity. Put people in closed systems (teams and orgs that don’t talk to other teams and orgs) and watch them get more done. This system works like blinders on a racehorse: it keeps vision focused down the track, on the goal, minimizing peripheral distraction. That’s all they need to see and they run/work faster because of it.\nOne final aspect of Apple’s behavioral rounds is that they will ask you specific questions about relevant skills. For example, if a team works with big data, they will ask specifically about a time you have worked with large-scale distributed systems in the context of your answer. If you don’t have direct experience with the field, they will try to get as close as possible, like asking you for what tradeoffs you’ve made when choosing a storage system. These behavioral interview questions serve two purposes: showing you have had relevant experience in the context of what the team is hiring for and trying to get you to talk about a particular behavioral skill (e.g., leadership, conflict resolution).\nAs evidenced by the highest chaos score, Apple doesn’t do many things in hiring consistently, across the whole company. One trend is that Apple teams rely on post-interview live discussions to make hiring decisions. This varies from somewhat informal (compared to the rest of FAANG) to laughably informal.\n“Post-onsite feedback for my org was 100% live discussions. At Apple I never had to write feedback. Which made me do more interviews. We made the decision on the same day. Everyone had to make a decision at the end of the day. Do an onsite, then at 5pm, we gather in a single meeting room, we do on the count of three: thumbs up, down, or in the middle. Then we talk after seeing the thumbs. And try to convince the people on the other side. If there’s less than 5 thumbs-up, then that might be an instant rejection. If there’s 6 or 7 or more thumbs up, the ‘thumbs up’ people try to convince the other side. Or in that same situation, the 3 or 4 thumbs down will try to convince the other side.”\nBecause of the informal decision-making process and reliance on live discussion, managing the impressions of your interviewers is more important at Apple than at other FAANG. In these decision-making meetings, if there’s dissent, they strive for consensus. The people on one side try to convince the other side. This process can last 15-30 minutes on average; all FAANG companies say interviewers fight for candidates, but Apple tends to fight more than most of them.\nBecause of their patterns of live-discussions and striving for consensus, Apple interviewers are more likely to fight for or against you (if your performance was on the fence) than any other FAANG, except maybe Netflix.\nUltimately, the hiring manager for that particular role has the most say, which means that that’s the person you should be working to impress the most.\n“My manager wanted to hire this person. But he failed my interview so badly. I didn't want to argue with my manager but at the same time I didn't want to work with this person. Because we are hiring people we’d work with on a daily basis. So arguments happen a lot. And in this case, I was the only ‘no’ on the board and the candidate got rejected.”\nWe’ve aggregated a bunch of useful Apple content for you! We have replays of candidates doing mock interviews with Apple interviewers, long-form solutions to common Apple questions, and deep dives into technical topics that tend to come up in Apple interviews.\nBelow are a series of mock interview replays, conducted by Apple interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Apple ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Apple interviews, we did two things. First, we spoke to a bunch of Apple interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Apple. Based on all of the above, here are the technical topics you’re likely to encounter:\nFor more in-depth information on Apple and their hiring process, or to learn more about Apple’s company culture, be sure to check out the resources listed below. These documents will help you better prepare for software developer and software engineer interviews.\nWant to know if you’re ready to interview at Apple? Do anonymous mock interviews with real Apple interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/apple",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Affirm’s Interview Process & Questions",
      "content": "Affirm’s Interview Process & Questions\nAffirm's Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Affirm can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Onsite (4 hours)\nAffirm has a hybrid process, which means that you interview for a specific org but will have engineers involved from across the company on your panel, as well as a hiring manager from the specific org you are interviewing for.\nThe entire process can be completed within 2 weeks. You’ll be asked to provide 3 different times that you’re available so you can be more, or less, aggressive in how you approach it.\nStep 1: Recruiter Call\nAffirm’s recruiter call lasts 30 minutes, and it’s more about prep for the hiring process than anything else. You might be asked about your interest in Affirm, and they will likely talk about the role you are applying for.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nAffirm’s technical phone screen lasts about an hour and is conducted in HackerRank.\nWe will cover what we know of their question style in the section called “Types of Interview Questions to Expect at Affirm” below.\nStep 3: Onsite\nYou can do the onsite section in one day or over two days.\n- Behavioral (45 mins). This is with the hiring manager of the team you are interviewing with. For more detail about the kinds of questions to expect, see the Behavioral section below.\n- Coding (1 hour). This will be conducted in HackerRank. For more detail about the kinds of questions to expect, see the Coding section below.\n- Second coding (1 hour). As above.\n- System design (1 hour). This will also be conducted in Hackerrank. For more detail about the kinds of questions to expect, see the System Design section below.\nTypes of Interview Questions to Expect at Affirm\nCoding\nAffirm’s coding questions are pretty straightforward and will be familiar to anyone practicing on LeetCode. You can commonly find them online. That said, their interviewers will try to put their own spin on questions – expect some variations, but if you can solve medium LeetCode problems, you should be fine.\nBelow are the technical topics you’re likely to encounter in Affirm interviews. To compile this list, we did two things. First, we spoke to some current and former Affirm engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nThis round won’t be a completely generic system design interview. It will usually relate to Affirm’s business. Expect questions about databases, multiple layers of schema, and functional design.\nYou might be asked to design a system that enables transactions between two users via their bank accounts but that has certain constraints built-in e.g., they can’t transfer more than what is in their account.\nTiming is important here. You won’t have enough time to go into everything in detail. Try to cover everything at a high level, and ask your interviewer which areas would be most interesting to delve into more thoroughly.\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nExpect the standard behavioral questions here. Questions like:\n- Have you ever felt pressure at work? How did you handle it?\n- When have you worked on a good team? Can you describe why it was good?\n- Have you ever received criticism from leadership at work?\nThis round is important as it is conducted by your potential manager. You can do well in the coding rounds but still fail out if you don’t perform well in the behavioral interview.\nHow Affirm Makes Hiring Decisions\nAll the interviewers submit their feedback, and the decision is made by the hiring manager.\nWant to know if you're ready to interview at Affirm? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/affirm-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Airbnb's Interview Process & Questions in 2024",
      "content": "Airbnb’s Interview Process & Questions\nAirbnb's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Airbnb can expect the following process\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Onsite (5-7 hours)\n- Team matching\nAirbnb’s interview process is fully centralized, which means that everyone enters the same standardized process, and team matching happens at the end.\nFor most levels of engineering at Airbnb, the process and questions are the same, but your answers are graded differently depending on your level. There is also a huge emphasis on culture fit, much more so than at most other companies of their size and stage.\nStep 1: Recruiter Call\nAirbnb’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Airbnb, and what you’re looking for moving forward. They’ll also review the specific role you’re applying for to make sure you understand the expectations and requirements.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nGenerally, there’s only one technical phone screen, but if your interviewer didn’t get enough signal in the first one, you may be asked to do one more. Airbnb uses CoderPad to conduct technical interviews, and in these interviews you’re expected to write working code and run it – pseudocode is not allowed, and the expectation is that you’re extremely proficient in your language of choice.\nStep 3: Onsite\nThe onsite at Airbnb consists of 5-7 interview rounds with the following steps:\n- Coding (1-3 hours)\n- System design (1 hour)\n- Behavioral (1 hour)\n- Culture Fit (2 hours)\nCoding\nAs with the technical phone screen, you’ll have to write working code and run it (no pseudocode). The number of rounds is dependent on your level, so more senior engineers will have less coding interviews, but more system design.\nSystem Design\nThis interview is similar to Google’s system design interview.\nBehavioral\nThis interview will touch on your past projects, contributions, how you work in teams, and so on. The core engineering culture at Airbnb is all about making your mark and owning your impact.\nCulture Fit\nAirbnb calls these “Host interviews”, and they’re conducted by non-engineers. These interviews are very important, even if you do well on the technical portion, fail these and you won't get an offer. They'll be evaluating whether or not you’d be a good culture fit with everyone at Airbnb, and how you embody their values:\n- Champion the mission\n- Be a host\n- Embrace the adventure\n- Be a cereal entrepreneur\nStep 4: Team matching\nOnce you’ve passed your onsite, you can expect to speak with anywhere from 1 to 4 hiring managers. The hiring managers will try to sell you on joining their team, but will also use the time to decide if you’re ultimately a good fit for their specific org.\nTypes of Interview Questions to Expect at Airbnb\nCoding\nAirbnb asks LeetCode-style questions, ranging from medium to hard difficulty.\nTo figure out what types of questions to expect in your Airbnb interviews, we did two things. First, we spoke to some current and former Airbnb interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews. Based on all of the above, here are the types of questions you’re likely to encounter:\nSystem Design\nYou may get low-level or high-level questions in this round. Examples include:\n- Design a cache system\n- Design a voting system\n- Design Twitter's trending topics\n- Design a load balancer\n- Design Facebook Messenger\n- Design an auth platform\nCheck out our guide to system design interviews to help you prepare.\nCommon Airbnb Interview Questions\nBelow are common questions that interviewers from Airbnb ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nHow Airbnb Makes Hiring Decisions\nThere is a hiring committee for engineering positions at Airbnb, who will ultimately decide on leveling, but whether or not to extend the offer falls to the hiring manager. You can expect an offer to come within a week or so of successful team matching.\nAirbnb Interview Replays\nWant to know if you're ready to interview at Airbnb? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/airbnb-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anduril’s Interview Process & Questions",
      "content": "Anduril’s Interview Process & Questions\nThe info below is based on conversations with Anduril engineers.\nAnduril's Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Anduril can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen AND/OR Hiring manager call (1 hour)\n- Onsite (4 hours)\nAnduril has a hybrid process, which means that you might interview with a specific team or you might do team matching at the end. One engineer we spoke to who recently went through the process told us:\nThey seem to tailor the interviewing process to what you say you’re interested in at the company during the early rounds, so be careful about what you say you want. Stick to what you’re good at.\nFrom our conversations, it seems that in certain cases you do interview for a specific role, but you could end up on multiple teams depending on how the process goes. If you are interviewing for a specific role, we were told by another engineer that you should:\nRead up about their product and the relationship between the role and the product, they will ask questions very specific to the role and product.\nSome of the engineers we spoke with had a hiring manager call instead of a technical phone screen, and some got both. More on that below.\nGeneral tips:\n- They might ask you how comfortable you’d be working in the defense industry.\n- LeetCode practice will help, as their coding problems are at a LeetCode medium level, although they like to add practical elements too.\n- If you’re going for a role that involves robotics, you need to know robotics in detail, particularly for L5/L6 level roles. They will press you to discuss the technical aspects of robotics even if your main question is more coding or system design based.\n- They don’t tend to hire for remote roles.\nThe entire process takes about 3-4 weeks, and we’ve heard it’s more enjoyable than the typical FAANG style interview process. From one of our users who recently interviewed with Anduril:\nTheir entire process seemed less formal than FAANG, more personable, more conversational.\nThey seem to be OK to move at your speed through the process. We’ve heard it can be done in as little as two weeks but that they don’t have a problem with you slowing things down.\nStep 1: Recruiter Call\nAndurils’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Anduril, and what you’re looking for moving forward. They’ll also sometimes ask you about your qualms, if any, about working in the defence industry.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen / Hiring Manager Call\nSometimes you’ll get one or both of these. It seems to depend on the role you are interviewing for.\nIf you get the standard technical phone screen, you can expect LeetCode medium-level questions. It will be algorithms and data structures based, but they will put it into an Anduril context, e.g., drone management. One engineer told us:\nThe question is not difficult algorithmically, but the follow-up questions in terms of how to speed and scale it up were trickier.\nIf you end up getting the hiring manager call instead, the objective will be to show you are a fit for the role, technically speaking. They’ll ask questions about your resume and experience before throwing in a coding question that is practical for the role in question.\nStep 3: Onsite\nThis will vary slightly by role but here’s what you can expect.\n- Coding (1 hour). This interview will be conducted in CoderPad. For more detail about the kinds of questions to expect, see the Coding section below.\n- Second coding (1 hour). For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). This interview will be conducted in CoderPad or on a whiteboard if you go in person. They also sometimes use the whiteboard feature in Zoom. For more detail about the kinds of questions to expect, see the System Design section below.\n- Behavioral (1 hour). For more info about what questions to expect, see the Behavioral section below.\nTypes of Interview Questions to Expect at Anduril\nCoding\nThis will likely be algorithms and data structures-focused but will skew more practical than typical LeetCode questions. A sample question we heard was about a collection of robots, where they had tasks to perform, and you needed to keep track of the highest priority tasks. Others involved drone management or graph manipulation\nYou will have two coding rounds, and they’ll be quite similar.\nBelow are the technical topics you’re likely to encounter in Anduril. To compile this list, we did two things. First, we spoke to some current and former Anduril engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nYou might get a pretty industry standard question here, or it could be very practical, depending on the role you are interviewing for. Some of the standard questions we’ve heard are:\n- Design Tinyurl\n- Design Tetris\nIf you get a more practical round, it might be related to managing drones in the field, where you have to get a signal from the drone and then send it back instructions. If you get a practical question, you need to be prepared to discuss the technologies, hardware included at least at a high level. The rounds for L5/L6 roles seem to skew more practical.\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nThe behavioral interview will be more conversational and less traditional than you might have seen at other companies. That said, it will still include the questions you’d expect in a behavioral interview. They will go over your resume and ask you about projects you’ve worked on in the past. Expect questions about the projects you’ve worked on and areas like:\n- Their scale and scope\n- Technical challenges and how you solved them\n- Conflict that arose and how you handled it\nYou might also learn more about the type of projects they are working on for the team you are being matched with or interviewing for. If so you’ll have the chance to ask questions, but you’ll also be asked how you’d see yourself fit into the role.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/anduril-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Anthropic’s Interview Process & Questions",
      "content": "Anthropic’s Interview Process & Questions\nThe info below is based on conversations with Anthropic engineers.\nAnthropic's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Anthropic can expect the following process:\n- Recruiter call (30 minutes)\n- Coding challenge (60-90 mins)\n- Hiring Manager call (1 hour)\n- Onsite (4 hours)\nAt Anthropic, you interview for one of their two orgs: Research or Applied. Your interviewers will all come from that org. There is likely some flexibility in terms of which team in that org you end up on.\nGeneral tips:\n- Brush up on system design\n- Though Anthropic’s coding questions are algorithmic, they tend to be more practical than the verbatim LeetCode questions that many companies use\n- Use a larger monitor for your coding Challenge – time is of the essence, and a laptop has limited real estate to view and write code\n- They don’t give exploding offers and are very patient through the process\n- They use Python, and you’ll need to be comfortable with it\nThe entire process takes about 3-4 weeks, and we’ve heard it’s very well thought out. From one of our users who recently interviewed with Anthropic:\nThis felt so easy and thoughtful compared to all the other companies I interviewed with. They have their shit together. Efficient, thoughtful, won’t waste your time. They move faster than expected!\nStep 1: Recruiter Call\nAnthropic’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Anthropic, your understanding of Anthropic’s value proposition, and what you’re looking for moving forward. They’ll also explain that they are a B Corp and cover what that means.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Coding Challenge\nWe’ve heard that this can be done live or asynchronously. Most of the people we spoke to took a 90-minute take-home assessment in CodeSignal, but Anthropic's website says you might get a 60-minute live assessment, so it seems to be role-dependent. It won’t be a LeetCode-style problem, but will still be pretty straightforward. You will be asked to complete a task that gets progressively more complex. One challenge we heard about was to implement a bank with multiple transaction types. You would have to build the core business logic for the application. We’ve heard that candidates tend to run out of time in this round, so manage your time carefully.\nOne engineer who took the take-home assessment told us that:\nThe screening was conducted on Code Signal, consisting of a general specification and a black-box evaluator. There were four levels. The spec would get more complicated at each level, and your code had to pass all the tests at one level to get to the next level. All in two hours.\nThe verbal spec was straightforward. No special algorithmic knowledge was needed. But the spec interpretation could only be obtained by repeatedly running your code to see what test cases failed.\nMakes me think the folks who go to the next level are probably good at reading ambiguous specs and trying out theories against black-box graders.\nStep 3: Hiring Manager Call\nThis is mostly a technical call and is usually split into two parts. You will be asked to talk about (1) a project you’ve completed and (2) review code examples in different programming languages. You’ll be asked to detect issues and recognize what task the code is used for.\nStep 4: Onsite\nThis will vary slightly by role but here’s what you can expect.\n- Coding (1 hour). This interview will be conducted in CodeSignal. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). This interview will be conducted in the drawing tool of your choice. For more detail about the kinds of questions to expect, see the System Design section below.\n- Second coding (role-specific)(1 hour). For more detail about the kinds of questions to expect, see the Coding section below.\n- Behavioral (1 hour). For more info about what questions to expect, see the Behavioral section below.\nTypes of Interview Questions to Expect at Anthropic\nCoding\nThis will likely be algorithms and data structures-focused but will skew more practical than typical LeetCode questions. A sample question we heard was about iterating over and debugging a call stack.\nMost coding rounds are carried out in a shared Python environment, so you’ll need to be comfortable with the syntax and standard library. Some roles will incorporate Machine Learning elements but only in one of the coding rounds and you can pass on that if you’d like. You do not have to know anything about machine learning to interview with Anthropic as an engineer. Below are the technical topics you’re likely to encounter in Anthropic interviews. To compile this list, we did two things. First, we spoke to some current and former Anthropic engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews.\nFirst, here’s a list of more niche technical topics that are, in our experience, specific to Anthropic:\n- Data mutation\n- Concurrency\nAnd here are technical topics that you’re likely to find at other companies as well (for these we’ve created detailed write-ups of their own):\nSystem Design\nAs with the other interviews, expect something practical here. It will very likely be related to an issue that Anthropic has encountered before. You might be asked to:\n- Design a system that enables a GPT to handle multiple questions in a single thread\n- Design a Claude chat service\n- Design a banking app\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nThis will be more conversational and less traditional than you might have seen at other companies. Expect questions about AI in areas like ethics, data protection, safety, the job market and knowledge sharing.\nHow Anthropic Makes Hiring Decisions\nDecisions are reached by consensus (everyone agrees to hire or no-hire), but in cases where consensus isn’t possible, the hiring manager has final say.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/anthropic-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Atlassian’s Interview Process & Questions",
      "content": "Atlassian’s Interview Process & Questions\nThe info below is based on conversations with Atlassian engineers.\nAtlassian's Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Atlassian can expect the following hiring process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Onsite (4-5 hours)\nAt Atlassian, the process is centralized, meaning you won’t do team matching until after the onsite phase. You’ll be interviewed by people from different teams during the interview loop.\nGeneral tips:\n- Their coding questions are discoverable online – they have a set bank that they use\n- You can use any language for the coding rounds and your own IDE\n- They have published their own guide to the engineering hiring process\n- They hire remotely, but salaries are location-specific\nThe entire process takes about 4-6 weeks.\nAn engineer familiar with their hiring process told us that Atlassian’s “Chaos Score is very low, i.e., there is a high level of consistency in terms of process and outcomes for different candidates.\nStep 1: Recruiter Call\nAtlassian’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Atlassian, and how the teams you’ve worked on before have been structured. They’ll also discuss the possible roles that are available.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen via Karat\nAtlassian uses a third-party interview service called Karat to conduct the technical screen that comes before the onsite. This seems to be true for most engineering roles but not all. If you haven’t been interviewed by Karat before, you’ll be interviewed by an engineer who does NOT work for Atlassian but who’s getting paid by Karat to conduct interviews on their behalf.\nIf you are interviewing for a backend or full stack engineering role, you’ll get a coding question. It will be a LeetCode-style, medium-level question selected from Atlassian’s question bank. You can find examples of the types of questions they ask online.\nIf you aren’t interviewing for a backend or full stack engineering role, we’ve heard that this can be a coding round OR a system design round and may be conducted by an Atlassian engineer, rather than an outsourced third party like Karat. If that ends up being the case, you will be able to use your own IDE or tooling, whatever language you’d prefer, and even any developer tools you use during your day-to-day, outside of AI technologies.\nIf you get a system design round, you might be asked to design something like a task list or job scheduler. You’ll be able to use any tooling you’d like to build the system. It’s really important to show how you are thinking about the problem by asking good questions, discussing tradeoffs and constraints, and mentioning both technologies and internal partners you might use to achieve your goal.\nStep 3: Onsite\nThis will vary slightly by role but here’s what you can expect during the back-end and full-stack hiring loops.\n- Coding x 2 (60 mins each). These interviews will be conducted in your IDE of choice. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (60 mins). This interview will be conducted in the drawing tool of your choice. For more detail about the kinds of questions to expect, see the System Design section below.\n- Values (45 mins). For more info about what questions to expect, see the Values section below.\n- Manager interview (60 mins) For more info about what questions to expect, see the Manager interview section below.\nTypes of Interview Questions to Expect at Atlassian\nCoding\nAtlassian has a bank of questions that they use for coding rounds, and you can find examples online. Except something that feels like a LeetCode medium-level question.\nThey are trying to test out how you would approach a problem if you encountered it at work, so you’re able to use the language and tooling you are comfortable with. They are assessing you based on 5 key criteria:\n- Code Quality: Clean up your code as you go and act as if it is eventually going into production.\n- Adaptability: Be prepared to be given additional requirements to incorporate as you go and be open to change when it makes sense.\n- Conceptual Thinking: Break down the problem in components and discuss it in conceptual terms before you start to solve it.\n- Decision Making: They put more focus on why you approach a problem from a certain angle than whether you solve it. Discuss the pros and cons of your decisions.\n- Resourcefulness: They want to see how you use your experience and other resources to solve problems when needed.\nBe prepared to discuss how to scale your solution as well!\nBelow are the technical topics you’re likely to encounter in Atlassian interviews. To compile this list, we did two things. First, we spoke to some current and former Atlassian engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nAgain, you can use any tooling you’d like for this round. You might be asked to:\n- Design a job scheduler\n- Design a task list\n- Design a tagging system\nThis is a pretty standard system design interview. You won’t need to code anything and the focus will be on how you would build the system and the tradeoffs, considerations and optimizations that might be involved.\nCheck out our guide to system design interviews to help you prepare.\nValues\nThis interview can be conducted by anyone at the company. You might talk to someone from Marketing, Sales or any other department. It will feature scenario-based behavioral questions. They prefer the STAR framework for answering questions, so brush up on that methodology. It’s a good idea to review Atlassian’s values and incorporate them into your answers. Expect questions about how you’ve handled giving and getting feedback, how you’ve worked on teams, etc.\nManager Interview\nThis is another behavioral interview, this time with an engineering manager, and it will be a deep dive into a past project you’ve worked on with a team, so be sure to prepare. The types of questions that you get here will focus on things you learned while working as part of a team and the scale and scope of your impact. They will ask questions around conflict resolution, the lessons you’ve learned, how you’ve mentored others, and how you were able to drive outcomes. Again, knowing Atlassian’s values, and incorporating them into your answers will help.\nHow Atlassian Makes Hiring Decisions\nDecisions are made by a hiring committee. We don’t have a lot of information on their process but we do know that they sometimes ask you to complete an additional round if you didn’t quite meet the bar during the onsite.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/atlassian-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Block/Square's Interview Process & Questions in 2023",
      "content": "Block/Square’s Interview Process & Questions\nThe info below is based on conversations with Block/Square engineers in 2023.\nSquare's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Block/Square (from now on we'll refer to them as Square) can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Onsite (4-5 hours)\n- Team matching\nSquare’s hiring process is a hybrid. Although you apply for a specific team from the get-go, your interviews will likely not be with the people on your team – interviewers are randomly selected from a pool – except for the hiring manager interview.\nNote: Square is one of the few companies that will actually give you some constructive post-interview feedback!\nThe entire process takes about 6 weeks, based on our sources.\nStep 1: Recruiter Call\nSquare’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Square, and what you’re looking for moving forward. They’ll also review the specific role you’re applying for to make sure you understand the expectations and requirements.\nIt’s really important to not reveal your salary expectations or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nSquare’s technical phone screen lasts about an hour. In rare cases, they will let very senior candidates skip this step. In this interview, you’ll pair with your interviewer on a coding problem in CoderPad.\nAfter this round is over, you’ll get high-level feedback about your performance from your recruiter, regardless of outcome (e.g., you might get feedback about your coding speed, your attention to detail, and so on).\nStep 3: Onsite\nThe onsite at Square consists of 4-5 sessions, depending on the role and experience level of the candidate. Most of the interviews, except for the hiring manager interview and the coding rounds, are two-person panels. If you’re a mid to senior-level engineer, you can expect the onsite to look something like this:\n- Coding (2 hours)\n- System design (1 hour)\n- (For L6+) Leadership interview (1 hour)\n- Hiring manager interview (30 minutes)\nCoding\nSquare’s onsite includes two separate 1-hour coding interviews, conducted in CoderPad.\nSystem Design\nThis round is conducted by a two-person panel.\n(For L6+) Leadership Interview\nThis round is conducted by a panel of two very senior engineers (both will be L6 and above).\nHiring Manager Interview\nThis is a call with a hiring manager from the team you’d be working on. For more junior engineers, it usually takes the form of a “Teach me something technical”. For more senior engineers, it’s usually a deep-dive into a relevant project you’ve worked on in the past.\nTypes of Interview Questions to Expect at Square\nCoding\nCoding questions at Square are practical, e.g., “Build an app to split a bill with friends”, rather than LeetCode-style. Square has a question bank with approved questions that interviewers can pull from, and they can submit their own questions to it as well, though there’s a rigorous review process:\n- You propose your question\n- It gets approved by other interviewers\n- You try out your question in the wild, and it gets shadowed as well\n- Once it’s fully approved, it goes into a company-wide question bank\nInterviewers are also encouraged to layer complexity in their interviews, and a question that might start out simple can go to unexpected places.\nSquare’s questions, while practical, may touch on the following technical topics/concepts, as you’ll need them to build whatever it is your interviewer tasks you with:\nSystem Design\nThese will likely be high-level system design questions, and though it’s now retired, one of the more common system design questions at Square was “Design a Hotel booking system”.\nCheck out our guide to system design interviews to help you prepare.\nCommon Square Interview Questions\nBelow are common questions that interviewers from Square ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nHow Square Makes Hiring Decisions\nAfter each round, interviewers leave feedback and makes a hire or no-hire recommendation. Those are then collected and sent to the hiring manager, who will decide whether to “plead your case” in front of the Hiring Bar (Square’s version of a hiring committee).\nNote that you can get mixed feedback from your interviewers and still get moved forward. It really depends on what the hiring manager needs and what they can justify.\nSquare’s Hiring Bar is composed of 3 people – either eng managers or senior engineers. Your hiring manager takes your resume and interview results and explains why you’d be an asset to their team. Then the Hiring Bar votes, and if you get at least 2 of the 3 votes, you get an offer.\nSquare Interview Replays\nWant to know if you're ready to interview at Block/Square? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/block-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Bloomberg’s Interview Process & Questions",
      "content": "Bloomberg’s Interview Process & Questions\nBloomberg’s interview process is completely decentralized. Each team asks its own questions, focuses on different things, and might have slightly different processes – for instance, some teams don’t ask any system design questions.\nLike many other decentralized companies (e.g., Amazon), you can apply to and interview with multiple teams simultaneously. However, all teams have access to the same applicant tracking system, so it’s possible that if you’ve done poorly with many teams already, subsequent teams may decline to interview you. From what we’ve heard, however, there’s no real downside in hedging your bets and talking to as many teams as possible.\nIf you do decide to interview with multiple teams, you’ll have to repeat the entire process below every time.\nGeneral tips for your Bloomberg interviews:\n- Do lots of algorithms and data structures practice\n- Be ready to interview in Java or C++\n- Read up on what Bloomberg does before your interviews, and have a good answer for Why Bloomberg?\nBloomberg’s Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Bloomberg can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Onsite (4 hours)\nStep 1: Recruiter Call\nBloomberg's recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Bloomberg, your understanding of Bloomberg’s value proposition, and what you’re looking for moving forward. They’ll also review the specific role you’re applying for to make sure you understand the expectations and requirements and go over the hiring process.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nBloomberg’s technical phone screen lasts about an hour and is conducted on Zoom and HackerRank. Algorithms and data structures are typically the areas of focus. Unlike at many other companies, you will not be running your code during the interview, so it’s OK if it’s not syntactically perfect, as long as it’s efficient and largely correct.\nStep 3: Onsite\nThe Bloomberg hiring process is all virtual, and they break the onsite up into individual sections – once you get through the first technical phone screen, you are essentially at the onsite phase but will have to pass each interview to get to the next.\nDuring the virtual onsite, you will use Zoom and HackerRank for all the sessions. The topics will vary team by team, so you may get system design questions or algorithms & data structures questions during the technical rounds, or a combination of both. It is possible to only get coding questions and not have to do any system design – the details vary from team to team.\n- Technical interview (1 hour). Just like in the phone screen, you won’t have to run your code. For more detail about the kinds of questions to expect, see the “Types of Interview Questions to Expect at Bloomberg” section below.\n- Technical interview (1 hour). As above.\n- Behavioral interview (1 hour). This will be a test of your soft skills by the HR team. Cultural fit is very important to them, so have a well-thought-out answer as to why you want to be there.\n- Final interview with a senior manager (1 hour). This will be your final interview and it will be conducted by a senior manager, someone who manages at least 50 engineers at Bloomberg. Some of the questions may be technical, others behavioral. Details depend on both the manager and the team.\nTypes of Interview Questions to Expect at Bloomberg\nEach team has its own questions, and there is no central bank. Some teams only ask coding questions, but others will mix in system design questions. Your questions might be in C++ or Python depending on the team. Most teams at Bloomberg use C++. Senior people should know C++ going in, though Java also works. Not knowing either of these languages isn’t a deal-breaker, but it can be a tiebreaker when deciding between two candidates who did well otherwise.\nCoding\nAs there is no central bank of questions, each team and each interviewer will pull questions from elsewhere. This could be from LeetCode, previous companies they’ve worked at, or questions they’ve seen before at Bloomberg.\nMostly, you should expect standard algorithms and data structures questions in this round. To figure out what technical topics might come up in your Bloomberg interviews, we did 2 things. First, we spoke to some current and former Bloomberg interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews. Based on all of the above, here are the types of questions you’re likely to encounter.\nSystem Design\nSystem Design questions at Bloomberg tend to skew practical and tend to be finance-related. For instance, you might be asked questions such as: How would you design a stock exchange?. Unlike other companies, you might be asked to write code during this interview.\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nThis will be a pretty standard behavioral interview conducted by someone from the HR team. Expect questions about your past experience and some situational scenarios, e.g., How would you handle conflict in the office?\nIt’s also very important to do your homework and read up on Bloomberg and what they do, so you can effectively answer questions about why you want to work there.\nHow Bloomberg Makes Hiring Decisions\nTheir interviewing team will sync after each stage of the onsite process and do a debrief. This will determine whether or not you pass through. It’s possible to be sent home after any of the onsite rounds.\nWant to know if you're ready to interview at Bloomberg? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/bloomberg-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Capital One's Interview Process & Questions in 2024",
      "content": "Capital One’s Interview Process & Questions\nCapital One’s Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Capital One can expect the following process:\n- Recruiter call (30 minutes)\n- Online assessment (via CodeSignal) (1.5 hours)\n- Onsite, or as they call it, a “Power Day” (3-4 hours)\n- Team matching\nCapital One’s process is fully centralized. This is a recent change – before that, you had to apply separately to each team. Now, everyone enters the same standardized process, and team matching happens at the end.\nOnce you apply, a hiring manager will review your information and coding assessment to decide if they want to invite you for the virtual onsite (aka Power Day). If there are multiple hiring managers interested, you’ll have an opportunity to chat with them after your onsite and make a choice of team.\nStep 1: Recruiter Call\nThis is a typical recruiter call, where they’ll ask about previous experience, relevant projects, and why you’re interested in Capital One. They’ll also elaborate on the role and confirm that your experience and expectations are a good match.\nIt’s really important, at this stage, not to reveal your salary expectations, your salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number. Just don’t do it – when you give out information this early in the process, you’re painting future you into a corner.\nStep 2: Online Assessment\nCapital One’s online assessment consists of three LeetCode-style algorithms and data structure questions: one easy, one medium, and one hard, administered via CodeSignal. You get 1.5 hours to complete it.\nStep 3: Onsite aka “Power Day”\nCapital One’s onsite lasts roughly 4 hours and consists of the following steps:\n- Coding (1 hour)\n- System design (1 hour)\n- Behavioral (1 hour)\n- Case study (1 hour)\nCoding\nThis interview takes about an hour and focuses on algorithms and data structures. You’ll share your screen with the interviewer (usually over Zoom) and code in whatever environment you usually work in. Capital one’s preferred languages are JavaScript, Java, TypeScript, Python, and Go.\nSystem Design\nThis is a one hour interview. The expectation here is that you’ll be able to go in-depth on your design choices and that your design needs to be as functional as possible, given the interview time allotted. One common mistake we heard about from one of our interviewers at this step is that people get hung up on trying to perfect a small piece of their solution instead of getting to an end-to-end solution that works. With that in mind, make sure that you’re able to articulate your assumptions and call out any shortcomings in your design.\nBehavioral\nThis interview can either happen live, in which case it lasts one hour, or in some cases it’ll be an asynchronous online assessment. In both cases, it’s pretty standard behavioral fare – you’ll get questions with the expectation that you’ll answer using the STAR format.\nCase Study\nIn this interview, you’ll be presented with a hypothetical situation and asked to develop a solution to the underlying business problem. This interview evaluates your communication skills and business sense, as well as your ability to think logically and quantitatively. It’s important to be aware of Capital One’s values and incorporate them into your responses.\nStep 4: Team Matching\nOnce you finish your onsite, your interviewers will submit their hire/no hire recommendations. If you were matched with only one team, you’ll be extended an offer. If you matched with multiple teams, you’ll have a brief chat with each of the hiring managers, so that you have an opportunity to decide where to go, at which point the offer will be extended officially.\nTypes of Interview Questions to Expect at Capital One\nCoding\nThis interview usually has two medium-difficulty LeetCode-style questions.\nTo figure out what types of questions to expect in your Capital One interviews, we did two things. First, we spoke to some current and former Capital One interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews. Based on all of the above, here are the types of questions you’re likely to encounter:\nSystem Design\nThe focus of this interview depends on the interviewer and your seniority. While there’s a general focus on high-level system design, some interviewers will let you choose the focus (OOD, UI, etc.). The most popular question we’ve heard about is “Design a banking system”.\nCheck out our guide to system design interviews to help you prepare.\nCommon Capital One Interview Questions\nBelow are common questions that interviewers from Capital One ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWant to know if you're ready to interview at Capital One? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/capital-one-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Coinbase’s Interview Process & Questions",
      "content": "Coinbase’s Interview Process & Questions\nCoinbase’s process is almost completely decentralized, with each team typically running its own hiring funnel. This means you can interview with multiple teams although they sometimes allow you to skip stages if they feel like they’d be duplicating their efforts. There doesn’t seem to be any downside to interviewing for more than one role at a time. In fact, if you end up interviewing for multiple teams, you may be able to skip steps (e.g. not have to repeat CodeSignal).\nA good way to get into the process with Coinbase is to find a role you like and then track down the lead recruiter or hiring manager aligned to it on Linkedin. Recruiters will also share candidates they like with other teams if they don’t have a slot open on their specific team.\nGeneral tips for your Coinbase interviews:\n- It’s OK to reach out to your recruiter or hiring manager contact to ask questions\n- If you feel like there was some miscommunication during an interview, be proactive and reach out to the recruiter afterward to clear things up\n- Apply for the right level and don’t be too aggressive – it’s better to secure a role at a lower level than to fail out of a higher one.\nCoinbase’s Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Bloomberg can expect the following process:\n- CodeSignal assessment (70 minutes)\n- Recruiter call (30 minutes)\n- Onsite (3 hours)\nStep 1: CodeSignal Assessment\nThis is an asynchronous challenge focused on data structures and algorithms. As of the date of publication, it includes 4 questions for you to work on. The first one is usually a warm-up. The others are LeetCode medium-level.\nStep 2: Recruiter call\nCoinbase’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Coinbase, your understanding of Coinbase’s value proposition, and what you’re looking for moving forward. They’ll also review the specific role you’re applying for to make sure you understand the expectations and requirements and go over the hiring process. Once you pass this stage you’ll enter the team pipeline.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 3: Onsite\nThe Coinbase onsite is usually done over two days and includes three, one-hour long interviews. You’ll do two technical interviews and one final call with a hiring manager. For the technical portions, you can use your own IDE with a screen-share, or they can provide tooling.\n- Technical interview (1 hour). For more detail about the kinds of questions to expect, see the “Types of Interview Questions to Expect at Coinbase” section below. You can typically use whatever language you want, although a few teams do require you to use a specific language.\n- System design interview (1 hour). As above.\n- Interview with a hiring manager (1 hour). As above\nTypes of Interview Questions to Expect at Coinbase\nEach team has its own questions, but there are consistencies in the type you will encounter at each stage.\nCoding\nThis round is a “pseudo project” – you’ll be asked to build a feature, and you’ll get input data in the form of a mini database. You will have one hour to get as far as you can.\nSystem Design\nSystem design questions at Coinbase tend to skew practical. Many questions involve setting up microservices and then showing the network topology of your chosen architecture. Basically, they will want to test your understanding of microservice architecture but through the lens of building a product.\nCheck out our guide to system design interviews to help you prepare.\nHiring Manager Interview\nThis will be your final interview, and it will be conducted by a hiring manager. You’ll likely be asked some culture fit/behavioral questions, but at this point, the hiring manager will also be trying to sell you on the role.\nHow Coinbase Makes Hiring Decisions\nTheir interviewing team will all meet after the onsite and give their feedback to the hiring manager, who will make the decision. A director will then review the decision and has the power to veto, but this very rarely happens.\nWant to know if you're ready to interview at Coinbase? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/coinbase-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Databricks’s Interview Process & Questions",
      "content": "Databrick’s Interview Process & Questions\nThe info below is based on conversations with Databrick engineers\nDatabricks's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Databricks can expect the following process:\n- Recruiter screen (30 minutes)\n- Technical phone screen (1 hour)\n- Hiring manager call (1 hour)\n- Onsite (spread across 4-5 hours)\nDatabricks has a hybrid hiring process. Candidates are typically matched to a specific part of the organization early on, and you'll interview for a specific role, but your interviewers will not necessarily be people from your future team. There is also scope to switch roles after the onsite. According to our sources, about a quarter of candidates pivot to another team after completing their onsite interviews.\nThe entire process can take up to 8 weeks, making it one of the longer hiring processes in the industry. Recruiters are upfront about this timeline with candidates.\nGeneral tips:\n- Study LeetCode questions, particularly those tagged for Databricks in the past 3 months, as some questions come directly from this pool. You’ll get LeetCode medium and hard level questions.\n- Brush up on concurrency and multithreading concepts, which are essential for one of the coding rounds.\n- Practice system design on Google Docs, as it is sometimes used for the system design round.\n- Be prepared for graph algorithms and optimization problems, as these appear frequently in the coding rounds.\n- Have impressive references ready—they're weighted heavily in the final decision process at Databricks.\nStep 1: Recruiter Call\nDatabricks' recruiter screen lasts about 30 minutes, and it’s pretty standard fare.. They'll ask about your previous experience, your interest in Databricks, and go over the specific role you're applying for. At this stage, your profile (resume, referral information, location preferences) begins to be shared with engineering leads for potential team matching.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nThe technical phone screen lasts about 1 hour with an engineer. You'll use CoderPad or a similar online IDE with runnable code. Expect LeetCode-style questions, typically medium to hard difficulty. One engineer we spoke with, who had just gone through the process, told us:\nThe question was one of the LeetCode questions for Databricks. I was able to find it by searching for the common Databricks questions from the past 3 months.\nQuestions candidates have faced include a weighted paths problem (graph optimization) and the house robber problem, which builds in difficulty as time permits. After the technical screen, Databricks begins preliminary level mapping. For L4/L5 roles, the interview loops remain similar.\nStep3: Hiring Manager Call\nMost candidates, particularly for senior roles, will have a 1-hour call with a hiring manager for the role they have been mapped to initially. This interview is primarily behavioral, covering your background and experience, what you've worked on and enjoy working on, and questions you have about Databricks and the specific organization. If a hiring manager is unavailable, you might be interviewed by the Director of Engineering for the organization in question.\nStep 4: Onsite Interviews\nAt this point, candidates interview for specific teams based on their background and interests. Onsite interview loops vary slightly depending on role (ML, frontend, backend, etc.) and seniority level, but the below is generally what you'll get:\n- Coding 1: Algorithms (1 hour). This interview will be conducted in CoderPad or a similar online IDE with runnable code. For more detail about the kinds of questions to expect, see the Coding section below.\n- Coding 2: (1 hour). For more detail about the kinds of questions to expect, see the Coding section below.\n- Coding: Concurrency/Multithreading (1 hour). This round focuses on implementing programs that leverage multithreading for efficiency. For more detail about the kinds of questions to expect, see the Coding: Concurrency/Multithreading section below.\n- System Design (1 hour). The system design interview is often conducted using Google Docs, which some candidates find unusual compared to whiteboarding or specialized diagramming tools. For more detail about the kinds of questions to expect, see the System Design section below.\n- Cross-functional/Behavioral (1 hour). For more detail about the kinds of questions to expect, see the Cross-functional/Behavioral section below.\nTypes of Interview Questions to Expect at Databricks\nDatabricks' technical questions tend to lean toward the difficult side. For coding interviews, expect LeetCode hard more than medium questions.\nCoding\nThere are usually 3 coding rounds. Two will focus on Data Structures and Algorithms, and one might focus on concurrency and multithreading. The coding rounds that include algorithm questions are LeetCode medium or hard in terms of level. An example question we heard involved IAP to CIDR (checking if IP address ranges fit into CIDR notation). Another was a variable-sized tic-tac-toe game implementation question.\nCandidates report these coding rounds tend to involve tricky optimizations—you can use a brute force solution to make progress, but you should be thinking of optimizations throughout.\nIn the Concurrency and Multithreading coding round, you might be asked to implement an efficient logger that processes messages in a queue. This round is considered particularly challenging by most candidates. One engineer we spoke to, who is familiar with the process, told us:\nThis question wasn’t on LeetCode, but preparing by solving the LeetCode questions on concurrency and multithreading will be a huge help.\nBelow are the technical topics you’re likely to encounter in Databricks interviews. To compile this list, we did two things. First, we spoke to some current and former Databricks engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nTheir system design questions are pretty standard, but they will expand on the initial question to dig deeper into your depth of knowledge. One example we heard involved designing a service that provides customers with the cheapest copy of a book they're searching for, which requires considering integration with different book distributors, search functionality, and purchase flows.\nBe prepared to use Google Docs for these interviews rather than whiteboarding tools, which some candidates found unusual. This choice seems to be up to the individual interviewer, so don’t be caught off guard!\nCheck out our guide to system design interviews to help you prepare.\nCross-Functional/Behavioral\nThis interview is with the hiring manager and includes standard behavioral questions about your past experiences and projects. The recruiter may brief you on the hiring manager's style beforehand. You’ll be asked about your past projects and explore areas of conflict resolution and teamwork. Expect questions like \"Tell me about a time you had a conflict with a coworker\" and \"Describe a project you're most proud of,\" with deep follow-up questions on specifics.\nHow HubSpot Makes Hiring Decisions\nAfter the onsite interviews, Databricks has a thorough evaluation process that consists of multiple layers of review.\nReference checks are an important part of the evaluation, typically involving 1 manager and 2 more senior team members. Databricks emphasizes having impressive references, as they're weighted heavily in the final decision.\nNext comes the Hiring Committee review. Unlike the interview panel, this is a separate committee that reviews all aspects of your candidacy: interview feedback, background, career trajectory, and references. Our sources emphasize that the final decision is holistic, so having every aspect of your application as strong as possible is crucial.\nFinally, the VP of Engineering reviews the complete candidate packet and has the final say on hiring decisions. One of our sources reported failing at this step despite positive feedback in earlier rounds, suggesting that the bar remains high throughout the entire process.\nIn some cases, candidates might be asked to complete an additional take-home assessment after the onsite. While this is rare, it might be used when the recruiter believes it could strengthen a candidate's application. These assessments can take around 5 hours to complete and may involve specialized problems such as database challenges.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/databricks-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Datadog's Interview Process & Questions",
      "content": "Datadog’s Interview Process & Questions\nThe info below is based on conversations with Datadog engineers.\nDatadog's Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Datadog can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Onsite (4 hours)\nGeneral tips:\n- Practice algorithmic questions that lean practical in terms of the type of work Datadog does (but practicing LeetCode questions will help do well in these – many of their questions start as a LeetCode medium and then layer on complexity/get more practical)\n- Prepare to answer some technical questions about your past work during the behavioral portion of the onsite.\nAt Datadog, the process is centralized, which means that you won’t do team matching until after the onsite phase. You’ll be interviewed by people from different teams during the interview loop.\nThe entire process takes about 6 weeks, and we’ve heard it can seem quite slow at times. You might have to push to speed things up.\nStep 1: Recruiter Call\nDatadog’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Datadog, and what you’re looking for moving forward.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nDatadog’s technical phone screen lasts about an hour and is conducted in CoderPad. You will get two questions in this interview. We will cover what we know of their question style in the section called “Types of Interview Questions to Expect at Datadog” below.\nStep 3: Onsite\nOnsite interview loops can vary slightly depending on the role and seniority, but the below is generally what you’ll get.\n- Coding (1 hour). This interview will be conducted in CoderPad. For more detail about the kinds of questions to expect, see the Coding section below.\n- [Only for roles below Staff] Second coding (1 hour). As above.\n- System design (1 hour). This interview will be conducted in your choice of tool (many candidates choose Excalidraw). For more detail about the kinds of questions to expect, see the System Design section below.\n- Behavioral (1 hour). This interview will be conducted by a hiring manager or director of engineering. It may feature some technical questions! For more info about what questions to expect, see the Behavioral section below .\n- [For Staff level roles and above] Presentation (1 hour). This will replace one of the coding rounds. You will be asked to present a project you’ve worked on in the past to a panel. You’ll be expected to justify the technical decisions involved and explain the business context or rationale for what you did. If you do this interview, you may have to pick teams you're interested in beforehand so people from those teams can attend.\nTypes of Interview Questions to Expect at Datadog\nCoding\nFrom the first technical phone screen through to the onsite coding rounds, you should expect algorithmic questions but likely NOT questions taken verbatim from LeetCode – Datadog has their own internal question bank. We’ve heard that the questions are a hybrid between practical and LeetCode-style. They might start with something similar to what you can find on LeetCode but then layer on additional complexity. Datadog themselves recommend practicing medium-level LeetCode questions. You might be asked questions like these:\n- Bucketing numbers given specific requirements\n- Given a root directory, find the total size of all the files across all sub-directories\n- Given an interface and a file class, build a buffered file writer\nBelow are the technical topics you’re likely to encounter in Datadog interviews. To compile this list, we did two things. First, we spoke to some current and former Datadog engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nWe’ve heard that this round is less broad than it can be at other companies. You won’t be asked to “Design Twitter”, for example. Instead, you might get a question such as, “Given a service that returns flight deals for the last 7 days, design a system that surfaces relevant flight data to a user and notifies the user when there’s a new flight that matches their criteria.”\nAs one of our users said:\n\"[I] didn’t have to go into detail in every area. They kept it very high level, and the interview felt fair.”\nWhile it might be a fair interview, it’s also used for leveling so make sure to brush up on system design. We’ve heard of candidates being down-leveled for less-than-flawless performance here.\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nThis interview will be with someone in a leadership role at the company, possibly a director. It will contain some standard behavioral questions but also some technical questions about your past work.\nYou might be asked to show a simple design of something you built at a previous company. The interviewer will want to know why certain design choices were made so they can understand your impact on the project and your level of experience working within teams.\nHow Datadog Makes Hiring Decisions\nAfter a successful onsite, a Hiring Committee will decide if you should be hired.\nIf they want to make an offer, your profile will be shared with multiple hiring managers for team matching. You’ll get a chance to meet a few people from the team including the hiring manager. This is more about you figuring out a good fit than being a continuation of the interview process.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/datadog-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "DoorDash’s Interview Process & Questions",
      "content": "DoorDash’s Interview Process & Questions\nDoorDash's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at DoorDash can expect the following process:\n- Recruiter call (30 minutes)\n- Hiring manager screen (1 hour)\n- Technical phone screen (1 hour)\n- Onsite (4-5 hours)\nGeneral tips:\n- Have STAR-style behavioral answers prepared because behavioral interviews are used for leveling\n- Polish up on system design. Along with behavioral, it’s what determines your level, and the bar is high.\nAt DoorDash, the process has recently moved from centralized to decentralized. This means that the interview process will vary from team to team somewhat. You apply and interview for a specific role, and the hiring manager for that role will be part of your loop. You can interview for up to 3 roles at a time and will encounter interviewers from across the organization in most scenarios.\nThe entire process takes about 3-4 weeks but can be completed in as little as 2 weeks, according to our sources.\nStep 1: Recruiter Call\nDoorDash’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in DoorDash, your understanding of DoorDash’s value proposition, and what you’re looking for moving forward. They’ll also review the specific role you’re applying for to make sure your skill set matches the requirements. After this call, the recruiter will circulate your resume and specific hiring managers will have the opportunity to pick it up and request to interview you.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Hiring Manager Screen\nThis interview will be with the hiring manager for the team you applied to. They will ask you to do a deep dive into a previous project.\nStep 3: Technical Phone Screen\nThis is a pretty standard technical screen and normally gets conducted in CodePair (HackerRank). Our sources tell us that LeetCode medium questions are pretty typical in this round.\nStep 4: Onsite\nAt this point, candidates are split into different loops depending on the role they are interviewing for, e.g., infrastructure, frontend, backend etc. Onsite interview loops vary slightly depending on the role and seniority, but the below is generally what you’ll get:\n- Two coding rounds (1 hour each). These rounds usually take place in CodePair (HackerRank). For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). For more detail about the kinds of questions to expect, see the System Design section below.\n- Behavioral (1 hour). For more info about what questions to expect, see the Behavioral section below.\nTypes of Interview Questions to Expect at DoorDash\nDoorDash has shifted its process from a centralized one to a decentralized one pretty recently, so there is some variation in terms of the style of question you will encounter. That said, the engineers we’ve spoken to say it’s still pretty standard fare across the board, so practicing medium-level LeetCode questions will help.\nCoding\nThis interview will be less algorithms and data structures heavy and will look to test your ability to write code fast and refactor quickly. You won’t be asked to use any specific programming language. Most questions should be practical in nature, and LeetCode questions that focus on job scheduling are popular.\nFrom one of our users, who was a DoorDash interviewer:\nSome questions are very practical, but it depends on the interviewer. Some love very specific LeetCode-style graph questions.\nBelow are the technical topics you’re likely to encounter in DoorDash interviews. To compile this list, we did two things. First, we spoke to some current and former DoorDash engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nThis round focuses mostly on large systems and will involve designing an entire service or app with scalability, reliability, and usability concerns in mind. Expect a vague problem with ill-defined boundaries. Your focus should be on not getting lost in one area. Ask your interviewer what area you should hone in on.\nThey use this round for leveling, and senior candidates should be able to call out all requirements and considerations. They aren’t looking for a full solution here, so don’t get lost in the details. Cover all bases and concerns.\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nThis round varies by role but is usually with the hiring manager for your team. It is a behavioral interview, but the hiring manager will also try to close you. You could pass all the other rounds and not do well here but still get an offer. Expect to answer questions about past experiences.\nHow DoorDash Makes Hiring Decisions\nThe entire onsite panel submits written feedback after the interviews are completed, and then they have a roundtable meeting to discuss both hire/no-hire and leveling. Most of the time, decisions are reached by consensus (everyone agrees to hire or no-hire), but in cases where consensus isn’t possible, the hiring manager has final say. Our sources say that it is rare for a hiring manager to veto a hire.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/doordash-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Figma’s Interview Process & Questions",
      "content": "Figma’s Interview Process & Questions\nThe info below is based on conversations with Figma engineers.\nFigma's Interview Process for Software Engineers: 4-5 Steps\nMid to senior-level engineers interviewing at Figma can expect the following process:\n- Recruiter call (30 minutes)\n- Hiring manager call (45 mins)\n- Technical phone screen (1 hour)\n- Onsite (4 hours)\n- Additional “Executive Screen” for Staff-level engineers (1 hour)\nStaff-level engineers (or even Seniors on the cusp of Staff) can sometimes get an additional round after the onsite. This is an executive screen, which is essentially a behavioral interview with the director of the team you are interviewing for.\nFigma’s hiring process is a hybrid. Although you apply for a specific team from the get-go, your interviews will likely not be with the people on your team – interviewers are randomly selected from a pool – except for the hiring manager interview and the executive screening (if applicable).\nGeneral tips:\n- You’ll get a guide to Figma’s hiring process that includes a lot of useful information\n- Their interview process is language-agnostic\n- Brush up on general algorithms and data structures, but be prepared for them to use Figma terminology when they pose the questions\n- They say you can only apply to one role at a time, so pick wisely\n- Try to get a referral; it’s hard to get into the process otherwise\n- Learn as much as you can about Figma’s architecture\n- Express why you like the product and why you want to join–they are on the path to IPO and getting a lot of high-quality applicants\nThe entire process takes about 3-4 weeks, but we heard they can move faster if needed.\nStep 1: Recruiter Call\nFigma’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Figma, your understanding of Figma’s value proposition, and what you’re looking for moving forward.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Hiring Manager Call\nThis is a pretty standard behavioral call with the hiring manager of the team you are interviewing for. Expect some questions about your background and experience but also some information about the team and what they are working on. You’ll get time to ask your own questions too.\nStep 3: Technical Phone Screen\nThis interview is scheduled as a block with the hiring manager call above and will be conducted in CoderPad. The questions will be algorithmic, but they will be set in a Figma context. In other words, they might pose a problem they run into at Figma and ask how you’d solve it with code, or ask you a very standard algorithmic question, but layer in some Figma terminology. It’s a good idea to brush up on Figma’s names for the various components they use. You can find information here. Expect about a medium in terms of LeetCode-level.\nStep 4: Onsite\nAt this point, candidates split into different loops depending on the role they are interviewing for e.g., ML, frontend, backend etc. Onsite interview loops also vary slightly depending on the role and seniority, but the below is generally what you’ll get:\n- Coding (1 hour). This interview will be conducted in CoderPad. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). This interview will be conducted in Figma. For more detail about the kinds of questions to expect, see the System Design section below.\n- Second system design (1 hour) This interview will be conducted in Figma. For more detail about the kinds of questions to expect, see the System Design section below.\n- Behavioral (1 hour). For more info about what questions to expect, see the Behavioral section below.\n- Project deep dive (1 hour) For more info about what questions to expect, see the Project Deep Dive section below.\n[Staff-level or Close to It] Step 5: Executive Screen\nIf you’re interviewing for a Staff level role, or quite senior and on the cusp of Staff, they will do one more round after the onsite. It is a behavioral round with a Director. They might tell you this is a casual chat, but one engineer said:\nThe Director clearly used all the feedback given during the onsite and intentionally drilled into areas that were outside of what I’d covered before. This was very intense!\nTypes of Interview Questions to Expect at Figma\nCoding\nThis will likely be algorithms and data structures-focused but will skew more practical than typical LeetCode questions. Expect about a LeetCode-medium level of difficulty. An engineer we spoke called described them as\nPretty standard algorithms and data structures questions, but they are all Figma-flavored.\nSample questions include:\n- Implement a Figma doc with layers, properties, class definitions, and ways to update\n- Print out objects on a 2D canvas in a sequential order, left to right and top to bottom\nBelow are the technical topics you’re likely to encounter in Figma interviews. To compile this list, we did two things. First, we spoke to some current and former Figma engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nYou will get two system design rounds:\n- Relating to Figma components and how to design a feature around them\n- Another that is more focused on your specific role\nThey will send you a public guide to Figma components to help with the first system design round, so brush up on that. Components are like classes in Figma. The second round will lean more towards the type of work you will be doing, e.g., back-end or front-end.\nAs with the coding interviews, expect something practical here. It will very likely be related to an issue that Figma has encountered before. You might be asked to design a poll system within Figma that can handle multiple concurrent users. Expect to be asked about scaling and storage options.\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nThis interview will be conducted by a hiring manager from within the same organization but not the team you are interviewing for. It’s going to be pretty standard, with questions about:\n- How you’ve handled feedback in the past\n- How you approach conflict\n- Past projects you’re proud of\nProject Deep Dive\nFor this interview, you’ll be asked to prepare a few slides on a previous technical project you’ve worked on. It’s a pretty interactive session where they’ll dig into:\n- The scale and scope of your role on the project\n- The technical details of the project\n- What issues you ran into\n- What tradeoffs were made\n- What you’d do differently\nUnlike some project deep dives we’ve come across, this will likely be with only one interviewer.\nExecutive Screen\nAll we can say is that this is a behavioral round. It’s hard to say what the Director will ask during this session, but they will be looking for any areas left unturned during the onsite and drilling into them.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/figma-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "FireEye Interview Process & Questions in 2024",
      "content": "Common FireEye Interview Questions\nBelow are common interview questions that interviewers from FireEye ask in mock interviews on our platform. Because our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWe'll add details about FireEye's interview process in the future.\nMEDIUM\nData Structures and Algorithms\nFireEye Interview Replays\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/fireeye-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Grammarly’s Interview Process & Questions",
      "content": "Grammarly’s Interview Process & Questions\nThe info below is based on conversations with Grammarly engineers.\nGrammarly's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Grammarly can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Hiring Manager screen (1 hour)\n- Onsite (5.5 hours)\nGeneral tips:\n- Having a referral guarantees a call-back (not true at many other companies).\n- Grinding on LeetCode will help because they primarily ask questions straight from LeetCode.\n- They can be slow, so don’t be afraid to follow up a lot and keep reminding them you have other offer deadlines.\n- Learn their EAGER framework of values. They will want you to know these and align with them during your interviews.\n- It's a foreign-founded company, so you may encounter interviewers who aren’t native English speakers and have a different cultural style than you’re used to.\nGrammarly has a hybrid process, which means that you will interview for a specific team and role but your interview panel will be a mix of engineers from the team and from elsewhere in the company. It will also include the hiring manager for the role you are interviewing for.\nThe entire process takes about 6 weeks, but our sources tell us it shouldn’t have to – by default, Grammarly is slow in moving things forward, but if you’re proactive, you can speed up the process.\nStep 1: Recruiter Call\nGrammarly’s recruiter call lasts about 30 minutes, and it’s different from a lot of recruiter screens. Be prepared to get asked questions that require STAR-style responses. One of our sources was surprised by the style of question they got at this stage, so be prepared!\nIt’s also really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nGrammarly’s technical phone screen lasts about an hour. It will be conducted in HackerRank, and you should expect medium-difficulty LeetCode-style questions.\nStep 3: Hiring Manager Screen\nThis is a presentation and a deep dive into a complex project that you’ve worked on. For more senior roles, you’ll be asked to describe a project you led.\nWe’ve heard that you may not necessarily get clear instructions about this round, and you may not be told to prepare a presentation in advance, but we heartily recommend that you do! One of our sources did well in this round because he already had a presentation prepared for another company and was able to seamlessly jump into it when he realized what the call was about. Though it may not be critical to have a presentation fully prepared, doing so will give you an edge. Either way, come prepared to discuss the overall architecture (including diagrams as needed), what problem you were trying to solve, and your role in the successful completion of the project.\nStep 4: Onsite\nWe’ve heard that Grammarly’s onsite is very long and can be split across multiple days.\n- Product intuition/domain expertise (1 hour). This interview will be conducted in CodePair (HackerRank’s coding interview tool). For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). This will likely be in Miro or HackerRank's whiteboarding tool. For more detail about the kinds of questions to expect, see the System Design section below.\n- Coding / CS fundamentals (1 hour). This interview will be conducted in CodePair. For more detail about the kinds of questions to expect, see the Coding section below.\n- Coffee chat (virtual) (30 minutes). You meet with two people from your future team and get to ask them questions.\n- Values call 1 (1 hour) This interview will be with someone from Grammarly who isn’t from the org or team you are applying to. For more info about what questions to expect, see the Values section below .\n- Values call 2 (1 hour) This interview will be conducted by a hiring manager. For more info about what questions to expect, see the Values section below .\nTypes of Interview Questions to Expect at Grammarly\nFrom what we’ve heard, Grammarly doesn’t ask practical questions. They do have a standard bank of questions they regularly ask, and LeetCode-style questions are common.\nProduct Intuition / Domain Expertise\nThis might be a two-part question and varies by role. In the first part, you could be shown an email with the Grammarly tool engaged and certain words or phrases highlighted. Your job will be to improve the product.\nThe second part will involve a standard LeetCode-style question.\nCoding\nExpect another two-part interview here with standard LeetCode-style questions in the first part.\nThe second part might be a lot more academic. One source told us:\n\"The second problem looked like it came straight out of an algorithms textbook.”\nBelow are the technical topics you’re likely to encounter in Grammarly interviews. To compile this list, we did two things. First, we spoke to some current and former Grammarly engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nThis will likely be a two-part question where you’re asked to design something at a small scale in the first part and then asked to scale it up in the second. Time management is critical here because they will ask lots of questions during the first part. We’ve heard that this is a tough interview, but that you can do poorly, and potentially get a chance to redo it after the onsite.\nAreas to focus on are:\n- Client-server communication\n- Separation of concerns\n- Data structures and flows\n- A system’s extensibility and scaling\nCheck out our guide to system design interviews to help you prepare.\nValues\nYou will have two calls that focus on Values, one with a hiring manager and the other with someone from a completely different part of the company. One of the people we interviewed for this guide was interviewed by someone from the Social Media team.\nBoth calls will ask questions about your past work experience. They will use your resume and frame their questions around your past companies. Be prepared to use their EAGER framework of values, and show that you understand and embody the values they are looking for. EAGER stands for Ethical, Adaptable, Gritty, Empathetic, and Remarkable. Look for ways to show that you embody these values as you go through your interviews, even the technical ones.\nExpect to go through each company you’ve worked from and answer questions like:\n- What would your manager say your strengths were?\n- What would your manager say your weaknesses were?\n- What would you say your manager's strengths were?\n- What would you say your manager's weaknesses were?\nHow Grammarly Makes Hiring Decisions\nThe entire onsite panel submits written feedback after the interviews are completed and then meets to discuss. Most of the time, decisions are reached by consensus (everyone agrees to hire or no-hire), but in cases where consensus isn’t possible, the hiring manager has the final say.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/grammarly-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "HubSpot’s Interview Process & Questions",
      "content": "HubSpot’s Interview Process & Questions\nThe info below is based on conversations with HubSpot engineers.\nHubSpot's Interview Process for Software Engineers: 2-4 Steps\nMid to senior-level engineers interviewing at HubSpot can expect the following process:\n- Recruiter call (30 minutes)\n- Asynchronous coding challenge (3 hour)\n- Onsite (4 hours)\nHubspot’s hiring process is a hybrid. Although you apply for a specific team from the get-go, your interviews will likely not be with the people on your team – interviewers are randomly selected from a pool – except for the hiring manager interview.\nHubspot is one of the few companies that will actually give you some constructive post-interview feedback!\nGeneral tips:\n- LeetCode practice is helpful, as their coding questions are all in that style.\n- During the coding rounds, it is important to find edge cases.\n- You might read that they are very focused on the behavioral round and your ability to match up to their values, but in practice we’ve heard their behavioral round is pretty standard. That said, the interviewers will talk about the culture so it’s best to come prepared with questions about their values.\n- They use Java, but the interview process is language-agnostic.\n- You must convince the interviewer you are familiar with the technologies you mention in a system design interview. You need to know more than buzzwords.\n- They know that most of their questions are found online, so they look for you to go deeper.\n- You’ll get detailed feedback from the recruiter after the technical onsite rounds. This can be given verbally or via email and will happen before the behavioral round.\nThe hiring process takes about 2-4 weeks, and we’ve heard that their interviewers are pretty friendly and collaborative compared to FAANG companies. They are also competitive with FAANG salaries.\nStep 1: Recruiter Call\nHubSpot’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in HubSpot, and what you’re looking for moving forward. They will discuss salary ranges, and we’ve heard they are competitive with Meta and Google.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Asynchronous Coding Challenge\nIn this challenge, you’ll get API access. You’ll need to make a call to the API, process data, and POST back a response/solution. If the solution is correct, you’ll get a 200 status code, which means you’ve completed the exercise.\nYou can use any language for this assignment, and it starts as soon as you click the link in the email they will send you. You have three hours to complete the assignment, i.e., make the request to the API. After that, you’ll need to submit the code in a zip file, but that doesn’t need to happen within the three hour window, so you’ll have time to clean up your code afterward.\nOne engineer we spoke to said:\nI don’t think they even review the code, you just need to get 200, and that’s good enough to pass.\nAnother engineer we spoke to described the problem as follows:\nOverall, the pattern is going to be a sorting/aggregating approach to a JSON array, where you have some field like “timestamp”, and some other field that might be an enum, and you will be posting it back to the API provided\nStep 3: Onsite\nThis will vary slightly between Senior SWE 1 and Senior SWE 2 but only during the second system design round. You have to pass each round before moving on to the next.\n- Coding (1 hour). This interview will be conducted in CoderPad, but we have heard you can use your own IDE too. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). This interview will be conducted in the drawing tool of your choice. For more detail about the kinds of questions to expect, see the System Design section below.\n- System design 2 (depending on your level, details are different) (1 hour). For more detail about the kinds of questions to expect, see the System Design section below.\n- Behavioral (1 hour). For more info about what questions to expect, see the Behavioral section below.\nTypes of Interview Questions to Expect at HubSpot\nCoding\nThis will be algorithms and data structures-focused, with LeetCode-style questions. We’ve heard they usually ask LeetCode easy to mediums. While the challenge might seem easy, HubSpot wants you to catch all the edge cases and run tests.\nCommunication and clarifying questions are things they are looking for. They know their questions can be found online. They expect you have already seen and solved them.\nSome examples of the question types they ask are:\n- Most repeated substring of size k\n- Find the matching string pattern in a given string.\n- Find all commonly repeated strings in the 'engineering' string one. How to create an add comma function in js and add it to the global\n- Merge two sorted lists up to size k\nBelow are the technical topics you’re likely to encounter in HubSpot interviews. To compile this list, we did two things. First, we spoke to some current and former HubSpot engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nYour first system design round will be very standard. You’ll be asked to design something like Netflix. The main difference between HubSpot and other companies is that they aren’t as obsessed with you mapping out the most optimized solution. It’s more about capturing a broad answer than going deep into one solution.\nYour second system design will depend on which role you are interviewing for.\nSenior SWE 1 (Equivalent to L4 at other companies)\nYou will usually be asked to design something like a weather service. One engineer we spoke to described it as being more like application design. The areas you need to consider are:\n- Data storage\n- Reliability\n- Performance\n- Horizontal scaling\n- Trade-offs\nMake sure to ask clarifying questions before you do anything. Their interviewers are collaborative. If you bring up any technologies, you need to know them well as they will drill into them.\nCheck out our guide to system design interviews to help you prepare.\nSenior SWE 2 (Equivalent to L5 at other companies)\nThis system design round is split into two parts. First, you will be asked to write a document covering a past, technically challenging project and submit it for review They want you to list everything involved from start to finish, including:\n- An overview of business problem\n- The challenges faced\n- The technical implementation\n- Any design tradeoffs\n- The rollout plan\n- The chosen success metrics\n- Any lessons learned\nThey will review your write-up, and, if they like it, you will be invited to another live interview where they will ask you questions about the project.\nBehavioral\nThis interview will be conducted by the hiring manager of the team you are interviewing for. It’s going to be pretty standard, with situational questions. As above, they may talk about the culture at HubSpot so it’s a good idea to come prepared with questions that delve into their values.\nHow HubSpot Makes Hiring Decisions\nDecisions are reached based on your performance in each round. You can still get an offer with one “no-hire”, but your other rounds need to be very strong for this to happen. Hiring managers may still reject candidates in the team matching phase if they see one “no-hire”.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/hubspot-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Instacart’s Interview Process & Questions",
      "content": "Instacart’s Interview Process & Questions\nInstacart's Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Instacart can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (45 mins)\n- Onsite (3-4 hours)\nInstacart has a hybrid hiring process: it’s not fully decentralized or centralized. You usually apply or get brought in for a generic job listing, and then they will determine which team you interview for. Your interviewers will come from all across the org, but the hiring manager for the role you are interviewing for will usually be involved from the start. You can only interview once, but if you don’t get an offer from the team you interviewed with, you may still have a chance with another team.\nThe entire process takes about 2-4 weeks.\nGeneral advice:\n- Instacart doesn’t ask questions that require knowledge of academic or obscure data structures and algorithms. Although questions can still skew LeetCode-y, they won’t be questions that require knowledge of niche trees, dynamic programming, etc. Brush up on the basics, and you should be fine.\n- Make sure you practice system design, as that interview is often make or break and is definitely used for leveling\nStep 1: Recruiter Call\nInstacart’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, and why you’re interested in Instacart. They’ll also talk about the specific role and team you’ve been matched with.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nInstacart’s technical phone screen lasts about an hour. They use CodeSignal.\nStep 3: Onsite\n- Coding (45 mins). Like the technical phone screen, this round will be conducted in CodeSignal, and you can use any language that CodeSignal supports. For more detail about the kinds of questions to expect, see the Coding section below.\n- Second coding. As above.\n- System design (45 mins). This section is really important and usually where people fail. You can use any tooling you’d like, e.g., Google Draw or Excalidraw. For more detail about the kinds of questions to expect, see the System Design section below.\n- Behavioral (45 mins). This interview will be conducted by a hiring manager. For more info about what questions to expect, see the Behavioral section below.\nTypes of Interview Questions to Expect at Instacart\nA lot of Instacart’s questions are created in-house, but you may run into LeetCode-style questions as well.\nCoding\nYou’ll be tested for pragmatic coding skills here. You might be asked to write a script to convert dollars to euros, get a question about API optimization, be asked about designing key-value stories, edit distance, expression evaluation, combinatorics, file I/O, or any number of other fairly practical questions.\nIn recent years, as Instacart has hired more FAANG alums, the question composition has shifted a bit to include more LeetCode-style questions. That said, even if you do get a LeetCode question, it will likely NOT touch on obscure algorithms or data structures.\nBelow are the technical topics you’re likely to encounter in Instacart interviews. To compile this list, we did two things. First, we spoke to some current and former Instacart engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nSystem design interviews at Instacart matter a lot for leveling. The most common failure mode we heard about was passing the coding portion and then failing on architecture.\nSpecifically, if you want to hit at least L6, you NEED to do well in this interview.\nThe engineers we spoke to said that in the system design portion, it’s really important to manage your time because there’s typically a lot you can cover with your answer, but they are looking for you to be concise. Also be prepared to justify your design decisions.\nYou might be asked to:\n- Design a database model for an Instacart-like system\n- Design a system for tracking shipments\n- Design a system for communicating with a payment processor\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nInstacart’s behavioral interviews are pretty standard fare. You’ll be asked about past projects and your impact in previous roles. This interview is primarily used for leveling.\nHow Instacart Makes Hiring Decisions\nHiring decisions are made by rough consensus. There’s a debrief the same day or the day after your interview loop. People vote, but ultimately the decision rests with the hiring manager. From one of the engineers we spoke to:\n“If there’s one strong no, that’s usually the end of it, and a strong yes from someone else probably wouldn’t countermand that.”\nWant to know if you're ready to interview at Instacart? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/instacart-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "interviewing.io Interview Process & Questions in 2024",
      "content": "Common interviewing.io Interview Questions\nBelow are common interview questions that interviewers from interviewing.io ask in mock interviews on our platform. Because our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWe'll add details about interviewing.io's interview process in the future.\nMEDIUM\nData Structures and Algorithms\nMEDIUM\nData Structures and Algorithms\ninterviewing.io Interview Replays\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/interviewingio-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Jane Street’s Interview Process & Questions in 2024",
      "content": "Jane Street’s Interview Process & Questions\nThe info below is based on conversations with Jane Street engineers.\nJane Street's Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Jane Street can expect the following hiring process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Onsite (5 hours)\nAt Jane Street, the process is centralized, i.e., you interview with a central team and then get matched to a specific team after you pass the onsite loop.\nGeneral tips:\n- Work on your coding stamina - the onsite is pretty intense.\n- Practice coding something up from scratch – during the onsite, they’ll ask you to build something from nothing, e.g., a Tetris game\n- Their interviewers want you to be collaborative, so ask lots of questions and communicate well throughout the process. They value collaboration as much as they do good code.\n- Read Jane Street’s blog post about their interview process. Unlike most company pages, it’s detailed, useful, and good, and talks a lot about engineering interviews, specifically.\n- Don’t try to impress them by coding in OCaml (their internal functional language of choice). Use the language you’re most comfortable in.\nThe entire process takes about 4 weeks.\nStep 1: Recruiter Call\nJane Street’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Jane Street, your understanding of Jane Street’s value proposition, and what you’re looking for moving forward.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nThis is a pretty standard technical round, with one LeetCode medium-style question that will have two parts. Your interviewer will be more interested in how you think and how you arrive at the solution than an optimal solution. Communicate your assumptions and discuss alternate approaches as you work your way through the problem.\nStep 3: Onsite\n- 3 coding / system design hybrid rounds (75 mins each). These interviews will be conducted in CoderPad. For more detail about the kinds of questions to expect, see the Coding / System Design section below.\n- Technical project deep dive (75 mins). For more info about what questions to expect, see the Technical project deep dive section below.\nTypes of Interview Questions to Expect at Jane Street\nCoding / System Design\nWhereas the technical screen before the onsite is LeetCode-style and more academic, the coding rounds during the onsite are a little bit more practical. They also blend coding and system design so you might have to whiteboard out some pieces initially before jumping into code.\nYou will get a problem statement that is underspecified. Your job is to ask the right questions before you dive in and while you are working. Get comfortable building things from scratch. You might be asked to:\n- Design Tetris\n- Design a video player API\nYou’ll have to design it, code it out, and go deep into the logic.\nBelow are the technical topics you’re likely to encounter in Jane Street interviews. To compile this list, we did two things. First, we spoke to some current and former Jane Street engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nTechnical Project Deep Dive\nYou will be asked to present an interesting, technically complex project that you’ve worked on, ideally something that you can talk about for an hour. They tell you not to over-prepare for this one, so you don’t necessarily need a robust presentation, but do prepare to answer a lot of questions about the project you’re presenting, the reasoning and logic behind it, and its impact.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/jane-street-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "J.P. Morgan's Interview Process & Questions in 2024",
      "content": "Common J.P. Morgan Interview Questions\nBelow are common interview questions that interviewers from J.P. Morgan ask in mock interviews on our platform. Because our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWe'll add details about J.P. Morgan's interview process in the future.\nJ.P. Morgan Interview Replays\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/jpmorgan-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "LinkedIn's Interview Process & Questions in 2024",
      "content": "LinkedIn’s Interview Process & Questions\nLinkedIn's Interview Process for Software Engineers: 5 Steps\nFor a mid to senior-level software engineer, LinkedIn’s process (usually) looks like this:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Second recruiter call (30 minutes)\n- Onsite (5-6 hours)\n- Team matching\nLinkedIn’s interview process is centralized, which means that you don’t interview with specific teams and do team matching after the fact.\nStep 1: Recruiter Call\nThe first recruiter call lasts 30 minutes. Its purpose is to check qualifications, hear about past projects, and find out what you’re looking for from LinkedIn and in general. It also acts as a culture fit check, so they’ll want to see how your communication and personality align with their values. Make sure you’re up to date on LinkedIn features, blog posts and news. Finally, your recruiter will make sure you understand the role you’re applying for and clarify next steps in the process.\nIt’s really important, at this stage, not to reveal your salary expectations, your salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number. Just don’t do it – when you give out information this early in the process, you’re painting future you into a corner.\nStep 2: Technical Phone Screen\nThe technical phone screen lasts an hour, and interviews at this stage (and beyond) will usually have two interviewers, the primary interviewer and a trainee interviewer who’s shadowing.\nYou’ll be given 2-3 algorithms and data structures questions, structured as follows:\n- If you’re applying for a niche role (e.g., mobile), you’ll get a 10-minute domain-specific question. This question is meant to quickly gauge your expertise on your niche subject and screen out generalists.\n- 15-minute small problem\n- 30-minute medium problem\nStep 3: Second Recruiter Call\nIf you pass the technical phone screen, a recruiter will reach out again for a 30 minute call. Having a second recruiter call in the middle of the process is unusual, but LinkedIn does it for a good reason: they have historically lost a lot of good candidates to FAANG, and so this call is their way of playing defense to get ahead of attrition. In this call, they’ll re-ask about whom you’re in process with and will try to make sure that they don’t lose you by moving too slowly.\nThough our advice about not revealing your hand stands, in this call, if you do have any tight timelines from other companies, it’s good to let them know because, according to our sources, they are indeed able to speed things up and move quickly.\nStep 4: Onsite\nLinkedIn’s onsite usually lasts 5-6 hours and includes the following steps:\n- Coding (1 hour)\n- (For niche roles) Domain-specific coding (1 hour)\n- System design (1 hour)\n- Technical communication (1 hour)\n- Behavioral (1 hour)\nThe order of these rounds can vary, as well as the number of coding interviews required. Depending on your score for various portions of the onsite, you may be required to complete an extra system design, object oriented design, or algorithms interview. There may be extra rounds for certain teams and roles as well. Given that LinkedIn’s interview process is centralized, you generally won’t be interviewing with engineers or managers from the team you’ll end up on.\nCoding\nThis interview will generally be one question or sometimes two, depending on how quickly you work through the first one.\n(For Niche Roles) Domain-Specific Coding\nIf you’re applying for a niche role (e.g., mobile), in addition to a general coding interview, you’ll have to do a domain-specific interview as well.\nSystem Design\nThe system design interview will cover general system design knowledge and will focus on building large-scale systems. Make sure to communicate clearly and often during this interview and substantiate your design choices as well as your choices of specific technologies.\nTechnical Communication\nThis interview will evaluate your ability to communicate and collaborate. You’ll be asked about one of your past projects and then walk your interviewer through it, with an emphasis on the technical aspects of your projects. Make sure you explain what the project was, why it mattered to the business, and what you did specifically. They’re expecting you to be able to dive really deep into the project you choose, so be ready to answer anything and everything about it.\nBehavioral\nThe behavioral interview at LinkedIn is very conversational. They’re looking to assess your culture fit and will ask you ad-hoc questions rather than preset or typical behavioral interview questions. Despite it being conversational in nature, it’s important to find ways to tie your answers to LinkedIn’s values:\n- We put members first\n- We trust and care about each other\n- We are open, honest and constructive\n- We act as One LinkedIn\n- We embody diversity, inclusion and belonging\n- We dream big, get things done and know how to have fun\nStep 5: Team matching\nAssuming all has gone well to this point, you’ll be contacted by hiring managers for a team matching call. These calls are for the hiring managers to sell you on joining LinkedIn, and to create excitement about their specific orgs. It’s important to use this time to ask any questions you have about LinkedIn, the role or the process so far, and find out as much as possible about your team options.\nOnce you’re matched with a team they will extend you an offer. If you are far along in the process with other companies, make sure that you let them know that they should move quickly. This is another stage where LinkedIn loses a lot of candidates to FAANG, so they’re ready and able to speed things up.\nIn the event you’re unable to be matched with a team, your onsite results are valid with LinkedIn for 1 year, so they will continue trying to find a team for you.\nTypes of Interview Questions to Expect at LinkedIn\nCoding\nLinkedIn has a company-wide question bank, though interviewers have a bit of wiggle room to change them up. We’ve heard from several sources that the question bank is fairly small (compared to other companies), and that the questions haven’t changed much over the past 7 years or more.\nTo figure out what specific types of questions to expect in your LinkedIn interviews, we did two things. First, we spoke to some current and former LinkedIn interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews. Based on all of the above, here are the types of questions you’re likely to encounter:\nSystem Design\nTypical system design questions include:\n- Design a system that will determine trending posts\n- Design a system that will log requests\n- Design a system that will show client feeds\n- Design an API for some specific use case\nCheck out our guide to system design interviews to help you prepare.\nCommon LinkedIn Interview Questions\nBelow are common questions that interviewers from LinkedIn ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nHow LinkedIn Makes Hiring Decisions\nLinkedIn grades each onsite round on a 4-point scale, where 3 is passing. If your aggregate score after the onsite is borderline, you may get asked to do another interview.\nCandidates who end up over the line get passed to the hiring committee, who make the final decision about both hiring and leveling.\nLinkedIn Interview Replays\nWant to know if you're ready to interview at LinkedIn? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/linkedin-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "MathWorks' Interview Process & Questions in 2024",
      "content": "Common MathWorks Interview Questions\nBelow are common interview questions that interviewers from MathWorks ask in mock interviews on our platform. Because our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWe'll add details about MathWork's interview process in the future.\nMathWorks Interview Replays\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mathworks-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Morgan Stanley’s Interview Process & Questions",
      "content": "Morgan Stanley’s Interview Process & Questions\nMorgan Stanley's Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Morgan Stanley can expect the following process:\n- Recruiter call (30 minutes)\n- Online assessment (only for some teams) (45 mins)\n- Onsite (3-4 hours)\nMorgan Stanley has a decentralized hiring process. Each team interviews in its own style, and there are variations in the numbers and types of interviews you might encounter. A lot of it depends on the region you are interviewing in. You can apply to and interview for multiple roles simultaneously.\nYour interviewers will be selected from the team you are interviewing for by the hiring manager, based on their ability to assess you for specific skills, e.g., if the role requires you to be a Python expert, they will use another Python expert to interview you. The order of your interviews for the onsite portion is not predetermined, and the hiring manager will decide the schedule based on the availability of the interviewers deemed necessary.\nThe process can be quite slow, and they will not expedite things unless they feel like you are a perfect fit. Expect the process to last more than 6 weeks in most cases.\nGeneral advice:\n- There is a big focus on collaboration, so don’t be combative in interviews.\n- Communication is important for leveling. They want to know if you can communicate cross-functionally or potentially manage a team in the future.\n- Practice the STAR method of answering behavioral interview questions.\n- Just because you don’t get a job with one team doesn’t mean you’ve failed with Morgan Stanley as a whole. You don’t need to wait a year to apply to other teams, and you might find a more suitable role in the course of that same job search.\nStep 1: Recruiter Call\nMorgan Stanley’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, and why you’re interested in Morgan Stanley. They’ll look for basic skill set alignment. They’ll also talk about the specific role and team you’ve been matched with.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Onsite\nAgain, this will vary in terms of interview types and order depending on the team you are interviewing with, but here is a sample schedule:\n- Asynchronous coding challenge (45 mins). This challenge will be conducted in HackerRank. For some teams, this may happen before the onsite rather than as part of it. For more detail about the kinds of questions to expect, see the Coding section below.\n- Language-specific coding (45 mins). Morgan Stanley is one of the few companies we’ve written about whose process isn’t always language agnostic. For some roles and teams, they may need you to know a specific language, and if that’s the case, they will do one round in that language where they’re specifically vetting you for familiarity with that language and its idiosyncrasies. This round is usually conducted in HackerRank. .\n- Data structures and algorithms (45 mins). This round is usually conducted in HackerRank. For more detail about the kinds of questions to expect, see the Coding section below.\n- Object-oriented programming (45 mins). This will not be a coding interview. You’ll be asked a series of questions on the topic of object-oriented programming. For more detail about the kinds of questions to expect, see the Object-Oriented Programming section below.\n- Behavioral (45 mins) This is a team fit call with the hiring manager. Morgan Stanley’s behavioral interviews are pretty standard fare. You’ll be asked about past projects and your impact in previous roles.\nYou might notice the lack of a system design interview in the schedule above. This is typical for a lot of teams although you might interview for a team that includes one. If you do get a system design interview you might be asked product-focused system design questions.\nBe prepared for some repetition here. You should be ready to drive into your own product designs.\nTypes of Interview Questions to Expect at Morgan Stanley\nManagers tend to come up with their own questions, but for core coding interviews, prepping on LeetCode will be very helpful. A lot of the teams will pull questions from there.\nCoding\nAs above, you’ll run into a lot of LeetCode-style questions here. Below are the technical topics you’re likely to encounter in Morgan Stanley interviews. To compile this list, we did two things. First, we spoke to some current and former Morgan Stanley engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nObject-Oriented Programming\nBelow are the types of questions you’ll likely be asked during this interview:\n- Explain object-oriented programming. What is inheritance? What are the different types of inheritance?\n- What is polymorphism?\n- Give an example of operator overloading\n- What is the difference between a struct and a class?\n- What is the difference between an abstract class and an interface?\n- What is the difference between object-oriented programming and procedural programming?\nHow Morgan Stanley Makes Hiring Decisions\nDecisions are at the hiring manager's discretion. Some managers will make the decision themselves, and most will take feedback, but they do overrule negative feedback at times.\nWant to know if you're ready to interview at Morgan Stanley? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/morgan-stanley-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Nvidia’s Interview Process & Questions in 2024",
      "content": "Nvidia’s Interview Process & Questions\nThe info below is based on conversations with Nvidia engineers in 2024.\nNvidia's Interview Process for Software Engineers: 2-4 Steps\nMid to senior-level engineers interviewing at Nvidia can expect the following process:\n- [Can skip if referred in] Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- [Not always] Hiring Manager call (30 minutes)\n- Onsite (5 hours)\nNvidia has a decentralized process that varies based on the hiring manager's preference, e.g., some people we spoke with had no recruiter screen and some had no hiring manager call before the onsite. One candidate even had their hiring manager call first, before anything else happened! The onsite rounds can also change a lot. We will do our best to sketch out the process, but yours may differ depending on the role you are interviewing for. While there is some flexibility regarding what role you end up interviewing for, you don’t seem to be able to interview for multiple teams. All of your interviewers will be from the team you are interviewing for.\nOne engineer we spoke to, who interviewed with Nvidia for two separate teams told us:\nIf you get an early hiring manager call, you can ask them exactly what to expect in the rest of the rounds. If they say the language is the priority, brush up on those skills, if they say it will be more general, then focus on general coding.\nGeneral tips:\n- LeetCode practice will help, but they will throw in more practical questions too.\n- They don’t have an internal question bank, so the interview questions are up to the individual interviewer.\n- Nvidia puts a premium on experience and advanced academic degrees.\n- A good (senior) referral can help you skip the recruiter call.\n- Most roles they hire for are software-orientedsoftware oriented, not hardware as you might expect\n- If you fail with one team, you can immediately interview with another one, but you will have to go through the whole process again, though it’s possible you’ll be able to skip the technical phone screen.\n- They will always have at least one interview that is focused on the language you will need for whatever team you are joining.\nThe entire process takes about 6-8 weeks.\nStep 1: Recruiter Call\nNvidia’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, and why you’re interested in Nvidia and do some basic skills assessment.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nYou might start with 15 minutes of general chat in this round but, the guts of the interview will be technical. In the general chat, you might be asked about your background and why you’re interested in Nvidia. The technical portion will be 45 minutes long. One engineer we spoke to was asked only LLM questions here and everything was done in PyTorch, but this is largely dependent on the role you are interviewing for. Nvidia is very focused on hiring engineers with LLM experience right now so, if that’s what you applied to, expect LLM questions rather than general CS skill questions. If not, expect a LeetCode medium-style question, but remember, they don’t have an internal bank from what we’ve heard, so you might get something more practical too.\nIf you are asked LLM questions, expect them to focus on concepts such as:\n- Mixture-of-experts model\n- Beam search\n- Autoregressive decoding with KV-cache\n- Low-rank adaptation (LoRA)\n- High-level distributed computing\nFor example, you might be asked to implement beam search for LLM inference and evaluate the time complexity of each operation.\nStep 3: Hiring Manager Call\nThis is usually split into two parts. You will be asked about your background and experience in the first part. The hiring manager will be testing for culture fit. In the second part, they will be selling you on the role and team.\nStep 4: Onsite\nThis will vary by role but here’s what you can expect.\n- Coding x 2 (1 hour each). This interview will be conducted in CoderPad. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). For more detail about the kinds of questions to expect, see the System Design section below.\n- Second Coding (1 hour). For more detail about the kinds of questions to expect, see the Coding (domain-specific) section below.\n- Hiring Manager (1 hour). For more detail about the kinds of questions to expect, see the Hiring Manager interview section below.\nTypes of Interview Questions to Expect at Nvidia\nCoding\nOk, things can vary quite a bit here, as with everything in the Nvidia hiring process! One engineer we spoke to had 2 low-level coding rounds that were very practical and domain-aligned for the team he interviewed with. Others got more standard LeetCode-style questions during these two rounds.\nWe also heard that there are different formats for the coding rounds for certain teams. You might get a problem to solve in some and have to review existing code in others, similar to a debugging round.\nIf the role you have applied to will rely heavily on Cuda, expect to be interviewed in C++. Every role at Nvidia is a bit different though so lot’s of languages are used. It should be clear from the job description if there is a specific language required. If not, ask the hiring manager in advance so you are prepared!\nBelow are the technical topics you’re likely to encounter in Nvidia interviews. To compile this list, we did two things. First, we spoke to some current and former Nvidia engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews.\nFirst, here’s a list of more niche technical topics that are, in our experience, specific to Nvidia:\n- C++ Fundamentals\n- LLMs\n- See the technical phone screen section above for examples of LLM sub-topics\nAnd here are technical topics that you’re likely to find at other companies as well (for these we’ve created detailed write-ups of their own):\nCoding (Domain-Specific)\nThis will be a more practical round. You might be asked to reimplement an algorithm from first principles. You might get a mix of technical questions and actual coding to do. Whatever you get will be specific to the role you are interviewing for.\nSystem Design\nThis will more than likely be a pretty standard system design round but, again, things vary from team to team. Brush up on the usual questions like “How would you design Twitter / Uber / a chatbot for a website,” BUT they may ask you something more practical for the role. Learn about CPU/GPU architecture and anything else relevant to the team you are interviewing for!\nCheck out our guide to system design interviews to help you prepare.\nHiring Manager Interview\nThis will be more conversational than the other rounds but could have behavioral/experience-based questions, as well as technical questions depending on the hiring manager.\nHow Nvidia Makes Hiring Decisions\nAfter the onsite, the panel all submit a scorecard. You don’t need to score perfectly (it’s from 1-5) on each scorecard, but it’s unlikely to be hired if you’ve scored poorly on even one round.\nWant to know if you're ready to interview at Nvidia? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/nvidia-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "OpenAI’s Interview Process & Questions",
      "content": "OpenAI’s Interview Process & Questions\nThe info below is based on conversations with OpenAI engineers.\nOpenAI's Interview Process for Software Engineers: 3-4 Steps\nMid to senior-level engineers interviewing at OpenAI can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Possible 2nd technical screen or assessment, where the format depends on the role (1 hour)\n- Onsite (4-6 hours)\nGeneral tips:\n- Your recruiter will give you detailed tips on what to prepare for before some interviews. Take the tips seriously!\n- The coding questions you’ll get are more practical than LeetCode. They are algorithms and data structures questions, but they are actual things that you might do at work.\n- Prepare slides for the presentation part of the onsite (even though it’s not required).\n- Be prepared to discuss ethics and safety in AI. Read their blog!\nThe hiring process at OpenAI is decentralized, with a lot of variation in interview steps and styles depending on the role and team you are interviewing for. You will get some sort of technical assessment before the onsite, and it can be anything from a technical phone screen, an asynchronous assessment, or a take-home project. It may even be two separate steps. We’ve heard they use HackerRank for asynchronous coding tests but CoderPad for live interviews. This guide will assume that there will be two live technical phone screens, but your mileage may vary depending on team and role – check out OpenAI’s own interview guide for more info.\nAt OpenAI, there is some flexibility in terms of which role and team you might end up on – you might apply to one role but have them suggest others as you move through the process. Your interviewers will probably come from multiple different teams. Prepare for it to feel chaotic.\nFrom one of our users who recently interviewed with Open AI:\n“Everything they did made them seem wildly disorganized. They didn’t stay in touch through the process. A lot of radio silence.\"\nThe entire process can take 6-8 weeks, but if you put pressure on them throughout you can speed things up, especially if you mention that you have other offers.\nStep 1: Recruiter Call\nOpenAI’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in OpenAI, your understanding of OpenAI’s value proposition, and what you’re looking for moving forward.\nIn this round, your recruiter will also tell you what to expect in the next round, given how much variability there is in the interview process for different roles and teams. Your recruiter will also be in touch throughout the interview process to prep you for what’s coming up next.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nOpenAI’s first technical phone screen lasts about an hour and is conducted in CoderPad. This is an algorithms and data structures style interview, but the questions are more practical than questions you’d find on LeetCode. We will cover what we know of their question style in the section called “Types of Interview Questions to Expect at OpenAI” below.\nStep 3: Second Technical Phone Screen or Assessment\nThe format of this round varies by role and will be more domain-specific than the previous round. For instance, you may get an asynchronous exercise or a take-home assignment. Or you may have to do another technical phone screen.\nWe expect that for many of our readers, who tend to be senior, back-end focused engineers, this round will be an architecture interview. See the System Design section below for more details on question types.\nIf you have more information about this part of the process or see anything that’s incorrect, please fill in our form\nStep 4: Onsite\nOnsite interview loops also vary slightly depending on the role and seniority, but the below is generally what you’ll get:\n- Behavioral interview with a senior manager (45 mins) This is a phone call with a hiring manager, typically someone quite senior at the company. For more detail about the kinds of questions to expect, see the Behavioral section below.\n- Presentation (45 mins) You’ll be asked to prepare this in advance. For more detail, see the Presentation section below.\n- Coding (1 hour). This interview will be conducted in your own IDE with screen-share or in CoderPad. Your choice. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). You'll use Excalidraw for this round. For more detail about what kind of questions to expect, see the System Design section below.\n- Behavioral interview focused on working with teams (30 mins). This and the hiring manager screen above are both behavioral. For more info about what questions to expect, see the Behavioral section below.\nTypes of Interview Questions to Expect at OpenAI\nAll of OpenAI’s interview questions have a degree of practicality and are usually language agnostic.\nCoding\nOpenAI’s onsite coding interviews will be more practical than many companies’. Although you will still get algorithmic questions, they are going to be about stuff you might actually do at work.\n“You’re not going to get questions on string manipulation.”\nIn these interviews, they are looking for your ability to write code that is going to be fast enough now but flexible enough to scale and adapt in the future.\nYou can choose the language for the coding rounds, and the questions are picked based on whichever language you choose.\nBelow are the technical topics you’re likely to encounter in OpenAI interviews. To compile this list, we did two things. First, we spoke to some current and former OpenAI engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nFirst, here’s a list of more niche technical topics that are, in our experience, specific to OpenAI:\n- Time-based data structures\n- Versioned data stores\n- Coroutines in your chosen language (multithreading, concurrency, etc.)\n- object-oriented programming concepts (abstract classes, iterator classes, inheritance, etc.)\nAnd here are technical topics that you’re likely to find at other companies as well (for these we’ve created detailed write-ups of their own):\nSystem Design\nYou may get two system design rounds during the interview loop, one before the onsite and one during.\nIf you get one before the onsite, expect something practical – you might be asked to design Yelp, Foursquare, Twitter, or a notifications system.\nIn this round, they probe for depth of knowledge and will ask a bunch of follow-up questions. It’s also best not to name-drop names of tools:\n“If you call out any specific technologies during this round, be prepared to go into detail about them! It may be best not to bring up specific examples as they seem to like drilling into the pros and cons of your choice.”\nAlthough a more domain-specific interview may pop up for some roles, most engineers will get another system design round during the onsite. You will likely be prepped well for the topic of this interview, so pay attention to any tips they give you beforehand. If you got a system design round before the onsite, the style of question that you get in the onsite round will be very similar, though they may ask you to get into more detail.\nWe have heard that OpenAI might ask you to code in this interview. One user told us that they designed a solution to the problem that was posed to them but were then asked to code up a new solution using a different method.\nCheck out our guide to system design interviews to help you prepare.\nPresentation\nYou’ll be asked to present a project you worked on to a senior manager. You won’t specifically be asked to prepare slides, but it’s a very good idea to do so. Be prepared to discuss the technical and business aspects and impact of the project, as well as your level of contribution, what tradeoffs were made, what other team members were involved, and what everyone’s responsibilities were. You may get some behavioral questions about how you worked with the team.\nBehavioral\nSenior Manager Call\nThis is often with someone pretty high up at OpenAI. Our sources tell us it can be an interesting call. Although a lot of the questions will be standard, you may also be asked to delve deeper into something on your resume that catches the eye.\nFrom one source who interviewed with OpenAI recently:\n\"This interview was with John Rizzo, who is a well-known employee at OpenAI. It wasn’t an intense call, and John asked me some great questions about my background. It felt like he might have had veto power, but I enjoyed the call.\"\nIt’s also a good idea to read OpenAI’s blog, particularly any articles that discuss ethics and safety in AI. They want to know that you’ve thought about the topic, so prepare yourself!\nWorking with Teams\nThis is another type of behavioral interview you might encounter. Expect questions about times:\n- You had to work cross-functionally across teams\n- You’ve experienced conflict between teams or roles\n- You’ve had competing ideas to move a project forward within your own team.\nAll of these questions are meant to get at your ability to work collaboratively.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/openai-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Palantir’s Interview Process & Questions",
      "content": "Palantir’s Interview Process & Questions\nThe info below is based on conversations with Palantir engineers.\nPalantir's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Palantir can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Onsite (3 hour)\n- Hiring manager screen (1 hour)\nGeneral tips:\n- They put a huge emphasis on cultural fit. Behavioral questions will be asked in every interview. Come prepared!\n- Palantir believes in protecting civil liberties and rights. They look for people who are comfortable discussing these topics.\n- It’s a mix of standard LeetCode-style questions and very non-standard questions. LeetCode prep isn’t going to be enough here.\nAt Palantir, you apply for a catch-all backend or full stack role and team matching will happen later in the process. The process doesn’t vary much between roles although there are some variations for different levels of seniority. The recruiter might adjust the track you are on very slightly through the process but you’re more likely to do team matching after the onsite.\nThe entire process takes and 3-4 weeks but it’s possible to expedite things, especially with other offers in hand.\nStep 1: Recruiter Call\nPalantir’s recruiter call lasts 30 minutes, and it’s an important step. They filter out more candidates than most companies do at this stage from what we hear. They are looking for your motivations to join the company, so come to this call prepared to discuss why you want to be there in detail. It helps to have a compelling story as to what drew you to Palantir. You might get asked about your favorite, and least favorite past projects, as well as what you want to work on moving forward. They look for any red flags indicating you won’t be there long-term. An engineer who knows their process very well says:\n“Surface-level motivations to join the company won’t get you far and they will reject strong technical candidates if they don’t seem like a good cultural fit!”\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nPalantir’s technical phone screen lasts about an hour and happens in CodePair. This interview will feature algorithms and data structures but, the difference is that it won’t be purely technical and the algorithm you are solving will be put in the context of something you are building for an end-user. You’ll get asked to solve a problem in one half of the interview and behavioral questions in the other half. We will cover what we know of their question style in the section called “Types of Interview Questions to Expect at Palantir” below.\nStep 3: Onsite\nPalantir has 4 types of interviews they give most engineers during the onsite loop. You will only get 3 of the 4, but we will describe each here.\nEvery onsite interview will have 20 minutes of behavioral questions!\n- Problem decomposition (1 hour). This is one of the options that you will almost definitely get. It’s really important and non-standard. For more detail about the kinds of questions to expect, see the Problem decomposition section below.\n- System design (1 hour). This will be conducted in CodePair using the whiteboard functionality. For more detail about the kinds of questions to expect, see the System Design section below.\n- Re-engineering (1 hour). You’ll be given a piece of code in CodePair and asked to review it for bugs. For more detail about the kinds of questions to expect, see the Re-engineering section below.\n- Coding (1 hour). This will be similar to the technical screen before the onsite, and is conducted in CodePair. For more detail about the kinds of questions to expect, see the Coding section below.\nStep 4: Hiring Manager Interview\nThis interview will be a repeat of one of the onsite interviews. They look for red flags during the onsite and like to revisit any area they felt wasn’t up to scratch. It might not even be the technical piece they want to review! Again, the behavioral questions are very important.\nTypes of Interview Questions to Expect at Palantir\nWe can’t stress enough how embedded behavioral questions are at Palantir. As there is no behavioral interview during the onsite, they like to assess your motivations, cultural fit, and ability to work collaboratively all through the process. Come prepared with STAR-style answers, stories about why you want to work for Palantir, and ways you’ve thought about the end-user experience in other roles. If you propose a solution, talk about how it could be improved or modified for the users' benefit. You will also be asked about what projects you’ve enjoyed and not enjoyed. They want to know you’re OK working on all sorts of projects, not just glamorous ones.\nCoding\nThe coding problems posed before are during the onsite will reflect the type of work you will be doing at Palantir, i.e., building products for end-users. So, while the core technical question might look like a standard LeetCode-style problem, it will be put in the context of a larger solution for an end-user. You’ll have to solve the problem but also consider and discuss its impact on the whole system, and how it will be used by the user. You’ll need to ask a lot of clarifying questions as it will be under-defined at first. Just keep thinking about the end-user and what trade-offs you will have to make in order to make the user experience positive. Maybe your solution is memory intensive, or maybe it's more runtime complexity intensive - think about and discuss improvements you could make to help the user in future iterations. They value user-centric thinking and empathy in finding solutions over algorithmic complexity. Think about how the user will use the code and how it could be improved, e.g., maybe you could implement caching so the user has a better experience each time they use the solution.\nA user who is very familiar with the Palantir interview process had this to say:\n“What strategies do you consider for enhancing performance beyond just the code you’re currently working on? Consider aspects such as caching and pre-computation to improve efficiency. Initially, your solution may not be the fastest, but implementing these strategies could significantly speed up subsequent operations.\n\"Expect the problem to be intentionally vague. It’s important to anticipate and address any ambiguous scenarios, demonstrate caution regarding potential issues, and safeguard the system from malicious users.”\nRegardless of what question you get, they’ll ask about decision-making, time and space complexity, etc. They want to know why you would approach a problem in a certain way, and they look for things that might cause issues with client integrations, etc.\nBelow are the technical topics you’re likely to encounter in Palantir interviews. To compile this list, we did two things. First, we spoke to some current and former Palantir engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nAgain, this will be an industry standard round bar the added behavioral aspects. Our system design guide has been called “excellent preparation” by someone very familiar with Palantir’s interview.\nCheck out our guide to system design interviews to help you prepare.\nRe-engineering\nIn this interview, you will be given a bunch of code in CodePair and asked to review it for bugs. You’ll be told how the system is supposed to work and that the output is wrong when you run the code. It will be about 500-100 lines of code, and it’s really important not to get lost in the first issue you see. Review everything from top to bottom as they will probably put in red herrings to distract you!\nProblem Decomposition\nThis is probably the most important technical round you will face. It’s a non-standard interview where you will be asked to solve a high-level, real-world technical problem, with a real focus on thinking about the end-user. You won’t have to write code outside of maybe some pseudocode.\nThe problem might be something like:\n\"How would you design a technology to help elderly people with poor vision who want to cook for themselves?\"\nIt will be focused on an individual or an organization. Your goal is to come up with how to use technology to solve this problem. A lot of the focus here is on breaking the problem down into its component parts so you can tackle it. You’ll need to think about the time your solution will take, as well as how the respective parts of the solution might be built by different teams.\nThere will be two parts:\n- Ideation: Break the problem down into its respective pieces and propose a solution to each. Agree on the solution with your interviewer.\n- Execution: How you would design the solution at a high-level. This is more like system design. You won’t need to go too deep technically, e.g., you won’t need to provide detail on the type of database you would use, but you might discuss the type of data / schema you’d need to solve the problem.\nThe important thing here is, as with other rounds, to focus on the end-user. Think about how your solution would be used. Discuss ways to make it better. You’re being asked to display both your ability to problem-solve and your ability to empathize with users/clients.\nHiring Manager Interview\nAfter the onsite, the interview panel meets with a hiring manager to discuss your performance. If you pass, they’ll match you with a team that needs your skillset. From there, you’ll interview again with the hiring manager for that team. This will be your final round and it will repeat one of the above rounds. If they see a red flag around motivation or culture fit, they’ll be looking to test you on it again.\nHow Palantir Makes Hiring Decisions\nThe final decision rests with the hiring manager you interview with last from what we can tell.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/palantir-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Pivotal Labs Interview Process & Questions in 2024",
      "content": "Common Pivotal Labs Interview Questions\nBelow are common interview questions that interviewers from Pivotal Labs ask in mock interviews on our platform. Because our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWe'll add details about Pivotal Labs' interview process in the future.\nPivotal Labs Interview Replays\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/pivotal-labs-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Rippling's Interview Process & Questions",
      "content": "Rippling’s Interview Process & Questions\nThe info below is based on conversations with Rippling engineers.\nRippling's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Rippling can expect the following process:\n- Recruiter call (15-30 minutes)\n- Technical phone screen (1 hour)\n- Hiring manager screen (1 hour)\n- Onsite (3-4 hours)\nGeneral Tips:\n- Rippling places a big emphasis on testing and running code during interviews\n- Grinding on LeetCode medium and hard questions will help - you will need to move fast!\n- System design round is used for leveling\nRippling has a decentralized hiring process, which means that you interview for a specific role and will most likely be interviewed by people from that team, including a hiring manager. They seem to have recently moved to a decentralized process from a centralized one.\nThe entire process takes about 4-6 weeks but can be completed in as little as two weeks. Getting a referral might help you skip certain steps like online assessments and initial recruiter screens, but this seems to vary by team.\nStep 1: Recruiter Call\nRippling’s recruiter call lasts up to 30 minutes, and, if you’ve gotten referred in, it isn’t an assessment. The recruiter will introduce you to the company and walk you through the interview process. Without a referral, you may get some light behavioral questions.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nRippling’s technical phone screen lasts about an hour and is conducted in CodePair. It will feature LeetCode-style questions. We will cover what we know of their question style in the section called “Types of Interview Questions to Expect at Rippling” below.\nStep 3: Hiring Manager Screen\nThis round can vary depending on team and location. Some hiring managers will use this round to discuss team fit, your background, and the scale and scope of projects you’ve worked on in a general sense.\nWe’ve heard that other hiring managers will ask you to present a project you’ve worked on and answer questions about it. You will know in advance. If you have to present a project, it’s wise to create slides. You will be asked about workflows and processes, what you were responsible for, what you learned, and what you might do differently. Either way, you will have time to ask questions, so come prepared.\nStep 4: Onsite\n- Coding (90 mins). This interview will be conducted in either your own IDE with screen-share or in CodePair. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). Different teams at Rippling use different tooling here. We’ve even heard of one team asking for sketches to be done on paper! For more detail about the kinds of questions to expect, see the System Design section below.\n- Coding (1 hour). This round will be in CodePair. For more info about what questions to expect, see the Coding section below.\nTypes of Interview Questions to Expect at Rippling\nRippling does ask LeetCode-style questions. Most will be LeetCode medium-level, but we have heard of some harder questions being asked.\nCoding\nThere are two coding interviews during the onsite.\nThe 90-minute coding interview will have two parts. In the first one, you will be asked to build something. In the second, you will discuss what you built, what you could have done differently, how you would scale it, etc. This interview will be fairly practical. You might be asked to prepare a simple HTTP server and then write some simple REST APIs.\nThe 1-hour coding interview will be LeetCode-style, but the questions will build on each other. You might be asked to design a data structure where you can get objects, insert objects, and get the average of all the objects in the data structure in a given time.\nFrom one of our users:\n“You’ll need to get comfortable with LeetCode medium and hard questions – you won’t have time to figure it out on the day. You need to work at a Meta-like pace.”\nBelow are the technical topics you’re likely to encounter in Rippling interviews. To compile this list, we did two things. First, we spoke to some current and former Rippling engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nYou shouldn’t encounter anything too unusual here. You might be asked to design a news recommendation engine, a shopping recommendation engine, or a file-sharing system. The key here is to recognize the tradeoffs between approaches early and articulate them. Do move fast though, as they’ll ask a lot of questions about scaling. They are looking for breadth and depth of system design experience here, and this interview is often used for leveling.\nCheck out our guide to system design interviews to help you prepare.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/rippling-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Robinhood's Interview Process & Questions",
      "content": "Robinhood’s Interview Process & Questions\nRobinhood's Interview Process for Software Engineers: 5 Steps\nMid to senior-level engineers interviewing at Robinhood can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Recruiter prep call (30 minutes)\n- Onsite (5 hours)\n- Team matching\nRobinhood’s process is centralized, meaning that everyone follows the same standardized process and team matching happens at the end. Moreover, the people interviewing you won’t necessarily be from your future team (and likely won’t be).\nStep 1: Recruiter Call\nThis step doesn’t happen 100% of the time. It depends on whether Robinhood recruiters reached out to you or whether you applied. If you applied, you do the recruiter call, and it’s standard stuff. They’ll discuss the role, expectations, your previous work history and Robinhood itself.\nIt’s really important at this stage not to reveal your salary expectations, salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nRobinhood's technical phone screen combines algorithms/data structures and system design, conducted through Karat. If you haven’t interviewed at a company that uses Karat before, it’s basically interviewer-as-a-service – companies pay them to conduct interviews on their behalf. This means that the person you’ll be talking to isn’t a Robinhood employee and won’t be able to answer questions about the team, roadmap, projects, etc. Their only objective is to screen you.\nThere are 30 minutes for each section, the coding portion will often feature one or two medium difficulty questions, whereas the system design will focus on general knowledge in a trivia-like format.\nStep 3: Second Recruiter Call\nThe second recruiter call is meant primarily to prep you for the onsite, especially if you didn’t do the first call.\nStep 4: Onsite\nThe onsite at Robinhood consists of 5 interview rounds with the following steps:\n- Coding (1 hour)\n- System design (2 hour)\n- Past project review (1 hour)\n- Hiring manager call (1 hour)\nCoding\nThis is an algorithms and data structures interview. Robinhood places an emphasis on correctness over scalability. These interviews typically happen in CoderPad.\nSystem Design\nTypically, the onsite interviews include two system design interview rounds, each covering different aspects. One interview assesses your familiarity with a wide range of system design concepts, emphasizing high-level and well-rounded solutions. The other interview will delve into a specific facet of system design, challenging you to problem-solve in a more targeted area (e.g. front-end system design).\nPast Project Review\nThe past project round will evaluate your ability to communicate about technical topics. You’ll be asked to prepare something ahead of time based on a prompt. Be ready to discuss what you bring in depth. An example prompt is: Prepare a system diagram of a previous project.\nHiring Manager Call\nRobinhood’s hiring manager call is a standard assessment of behavioral and cultural fit. The discussions are centered around role-related scenarios, with the aim of gauging problem solving and communication abilities.\nTypes of Interview Questions to Expect at Robinhood\nCoding\nRobinhood has a question bank with company-specific versions of common questions, but it’s not mandatory for interviewers to use, so there will often be a mix of those and other standard medium difficulty coding problems.\nTo figure out what specific types of questions to expect in Robinhood interviews, we did two things. First, we spoke to some current and former Robinhood interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews. Based on all of the above, here are the types of questions you’re likely to encounter:\nSystem Design\nThese questions will usually revolve around Robinhood’s own product, or adjacent/related products.\nCommon system design questions at Robinhood include:\n- Build Twitter\n- Design stock exchange\n- Design a new feature for Robinhood\n- Build Google Docs\nCheck out our guide to system design interviews to help you prepare.\nHow Robinhood Makes Hiring Decisions\nRobinhood uses a hiring committee to make decisions, except in cases where there is a low volume of candidates for a role. In the event there is a hiring committee, those who participated in the interview directly will come together to discuss and review performance, before coming to an agreement on hire or no hire.\nWant to know if you're ready to interview at Robinhood? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/robinhood-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Roblox’s Interview Process & Questions",
      "content": "Roblox’s Interview Process & Questions\nThe info below is based on conversations with Roblox engineers.\nRoblox's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Roblox can expect the following hiring process:\n- Recruiter call (30 minutes)\n- Technical phone screen (60-90 mins)\n- Onsite (4-7 hours)\n- Bar raiser interview (1 hour)\nAt Roblox, the process is decentralized, with a lot of variation in interview steps depending on the role and seniority you are interviewing for. You interview for one specific role, and most of your interviewers, with one exception, will come from the same team.\nThe stages in the process vary depending on the seniority and role you are interviewing for, with managers having a lot of scope to customize the process for their open roles.\nGeneral tips:\n- Referrals will help you get a recruiter call.\n- They look for a good match between a candidate’s skills and the role, so make sure your resume matches the job description you apply to.\nThe entire process takes about 6-8 weeks. By default, they tend to schedule interviews quite far apart compared to other companies, but if you push you can sometimes move things along.\nStep 1: Recruiter Call\nIf you get a recruiter call, it’s a great sign that they are genuinely interested. Recruiters will often send resumes to hiring managers before they even take a call so you’ve done well to get this far already. The recruiter call itself lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Roblox, and what you’re looking for moving forward.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nThere is some variation in the type of screen you might get here, with more senior roles sometimes getting a system design interview. Most mid to senior-level backend and full stack engineers will get a coding round. It will be conducted in CodeSignal. We will cover the types of questions you can get here in the Coding section below.\nStep 3: Onsite\nSometimes you’ll get a recruiter prep call before the onsite. You can split the onsite interviews and complete them over a week or two. The mix of interviews can vary by team, and the more senior you are, the more rounds you can get, but this is what most candidates can expect.\n- 2 x Coding (1 hour). These interviews will be conducted in CodeSignal. For more detail about the kinds of questions to expect, see the Coding section below.\n- 1-2 x System design (1 hour). For more detail about the kinds of questions to expect, see the System Design section below.\n- 1-3 Behavioral (1 hour). For more info about what questions to expect, see the Behavioral section below.\nStep 4: Bar Raiser Interview\nIf you pass the onsite, the final round will be a bar raiser interview. The style of this interview is unique to Roblox. They will give you a technical problem, likely one they have faced at Roblox in the past, but it will be designed to take you out of your comfort zone. It’s not a coding exercise but more a test of your creativity, intelligence, values and ability to navigate tricky situations.\nAn example of the type of technical problem might be that people are finding ways to bypass the Roblox moderation system and post inappropriate content.\nThe problem [in the Bar Raiser interview] will be something uncomfortable for you - something you can’t assign normal CS best practices to. It’ll be a weird situation.\nThe problem [in the Bar Raiser interview] will be something uncomfortable for you - something you can’t assign normal CS best practices to. It’ll be a weird situation.\nTypes of Interview Questions to Expect at Roblox\nCoding\nRoblox’s coding questions will be LeetCode medium in terms of difficulty but won’t necessarily be LeetCode-style. They will try to place problems in a situational context that is relevant to the type of work you will do there, although you will use algorithms and data structures in your solutions. They aren’t trying to trick you with anything too difficult, but they do want to see clean code. For Roblox, it’s not just about solving the problem, you have to write clean code, run test cases, compile the code etc.\nBelow are the technical topics you’re likely to encounter in Roblox interviews. To compile this list, we did two things. First, we spoke to some current and former Roblox engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nRoblox’s system design rounds come in two different styles. One is a standard system design round, and the other is a deep dive into a system you have previously designed or been involved in. If you only get one round during the onsite, it will likely be the former.\nFor the standard interview, you might be asked to build something like Minesweeper. For the project deep dive, you will be asked to explain how you built something and what the tradeoffs were.\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nYou might have as many as 3 behavioral rounds at Roblox. They can be with the engineering manager, director of engineering and/or VP of engineering overseeing the role you are interviewing for. The interview with the engineering manager and director are standard behavioral interviews, where you will be posed situational questions, and can use something like the STAR method to answer them.\nThe VP interview is different. It can seem more casual in terms of their tone, but it’s a really critical interview. If you get one of these interviews it’s a good sign that other rounds have gone well, but it is also a round many fail due to treating it casually. They will likely start by going through your resume but will find something to drill down into. They want to hire engineers they can be proud of, so if you have something on your resume, be prepared to justify why it is there and why it makes you a good hire. You might get asked about the project you’re most proud of. Don’t just give them a project that had a successful outcome; show them something that makes you stand out.\nDon’t be just a nice guy, be impressive, think about your resume and your stories.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/roblox-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Salesforce's Interview Process & Questions in 2024",
      "content": "Salesforce’s Interview Process & Questions\nSalesforce’s Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Salesforce can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Onsite (usually 4 hours but might be more depending on the team)\nSalesforce’s process is decentralized, which means that you’re applying to either a specific team or, sometimes, a specific org. Each of their orgs is called Something Cloud, so if you’re interviewing at the org level, it might be for, say, Marketing Cloud or IoT Cloud, and which team you end up on will be determined after you interview. That said, how each team or org runs their own process is up to them.\nIf you end up applying to an org rather than a specific team, you'll do team matching within the org before you get your offer numbers.\nFinally, our sources tell us that while Salesforce is pretty quick to move for a company of their size once you actually start interviewing. The time from the first interview to offer can take as little as 3 weeks, but they may take a while to get that first interview scheduled.\nStep 1: Recruiter Call\nThis is a typical recruiter call, where they’ll ask about previous experience, relevant projects, and why you’re interested in Salesforce and the specific team/org you’re targeting. They’ll also elaborate on the role and confirm that your experience and expectations are a good match.\nOne important thing – if you’re primarily a back-end engineer, let your recruiter know as soon as possible so they route you accordingly. If you don’t, and you end up saying you’re full-stack when you’re really not (or when you haven’t touched front-end work in a long time), you might be in for a rude awakening in your coding rounds when you have to traverse the DOM or build progress bars in JavaScript. Even though “full-stack” can mean any number of different things depending on the company, at Salesforce, they really mean it!\nFinally, it’s really important, at this stage, not to reveal your salary expectations, your salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number. Just don’t do it – when you give out information this early in the process, you’re painting future you into a corner.\nStep 2: Technical Phone Screen\nThe structure and content of the technical phone screen at Salesforce is team-dependent, as is tooling. One tool you’re likely to see, though, is Quip (their answer to Google docs).\nStep 3: Onsite\nSalesforce’s onsite lasts roughly 4 hours and consists of the following steps:\n- Coding (2 hours)\n- System design (1 hour)\n- Behavioral (1 hour)\nCoding\nSalesforce’s onsite usually has 2 coding interviews. As with the technical phone screen, tooling varies, but you might have to use Quip (their answer to Google docs).\nThese are the most important parts of the onsite – both the system design and the behavioral rounds don’t carry as much weight.\nSystem Design\nThis round lasts 1 hour and may also happen in Quip.\nBehavioral\nThe behavioral round is probably the least important out of all the onsite rounds. You’ll get the usual questions about past projects, your contributions, strengths and weaknesses, and so on.\nThat said, Salesforce really values the concept of Ohana (family), and you may get questions about the importance of community, supporting your team, the importance of customer relationships, and so on.\nTypes of Interview Questions to Expect at Salesforce\nCoding\nOne unique aspect of this round is more of an emphasis on specific programming language skills (rather than the type of language-agnostic interview you might see at FAANGs and many FAANG-adjacent companies).\nMoreover, if you’re applying for a full-stack role, you may get front-end or back-end questions, and which you get is up to your interviewer. One typical question is, “Build a progress bar in JavaScript”. If you’re primarily a back-end engineer who’s done some front-end work in the distant past, questions like this may be really jarring..\nIt’s less likely than at other companies that you’ll get LeetCode-style questions, but you might (again, what you get is team-dependent). However, if you do get them, they’re going to be easy to medium (rather than medium to hard, as you might see with other companies we’ve written about), and our sources tell us that if you practice the top 10 medium-difficulty questions on LeetCode, you’ll be in good shape.\nBetween the above and cross-referencing it with our own data-set of mock interviews, if you do get back-end, algorithmic questions in your coding interviews, these are the types of questions you’re likely to encounter:\nSystem Design\nThe kinds of questions you’ll get here vary a lot from team to team and may be anything from database-related questions (including writing SQL) to design questions about CRMs (not surprising, given that Salesforce is a CRM company).\nYou should also study up on the internal tooling the org/team you’re interviewing for uses, as you are likely to get questions about that (e.g., technologies they’ve acquired somewhat recently like Slack, Quip, Tableau, etc.).\nCheck out our guide to system design interviews to help you prepare.\nCommon Salesforce Interview Questions\nBelow are common questions that interviewers from Salesforce ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWant to know if you're ready to interview at Salesforce? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/salesforce-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Samsung's Interview Process & Questions in 2024",
      "content": "Common Samsung Interview Questions\nBelow are common interview questions that interviewers from Samsung ask in mock interviews on our platform. Because our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWe'll add details about Samsung's interview process in the future.\nSamsung Interview Replays\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/samsung-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Shopify's Interview Process & Questions in 2023",
      "content": "Shopify’s Interview Process & Questions\nThe info below is based on conversations with Stripe engineers in 2023.\nShopify's Interview Process for Software Engineers: 4 Steps\nFor a mid to senior-level software engineer, Shopify’s process (usually) looks like this:\n- Recruiter call (30 minutes)\n- Technical phone screen (40 minutes)\n- \"Life Story\" interview (1 hour)\n- Onsite (3-4 hours)\nShopify’s process is decentralized, which means that you interview for a specific team out of the gate.\nStep 1: Recruiter Call\nThe first recruiter call lasts 30 minutes. Its purpose is to check qualifications, hear about past projects, and find out what you’re looking for from Shopify and in general. It also acts as a culture fit check, so they’ll want to see how your communication and personality align with their values. Make sure you’re up to date on Shopify features, blog posts and news. Finally, your recruiter will make sure you understand the role you’re applying for and clarify next steps in the process.\nThis is a typical recruiter call, but shorter. It’s primarily meant to gauge your interest in Shopify and lay out the rest of the process. There will be a more detailed recruiter call, called the “Life Story” interview, later on.\nThat said, it’s still really important not to reveal your salary expectations or your salary history. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number. Just don’t do it – when you give out information this early in the process, you’re painting future you into a corner.\nNormally, we’d also advise you not to reveal where you are in process with other companies, but we’ve heard from our sources that Shopify is very good at moving quickly if you’re getting close to offer stage with other companies, so if you need them to move, make sure to mention that in this call (you don’t have to go into detail about which companies you’re talking to, just that you’re getting close to offers or have some already).\nStep 2: Technical Phone Screen\nThe technical phone screen at Shopify is a data structures/algorithms interview conducted via CoderPad. There will likely be 2 interviewers conducting this round.\nStep 3: \"Life Story\" interview\nThis interview is conducted by a recruiter, who will be asking you questions about your past to see what motivates and drives you: is there some common thread that’s been a theme or shown up in multiple places in your story and your career to date? Their goal is to suss out whether you’re a “3D person” who can communicate effectively with others, instead of just someone who’s technically gifted. Because Shopify is fully remote, they place extra importance on having employees who are personable and able to have a chat.\nYou may also be asked to sign Shopify’s code of conduct (we were able to find this copy from 2019; please email us to let us know if it’s no longer valid).\nStep 4: Onsite\nShopify’s onsite lasts roughly 4 hours and includes the following steps:\n- Pair programming (2 hours)\n- Technical deep dive (1 hour)\n- Possibly system design (1 hour; usually just for senior/staff-level engineers)\nPair Programming/Coding\nYou’ll have two separate pair programming sessions as part of your onsite.\nIn these interviews, you’ll be using your IDE of choice and sharing your screen.\nWhen you practice for this interview, get in the habit of talking out loud about what may work even if it's not ideal, and explain to the interviewer what you would do differently, or how you would improve it if you had more time. The goal isn’t just to solve the problem, but to show that you know what you’re doing and are able to consider the long-term effects of your design decisions.\nTechnical Deep Dive\nIn this interview, you’ll be doing a deep dive on a project you worked on, why it mattered, your contributions, how you overcame challenges, and so on. Be prepared to discuss technical details in depth.\nSystem Design\nYou may not get a separate system design interview in your loop – those are reserved for senior (and sometimes staff-level candidates). There will be a system design component in your pair programming sessions, however.\nTypes of Interview Questions to Expect at Shopify\nCoding/Pair Programming\nYou’re more likely to get LeetCode-style questions in the technical phone screen, rather than the onsite.\nTo figure out what types of questions to expect in your Shopify interviews, we did two things. First, we spoke to some current and former Shopify interviewers in our community. Then we cross-referenced all the anecdotes we heard with our own data-set of mock interviews. Based on all of the above, here are the types of questions you’re likely to encounter:\nDuring the onsite, you will not get LeetCode-style questions. Rather, you will iteratively build something with your interviewer. You’ll start with the simplest possible implementation and then add features to it, testing as you go. Depending on how the interview is going, your interviewer will likely add on up to three additional layers of complexity, and what started as a simple problem will end up with a system design component as well.\nExample questions include:\n- Design and implement an LRU cache\n- Given a list of products with a price and popularity rating, order them based on price and use popularity as a tiebreaker\n- Implement a discounting feature for retail\nSystem Design\nIf you do get a system design round, be prepared for high-level system design questions that will likely expect a tie into a feature/design relevant to Shopify’s product.\nCheck out our guide to system design interviews to help you prepare.\nCommon Shopify Interview Questions\nBelow are common questions that interviewers from Shopify ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWant to know if you're ready to interview at Shopify? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/shopify-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Slack Interview Process & Questions in 2024",
      "content": "Common Slack Interview Questions\nBelow are common interview questions that interviewers from Slack ask in mock interviews on our platform. Because our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWe'll add details about Slack's interview process in the future.\nSlack Interview Replays\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/slack-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Snap's Interview Process & Questions in 2024",
      "content": "Snap’s Interview Process & Questions\nSnap's Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Snap can expect the following process:\n- Recruiter call (1 hour)\n- Technical phone screen (1 hour)\n- Onsite (6 hours)\nSnap’s interview process is fully centralized, which means that everyone enters the same standardized process, and team matching happens at the end.\nLike Amazon, Snap has interviewers who are trained up to be Bar Raisers, except that they’re called Deciders. Instead of Leadership Principles, they evaluate candidates on their adherence to Snap’s values: “We are Kind, “We are Smart”, and “We are Creative”. Note that Snap’s behavioral evaluations are spread across all of your interviews, so, unlike most companies, there isn’t a dedicated behavioral interview. Make sure to keep the Snap values in mind during your rounds. They’re also looking for product knowledge and passion for Snap in every interview, so make sure you’re familiar with the app and ready to talk about it. Review their values and specifically their engineering values before heading into your interviews!\nFinally, Snap has a bar that’s been described to us as “unexpectedly high”, and exactly how high can vary from team to team.\nStep 1: Recruiter Call\nSnap’s recruiter call is pretty typical, but in addition to the standard recruiter questions, they may ask you product questions or want to hear about your usage of the app and its features. Be sure to spend some time playing around with their product before going in.\nIt’s really important, at this stage, not to reveal your salary expectations, your salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nThe technical phone screen at Snap is a data structures/algorithms interview via HackerRank (their interview tool, not the async assessment tool). Depending on the interviewer, there may also be some light behavioral questions in this round (as we mentioned earlier, behavioral questions will be sprinkled throughout the process).\nStep 3: Onsite\nThe onsite at Snap consists of 6 interview rounds with the following steps:\n- Coding (4 hours)\n- System design (1 hour)\n- Q&A (30 minutes to 1 hour)\nCoding\nThere are generally four interviews focused on algorithms and data structures. The main thing they’re looking for besides a working solution that actually runs is speed.\nSystem Design\nThe system design interview at Snap will focus on high-level system design questions and will likely expect a tie into a feature/design relevant to their product.\nQ&A\nOnce you’ve wrapped up your technical interviews, you’ll get the chance to chat with a hiring manager and ask any burning questions you may have about Snap. This round isn’t meant to be an evaluation and does not factor into whether you get an offer.\nTypes of Interview Questions to Expect at Snap\nCoding\nSnap's coding questions come from a company-wide question bank and are usually LeetCode-style questions ranging from medium to hard difficulty.\nTo figure out what types of questions to expect in your Snap interviews, we did 2 things. First, we spoke to some current and former Snap interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews. Based on all of the above, here are the types of questions you’re likely to encounter:\nSystem Design\nTypical questions include:\n- Design a chat app\n- Design an ad server\n- Design a photo sharing app\n- Design a document management system\nCheck out our guide to system design interviews to help you prepare.\nCommon Snap Interview Questions\nBelow are common questions that interviewers from Snap ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nHow Snap Makes Hiring Decisions\nOnce you’ve wrapped up your onsite, you’ll be given an offer based on the performance in the technical interviews, decided by your interviewers. Once you receive and accept your offer, you’ll begin the team matching process (given that team matching comes after an offer in their process, we didn’t officially include it as part of the interview).\nThis process can take several weeks (or longer in some cases), and consists of multiple calls with different interested hiring managers from across Snap.\nSnap Interview Replays\nWant to know if you're ready to interview at Snap? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/snap-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Snowflake Interview Process & Questions in 2024",
      "content": "Snowflake’s Interview Process & Questions\nSnowflake’s Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Snowflake can expect the following process:\n- Recruiter call (30 minutes)\n- (Possible) Hiring manager screen (30 minutes)\n- Technical phone screen (2 hours)\n- Onsite (4 hours)\nSnowflake’s process isn’t centralized, so there can be differences from team to team in terms of exactly how many interviews are required, what type, and what order they’re scheduled in. You’ll also generally be interviewing with members of the team you’ve applied to.\nStep 1: Recruiter Call\nSnowflake’s recruiter call is pretty typical. They’ll ask about your background and interests, and how they relate to the role you’re interviewing for. In some cases this call will also replace the hiring manager call, depending on if the recruiter is aware of exactly what the hiring manager of the specific team is looking for.\nIt’s really important, at this stage, not to reveal your salary expectations, your salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number. Just don’t do it – when you give out information this early in the process, you’re painting future you into a corner.\nStep 2: Hiring Manager Call\nWhether you talk to a hiring manager or not depends on which team you’re applying for and the relationship that the hiring manager and the recruiter have – if the hiring manager feels that the recruiter is well-calibrated, they may opt to skip this step.\nIn the event that you do speak with a hiring manager, they’ll talk to you about your background and see how well it fits with the role and their specific team. They’re looking to see how well your passions, interests, and previous experience ties into the Snowflake values as well, and how it will translate into your role. Ideally, they’d like to see some overlap in your hobbies and the things you’ll be doing at work.\nThe hiring managers at Snowflake are encouraged to share all good candidates with other teams, so even if you’re not a good fit for their exact team, they may help you find something else.\nStep 3: Technical Phone Screen\nThe technical phone screen at Snowflake consists of BOTH a data structures/algorithms interview AND A system design interview. That’s why it takes 2 hours. These are conducted via CoderPad and Zoom.\nStep 4: Onsite\nIn addition to having a strong back-end focus, Snowflake’s interviews test your ability to perform within a specific team. It’s also important to note that since Snowflake is a database company, a lot of the interview questions will involve having some more database expertise and knowledge than your average company.\nSnowflake’s onsite is usually virtual and takes place over Zoom using CoderPad. While the type/amount of rounds may vary from team to team, generally you can expect to see the following depending on your level:\nMid-to-senior (IC3 and 4):\n- Presentation (30 minutes): This interview is usually with multiple engineers from the team you’re applying for and is an opportunity to showcase a past project in a way that highlights your technical ability and foundational knowledge.\n- Coding (1 hour)\n- Expertise (1 hour): This is a technical interview that will touch on skills relevant for the specific team you’re interviewing for. It may be coding, system design, or both. Or it could be a deep dive into a specific language or framework (again depending on the team).\n- Behavioral (1 hour): This interview is usually with a project manager but sometimes a hiring manager will do it, depending on your team.\n- Close (1 hour): This is a final call, with a recruiter or a senior leader (depending on the team), to answer any last questions about the role and team, and to potentially wrap up any loose ends from previous rounds.\nPrincipal (IC5 and above):\n- Presentation (30 minutes): Same as mid-level above.\n- Coding (1 hour)\n- Expertise (1 hour): Same as mid-level above.\n- Behavioral (1 hour): Same as mid-level above.\n- Cross-functional (1 hour): This will be an interview with members from multiple teams across Snowflake who will come prepared with their own questions as it pertains to their department and your potential team.\n- Close (1 hour): Same as mid-level above.\nTypes of Interview Questions to Expect at Snowflake\nCoding\nFor coding interviews, you can expect algorithmic questions that are around a LeetCode medium, but with a Snowflake-specific twist and a focus on database internals. An example question is: Get a log file, aggregate the logs, and do it in a way that won’t take too long.\nEven if the questions aren’t pure LeetCode, they will touch on a variety of technical topics. As such, to figure out what technical topics to expect in your Snowflake interviews, we did 2 things. First, we spoke to some current and former Snowflake interviewers in our community. Then we cross-referenced all the anecdotes with our own data-set of mock interviews. Based on all of the above, here are the types of questions you’re likely to encounter:\nSystem Design\nThis interview will focus more on data systems and database design, and the generic “Design Instagram” types of questions are much less common.\nAn example question could be: Take in events that happened at a certain time, keep track of and organize them so that you can retrieve them quickly, and insert new events quickly while keeping track of the tradeoffs.\nCheck out our guide to system design interviews to help you prepare.\nCommon Snowflake Interview Questions\nBelow are common questions that interviewers from Snowflake ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nHow Snowflake Makes Hiring Decisions\nOnce you’ve finished your onsite, the team you’re interviewing with at Snowflake will meet and discuss your performance, review the interviews and make a decision. This usually takes a few days, after which you’ll receive feedback for each round and find out whether or not there’s an offer.\nSnowflake Interview Replays\nWant to know if you're ready to interview at Snowflake? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/snowflake-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "SpaceX’s Interview Process & Questions",
      "content": "SpaceX’s Interview Process & Questions\nSpaceX's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at SpaceX can expect the following process:\n- Recruiter call (15 minutes)\n- Hiring manager call (1 hour)\n- Asynchronous coding assessment (3 hours of work, 2 weeks to complete)\n- Onsite (5 hours)\nSpaceX has a hybrid hiring process. You apply to a general job posting, and the recruiting team will decide if they want to have a call. After you speak with them, they will shortlist your profile and show it to different hiring managers. If a hiring manager thinks there is a good fit, you’ll move forward to speak with them. If you make it through that call and an offline coding assessment, you’ll head to the onsite phase where you’ll be interviewed by engineers from the hiring manager’s team.\nTo work at SpaceX you need to be a permanent resident and/or citizen of the United States.\nFrom what we’ve been told, the entire process can take about four weeks.\nGeneral advice:\n- Go onsite in person. They put a lot of stock in personal relationships, and visiting the site is worth it!\n- They don’t need you to get to full solutions, focus on asking the right questions and showing them how you think about the problems.\n- LeetCode is helpful for practice, but they are really looking for your ability to solve real-world challenges and pull from your experience.\n- Invest a lot of time in the presentation\n- Know Elon Musk's 5-step Design Process.\nStep 1: Recruiter Call\nSpaceX’s recruiter call lasts 15 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, and why you’re interested in SpaceX\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Hiring Manager Call\nThis is usually a hybrid call, with some questions about your experience and some technical questions. As the hiring manager has picked your profile from a shortlist, they will have seen something in your background that they want to delve into. After that, you might get a system design question that relates to your previous work or the team you are interviewing with.\nStep 3: Asynchronous Coding Assessment\nThis assessment should take you 3 hours, but you have 2 weeks to complete it. It takes place on Codility. Expect medium-level LeetCode questions that you can find online but with slightly different descriptions.\nStep 4: Onsite\nThe onsite can be virtual or on-location. As above, try to actually go onsite if possible. Seeing the rockets alone is worth it but, they also like to meet people in person. You’ll get an additional 45 mins to have lunch with the recruiter. This is a great time to ask good questions and build rapport.\n- Facility tour (if in person, 25 mins) The recruiter will walk you around the site.\n- Prepared project/source code presentation (1 hour). You’ll be asked to suggest five ideas ahead of time, and they’ll pick the one they’d like you to present in person. The presentation will be in front of the entire team. This is a really important step in the process. You’ll be asked to present your project and some of the source code (if possible), and they will ask lots of questions throughout your presentation. Keep Elon Musk’s 5-step Design Process in mind here. They look for simplicity in your approach.\n- Coding (1 hour). This will likely be in CodeSignal. There might be some design elements here in addition to coding, and it will usually relate to SpaceX. For more detail about the kinds of questions to expect, see the Coding section below.\n- Lunch (if onsite, 45 mins) This will be with the recruiter and is a great time for you to ask good questions.\n- Second Coding (1 hour). This will likely be in CodeSignal and is usually conducted by two interviewers. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour) For more detail about the kinds of questions to expect, see the System Design section below.\n- Behavioral (1 hour) This interview is with the hiring manager. For more detail about the kinds of questions to expect, see the Behavioral section below.\nTypes of Interview Questions to Expect at SpaceX\nCoding\nDon’t expect LeetCode-style questions at the onsite stage. Instead, you’ll see hybrid questions that have an algorithmic component, a coding component, and a design component. SpaceX likes to ask questions that make you think and draw on previous experience. A lot of their coding questions will bear some relation to real-world SpaceX problems. Talk through your approach, as it’s more important to show how you think than to reach a full solution.\nFrom one of our users who recently went through SpaceX interviews:\nThe coding portion was more about normal logic and problem-solving design questions which did not require deep algorithmic knowledge: more about understanding the problem, asking the right questions, and providing SIMPLE and scalable design.\nA sample question might focus on spare parts for rockets and how to keep track of them as they move in and out of refrigeration. You may have to write code that tracks and logs the time each spare part is out, for instance.\nBelow are the technical topics you’re likely to encounter in SpaceX interviews. To compile this list, we did two things. First, we spoke to some current and former SpaceX engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nOutside of the topics above, you may see questions about data hazards, memory management, and generally questions that get at your understanding of how programming works under the hood (e.g., compilers).\nSystem Design\nHere you will likely be presented with a relatively straightforward design task but not given many details. For instance, you might be asked to design an inventory management system that involves multiple locations and items, similar to the example in the coding section above, except that in this interview, you’ll be focusing more on the design and less on the coding parts. In the inventory management system question, you’ll have to:\n- Design database tables for managing spare part inventory\n- Think about how to handle movement and transfers of items\n- Discuss how you would do this at scale.\nNote that these questions will intentionally sound simple, and your interviewer will not provide a lot of details – they’re looking to see how you deal with ambiguity and how you ask questions to fill in the blanks.\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nThe behavioral interview is another critical step in the process. It’s possible that you perform well in this interview but poorly in one or more coding sessions yet remain in the process. If that happens’ you’ll likely be asked to do another coding interview.\nExpect to encounter similar questions to the Amazon Leadership Principles type of interview during this round.\nOne engineer we spoke to also said they were asked how they felt about working with Product Managers. They told SpaceX it wasn’t always necessary to work with one and the interviewer seemed happy. It’s possible they do not have PMs.\nHow SpaceX Makes Hiring Decisions\nDecisions are at the hiring manager's discretion but they look for consensus. If you fail a round you might be asked to complete an additional interview. For example, if you fail one of the coding rounds, you might get another to complete.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/spacex-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Spotify's Interview Process & Questions in 2024",
      "content": "Spotify’s Interview Process & Questions\nSpotify's Interview Process for Software Engineers: 3 Steps\nFor a mid to senior-level software engineer, Spotify’s process (usually) looks like this:\n- Recruiter call (30 minutes)\n- Technical phone screen (75 minutes)\n- Onsite (4 hours)\nSpotify is notorious for moving slowly, so don’t be surprised if there are a couple of weeks of lull in between each of these steps.\nSpotify’s interview process is a hybrid, which means that while you interview for a specific team at the outset, your interviewers won’t all be from that team. Usually, you will meet the hiring manager and one other engineer on the team. The rest of your interviewers will be from other teams. One exception to this rule is high-profile teams, in which case you may meet with 2 different engineers from that team.\nBecause you’re interviewing with a specific team from the outset, there is no additional matching round. However, for open-ended roles or in cases where you did well in your interviews, but the original team wasn’t a fit for whatever reason, they’ll pass you to a call with hiring managers where they sell you on joining their teams instead.\nStep 1: Recruiter Call\nThis is a typical recruiter call, where they’ll ask about previous experience, relevant projects, and why you’re interested in Spotify. They’ll also elaborate on the role and confirm that your experience and expectations are a good match.\nIt’s really important, at this stage, not to reveal your salary expectations, your salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number. Just don’t do it – when you give out information this early in the process, you’re painting future you into a corner.\nStep 2: Technical Phone Screen\nThe exact process can vary from team to team. Generally, you’re asked technical trivia questions and some values-based questions, followed by coding.\nHow interviews are conducted also varies. The most frequently used tools are Coderpad, HackerRank, and in some cases, you’ll be asked to share your screen and use your IDE while you work through the problems you’re given.\nFinally, you may be asked to describe a past relevant project you’ve worked on. Make sure you’re prepared to demo and/or go into detail.\nStep 3: Onsite\nSpotify’s onsite usually lasts 4 hours and consists of the following steps:\n- Case Study (1 hour)\n- Coding (1 hour)\n- System design (1 hour)\n- Behavioral/Values (1 hour)\nThe order of these rounds can vary, as well as the number of coding interviews required. Depending on your score for various portions of the onsite, you may be required to complete an extra system design, object oriented design, or algorithms interview. There may be extra rounds for certain teams and roles as well. Given that Spotify’s interview process is centralized, you generally won’t be interviewing with engineers or managers from the team you’ll end up on.\nCoding\nThe technical interview will consist of domain-specific questions, values-based questions, and a few medium to hard difficulty LeetCode-style questions.\nAs with the technical phone screen, tooling is team-dependent.\nSystem Design\nFor the system design interview, Spotify wants to see a broad and general understanding of the system design process, they'll also mix in domain specific questions. Generally the questions will follow the format of \"Design a system that does (x)\" with an opportunity for follow-up questions on scalability.\nSpotify uses Mural for system design interviews.\nCase Study\nThe most important round in Spotify’s onsite is the case study interview. In this interview, you’ll be presented with a very open-ended real-world problem that may require debugging a system to figure out what’s wrong with it or to figure out why some process has stalled.\nSome system design diagrams may be shared with you, along with fake terminals, code snippets, and so on.\nThis interview requires lots of dialogue and critical thinking, and the expectation is that you’ll ask your interviewer a bunch of questions. Successful candidates will have a broad understanding of the software engineering process itself, as well as a broad understanding of the system design process.\nValues/Behavioral\nSpotify places great importance on their values and on candidates being good culture fits. Their values are as follows:\n- Innovative\n- Collaborative\n- Passionate\n- Playful\n- Sincere\nIn this interview, you’ll get a series of behavioral questions that try to get at the following (taken verbatim from their careers site):\n- Do your values align with our values?\n- Do you take ownership of your work and take pride in what you deliver?\n- Are you adaptable?\n- Are you collaborative?\n- Are you driven?\nTypes of Interview Questions to Expect at Spotify\nCoding\nThis interview usually has a few medium to hard difficulty LeetCode-style questions.\nTo figure out what types of questions to expect in your Spotify interviews, we did two things. First, we spoke to some current and former Spotify interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews. Based on all of the above, here are the types of questions you’re likely to encounter.\nSystem Design\nFrom what we’ve heard, Spotify’s system design interview follows the format of “Design a system (or feature) that does X” followed by a discussion about scalability, concurrency, and/or load balancing.\nCheck out our guide to system design interviews to help you prepare.\nCommon Spotify Interview Questions\nBelow are common questions that interviewers from Spotify ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nHow Spotify Makes Hiring Decisions\nAt Spotify, the hiring manager has final say over who gets hired. They do have a rubric, but there is no specific score or bar that guarantees an offer, and the hiring manager has space to hire someone for potential or because they were impressed with the candidate’s communication style, even if their technical skills were borderline.\nSpotify Interview Replays\nWant to know if you're ready to interview at Spotify? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/spotify-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Stripe Interview Process & Questions",
      "content": "Stripe’s Interview Process & Questions\nStripe's Interview Process for Software Engineers: 4 Steps\nMid to senior-level engineers interviewing at Stripe can expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen with any engineer at the company (1 hour)\n- Second recruiter call (30 minutes)\n- Onsite (5 hours)\nStaff-level and above engineers interviewing at Stripe will follow the same basic 3 steps but with some variation at the Onsite stage. We’ll get to that later.\nStripe has a hybrid process. Their eng team is divided into two orgs: Product and Infrastructure. You interview for a specific org, but your interview loop will have engineers involved from across the company, as well as a hiring manager from the specific org you are interviewing for. There is likely some flexibility in terms of which team in that org you end up on. That discussion usually happens post-onsite. You will have the opportunity to discuss team placement during the onsite interview with the hiring manager.\nThe entire process takes about 6 weeks but can be completed in as little as 2 weeks, particularly if you are a referral, according to our sources.\nStep 1: Recruiter Call\nStripe’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll ask you about your previous experience, why you’re interested in Stripe, your understanding of Stripe’s value proposition, and what you’re looking for moving forward. They’ll also review the specific role you’re applying for to make sure you understand the expectations and requirements and go over the hiring process.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nStripe’s technical phone screen lasts about an hour. You can use either your own IDE and share your screen or you can just use CoderPad. They leave it up to you; whatever you’re most comfortable with.\nExpect the unexpected here i.e., they won’t ask standard LeetCode-style questions. We will cover what we know of their question style in the section called \"Types of Interview Questions to Expect at Stripe\" below.\nThe hiring managers at Stripe are encouraged to share all good candidates with other teams, so even if you’re not a good fit for their exact team, they may help you find something else.\nStep 3: Second Recruiter Call\nThis is an informational call to help prepare you for the onsite.\nStep 4: Onsite\nAt this point, candidates split into different loops depending on the role they are interviewing for e.g., ML, frontend, backend etc. Onsite interview loops also vary slightly depending on the role and seniority, but the below is generally what you’ll get:\n- Coding (1 hour). This interview will be conducted in either your own IDE with screen-share or in CoderPad. Your choice. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). This interview will be conducted in either your own drawing tool with screen-share or in Whimsical. Your choice. For more detail about the kinds of questions to expect, see the System Design section below.\n- Bug bash (1 hour). You’ll be given a piece of code and will have to find the bug(s). They usually pick something that they’ve actually seen before, so it will be a generic version of a real Stripe bug. In this round, they’re looking for you to approach the problem thoughtfully and test different approaches, rather than just barreling into something and hitting a wall\n- [For roles below Staff] Integrations (1 hour). You’ll be asked to use the Stripe API here, and it will be based on real-world integrations they've seen their merchant customers create. If you interview in the Integrations org, you will not get this round.\n- [For Staff roles and above] Presentation (1 hour). You’ll have to write a one pager about a past project and present this to a staff-level engineer, and one other, more junior engineer who will take notes. You’ll be asked to explain it, and the panel will assess your ability to communicate both via written word and to a live technical audience. They want to test your ability to give business context or rationale for what you did, and your ability to justify technical decisions. They may also ask you what you’d do in situations where constraints changed on the fly. They will assess the scope of the project and probe for your use of soft power to get the project done. This interview is particularly important for leveling – if candidates can’t effectively communicate the business impact of their work, for instance, they may be down-leveled.\n- Behavioral (1 hour). This interview will be conducted by a hiring manager or a “Leveler” – someone who interviews across a lot of levels and tries to maintain a consistent bar, similar to a Bar Raiser at Amazon. For more info about what questions to expect, see the Behavioral section below.\nTypes of Interview Questions to Expect at Stripe\nAll of Stripe’s interview questions are created in-house. They run questions through tests internally via mock interviews. They are tested for fairness and fun-ness. Don’t expect industry standard questions here. Be prepared to encounter something unusual but hopefully interesting! Stripe really values proactivity and independent thinking so their questions are aimed at testing you for those skill sets.\nStripe’s questions are language-agnostic but might change a little bit depending on the language used. They playtest the questions internally to figure out if they are easier or more difficult in certain languages, and the interviewer will adjust as needed during your interview.\n“Stripe is not for everyone” is something we heard often while writing this piece. You get a lot of freedom to do things you think are important, but that comes with the responsibility to deliver. If you thrive in that kind of culture you’ll do well, but if you like to operate in a more rigid structure with very clear instructions and deliverables, you might not enjoy it there.\nStripe does not ask LeetCode questions, and grinding on LeetCode may end up being counterproductive. Instead, they tend to be practical questions that originate with the work that Stripe engineers do every day. This means that while computer science fundamentals matter, questions designed to get at them will not be formulated the same way as LeetCode problems.\nCoding\nThis interview will be less algorithms and data structures heavy than the LeetCode-style of interview you’re probably used to. Expect questions like:\n- How would you build a simple version of Identity Access Management?\n- How would you blur credit card numbers from logs?\n- Design a rate limiter in any programming language\nRegardless of what question you get, they’ll ask about decision-making, time and space complexity, etc. They want to know why you would approach a problem in a certain way, and they look for things that might cause issues with client integrations, etc.\nBelow are the technical topics you’re likely to encounter in Stripe interviews. To compile this list, we did two things. First, we spoke to some current and former Stripe engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nThis round focuses mostly on large systems and will involve designing an entire service with scalability, reliability, and usability concerns in mind. What technologies would you use and why? What are you optimizing for? Would you use a relational or non-relational database? How would caching work? And so on.\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nThis varies by role. For IC roles you’ll be asked about your own experiences. For management roles, you will be asked about how you would handle certain scenarios (e.g., underperforming direct reports, conflict in your org, etc.).\nLike Amazon, Stripe has some principles they harken back to when evaluating your responses. They’re called Operating Principles (the analog to Amazon’s Leadership Principles). Unlike Amazon, however, you won’t be asked behavioral questions in other rounds, just like this one.\nHow Stripe Makes Hiring Decisions\nThe entire onsite panel submits written feedback after the interviews are completed and then meets to discuss. Most of the time, decisions are reached by consensus (everyone agrees to hire or no-hire), but in cases where consensus isn’t possible, the hiring manager has final say.\nWant to know if you're ready to interview at Stripe? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/stripe-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "TikTok’s Interview Process & Questions",
      "content": "TikTok’s Interview Process & Questions\nTikTok's Interview Process for Software Engineers: 5 Steps\nMid to senior-level engineers interviewing at TikTok can expect the following process, although there are variations from team to team:\n- Recruiter call (30 minutes)\n- Moral equivalent of an onsite (even though each interview is separate, and you have to pass one to get to the next) consists of:\n- Technical phone screen (30 minutes)\n- Second technical phone screen (1 hour)\n- System design (1 hour)\n- Behavioral (1 hour)\nAt TikTok, the process is decentralized, and you can usually interview for more than one team at a time. We have heard that certain teams do not allow this, but for the most part, it’s safe to apply to multiple positions. As each team manages its own headcount and process it is unlikely that you will be able to skip any steps for one team that you’ve already completed for another, i.e., you’ll still have to complete the full process each time. Your interviewers will all come from the team you are interviewing for.\nAs a lot of TikTok’s engineers are based in China, particularly their senior managers, you can expect to have interviews that overlap with Chinese business hours (e.g., Sunday evenings, other evenings).\nUnlike other companies where your virtual onsite will have all of your interviews scheduled on the same day, at TikTok you are likely to do one interview at a time, having to pass each one to get to the next.\nThe entire process takes about 5 weeks, although it can move much faster, especially if you let them know that you need to have your interviews complete by a certain date, e.g., if you have competing offers. TikTok is very amenable to moving quickly if they think there’s a chance they’ll lose out, but you’ll have to actively and repeatedly remind your recruiter to move faster.\nGeneral tips for interviewing with TikTok:\n- Be prepared to interview during Chinese business hours and even to be asked questions in Mandarin if you’ve added it to your resume.\n- Be prepared for huge variations in the process between teams. TikTok is hiring like crazy, and they don’t have an official process.\n- Practice LeetCode-style questions! They rely heavily on these questions in your first few technical rounds.\n- If you need them to move quickly, they can, but you have to really push and keep pushing. That goes for scheduling, and it goes for getting an offer in a timely fashion as well. If you keep bringing up that you have another offer, they’ll move.\nStep 1: Recruiter Call\nTikTok’s recruiter call lasts 30 minutes, and it’s more informational than anything else. You’ll be briefed on the process and prepared for the first interview. You may also be asked some questions about the company and your background.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nIf you have offer deadlines coming up and need TikTok to move faster, mention that on this call, and keep reminding your recruiter of it. We’d advise not going into details about where you’re interviewing til you’re ready to start negotiating (read more how to manage your negotiations at the start of your job search), but we do advise hammering home the point that you’re in a rush (if you are).\nStep 2: Technical Phone Screen\nTikTok’s first technical phone screen is relatively straightforward and should only take about 30 minutes. It’s usually done in HackerRank. If you brush up on LeetCode questions, you should do fine here.\nStep 3: Onsite\nAt TikTok, there isn’t a discrete onsite portion of the hiring process. Instead, you will do each interview one by one and have to pass them one at a time to move forward. That said, once you get past the first technical screen, the order will look similar to other company’s onsite interviews. Onsite interview loops also vary depending on the role and seniority, but the below is generally what you’ll get:\n- Coding (1 hour). This is much more challenging than the technical phone screen and should last about an hour. The interview is usually conducted by someone on the team you are interviewing for and will use HackerRank. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). This interview will be in HackerRank and will be conducted by a hiring manager on the team. For more detail about the kinds of questions to expect, see the System Design section below.\n- Behavioral (1 hour). This interview will be conducted by a skip-level manager. For more info about what questions to expect, see the Behavioral section below.\nTypes of Interview Questions to Expect at TikTok\nThe types of questions asked at TikTok vary by team, but you can expect a lot of industry-standard LeetCode-style questions.\nCoding\nExpect LeetCode-style questions here. Most teams are language agnostic. The first interview will be fairly simple, based on feedback we’ve gotten. The second one is a lot harder. A few of the engineers we spoke to recommended brushing up on synchronized read/write locks for the second interview, in particular.\nOutside of concurrency and threading, below are the technical topics you’re likely to encounter in TikTok interviews. To compile this list, we did two things. First, we spoke to some current and former TikTok engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSystem Design\nThis round focuses mostly on large systems and will likely involve designing an entire service with scalability, reliability, and usability concerns in mind. Some example questions:\n- Design LeetCode. What technologies would you use and why? What are you optimizing for? How would logging work for every single user action on such a large scale? And so on.\n- Design a system that can handle logging on a large scale for every single user action. Imagine 100k users are coming in and there are 5 different services. Each service has to do its own logging and send it to one final database. How would you do this?\nCheck out our guide to system design interviews to help you prepare.\nBehavioral\nThis varies by role, but be prepared to discuss your background, impactful projects you’ve worked on, and times you’ve shown initiative.\nCulture fit seems to be very important to TikTok, even as they are growing so fast. Their teams are based mainly in China so that brings its own unique flavor, and you should be prepared for it.\nHow TikTok Makes Hiring Decisions\nThis varies from team to team, but it’s likely at the discretion of the hiring manager, with input from other team members.\nWant to know if you're ready to interview at TikTok? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/tiktok-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Uber’s Interview Process & Questions",
      "content": "Uber’s Interview Process & Questions\nUber's Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at Uber can expect the following process:\n- Recruiter call (30 minutes)\n- Technical Phone Screen (1 hour)\n- Onsite (4-5.5 hours)\nUber’s interview process was centralized in the past but is in the process of becoming decentralized because they tend to only hire for specific roles in the current market. Right now, it looks to be a hybrid, and practically speaking, that means if you were to apply today, you might be matched with a specific team at the outset or you might do team matching at the end. We’ve seen both, and it appears to be a function of how niche your skills are (e.g., if you’re an ML engineer, you’ll likely be matched with a specific team at the outset).\nThat said, your interviewing panel will likely all be from the same org and use a company-wide, internal question bank. Candidates tend to interview for only one role, and though the process is somewhat standardized, the hiring manager will have a say in what the process will look like as well, so expect a little bit of variance.\nGeneral tips:\n- LeetCode practice will help a lot with the coding portion. The system design interviews are pretty standard as well.\n- They want you to write code that runs during coding rounds.\n- Referrals will help; you may even be able to skip the technical phone screen with one.\n- Be prepared to be grilled on your past experience and projects, particularly during the Collaboration and Leadership and Bar Raiser rounds.\n- If you go through team matching, it may take a while (weeks to months).\nThe entire process takes about 4-6 weeks but possibly longer if you end up having to do team matching.\nStep 1: Recruiter Call\nUber’s recruiter call lasts 30 minutes, and it’s pretty standard fare – they’ll speak about the role and team you are interviewing for, discuss salary, location, and level expectations, and ask about your interest in Uber.\nIt’s really important, at this stage, to not reveal your salary expectations or where you are in the process with other companies. We’ve written a detailed post about salary negotiation that lays out exactly what to say if recruiters pressure you to name the first number.\nStep 2: Technical Phone Screen\nAlthough we heard from one engineer that they were able to skip this stage with a referral, most senior engineers will get a pretty standard technical screen here. It will be conducted in CodeSignal, and there may be one or two questions. The questions themselves will be algorithmic. They have an internal bank of questions that most interviewers use, some of which are versions of real problems that Uber has had to solve in the past, and some of which are standard algorithmic questions with some Uber-isms papered over the top, but there does seem to be some variance. Either way, expect LeetCode medium in terms of difficulty.\nIt’s important to write fully compilable code here, i.e., code that runs. You should also run test cases.\nOne engineer, familiar with the process told us:\nYou might get slightly harder questions first, and it’s OK to ask for help. If you do solve it without help, it’s a definite pass, but you can still pass with help assuming your communication skills etc. are good.\nStep 3: Onsite\nThis will vary slightly by role but most engineers can expect something like this:\n- Coding (1 hour). This interview will be conducted in CodeSignal. For more detail about the kinds of questions to expect, see the Coding section below.\n- Second coding (depth in specialization) (1 hour). This interview will be conducted in CodeSignal. For more detail about the kinds of questions to expect, see the Coding section below.\n- System design (1 hour). This interview will be conducted in CodeSignal. For more detail about the kinds of questions to expect, see the System Design section below.\n- Collaboration and Leadership (75 mins). This is with the hiring manager for the role. For more info about what questions to expect, see the Collaboration and Leadership section below.\n- Bar raiser (1 hour) This is with a special bar raiser interviewer. For more infor about what questions to expect, the Bar Raiser section below.\nTypes of Interview Questions to Expect at Uber\nCoding\nThis round will be just like the technical phone screen – they have an internal bank of questions that most interviewers use, some of which are versions of real problems that Uber has had to solve in the past, and some of which are standard algorithmic questions with some Uber-isms papered over the top. If you get LeetCode-style questions, they’ll be of medium difficulty or slightly harder. Note that you may get two questions, but if you do, they’ll likely be mediums.\nYou should get in the habit of running test cases, if it’s not something you do by default already..\nBelow are the technical topics you’re likely to encounter in Uber interviews. To compile this list, we did two things. First, we spoke to some current and former Uber engineers. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews:\nSecond Coding (Depth of Specialization)\nWe’ve heard from multiple engineers that this round is sometimes just another LeetCode-style coding round but sometimes it’s not an algorithmic question at all. This round is meant to be more reflective of the role you are interviewing for and may include some design aspects.\nOne engineer we spoke with said:\nThis round is supposed to be more focused on [a mix of code and] designing… where you might have to build a mobile game like Snake, but in reality it’s very similar to the first coding round, and interviewers often use something from the internal question bank.\nNote that your recruiter may not be prepared to set expectations for this round, as there seems to be a lot of variability in how it’s run, possibly at the request of the hiring manager. Ask as much as you can about the round beforehand, but be prepared for a possible curveball.\nSystem Design\nMost of the people we interviewed told us to expect a very standard system design round, so you shouldn’t expect many surprises here. That said, they have an internal bank of questions that are based on old problems they had to solve at Uber so you might be asked to solve one of those. You might be asked to design a map that shows every Uber driver in the world. It won’t be a typical distributed systems question (like design a chat app), and you will need to focus on scale. Think about Uber in the early days and the problems they had to solve.\nYou’ll see other, more standard, questions such as:\n- Design Dropbox\n- Design Facebook Messenger\n- Design a ride-sharing app (surprise!)\n- Design a card game\n- Design an industrial system\nCheck out our guide to system design interviews to help you prepare.\nCollaboration and Leadership\nThis interview will be conducted by the hiring manager for the role you are interviewing for, or in some cases, a hiring manager from the same org.\nThere seem to be two distinct styles used:\n- You will be asked to go through past projects and how they were delivered\n- You will be asked how you would deliver potential projects\nThe hiring manager can take this in any direction they see fit,but they are looking to test your ability to work on a team, your ability to deal with failures, and your leadership skills. Have your past projects ready to discuss in detail, they might drill down into one specific project if it seems interesting. Be able to quantify both your impact and the impact of the project.\nIf the role is a speciality role, they might ask you questions that are relevant to it, e.g., if the role includes some frontend aspects, be prepared for some frontend questions.\nBar Raiser\nOk, this is where things get serious. If you’ve made it this far, it’s a good sign. We only spoke to one Uber engineer who did not get a bar raiser round and got hired. Everyone else told us that you need to pass one to get hired and that they sometimes won’t schedule it if the rest of your onsite hasn’t gone well.\nSimilar to Amazon, which is known for this type of interview, the bar raiser interviewer will be a specialty interviewer from across the company. They won’t be part of the team you are interviewing for. They will choose the focus on the interview. We’ve heard it’s usually a reverse system design / project introspection style of interview, but if you weren’t strong in one of the other onsite rounds, it might be a repeat of that.\nIf it is a reverse system design / project introspection interview, they will likely ask you to discuss one past project in deep detail. They will ask questions around:\n- The technical complexity of the project\n- The project’s impact\n- The high level architecture decisions and the pros and cons associated\n- The time it took to complete the project and/or reach each milestone\n- Any failures\nBe prepared to quantify the project’s impact where possible. The project discussed should match the level of seniority you are interviewing for in terms of scale and scope. A staff engineer will need to talk about a project that spans at least 2 or 3 quarters of work for example, but a senior engineer can use something a little less complex. They are looking for your depth of knowledge here and this round is used for leveling. It’s probably the most important round you will have.\nHow Uber Makes Hiring Decisions\nThe entire interview panel meets, and the decision should be unanimous. If there is a mixed signal, people on the panel can try to convince others until they achieve consensus. Typically, one soft no-hire can be turned around, but one strong no-hire will be enough to reject you. In rare cases, the Bar Raiser interviewer can also overturn a hire decision.\nWant to know if you're ready to interview at Uber? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/uber-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "VMware's Interview Process & Questions in 2024",
      "content": "VMware’s Interview Process & Questions\nVMware's Interview Process for Software Engineers: 3 Steps\nMid to senior-level engineers interviewing at VMware can (usually) expect the following process:\n- Recruiter call (30 minutes)\n- Technical phone screen (1 hour)\n- Onsite (5-6 hours)\nThat said, VMware’s interview process is very decentralized. You interview for a specific team from the get-go, and not only the content of the interviews, but the types of interviews themselves, vary significantly from team to team, so take the list above with a grain of salt.\nOne other somewhat unique aspect of VMware’s process is their commitment to the Rooney Rule, i.e., committing to interviewing at least one woman and one minority candidate for every open position. In practice, sometimes the entire process for a role will get stalled until recruiting can find those candidates, and all candidates who are not from traditionally underrepresented backgrounds may end up in an indefinite holding pattern.\nFinally, a word about VMware’s eng culture. VMware wants to find very technical people who are interested in solving hard problems but also want to go home at the end of the day. VMware’s sales cycles are slow – there’s just one big release every year, so they don't need to find people who are willing to work really long hours or people whose job is to make sure that the build tool chain is on the cutting edge (and in fact, most of their customers, who tend to be huge enterprise organizations, don't want cutting edge).\nStep 1: Recruiter Call\nThis is a typical recruiter call, where they’ll ask about previous experience, relevant projects, and why you’re interested in VMware. They’ll also elaborate on the role and confirm that your experience and expectations are a good match.\nIt’s really important, at this stage, not to reveal your salary expectations, your salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number. Just don’t do it – when you give out information this early in the process, you’re painting future you into a corner.\nStep 2: Technical Phone Screen\nThis is a 1-hour long algorithmic interview. You will likely be using CoderPad in your technical phone screen, but tools vary from team to team.\nStep 3: Onsite\nDepending on the role, you may have a virtual onsite or an in-person onsite. In either event they follow similar formats. The exact composition will vary not only with the team but with your seniority – if you’re a mid-level engineer they will be more focused on coding. If you’re very senior, your interview will be much more about what you’ve done in the past — your work history, your work style, technical decisions you’ve made and so on. At the highest levels, the interview will feel more like an exchange of stories rather than vetting for a specific skill.\nSome of your questions will invariably involve VMware-specific products and knowledge, so make sure you do some background research before heading in.‘\nThat said, VMware’s onsite lasts between 5 and 6 hours and consists of the following rounds:\n- Coding (1 hour)\n- (For niche roles) Domain-specific coding (1 hour)\n- System design (1 hour)\n- Technical communication (1 hour)\n- Behavioral (1 hour)\nThe order of these rounds can vary, as well as the number of coding interviews required. Depending on your score for various portions of the onsite, you may be required to complete an extra system design, object oriented design, or algorithms interview. There may be extra rounds for certain teams and roles as well. Given that VMware’s interview process is centralized, you generally won’t be interviewing with engineers or managers from the team you’ll end up on.\nCoding\nAt minimum there will be two algorithms and data structures interviews in your onsite loop. Your interview will happen in CoderPad if it’s remote, but if it’s in person, it’ll be on a physical whiteboard.\nSystem Design\nThere will be one or two design rounds depending on your specific role and focus.\n(Potential) Hiring manage round\nThe main purpose of this round is to chat about your past projects and work experience, and they’re very focused on your ability to communicate technical details clearly and concisely. Try to come prepared to talk about projects that are relevant to VMware and its values.\nBehavioral\nThis call’s aim is to assess your fit for VMware and will focus heavily on the company’s values and mission.\nTypes of Interview Questions to Expect at VMware\nCoding\nCoding questions will focus on algorithms and data structures, and while the questions asked can vary depending on the role, you’ll likely see medium to hard-difficulty LeetCode style problems.\nTo figure out what types of questions to expect in your VMWare interviews, we did two things. First, we spoke to some current and former VMWare interviewers in our community. Then we cross-referenced all the anecdotes we heard with our own data-set of mock interviews. Based on all of the above, here are the types of questions you’re likely to encounter:\nSystem Design\nThese rounds tend to ask you to build or design something team-specific, and they’re really looking at your ability to clearly explain your approach and choices.\nCheck out our guide to system design interviews to help you prepare.\nCommon VMware Interview Questions\nBelow are common questions that interviewers from VMware ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWant to know if you're ready to interview at VMware? Do anonymous interviews with interviewers from top companies, and see exactly where you stack up.\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/vmware-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Walmart Global Interview Process & Questions in 2024",
      "content": "Common Walmart Interview Questions\nBelow are common interview questions that interviewers from Walmart ask in mock interviews on our platform. Because our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWe'll add details about Walmart's interview process in the future.\nMEDIUM\nData Structures and Algorithms\nWalmart Interview Replays\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/walmart-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Wurl's Interview Process & Questions in 2024",
      "content": "Common Wurl Interview Questions\nBelow are common interview questions that interviewers from Wurl ask in mock interviews on our platform. Because our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nWe'll add details about Wurl's interview process in the future.\nWurl Interview Replays\nSee something inaccurate? Please fill out this form, and tell us about it.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/wurlinc-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "JavaScript Interview Questions & Tips for Senior Engineers",
      "content": "How is JavaScript Used in Technical Interviews?\nJavaScript Interview Stats\nThe selection of a programming language can often be a decisive factor in the arena of technical interviews. Based on the data collected from over 100k interviews on our platform, JavaScript emerged as the third most popular language of choice, being used in 12% of all technical interviews. JavaScript ranks just below popular programming languages like Python and Java, yet, when chosen, JavaScript delivers a pass rate of 42% in the interviews, showcasing its significance and effectiveness.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews by language.\nOne of the reasons for JavaScript's popularity is its versatility. It works on both the backend and frontend, making it a valuable tool for full-stack developers. Using a single language across multiple layers of an application can enhance productivity and improve workflow.\nOf course, it wouldn't be a discussion about JavaScript without acknowledging the love-hate relationship it enjoys with programmers. JavaScript can be likened to that old friend you may sometimes find eccentric and unpredictable, yet they always surprise you with their resourcefulness and charm. No matter how you feel about it, one thing is sure — you can't ignore JavaScript.\nWhy JavaScript is Important for Technical Interviews\nUnique Qualities of JavaScript\nJavaScript stands out due to its adaptability and prevalence in web development. It's a flexible tool that handles both object-oriented and functional programming styles, making it ideal for showcasing diverse problem-solving skills in interviews. Its role as the sole native language of web browsers puts it front and center in web development, offering a clear edge during interviews. Its use in front-end and back-end development, thanks to tools like Node.js and frameworks like React, makes it a full-stack developer's dream.\nIndustry Significance of JavaScript\nJavaScript's importance goes beyond its technical merits—it's also a leading language in the industry. The 2023 Stack Overflow Developer Survey marks it as the most commonly used language for the eleventh year in a row. GitHub's Octoverse Report 2022 also attests to the same fact, with JavaScript being the most used language on GitHub. This sustained industry demand ensures that JavaScript expertise remains highly valued in technical interviews.\nJavaScript Idioms & Idiosyncrasies\nJavaScript was developed by Brendan Eich in just ten days in the year 1995 while he was working at Netscape Communications. Over the years, JavaScript has undergone numerous changes and enhancements. ECMAScript (ES), the standardized language specification, has overseen these transformations. One of the most significant shifts came with the release of ES6 (also known as ES2015) in June 2015, which introduced new syntax and powerful features that transformed the way JavaScript code was written. Since then, new versions of the specification have been released yearly, with the latest being ES2023.\nWhile the specifications have evolved, JavaScript's core principles have remained unchanged. It's a dynamic, weakly typed, prototype-based language that supports object-oriented, imperative, and declarative programming styles. Additionally, it's a single-threaded, non-blocking, asynchronous language that uses an event loop to handle concurrency. In recent years, the emergence of TypeScript - a statically typed superset of JavaScript - highlights the evolving nature of JavaScript, offering type safety and improved tooling. In this section we'll learn about JavaScript's idioms and idiosyncrasies, that make it special.\nSingle Threaded Event Loop & Asynchronous Behavior\nJavaScript is single-threaded, meaning it can process one operation at a time in a single sequence, or thread, of operations. While this might seem limiting, especially considering that many programming languages use multi-threading, JavaScript leverages this single-threaded nature using an event loop mechanism to handle asynchronous operations efficiently.\nJavaScript's single-threaded nature helps it avoid the complexities of multithreading while manipulating DOM tree, making it easier to learn and use. But since it can only process one operation at a time, a long-running operation can block the thread and hang the system, causing what is known as a \"blocking\" operation.\nTo overcome this, JavaScript uses an event-driven, non-blocking I/O model. It utilizes an event loop and a callback queue. When an asynchronous operation is encountered, it's offloaded to the browser's Web APIs, freeing up the main thread to continue executing other operations. The associated callback function is pushed into a task queue when the asynchronous operation is completed. The event loop continually checks this queue and pushes any waiting callbacks back onto the main thread for execution as soon as it's free.\nThis unique design allows JavaScript to handle high I/O workloads efficiently without the complexity and potential issues of multi-threading, making it particularly well-suited for web development, where asynchronous operations like network requests, user interactions, and timers are common.\nconsole.log(\"Fetching data...\");\nsetTimeout(function() {\nconsole.log(\"Data fetch complete!\");\n}, 2000);\nconsole.log(\"Waiting for data...\");\n// Output:\n// Fetching data...\n// Waiting for data...\n// Data fetch complete!\n1console.log(\"Fetching data...\");\n2\n3setTimeout(function() {\n4 console.log(\"Data fetch complete!\");\n5}, 2000);\n6\n7console.log(\"Waiting for data...\");\n8\n9// Output:\n10// Fetching data...\n11// Waiting for data...\n12// Data fetch complete!\n13\nJavaScript Execution Environment\nThe environments in which JavaScript runs, such as web browsers (Chrome, Safari, Firefox, etc.) or servers (Node.js, Deno, Bun, etc.), each provide unique features and behaviors. Although ECMAScript defines the standard specifications for JavaScript, not all environments implement these uniformly, leading to environment-specific quirks. For instance, a feature like the Fetch API, widely supported in modern web browsers, wasn't natively supported in Node.js until version 17.5 (with experimental flag). Therefore, understanding your JavaScript execution environment and its specific features is crucial for creating robust, cross-compatible code.\nType Coercion\nAs a weakly typed language, JavaScript can automatically convert values from one type to another, a behavior known as type coercion.\nconsole.log(4 + \"2\"); // Output: \"42\"\nlet numStr = \"42\";\nlet num = +numStr; // '+' operator triggers type coercion.\nconsole.log(num); // Output: 42 (a number, not a string)\n1console.log(4 + \"2\"); // Output: \"42\"\n2\n3let numStr = \"42\";\n4let num = +numStr; // '+' operator triggers type coercion.\n5console.log(num); // Output: 42 (a number, not a string)\n6\nThis behavior of JavaScript may remind you of type casting seen in other languages. The key difference is that type casting (or type conversion) is explicitly done by the programmer, while type coercion is performed implicitly by the language. In JavaScript, it's important to understand when and how type coercion occurs to prevent unexpected outcomes.\nFunction Expressions\nJavaScript treats functions as first-class objects so that they can be assigned to variables, stored in data structures, passed as arguments to other functions, and returned from other functions.\n// function gets assigned to a variable\nlet calculateArea = function(radius) {\nreturn Math.PI \\* radius \\* radius;\n};\n1// function gets assigned to a variable\n2let calculateArea = function(radius) {\n3 return Math.PI \\* radius \\* radius;\n4};\nHoisting\nHoisting is a unique behavior of JavaScript where variable and function declarations are moved to the top of their containing scope during the compilation phase before the code has been executed.\ngreet(); // Output: Hello, Interviewing.io!\n// Function declaration\nfunction greet() {\nconsole.log('Hello, Interviewing.io!');\n}\n1greet(); // Output: Hello, Interviewing.io!\n2\n3// Function declaration\n4function greet() {\n5 console.log('Hello, Interviewing.io!');\n6}\nClosure\nA closure is a function that has access to the variables of its outer function, even after the outer function has returned. This is possible because the inner function has access to the outer function's scope, even after the outer function has finished executing. This helps create private variables and function factories.\nfunction outerFunc() {\nlet outerVar = 'I am outside!';\nfunction innerFunc() {\nconsole.log(outerVar);\n}\nreturn innerFunc;\n}\nlet inner = outerFunc();\ninner(); // Output: I am outside!\n1function outerFunc() {\n2 let outerVar = 'I am outside!';\n3 function innerFunc() {\n4 console.log(outerVar);\n5 }\n6 return innerFunc;\n7}\n8let inner = outerFunc();\n9inner(); // Output: I am outside!\nThe this\nKeyword\nIn JavaScript, this\nis a special keyword that refers to the context in which a function is called. This can vary depending on how and where the function is invoked. In a method of an object, this\nrefers to the object itself. In a simple function call, this\nrefers to the global object (in non-strict mode) or is undefined\n(in strict mode).\nconst myObj = {\nvalue: 'Hello, World!',\nprintValue: function() {\nconsole.log(this.value);\n}\n};\nmyObj.printValue(); // Output: Hello, World!\n1const myObj = {\n2 value: 'Hello, World!',\n3 printValue: function() {\n4 console.log(this.value);\n5 }\n6};\n7\n8myObj.printValue(); // Output: Hello, World!\nContrast this with Python, where the object context is passed explicitly as a parameter (self\n) to an instance method, and with Java, where this\nalways refers to the current instance of the class.\nUnderstanding the this\nkeyword, and its context-dependent nature, is crucial for writing and debugging JavaScript code. It’s also a source of frequent mistakes. We'll learn more about that in the next section.\nDestructuring\nIntroduced in ES6, destructuring allows for quickly unpacking values from arrays or properties from objects. This can help simplify code and make it more readable.\nlet candidate = {\nname: \"Alice\",\nlanguage: \"JavaScript\",\nexperience: \"3 years\",\n};\nlet { name, experience } = candidate;\nconsole.log(name, experience); // Output: Alice, 3 years\n1let candidate = {\n2 name: \"Alice\",\n3 language: \"JavaScript\",\n4 experience: \"3 years\",\n5};\n6\n7let { name, experience } = candidate;\n8console.log(name, experience); // Output: Alice, 3 years\nRest and Spread Operators\nThese operators provide convenient ways to handle collections of items and can often simplify the code written in an interview.\nSpread: While destructuring 'unpacks' elements from an array or properties from an object, the spread operator takes it further by allowing you to expand or 'spread out' these elements or properties in a new context. It's helpful when you want to combine arrays or to use an array's values as function arguments.\nlet candidate = {\nname: \"Alice\",\nbasicSkills: [\"HTML\", \"CSS\"]\n};\nlet updatedCandidate = {\n...candidate, // Using spread operator to copy properties from candidate object\nadvancedSkills: [\"JavaScript\", \"React\"]\n};\nconsole.log(updatedCandidate);\n/\\* Output:\n{\nname: \"Alice\",\nbasicSkills: [\"HTML\", \"CSS\"],\nadvancedSkills: [\"JavaScript\", \"React\"]\n}\n\\*/\n1let candidate = {\n2 name: \"Alice\",\n3 basicSkills: [\"HTML\", \"CSS\"]\n4};\n5\n6let updatedCandidate = {\n7 ...candidate, // Using spread operator to copy properties from candidate object\n8 advancedSkills: [\"JavaScript\", \"React\"]\n9};\n10\n11console.log(updatedCandidate);\n12/\\* Output:\n13{\n14 name: \"Alice\",\n15 basicSkills: [\"HTML\", \"CSS\"],\n16 advancedSkills: [\"JavaScript\", \"React\"]\n17}\n18\\*/\nRest: The Rest operator collects multiple elements and condenses them into a single array. It's used in function arguments to allow the function to accept any number of parameters.\nfunction getCandidateDetails({ name, ...skills }) {\nconsole.log(`Candidate ${name} has the following skills:`);\nconsole.log(`Basic: ${skills.basicSkills}`);\nconsole.log(`Advanced: ${skills.advancedSkills}`);\n}\ngetCandidateDetails(updatedCandidate);\n/\\* Output:\nCandidate Alice has the following skills:\nBasic: HTML,CSS\nAdvanced: JavaScript,React\n\\*/\n1function getCandidateDetails({ name, ...skills }) {\n2 console.log(`Candidate ${name} has the following skills:`);\n3 console.log(`Basic: ${skills.basicSkills}`);\n4 console.log(`Advanced: ${skills.advancedSkills}`);\n5}\n6\n7getCandidateDetails(updatedCandidate);\n8/\\* Output:\n9Candidate Alice has the following skills:\n10Basic: HTML,CSS\n11Advanced: JavaScript,React\n12\\*/\nCommon JavaScript Interview Mistakes\nIn the context of interviews, a deep understanding of JavaScript is critical. There are some common pitfalls that candidates often fall into. Recognizing these mistakes can greatly enhance your interview performance and overall coding skills.\nImproper Use of 'this' Keyword\nThe this\nkeyword in JavaScript can be tricky, as its context depends on how and where it's called. Let's consider an example where you are iterating over an array of numbers to calculate their sum:\nclass ArraySum {\nconstructor(numbers) {\nthis.numbers = numbers;\nthis.sum = 0;\n}\ncalculateSum() {\nthis.numbers.forEach(function(num) {\nthis.sum += num;\n});\n}\n}\nlet obj = new ArraySum([1, 2, 3]);\nobj.calculateSum();\nconsole.log(obj.sum); // NaN\n1class ArraySum {\n2 constructor(numbers) {\n3 this.numbers = numbers;\n4 this.sum = 0;\n5 }\n6\n7 calculateSum() {\n8 this.numbers.forEach(function(num) {\n9 this.sum += num;\n10 });\n11 }\n12}\n13\n14let obj = new ArraySum([1, 2, 3]);\n15obj.calculateSum();\n16console.log(obj.sum); // NaN\n17\nHere, this inside the forEach\ncallback doesn't refer to the ArraySum\ninstance, but to the global object (undefined\nin strict mode). This results in NaN\nbecause undefined\n+ number in JavaScript is NaN\n.\nThe issue can be fixed using an arrow function:\nclass ArraySum {\nconstructor(numbers) {\nthis.numbers = numbers;\nthis.sum = 0;\n}\ncalculateSum() {\nthis.numbers.forEach(num => {\nthis.sum += num;\n});\n}\n}\nlet obj = new ArraySum([1, 2, 3]);\nobj.calculateSum();\nconsole.log(obj.sum); // 6\n1class ArraySum {\n2 constructor(numbers) {\n3 this.numbers = numbers;\n4 this.sum = 0;\n5 }\n6\n7 calculateSum() {\n8 this.numbers.forEach(num => {\n9 this.sum += num;\n10 });\n11 }\n12}\n13\n14let obj = new ArraySum([1, 2, 3]);\n15obj.calculateSum();\n16console.log(obj.sum); // 6\nThe arrow function doesn't have its own this\ncontext, it inherits it from the surrounding code. Now this\nwithin the forEach\ncallback correctly refers to the ArraySum\ninstance, leading to the correct sum of numbers.\nUsing Array as a Queue without Time Complexity Considerations\nJavaScript has no built-in queue data structure. Using an array as a queue is common during data structure and algorithm questions. However, it can be computationally expensive. Suppose you're implementing a Breadth-First Search (BFS) on a graph in an interview; you might use an array as a queue to hold nodes:\nfunction bfs(graph, startNode) {\nlet queue = [];\n// enqueue operation\nqueue.push(startNode);\nwhile(queue.length > 0) {\n// dequeue operation, O(n)\nlet node = queue.shift();\nconsole.log(node.value);\nfor(let child of node.children) {\nqueue.push(child);\n}\n}\n}\n1function bfs(graph, startNode) {\n2 let queue = [];\n3 // enqueue operation\n4 queue.push(startNode);\n5\n6 while(queue.length > 0) {\n7 // dequeue operation, O(n)\n8 let node = queue.shift();\n9 console.log(node.value);\n10\n11 for(let child of node.children) {\n12 queue.push(child);\n13 }\n14 }\n15}\nArray.prototype.shift()\nhas a time complexity of O(n)\nbecause it re-indexes every remaining element in the array. This can be a major inefficiency for large arrays.\nYou should always let your interviewer know you know this limitation. If the interviewer insists, you should be able to implement it using a linked list. This will give you a time complexity of O(1)\nfor both enqueue and dequeue operations.\nMistakes with Type Coercion and Equality (== and ===)\nUnderstanding JavaScript's type coercion in comparison operations is crucial, especially when dealing with different data types. Let's look at a simple but confusing example:\nlet a = '0';\nlet b = 0;\nconsole.log(a == b); // true\nconsole.log(a === b); // false\n1let a = '0';\n2let b = 0;\n3\n4console.log(a == b); // true\n5console.log(a === b); // false\nIn the first log statement, JavaScript coerces the string '0' to a number due to the ==\noperator, resulting in true. In the second log statement, the ===\noperator checks both value and type, hence '0' (string) and 0 (number) are not considered equal.\nAs a best practice, it is always recommended to use the ===\noperator.\nNot Writing Idiomatic JavaScript\nIdiomatic JavaScript means writing code that aligns with the community's accepted best practices and conventions. The following table shows some common mistakes that are not idiomatic JavaScript and how to fix them:\n| Non-idiomatic JavaScript | Idiomatic JavaScript | Explanation |\n|---|---|---|\nlet x = new Array(); | let x = []; | Use literal notation to initialize arrays. |\nlet y = new Object(); | let y = {}; | Use literal notation to initialize objects. |\nfor (let i = 0; i < array.length; i++) { console.log(array[i]); } | array.forEach(element => console.log(element)); | Use forEach for array iteration. |\nif (a !== null && a !== undefined) {...} | if (a) {...} | JavaScript treats null , undefined , 0 , NaN , \"\" as falsy. Just use if (a) to check for these. |\nlet z; if (x) { z = y; } else { z = w; } | let z = x ? y : w; | Use the ternary operator for simple conditional assignment. |\narr.indexOf(el) === -1 | !arr.includes(el) | Use includes to check if an array contains a specific element. |\nfor (let i = 0; i < users.length; i++) { if (users[i].age > 21) { adults.push(users[i]); }} | let adults = users.filter(user => user.age > 21); | Use filter for creating a new array with all elements that pass a test. |\nUnintentionally Mutating Array or Objects\nJavaScript is a language where arrays and objects are mutable and are passed by reference. Therefore, any changes to the array or object inside a function will reflect outside the function as well, leading to unintentional side effects.\nLet's consider a simple array-based DFS approach where you're not properly managing mutations:\nlet graph = {\n'A': ['B', 'C'],\n'B': ['A'],\n'C': ['A', 'B', 'D', 'E'],\n'D': ['C', 'E', 'F'],\n'E': ['C', 'D'],\n'F': ['D']\n};\nlet visited = [];\nfunction dfs(node) {\nvisited.push(node);\nfor (let neighbor of graph[node]) {\nif (!visited.includes(neighbor)) {\ndfs(neighbor);\n}\n}\nreturn visited;\n}\nlet pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\nlet pathFromB = dfs('B'); // ['A', 'B', 'C', 'D', 'E', 'F']\n1let graph = {\n2 'A': ['B', 'C'],\n3 'B': ['A'],\n4 'C': ['A', 'B', 'D', 'E'],\n5 'D': ['C', 'E', 'F'],\n6 'E': ['C', 'D'],\n7 'F': ['D']\n8};\n9\n10let visited = [];\n11\n12function dfs(node) {\n13 visited.push(node);\n14 for (let neighbor of graph[node]) {\n15 if (!visited.includes(neighbor)) {\n16 dfs(neighbor);\n17 }\n18 }\n19 return visited;\n20}\n21\n22let pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\n23let pathFromB = dfs('B'); // ['A', 'B', 'C', 'D', 'E', 'F']\nIn the above code, we expect pathFromA\nand pathFromB\nto be different, but since visited\nis shared and gets mutated during each DFS\nrun, pathFromB\ndoesn't give us the expected result.\nTo fix this, we need to initialize visited\nwithin the function itself:\nfunction dfs(node, visited = []) {\nvisited.push(node);\nfor (let neighbor of graph[node]) {\nif (!visited.includes(neighbor)) {\ndfs(neighbor, visited);\n}\n}\nreturn visited;\n}\nlet pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\nlet pathFromB = dfs('B'); // ['B', 'A', 'C', 'D', 'E', 'F']\n1function dfs(node, visited = []) {\n2 visited.push(node);\n3 for (let neighbor of graph[node]) {\n4 if (!visited.includes(neighbor)) {\n5 dfs(neighbor, visited);\n6 }\n7 }\n8 return visited;\n9}\n10\n11let pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\n12let pathFromB = dfs('B'); // ['B', 'A', 'C', 'D', 'E', 'F']\nNow, pathFromA\nand pathFromB\nare different as expected. Understanding and managing mutations properly is crucial in JavaScript, particularly in tricky algorithms such as DFS.\nNot Understanding the Sort() Method\nJavaScript's built-in Array.prototype.sort()\nmethod can be a source of confusion, especially when sorting numerical arrays. If no compare function is supplied, sort()\nwill convert items to strings and sort them in lexicographic (alphabetical) order, which can lead to unexpected results when dealing with numbers.\nFor instance, let's say you're working on a coding problem where you're given an array of integers, and you need to sort them in ascending order. You might think you could simply use sort()\n:\nlet arr = [10, 21, 4, 15];\narr.sort();\nconsole.log(arr); // Outputs: [10, 15, 21, 4]\n1let arr = [10, 21, 4, 15];\n2arr.sort();\n3console.log(arr); // Outputs: [10, 15, 21, 4]\nThis output isn't what you'd expect if you wanted to sort numerically. It's because sort()\nconverts the numbers to strings, and '10' is lexicographically less than '4'.\nTo correctly sort numbers in JavaScript, you need to supply a comparator function:\nlet arr = [10, 21, 4, 15];\n// sort method is passed a comparator function\n// if comparator(a, b) returns a negative number, a comes before b\n// if comparator(a, b) returns a positive number, b comes before a\n// if comparator(a, b) returns 0, a and b are unchanged with respect to each other\narr.sort((a, b) => a - b);\nconsole.log(arr); // Outputs: [4, 10, 15, 21]\n1let arr = [10, 21, 4, 15];\n2\n3// sort method is passed a comparator function\n4// if comparator(a, b) returns a negative number, a comes before b\n5// if comparator(a, b) returns a positive number, b comes before a\n6// if comparator(a, b) returns 0, a and b are unchanged with respect to each other\n7arr.sort((a, b) => a - b);\n8\n9console.log(arr); // Outputs: [4, 10, 15, 21]\n10\nUsing 'var' instead of 'let' or 'const'\nThe use of var\nis considered outdated in modern JavaScript (ES6 and later). Instead, let\nand const\nare preferred because they provide block scoping, reducing potential bugs and making the code easier to predict and understand.\nThe general rule of thumb is:\n-\nUse\nconst\nwhen the variable should not be reassigned. This is often true for function declarations, imported modules, and configuration variables. Usingconst\ncan help you catch errors where you accidentally try to reassign a variable. -\nUse\nlet\nwhen the variable will be reassigned. This is common in loops (for instance, counters), and in some algorithm implementations.\nChoosing let\nor const\nappropriately in your code makes it more predictable and signals to other developers (and interviewers) that you understand the variable's purpose and lifecycle. This can make your code easier to read and maintain.\nIt's also important to note that const\ndoes not make the entire variable immutable, only the assignment. For instance, if you declare an object or an array with const\n, you can still modify the elements in the array or the object's properties. This can lead to unintentional behavior if not fully understood.\nconst obj = {};\nobj.property = 'value'; // This is allowed\nconst arr = [];\narr.push(1); // This is allowed\n1const obj = {};\n2obj.property = 'value'; // This is allowed\n3\n4const arr = [];\n5arr.push(1); // This is allowed\n6\nJavaScript Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in JavaScript. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose JavaScript as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/javascript-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Python Interview Questions & Tips for Senior Engineers",
      "content": "Python Interview Questions & Tips\nWhat Makes Python Unique?\nPython is an interpreted, object-oriented general-purpose programming language. It is beloved by many developers and one of the most popular languages in the world, ranking second to JavaScript in the 2022 Stack Overflow Developer survey.\nWhile few aspects of Python are unique to the language, a variety of attributes that developers love and a deep toolbox of features make it an exceptional choice for a wide range of applications and projects:\nReadability: Python is one of the most readable programming languages, frequently using English or understandable keywords (continue\n, pass\n, def\n, local\n, finally\n, etc). It also requires consistent spacing in order to run without errors and largely avoids the usage of symbols, which both improve readability.\nA robust standard library: From json\nto datetime\nto io\n, Python has a deep collection of standard library modules that enables the development of a variety of application types out of the box.\nAn even-deeper ecosystem of non-standard modules: NumPy (used for scientific computing and mathematics) and Pandas (used for data analysis and manipulation) lead an incredibly deep set of non-standard-library modules, followed by other libraries such as collections\n, Flask, Django and TensorFlow. All of these libraries contribute to Python’s versatility, a major aspect of its popularity.\nExcellent documentation: The official Python documentation, as well as many top libraries, have comprehensive and easy-to-understand documentation, which is appreciated by Python engineers of all levels.\nList comprehensions and dict comprehensions: Python also has an easy, approachable and compact syntax for iterating and mapping over lists. For example, in another language you may have to write something like this in order to iterate over a list of integers and multiply them by 3:\nnums = [2, 7, 12, 32]\nnewlist = []\nfor x in nums:\nnewlist.append(x \\* 3)\nprint(newlist) # [6, 21, 36, 96)\n1nums = [2, 7, 12, 32]\n2newlist = []\n3\n4for x in nums:\n5 newlist.append(x \\* 3)\n6\n7print(newlist) # [6, 21, 36, 96)\n8\nHowever, in Python this code can be done in one line using a list comprehension:\n```\nnums = [2, 7, 12, 32]\nnewlist = [x\\*3 for x in nums]\nprint(newlist) # [6, 21, 36, 96)\n```\n1```\n2nums = [2, 7, 12, 32]\n3newlist = [x\\*3 for x in nums]\n4print(newlist) # [6, 21, 36, 96)\n5```\n6\nYou can even nest list comprehensions and add if\nstatements, though doing so can make the code slightly more difficult to read and quickly comprehend:\ncapital\\_tuples = [['Colorado', 'Denver'], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\ncities\\_and\\_states\\_starting\\_with\\_m = [\ncity\\_or\\_state\nfor city\\_state\\_tuple in capital\\_tuples\nfor city\\_or\\_state in city\\_state\\_tuple\nif city\\_or\\_state[0] == 'M'\n]\nprint(cities\\_and\\_states\\_starting\\_with\\_m) # ['Minnesota', 'Massachusetts']\n1capital\\_tuples = [['Colorado', 'Denver'], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\n2cities\\_and\\_states\\_starting\\_with\\_m = [\n3 city\\_or\\_state\n4 for city\\_state\\_tuple in capital\\_tuples\n5 for city\\_or\\_state in city\\_state\\_tuple\n6 if city\\_or\\_state[0] == 'M'\n7]\n8print(cities\\_and\\_states\\_starting\\_with\\_m) # ['Minnesota', 'Massachusetts']\n9\nSimilarly, you can use construct dictionaries using dict comprehensions:\ncapital\\_tuples = [[\"Colorado\", \"Denver\"], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\ncapital\\_dict = {state: capital for state, capital in capital\\_tuples}\nprint(capital\\_dict) # { 'Colorado': 'Denver', 'Minnesota': 'St. Paul', 'Massachusetts': ‘Boston' }\n1capital\\_tuples = [[\"Colorado\", \"Denver\"], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\n2capital\\_dict = {state: capital for state, capital in capital\\_tuples}\n3print(capital\\_dict) # { 'Colorado': 'Denver', 'Minnesota': 'St. Paul', 'Massachusetts': ‘Boston' }\n4\nLambda expressions / lambda functions: Lambda expressions are anonymous, simple functions in Python often used within high-order functions such as filter\nor map\n. They are syntactically restricted to a single expression and semantically they are simply syntactic sugar for a normal function definition.\nnums = [2, 7, 12, 17, 23]\nodd\\_nums = list(filter(lambda x: x % 2 != 0, nums))\nprint(odd\\_nums)\nnums\\_squared = list(map(lambda x: x\\*\\*2, nums))\nprint(nums\\_squared)\n1nums = [2, 7, 12, 17, 23]\n2odd\\_nums = list(filter(lambda x: x % 2 != 0, nums))\n3print(odd\\_nums)\n4\n5nums\\_squared = list(map(lambda x: x\\*\\*2, nums))\n6print(nums\\_squared)\n7\nPython Interview Stats\nWe've hosted over 100k interviews on our platform. Python was the language of choice in those interviews 40% of the time, and engineers who interviewed in Python passed their interviews 56% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nCommon Python Interview Mistakes\nThough Python is known for being easy to understand, debug and reason about, there are a handful of quirks that may throw off newer developers or developers coming from other languages:\nSpacing matters: While strict spacing rules makes Python code more readable, it also won’t run properly without consistent spacing. For example, many languages use brackets ({\nand }\n) to denote the beginning and ending of code blocks or functions, but Python relies on indentation and colons.\nScope and closures: In many languages you can automatically reference variables in the enclosing scope (or other outer scopes), but in Python you can only reference local variables. In order to access variables in an outer scope the nonlocal\nkeyword is required, and in order to reference variables in the global scope the (you guessed it) global\nkeyword is required.\n# Global variable\nglobal\\_var = 10\ndef outer\\_function():\n# Outer function variable\nouter\\_var = 20\ndef inner\\_function():\n# Local variable\ninner\\_var = 30\nprint(\"Local variable:\", inner\\_var) # 30\nnonlocal outer\\_var\nouter\\_var = 40\nprint(\"Nonlocal variable:\", outer\\_var) # 40\nglobal global\\_var\nglobal\\_var = 50\nprint(\"Global variable:\", global\\_var) # 50\nprint(\"Outer variable:\", outer\\_var) # 20\ninner\\_function()\nouter\\_function()\n1# Global variable\n2global\\_var = 10\n3\n4def outer\\_function():\n5 # Outer function variable\n6 outer\\_var = 20\n7\n8 def inner\\_function():\n9 # Local variable\n10 inner\\_var = 30\n11\n12 print(\"Local variable:\", inner\\_var) # 30\n13 nonlocal outer\\_var\n14 outer\\_var = 40\n15 print(\"Nonlocal variable:\", outer\\_var) # 40\n16 global global\\_var\n17 global\\_var = 50\n18 print(\"Global variable:\", global\\_var) # 50\n19\n20 print(\"Outer variable:\", outer\\_var) # 20\n21 inner\\_function()\n22\n23outer\\_function()\n24\nInterpreted: Python is an interpreted language, meaning errors surface at run-time; as opposed to compiled languages such as Java, where errors surface at compile time.\nPython Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in Python. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose Python as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/python-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Java Interview Questions & Tips for Senior Engineers",
      "content": "Java Interview Questions & Tips\nJava Interview Stats\nWe've hosted over 100k interviews on our platform. Java was the language of choice in those interviews 29% of the time. Java also had the highest success rates – engineers who chose Java as their interview language passed their interviews 51% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nJava Idioms & Idiosyncrasies\nJava is a popular choice in software development for its portability, simplicity, and its robust, object-oriented capabilities. It's a high-level language that has a great emphasis on readability and simplicity.\nAs a seasoned and commonly used language, Java boasts a vast feature set and numerous libraries. It’s a language that enforces strict typing and has an extensive standard library. It’s a language and culture with a significant amount of formalism, especially regarding object-oriented programming and type systems.\nMost candidates and interviewers will be familiar with Java’s class structure, inheritance rules, and other internals. Focus on the core parts of what make Java great and express your solutions in with good Object-Oriented styles.\n- Classes and Objects: Java is a fully object-oriented language. Ensure you're comfortable with classes, objects, inheritance, polymorphism, and encapsulation.\n- Exception Handling: Java has a robust exception handling mechanism with try, catch, finally, and throw blocks. Understand the difference between checked and unchecked exceptions.\n- Java Collections Framework: Java provides a rich set of prepackaged data structures and algorithms called the Java Collections Framework. Be comfortable with common collections like List, Set, Map, Queue, etc.\n- Generics: Generics provide compile-time type safety that allows programmers to catch invalid types at compile time.\n- Concurrency: Understand the basics of multi-threading, synchronization, and the Java concurrency utilities from the java.util.concurrent package.\n- Stream API: Java 8 introduced the Stream API for functional-style operations on streams of elements. It is beneficial to understand how to use streams for operations like filtering, mapping, or collecting elements to a result container.\n- Java Memory Model: Understand how memory allocation works in Java, including the role of the garbage collector.\nCommon Java Interview Mistakes\nWhen interviewing in Java, there are a few common pitfalls to avoid.\nIgnoring Exceptions\nJava's exception handling capabilities are one of its strong points, offering developers a structured way to predict, catch, and handle errors during the execution of the program. These mechanisms consist of try, catch, and finally blocks, as well as throws clauses. Yet, despite the robustness of these features, mishandling exceptions can lead to code that is not only faulty but also difficult to debug and maintain.\nOne common mistake is ignoring or \"swallowing\" exceptions. This refers to the practice of catching an exception but not handling it appropriately, typically leaving the catch block empty. This can be problematic as it hides error symptoms that could be critical for diagnosing issues. Swallowing exceptions is especially perilous when it's done at the system's higher levels, which could result in an entire chain of operations failing silently.\nFor instance, consider the following piece of code:\ntry {\nint result = 10 / 0; // This line will throw an ArithmeticException\n} catch (ArithmeticException e) {\n// This is an example of swallowing an exception\n}\n1try {\n2 int result = 10 / 0; // This line will throw an ArithmeticException\n3} catch (ArithmeticException e) {\n4 // This is an example of swallowing an exception\n5}\nIn the above example, an ArithmeticException is thrown due to division by zero, but the exception is swallowed in the catch block, leading to a silent failure. This kind of error can be incredibly difficult to track down in a larger codebase because it leaves no trace.\nA better practice would be to at least log the exception, giving you a chance to diagnose the problem if something goes wrong. Here's how you might handle the exception more effectively:\ntry {\nint result = 10 / 0; // This line will throw an ArithmeticException\n} catch (ArithmeticException e) {\nSystem.err.println(\"An arithmetic error occurred: \" + e.getMessage());\n}\n1try {\n2 int result = 10 / 0; // This line will throw an ArithmeticException\n3} catch (ArithmeticException e) {\n4 System.err.println(\"An arithmetic error occurred: \" + e.getMessage());\n5}\nBy appropriately logging the exception, you will get a message in your error log indicating what went wrong, making it easier to debug and fix the issue. In real-world applications, you'd likely use a logging framework like Log4j or SLF4Jinstead of System.err.println, but the principle remains the same.\nRemember, ignoring exceptions may result in unpredictable behavior, while proper exception handling leads to more robust, reliable, and maintainable software.\nNeglecting Null Checks\nJava's object-oriented paradigm permits the use of null references, i.e., references that do not point to any object. While null references can be handy, they also pose a common pitfall: a NullPointerException\n(NPE). This exception is thrown when a program attempts to use an object reference that has the null value. These include calling an instance method on the object referred to by the null reference or trying to access a field of the object. Forgetting to check for null before accessing object methods or properties is a common oversight that can lead to such crashes.\nTake, for example, the following code:\nString myString = null;\nint length = myString.length(); // This will throw a NullPointerException\n1String myString = null;\n2int length = myString.length(); // This will throw a NullPointerException\nIn this scenario, myString\nis null\n, and calling length()\non it results in a NullPointerException\n. This mistake can be easy to overlook in complex codebases or when dealing with returned values from methods, or objects that have many fields in them, leading to program failure.\nA good defensive programming practice is to make null checks before accessing methods or properties of an object. Modifying the previous example, we would have:\nString myString = null;\nint length = 0;\nif (myString != null) {\nlength = myString.length(); // Safe!\n}\n1String myString = null;\n2int length = 0;\n3if (myString != null) {\n4 length = myString.length(); // Safe!\n5}\nIn this case, we only attempt to call the length()\nmethod if myString\nis not null\n, thereby avoiding the potential for a NullPointerException\n.\nMoreover, as of Java 8, the Optional\nclass was introduced to help deal with null references in a more explicit and safer manner. Using Optional\ncan help you design more robust APIs by making the potential absence of a value explicit in your method signatures and forcing the caller to consider the null case. Here's an example of that :\nOptional myOptionalString = Optional.ofNullable(null);\nint length = myOptionalString.map(String::length).orElse(0);\n1Optional myOptionalString = Optional.ofNullable(null);\n2int length = myOptionalString.map(String::length).orElse(0);\nIn this example, we wrap the potentially null string in an Optional\n. Optional.ofNullable\nis used to create an Optional\nthat will either hold a non-null value or be empty if the provided value is null. Then, we use the map function to apply the length method only if the Optional\nis not empty. If the Optional\nis empty, which means the original string was null\n, the orElse\nmethod will be used to provide a default value of 0\n.\nWhile null references cannot always be avoided, careful checks, liberal use of Optional\n, and thoughtful API design can prevent many common NullPointerExceptions\n, leading to more robust and error-resilient programs.\nImproper Usage of equals() and hashCode()\nJava's Object class, from which all other classes inherit, includes equals()\nand hashCode()\nmethods. When you create custom classes in Java, you may need to override these methods, particularly if you're going to use instances of these classes as keys in a HashMap\nor inside a Set\n. Not doing so may lead to unexpected results.\nThe equals()\nmethod checks if two objects are equal at a logical level. By default, this method checks for reference equality, meaning it returns true only if the two references being compared point to the same object in memory. In many cases, you'll want to change this behavior to check for logical equality instead.\nFor example, consider a Interviewer\nclass where equality should be determined by a interviewer's unique ID:\npublic class Interviewer {\nprivate String id;\nprivate String name;\npublic Interviewer(String id, String name) {\nthis.id = id;\nthis.name = name;\n}\n// Incorrect: uses reference equality, not logical equality\n// This equals method is inherited from the Object class\n// // public boolean equals(Object obj) {\n// return this == obj;\n// }\n// Correct: checks for logical equality using the unique ID\n@Override\npublic boolean equals(Object obj) {\nif (this == obj)\nreturn true;\nif (obj == null || getClass() != obj.getClass())\nreturn false;\nInterviewer interviewer = (Interviewer) obj;\nreturn id.equals(interviewer.id);\n}\n}\n1public class Interviewer {\n2 private String id;\n3 private String name;\n4\n5 public Interviewer(String id, String name) {\n6 this.id = id;\n7 this.name = name;\n8 }\n9\n10 // Incorrect: uses reference equality, not logical equality\n11 // This equals method is inherited from the Object class\n12 // // public boolean equals(Object obj) {\n13 // return this == obj;\n14 // }\n15\n16 // Correct: checks for logical equality using the unique ID\n17 @Override\n18 public boolean equals(Object obj) {\n19 if (this == obj)\n20 return true;\n21 if (obj == null || getClass() != obj.getClass())\n22 return false;\n23 Interviewer interviewer = (Interviewer) obj;\n24 return id.equals(interviewer.id);\n25 }\n26}\nThe hashCode()\nmethod, on the other hand, is used in collections like HashMap\nand HashSet\nfor efficient data access. It should be overridden in such a way that if two objects are equal according to the equals()\nmethod, their hashCode()\nmethod should return the same value. If it doesn't, this can lead to unexpected and incorrect behavior when using these objects in collections.\nContinuing the Interviewer class example:\n// Incorrect: does not override hashCode(), so it\n// uses the default one from Object class\n// which is not consistent with the overridden equals method\n// @Override\n// public int hashCode() {\n// return super.hashCode();\n// }\n// Correct: hashCode() is consistent with equals()\n@Override\npublic int hashCode() {\nreturn id.hashCode();\n}\n1 // Incorrect: does not override hashCode(), so it\n2 // uses the default one from Object class\n3 // which is not consistent with the overridden equals method\n4 // @Override\n5 // public int hashCode() {\n6 // return super.hashCode();\n7 // }\n8\n9 // Correct: hashCode() is consistent with equals()\n10 @Override\n11 public int hashCode() {\n12 return id.hashCode();\n13 }\nBy properly overriding equals()\nand hashCode()\n, you can ensure that your custom objects behave as expected when used in collections or when compared using equals()\n. Remember, when overriding one, you should override both. Otherwise, you might end up with hard-to-detect bugs and unexpected behavior.\nOvercomplicating Solutions\nJava offers various features, such as streams and optional. However, overuse can lead to unnecessarily complicated and hard-to-read code. In interviews, prioritize simplicity and readability over clever, complex solutions.\nFor example, a complex chain of stream operations might seem like a clever way to solve a problem in a single line. Still, it could also end up being confusing to the interviewer who's trying to follow your logic. Similarly, while we discuss the usefulness of Optional\nin the point above, excessive usage of Optional\nmight clutter your code, making it harder to understand and maintain.\nIn a coding interview, your primary goal is to convey your problem-solving skills effectively. Your solutions should be easy to understand, correct, and efficient. Prioritize simplicity and readability over using advanced language features to create clever but complicated solutions. An interviewer will be more impressed by your ability to write clean, straightforward code that solves the problem efficiently, rather than a convoluted solution that makes heavy use of advanced language features.\nTherefore, while it's beneficial to be familiar with advanced features in Java, it's crucial to use them judiciously and in a way that enhances, not obscures, your code's readability and simplicity.\nHow to Demonstrate Java Expertise in Interviews\nTo show off your Java expertise, you could delve deep into some of the core ideas behind the Java language, such as the JVM and memory management, or discuss the latest features in the recent JDK releases. Mention garbage collection where appropriate and be sure to use Java slang like describing objects as POJOs (Plain Old Java Objects).\nTalk about how Java has evolved over the years and how the introduction of new features like lambda expressions, the Stream API, and the module system have changed the way you code in Java. If you've adopted a more functional style with these features or even have dabbled with Kotlin then it could be worth mentioning.\nRemember to also follow Java best practices, such as preferring immutability, avoiding raw type usage, leveraging the enhanced for loop and try-with-resources statement, and properly overriding equals and hashCode when necessary.\nDemonstrating your understanding of Java best practices and idioms is crucial to succeed in Java interviews. Don't get lost in niche Java trivia and focus on showing that you can code and not how to solve a problem without involving a whole ton of extra bells and whistles.\nJava Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in Java. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose Java as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/java-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "C++ Interview Questions & Tips for Senior Engineers",
      "content": "C++ Interview Questions & Tips\nC++ Interview Stats\nWe've hosted over 100k interviews on our platform. C++ was the language of choice in those interviews 9% of the time, and engineers who did their interviews in C++ passed them 58% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nC++ Idioms & Idiosyncrasies\nAs a powerful and complex language, C++ boasts a vast feature set and low-level access – but with great power comes great responsibility 🕸️. It’s a language that allows both procedural and object-oriented programming and supports generic and metaprogramming. Some amount of functional programming is even possible with the \"newer\" language features of lambdas and the std::function\nwrapper. It’s a language and culture with a fair amount of formality, especially regarding the type systems and memory management.\nCandidates and interviewers may vary wildly in familiarity with C++’s class structure, templates, and other internals. The most important recommendation we can make is to make sure that if you’re using C++-specific terms to describe what you’re doing, you genuinely understand what they mean. It’s not required that you know all the details for an interview – and an understanding of all formal definitions is not obligatory – but you should be careful not to overreach, and you definitely shouldn’t attempt to gloss over your explanations, as C++ interviewers often appreciate precise and rigorous explanations.\nWith that in mind, here are some key, idiomatic concepts you'll want to be very comfortable with:\n- Classes and Objects: C++ is an object-oriented language. Make sure you understand classes, objects, inheritance, polymorphism, and encapsulation.\n- Templates: C++'s templates allow for code reuse and type safety and they are used in all modern production C++ codebases. Be comfortable with the syntax and usage of templates in classes and functions.\n- STL (Standard Template Library): C++ provides a rich set of STL components like containers, algorithms, iterators, etc. Be familiar with common containers (like vector, set, map), algorithms (like sort, find), and iterators.\n- Pointers and References: Pointers and references form a fundamental part of C++. Understand the usage, difference between pointers and references, and the concept of pointer arithmetic.\n- Memory Management: Manual memory management is a significant part of C++. Understand dynamic memory allocation (new, delete) and the RAII (Resource Acquisition Is Initialization) idiom.\n- Exception Handling: Understand how to use try, catch, and throw keywords for exception handling in C++. Know about the standard exception class hierarchy.\n- Concurrency: Be familiar with the basics of multi-threading, synchronization primitives, and the C++11 threading library.\nCommon C++ Interview Mistakes\nFirst and foremost, as with any language, you should NOT choose C++ as a way to show off if you don’t know it well. Make sure that you pick a language you are very comfortable with, have practiced interview questions with, and ideally have worked in recently (though not strictly required).\nOutside of that, here are some things you should try to avoid when interviewing in C++ specifically.\nMismanaging Memory\nC++ gives you manual control over memory. This can lead to problems if you don't manage memory correctly. For example, the following code results in a memory leak because memory allocated with new\nis never freed with delete\n:\nint main() {\nint\\* ptr = new int(5); // dynamically allocate integer\n// do some stuff\nreturn 0; // ptr goes out of scope and the memory is leaked\n}\n1\n2int main() {\n3 int\\* ptr = new int(5); // dynamically allocate integer\n4 // do some stuff\n5 return 0; // ptr goes out of scope and the memory is leaked\n6}\n7\nNot Leveraging the Standard Template Library (STL)\nThe STL provides a wide range of utilities such as containers and algorithms. Not using them or using them incorrectly can lead to inefficient code. For example, consider the following code to find a value in an unsorted std::vector\n:\nint findInVector(const std::vector& vec, int value) {\nfor (int i = 0; i < vec.size(); i++) {\nif (vec[i] == value) {\nreturn i;\n}\n}\nreturn -1; // not found\n}\n1\n2int findInVector(const std::vector& vec, int value) {\n3 for (int i = 0; i < vec.size(); i++) {\n4 if (vec[i] == value) {\n5 return i;\n6 }\n7 }\n8 return -1; // not found\n9}\n10\nWhile it is a pride point in particular C++ developers to be able to build anything from scratch, you should show the interviewer you're a truly senior engineer that also knows when this isn't appropriate. It's tempting to write everything yourself, but in this case, this could be written much more simply and efficiently using std::find\n.\nauto it = std::find(vec.begin(), vec.end(), value);\nif (it != vec.end()) {\nint index = std::distance(vec.begin(), it);\n}\n1\n2auto it = std::find(vec.begin(), vec.end(), value);\n3if (it != vec.end()) {\n4 int index = std::distance(vec.begin(), it);\n5}\n6\nWith the find method, while the implementation is similar to the code we could have written from scratch, we utilize iterators which reduce our choices of index-out-of bounds errors, we also follow best practices of code reuse rather than building something that wasn't necessary.\nOvercomplicating Interviews With Advanced Features\nWhile C++ offers many advanced features, such as metaprogramming and operator overloading, overuse can lead to unnecessarily complex and difficult-to-read code – especially for interviews! For example, unnecessary operator overloading:\nclass MySolution {\npublic:\nMySolution(int value) : value(value) {}\nMySolution operator+(MySolution other) {\n// Unexpected behavior: adding 1 is not usually part of addition\nreturn MySolution(value + other.value + 1);\n}\nprivate:\nint value;\n};\n1\n2class MySolution {\n3public:\n4 MySolution(int value) : value(value) {}\n5 MySolution operator+(MySolution other) {\n6 // Unexpected behavior: adding 1 is not usually part of addition\n7 return MySolution(value + other.value + 1);\n8 }\n9private:\n10 int value;\n11};\n12\nIgnoring Error Handling\nC++ has robust error handling capabilities with exceptions, but ignoring them can lead to difficult-to-debug errors. Consider a function that fails to handle a potential division by zero error:\ndouble divide(double numerator, double denominator) {\nreturn numerator / denominator; // No error handling for division by zero\n}\n1\n2double divide(double numerator, double denominator) {\n3 return numerator / denominator; // No error handling for division by zero\n4}\n5\nIt would be better to throw an exception when a division by zero occurs:\ndouble divide(double numerator, double denominator) {\nif (denominator == 0) {\nthrow std::invalid\\_argument(\"Denominator cannot be zero\");\n}\nreturn numerator / denominator;\n}\n1\n2double divide(double numerator, double denominator) {\n3 if (denominator == 0) {\n4 throw std::invalid\\_argument(\"Denominator cannot be zero\");\n5 }\n6 return numerator / denominator;\n7}\n8\nHow to Demonstrate C++ Expertise in Interviews\nTo impress your interviewer, delve deep into some of the core ideas behind the C++ type system, memory management, and STL.\nMore senior engineers who are already working in C++ daily and are involved in the community can demonstrate knowledge of the latest C++ standards and advanced features. Keep in mind, however, that this demonstration of mastery is only credible if it takes place on top of a strong foundation of fundamentals that you’ve already established earlier in the interview. Otherwise, you might come off as trying to obscure things – e.g. you can't code a binary search, but you're discussing how templates might be helpful in the problem? How does that make sense?\nFeel free to discuss what you know of the language evolution and standards of C++. You can talk about how C++ has evolved over the years, and how the introduction of new standards (C++11, C++14, C++17, C++20) has brought significant improvements and features. Discuss how some of these features have influenced your coding practices or how they have resolved some of the common problems in C++ programming.\nLastly, above all, use C++ best practices – even though it is an interview! You should still be doing things like avoiding raw pointers, preferring pre-built STL algorithms over hand-written loops, writing exception-safe code, using const\ncorrectness, and following SOLID principles.\nRemember, the ultimate goal is not really just to show that you know a lot about C++, but also that you can use the language effectively to write clean, efficient, and maintainable code.\nC++ Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in C++. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose C++ as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/cplusplus-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "C# Interview Questions & Tips for Senior Engineers",
      "content": "C# Interview Questions & Tips\nC# Interview Stats\nWe've hosted over 100k interviews on our platform. C# was the language of choice in those interviews 4% of the time. C# also had a slightly low succes rate – engineers who chose C# as their interview language passed their interviews 45% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nC# Idioms & Idiosyncrasies\nEach programming language comes with its unique set of idioms and idiosyncrasies, and C# is no different. Mastering these peculiarities is key to achieving fluency in the language and successfully navigating an interview.\n- Strongly-Typed Language: Unlike dynamically typed languages, C# requires explicit data type declaration which helps catch errors at compile-time.\n- LINQ (Language Integrated Query): This powerful feature allows developers to interact with data in a type-safe, declarative manner. However, it can also lead to overuse and performance issues if not managed correctly.\n- Nullable Reference Types: This feature, introduced in C# 8.0, aims to eliminate the infamous \"null reference exceptions\" by distinguishing nullable from non-nullable reference types.\n- Delegates and Events: These are fundamental to the C# language and .NET framework but can be challenging to understand and use correctly.\nCommon C# Interview Mistakes\nSeveral common mistakes emerge when candidates use C# during technical interviews. Here are some examples:\nPoor Data Structure Choices\nC# provides a rich library of data structures, each with their specific usage scenarios and strengths. A common mistake is using inefficient data structures for the problem at hand. For example, using a List when a HashSet would provide a significant performance boost due to constant-time lookups.\n// Instead of doing this...\nList myList = new List();\n// When lookups are frequent, do this...\nHashSet mySet = new HashSet();\n1// Instead of doing this...\n2List myList = new List();\n3\n4// When lookups are frequent, do this...\n5HashSet mySet = new HashSet();\n6\nOverlooking Exception Handling\nIt's easy to overlook exception handling during an interview, but this mistake can be a signal that the candidate isn't considering edge cases and potential failures.\n// Neglecting try-catch-finally\nStreamReader sr = new StreamReader(\"nonexistentfile.txt\");\nstring line = sr.ReadLine();\n1// Neglecting try-catch-finally\n2StreamReader sr = new StreamReader(\"nonexistentfile.txt\");\n3string line = sr.ReadLine();\n4\nPoor Handling of Nulls\nNullable types and the null coalescing operator are important tools in C#. Mistakes can happen when they are not handled correctly. This is especially critical in the recent versions of C# with nullable reference types. Using these features makes your code more concise than if/else conditionals would and makes your solution cleaner overall.\n// Instead of this...\nif (myObject != null)\n{\nmyObject.DoSomething();\n}\nelse\n{\nmyObject = new MyObject();\nmyObject.DoSomething();\n}\n// You can do this...\n(myObject ??= new MyObject()).DoSomething();\n1// Instead of this...\n2if (myObject != null)\n3{\n4 myObject.DoSomething();\n5}\n6else\n7{\n8 myObject = new MyObject();\n9 myObject.DoSomething();\n10}\n11\n12// You can do this...\n13(myObject ??= new MyObject()).DoSomething();\n14\nOvercomplicating Solutions\nSometimes the simplest solution is the best. Over-engineering and making the solution more complex than it needs to be is a common mistake. Avoid adding unnecessary patterns or features that complicate the code and make it harder to read. Understand the difference between code that is meant to show you understand a concept (like in interview questions) and code that is meant to be shipped and part of a production codebase.\n// Instead of over-complicating with design patterns...\nIList numbers = new ReadOnlyCollection(new List {1, 2, 3, 4, 5});\n// If all you're doing is iterating, do this...\nint[] numbers = {1, 2, 3, 4, 5};\n1// Instead of over-complicating with design patterns...\n2IList numbers = new ReadOnlyCollection(new List {1, 2, 3, 4, 5});\n3\n4// If all you're doing is iterating, do this...\n5int[] numbers = {1, 2, 3, 4, 5};\n6\nHow to Demonstrate C# Expertise in Interviews\nUse C# Data Structures\nC# offers several structures that can make your code more efficient, such as Tuples and ValueTuples. Demonstrate your expertise by utilizing these when it makes sense.\npublic (int, int) GetMinMax(IEnumerable numbers)\n{\nint min = numbers.Min();\nint max = numbers.Max();\nreturn (min, max);\n}\n1public (int, int) GetMinMax(IEnumerable numbers)\n2{\n3 int min = numbers.Min();\n4 int max = numbers.Max();\n5 return (min, max);\n6}\n7\nUse C# Conventions and Styles\nAlthough this may seem minor, properly following C#'s naming and style conventions demonstrate your experience with the language. This includes things like PascalCasing public methods and properties, camelCasing private fields and parameters, using meaningful variable names, and keeping methods short and focused.\npublic class Customer\n{\nprivate string name;\npublic string Name\n{\nget { return name; }\nset { name = value; }\n}\n}\n1public class Customer\n2{\n3 private string name;\n4\n5 public string Name\n6 {\n7 get { return name; }\n8 set { name = value; }\n9 }\n10}\n11\nDemonstrating your C# expertise during an interview is about more than just getting the code to work. It's about showing that you understand the language deeply, and that you know how to use its features effectively and appropriately.\nEffectively Use Interfaces and Abstract Classes\nThe ability to properly use interfaces and abstract classes is essential in C#. Show that you understand when to use which, and how they can be used to create flexible and reusable code.\npublic interface IWorker\n{\nvoid Work();\n}\npublic class Employee : IWorker\n{\npublic void Work()\n{\n// Implementation here\n}\n}\n1public interface IWorker\n2{\n3 void Work();\n4}\n5\n6public class Employee : IWorker\n7{\n8 public void Work()\n9 {\n10 // Implementation here\n11 }\n12}\n13\nLeverage LINQ\nAs mentioned earlier, LINQ is a powerful tool in C#, but many engineers fail to leverage it during their interviews. This can be due to a lack of familiarity in C# or because of the hidden time and space complexities associated with these methods. It's ok to write a solution yourself when you're not sure if the LINQ equivalent has a poor complexity, but it is better to leverage LINQ and show mastery over C# to help you with simple tasks.\n//Instead of this...\nList nums = new List { 1, 2, 3, 4, 5 };\nList evenNums = new List();\nforeach (int num in nums)\n{\nif (num % 2 == 0)\n{\nevenNums.Add(num);\n}\n}\n// Use LINQ like this...\nList evenNums = nums.Where(num => num % 2 == 0).ToList();\n1//Instead of this...\n2List nums = new List { 1, 2, 3, 4, 5 };\n3List evenNums = new List();\n4\n5foreach (int num in nums)\n6{\n7 if (num % 2 == 0)\n8 {\n9 evenNums.Add(num);\n10 }\n11}\n12\n13// Use LINQ like this...\n14List evenNums = nums.Where(num => num % 2 == 0).ToList();\n15\nLINQ should be leveraged for simple tasks that make your code more concise without sacrificing readability. Here is another example:\n// Instead of writing a loop to find the smallest number...\nint smallest = int.MaxValue;\nforeach (int num in numbers)\n{\nif (num < smallest) smallest = num;\n}\n// You could simply use LINQ\nint smallest = numbers.Min();\n1// Instead of writing a loop to find the smallest number...\n2int smallest = int.MaxValue;\n3foreach (int num in numbers)\n4{\n5 if (num < smallest) smallest = num;\n6}\n7\n8// You could simply use LINQ\n9int smallest = numbers.Min();\n10\nKnow Delegates and Events\nMany candidates struggle with the correct usage of delegates and events, which can lead to messy code and memory leaks. While these don't come up too often in interviews, it is worthwhile to know the ins-and-outs if you want to show mastery here.\n// Incorrect event subscription/unsubscription\npublic delegate void Del();\npublic event Del MyEvent;\n// Somewhere in the code\nMyEvent += SomeMethod;\nMyEvent -= SomeMethod; // Forgot to unsubscribe the event handler\n1// Incorrect event subscription/unsubscription\n2public delegate void Del();\n3public event Del MyEvent;\n4\n5// Somewhere in the code\n6MyEvent += SomeMethod;\n7MyEvent -= SomeMethod; // Forgot to unsubscribe the event handler\n8\nC# Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in C#. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose C# as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/csharp-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Go (Golang) Interview Questions & Tips for Senior Engineers",
      "content": "Go Interview Questions & Tips\nGo Interview Stats\nWe've hosted over 100k interviews on our platform. Go was the language of choice in those interviews 1% of the time, and engineers who interviewed in Go passed their interviews 51% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nGo Idioms & Idiosyncrasies\nGo, often referred to as Golang, is a statically typed, compiled language renowned for its simplicity, efficiency, and strong support for concurrent programming. Go was developed by Google, and its design makes it an excellent choice for concurrent and networked programming.\nGo's distinct features and programming style allow developers to write clear and efficient code. Here are some of the key aspects of Go that are worth flexing in a technical interview:\n- Structs and Interfaces: Go employs structs instead of classes and uses interfaces for abstraction and polymorphism. You should be comfortable defining and using structs and interfaces, understanding how to implement interfaces, and the role of embedding in Go.\n- Error Handling: Go takes a refreshing approach to errors by eschewing exceptions in favor of explicit error handling. This should be familiar to you from the fact that we pass back two values in functions with the second one being any potential errors in that function. Be familiar with the idiomatic Go error handling using the\nerror\ntype and always check errors right after they occur. - Go's Standard Library: Go boasts a robust and feature-rich standard library. Be comfortable using common packages such as\nfmt\n,net/http\n,io\n,os\n, andsync\nas these are common topics of trivia in interviews. - Goroutines and Channels: Understand the concept of goroutines for lightweight thread management and channels for communication between goroutines. Have a good grasp of Go's concurrency model.\n- Defer, Panic, and Recover: Go has unique error recovery mechanisms through the use of defer, panic, and recover. Understand how and when to use them.\n- Slices and Maps: Slices and maps are key built-in data structures in Go. Be comfortable creating and manipulating slices and maps.\n- Go Memory Management: Understand how Go handles memory allocation, and be aware of Go garbage collection.\nCommon Go Interview Mistakes\nWhen interviewing in Go, there are a few common pitfalls to avoid:\nIgnoring Errors\nGo doesn't use exceptions for error handling and instead relies on an explicit error return value. Ignoring errors can lead to unpredictable behavior, and it's considered bad practice. Always handle errors right after they occur.\nThe most common way this crops up is when a candidate ignores the error returned by a function or method:\nres, \\_ := http.Get(\"http://example.com/\")\n1\n2res, \\_ := http.Get(\"http://example.com/\")\n3\nIn the above code snippet, the Get function returns two values - a Response and an error. Ignoring the error by using an underscore (\\_) is bad practice. It's better to handle the error appropriately:\nNever ignore an error return value. Here is an example of handling errors correctly:\nfile, err := http.Get(\"http://example.com/\")\nif err != nil {\nlog.Fatal(err)\n}\n// continue processing with file\n1\n2file, err := http.Get(\"http://example.com/\")\n3if err != nil {\n4 log.Fatal(err)\n5}\n6// continue processing with file\n7\nIn the corrected example, the error is checked, and if it's not nil, the error is logged, and the application is terminated. This approach makes it easy to see when and where the problem occurred, making debugging easier.\nNot Using Concurrency When Appropriate\nIn coding interviews, concurrency is a topic that does not tend to come up very often. If you're coding in Go and likely applying for a role in Go then expect concurrency as a possible question type. One of the primary benefits of using Go is its built-in support for concurrent programming via goroutines and channels. Ignoring these features and writing strictly sequential code can be a significant oversight and will prevent you from demonstrating your mastery of one of Go's key strengths.\nGo's concurrency model, known as CSP (Communicating Sequential Processes), is one of the language's most powerful features. It allows multiple tasks to run independently of each other and provides a way to communicate between them without the need for locks or shared state, which can lead to complex bugs.\nThe go\nkeyword in Go is used to launch a new goroutine, which is a lightweight thread of execution. Channels provide a way for these goroutines to communicate safely with each other.\nfunc printNumbers() {\nfor i := 1; i <= 10; i++ {\nfmt.Println(i)\n}\n}\nfunc printLetters() {\nfor i := 'a'; i <= 'j'; i++ {\nfmt.Println(string(i))\n}\n}\nfunc main() {\ngo printNumbers()\ngo printLetters()\ntime.Sleep(time.Second)\n}\n1\n2func printNumbers() {\n3 for i := 1; i <= 10; i++ {\n4 fmt.Println(i)\n5 }\n6}\n7\n8func printLetters() {\n9 for i := 'a'; i <= 'j'; i++ {\n10 fmt.Println(string(i))\n11 }\n12}\n13\n14func main() {\n15 go printNumbers()\n16 go printLetters()\n17 time.Sleep(time.Second)\n18}\n19\nIn the above example, printNumbers\nand printLetters\nare executed concurrently. However, not all problems can or should be solved with concurrency, and its misuse can lead to problems like race conditions. Understanding when and how to use these features appropriately is an essential part of Go programming.\nMisunderstanding Nil Interfaces\nIn Go, an interface value is nil\nonly if both its type and value are nil\n. A common mistake is assuming that an interface holding a nil\npointer would itself be nil\n, which is incorrect. Here's an illustration:\ntype Foo struct {}\nfunc (f \\*Foo) Bar() {}\nvar f \\*Foo // f is a nil pointer\nvar i interface{} = f\nif i == nil {\nfmt.Println(\"i is nil\")\n} else {\nfmt.Println(\"i is not nil\") // Output: i is not nil\n}\n1\n2type Foo struct {}\n3func (f \\*Foo) Bar() {}\n4\n5var f \\*Foo // f is a nil pointer\n6\n7var i interface{} = f\n8\n9if i == nil {\n10 fmt.Println(\"i is nil\")\n11} else {\n12 fmt.Println(\"i is not nil\") // Output: i is not nil\n13}\n14\nIn the above example, even though the f\npointer is nil\n, the interface i\nis not nil\nbecause it has a type (\\*Foo\n). This is a subtle point that often trips up even experienced Go programmers. This mistake can lead to panics at runtime if you try to access a method on i\nassuming that it is nil\n.\ntype Fooer interface {\nBar()\n}\nvar f \\*Foo // f is a nil pointer\nvar i Fooer = f\nif i == nil {\nfmt.Println(\"i is nil\")\n} else {\nfmt.Println(\"i is not nil\") // Output: i is not nil\n}\ni.Bar() // Runtime panic: nil pointer dereference\n1\n2type Fooer interface {\n3 Bar()\n4}\n5\n6var f \\*Foo // f is a nil pointer\n7\n8var i Fooer = f\n9\n10if i == nil {\n11 fmt.Println(\"i is nil\")\n12} else {\n13 fmt.Println(\"i is not nil\") // Output: i is not nil\n14}\n15\n16i.Bar() // Runtime panic: nil pointer dereference\n17\n18\nIn the above example, we define an interface Fooer\nthat has a Bar\nmethod. f\nis a nil\npointer to Foo\n, and i\nis an interface of type Fooer\nwhich holds f\n. Although f\nis nil\n, i\nis not nil\nand calling the Bar\nmethod on i\nresults in a runtime panic as f\nis nil\n.\nThus, when working with interfaces in Go, it's crucial to understand the distinction between a nil\ninterface value and an interface value that holds a nil\n.\nHow to Demonstrate Go Expertise in Interviews\nWhile there are many ways to demonstrate mastery over Go in an interview, show that you aren't a Java/C++ coder that happens to be using Go, you're a Go developer with full understanding of what makes Go a unique language.\n- Talk about Concurrency: One of the highlights of Go is its native support for concurrent programming with goroutines and channels. Explaining how you've used these features in your past projects can illustrate your understanding of these essential Go concepts. You could say, \"I've utilized Go's powerful goroutines and channels to handle multiple tasks concurrently, resulting in more efficient and faster programs.\"\n- Error Handling: Go has a unique way of handling errors compared to other languages. You could talk about how you've implemented error handling using idiomatic Go code. For example, \"I've leveraged Go's explicit error handling methodology, always checking for errors where they occur and propagating them up to the appropriate level where they can be handled.\"\n- Interfaces and Type Embedding: Discuss how you've used interfaces for achieving polymorphism in Go and how type embedding has helped create complex types. You might say, \"In Go, I've used interfaces extensively to achieve abstraction and polymorphism. I've also found Go's type embedding to be a powerful way to build complex types while avoiding classical inheritance.\"\n- Discuss Go's Simplicity: Go is known for its simplicity and readability. Talk about how you adhere to this philosophy in your code. You can say, \"I adhere to Go's philosophy of simplicity, valuing clear and straightforward code over clever one-liners. I believe in writing code that's easy for others (and future me) to read and understand.\" This can help you stand out from the Pythonistas who write \"elegant\" (hard-to-read) one-liners and the Java folks that tend to over-engineer and abstract out all common sense from their solutions.\nGo Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in Go. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose Go as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/go-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Ruby Interview Questions & Tips for Senior Engineers",
      "content": "How is Ruby Used in Technical Interviews?\nRuby Interview Stats\nWe've hosted over 100k interviews on our platform. Ruby was the language of choice in those interviews 2% of the time, and engineers who interviewed in Ruby passed their interviews 47% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nAccording to Stack Overflow's 2023 Developer Survey, Ruby comes in the four highest-paid languages with a median income of 98.5k USD. GitHub's Octoverse 2022 report ranks Ruby in the top ten used programming languages globally.\nWhat does this mean for you as a candidate? If Ruby is your strongest language, there's no reason to avoid using it in technical interviews. While less common, Ruby is still a viable and respected choice among interviewers.\nRuby Idioms & Idiosyncrasies\nAs a language, Ruby is favored by several leading companies, such as Airbnb, GitHub, Shopify, and 37Signals, due to its readable syntax and the powerful Rails framework. While originally designed and developed by Yukihiro \"Matz\" Matsumoto, today there are several implementations available, such as MRI (Matz's Ruby Interpreter), JRuby (which runs on the JVM), and Rubinius, each with their unique features and performance characteristics.\nAmong these, MRI is the reference implementation of Ruby and is most commonly used. It is also the assumed default in most coding interviews unless specified otherwise, given its status as the original and most widespread version of Ruby. JRuby allows for integration with Java, leveraging the power and ecosystem of the JVM, and Rubinius emphasizes concurrency, using a bytecode virtual machine much like the JVM or .NET CLR.\nWhen preparing for a Ruby interview, understanding the idioms and idiosyncrasies of the language is essential. Here are the key ones to remember.\nEverything is an Object\nIn many programming languages, primitives like integers and booleans are not objects. However, Ruby is a pure object-oriented language, meaning everything in Ruby is an object, even literals like numbers, booleans, and nil\n. This means that every piece of data has methods and instance variables, which can be very powerful.\nFor instance, you're given an array of integers and asked to return an array of even numbers. Because everything is an object, you can call the select\nmethod directly on the array object and pass it a block of code to execute for each element:\nnumbers = [1, 2, 3, 4, 5]\nevens = numbers.select(&:even?)\nputs evens # Outputs: [2, 4]\n1numbers = [1, 2, 3, 4, 5]\n2evens = numbers.select(&:even?)\n3puts evens # Outputs: [2, 4]\nIn this example, select\nis a built-in method provided by the Array\nclass, and even?\nis a built-in method provided by the Integer\nclass. The &:\nsyntax is a shorthand that converts :even?\nto a Proc\nobject, which is then passed to select\n.\nTruthy and Falsy Values\nIn Ruby, only two things are falsy — false\nand nil\n. Everything else is considered to be truthy, including 0\n, 0.0\n, \"\"\n(empty string), and []\n(empty array). This differs from other languages where 0\n, \"\"\n, or []\ncould be considered falsy.\nBlocks, Procs, Lambdas\nRuby is known for its blocks, procs, and lambdas, which are chunks of code that can be passed around like objects. They are similar to Python's lambda functions, Java's lambda expressions, and JavaScript's first-class functions and arrow functions. However, they offer greater flexibility and power that defines Ruby's flavor of functional programming.\nwords = [\"apple\", \"fig\", \"cherry\", \"banana\", \"grape\"]\nsorted\\_by\\_length = words.sort { |a, b| a.length <=> b.length }\n# sorted\\_by\\_length is now [\"fig\", \"apple\", \"grape\", \"cherry\", \"banana\"]\n1words = [\"apple\", \"fig\", \"cherry\", \"banana\", \"grape\"]\n2sorted\\_by\\_length = words.sort { |a, b| a.length <=> b.length }\n3# sorted\\_by\\_length is now [\"fig\", \"apple\", \"grape\", \"cherry\", \"banana\"]\nIn this example, a block is passed to the sort\nmethod to define custom sorting logic. The spaceship operator <=>\nis used to compare the lengths of the strings.\nDynamic Typing\nRuby, similar to Python and JavaScript, is a dynamically typed language, which means that you don't have to declare the type of a variable when you define it. Ruby will figure it out for you. Variables are just names for containers that hold references to objects. The type of variable is simply the type of the object they reference.\nIn addition, Ruby is strongly typed (unlike JavaScript), which enforces type-checking during runtime. While you don't have to explicitly define a variable's type, once the type is assigned, Ruby won't automatically convert one type to another without explicit instruction.\nHere's an example:\nx = \"Hello, Interviewing.io!\" # x is a String\nx = 42 # Now x is an Integer\n# Ruby won't automatically convert a string into a number\ny = \"5\"\nz = y + 2 # This will raise an error because Ruby is strongly typed\n1x = \"Hello, Interviewing.io!\" # x is a String\n2x = 42 # Now x is an Integer\n3\n4# Ruby won't automatically convert a string into a number\n5y = \"5\"\n6z = y + 2 # This will raise an error because Ruby is strongly typed\nSingleton Methods and Metaprogramming\nMetaprogramming in Ruby is a technique where a program can treat its code as data and manipulate it accordingly, generating and defining new methods dynamically at runtime. Singleton methods are part of this toolkit, allowing for specific methods to be defined for individual objects.\nMetaprogramming is commonly used in Ruby libraries and frameworks such as Ruby on Rails. One of the most well-known examples is how Rails adds methods to ActiveRecord models based on the column names in the associated database table.\nSuppose you have a User\nmodel with first\\_name\nand last\\_name\nattributes. When you retrieve a User\nfrom the database, Rails dynamically adds methods to that instance for getting and setting these attributes.\nuser = User.find(1) # Retrieves a User from the database.\n# Rails uses metaprogramming to define singleton methods on the user instance:\ndef user.first\\_name\nself[:first\\_name]\nend\ndef user.first\\_name=(value)\nself[:first\\_name] = value\nend\n# You can now use these dynamically generated methods:\nuser.first\\_name = 'Brian'\nputs user.first\\_name # Outputs: \"Brian\"\n1user = User.find(1) # Retrieves a User from the database.\n2\n3# Rails uses metaprogramming to define singleton methods on the user instance:\n4def user.first\\_name\n5 self[:first\\_name]\n6end\n7\n8def user.first\\_name=(value)\n9 self[:first\\_name] = value\n10end\n11\n12# You can now use these dynamically generated methods:\n13user.first\\_name = 'Brian'\n14puts user.first\\_name # Outputs: \"Brian\"\nRails internally uses a technique called method\\_missing\nto achieve this. When you call a method that does not exist, method\\_missing\nis invoked, and Rails defines these attribute methods on-the-fly.\nImplicit Returns\nMethods implicitly return the value of the last statement executed in Ruby, which differs from many languages that require an explicit return\nstatement. This can make your code more concise and help in coding interviews where you want to write shorter, cleaner methods.\ndef array\\_sum(array)\n# no explicit return statement used\narray.reduce(0, :+)\nend\nnumbers = [1, 2, 3, 4, 5]\nputs array\\_sum(numbers) # Outputs: 15\n1def array\\_sum(array)\n2 # no explicit return statement used\n3 array.reduce(0, :+)\n4end\n5\n6numbers = [1, 2, 3, 4, 5]\n7puts array\\_sum(numbers) # Outputs: 15\n8\nBang Methods\nIn Ruby, methods ending with an exclamation mark, often called \"bang\" methods, usually indicate that the method will modify the object it's called on directly rather than returning a new object. This is a convention, not a rule, and it's up to the developer to adhere to this convention when defining their methods.\nFor example, for reversing a string, Ruby has reverse\nand reverse!\nmethods. reverse\nreturns a new string that is the reverse of the original, whereas reverse!\nmodifies the original string in place.\nWhile using built-in methods or creating your own, it's essential to be aware of this convention and to use it consistently.\nCommon Ruby Interview Mistakes\nNot Knowing the Difference Between ==\nand eql?\nOperators\nIn Ruby, both ==\nand eql?\ncheck for equality, but they are used for different types of comparisons. ==\nchecks if two objects have the same value. It returns true\neven if numbers of different types (integer and float) have the same numerical value Conversely, eql?\nchecks both the value and the type of objects. It returns true\nonly if both match, hence being more restrictive.\n# Array with mixed integer and float\nnums = [1, 2.0, 3, 2]\n# '==' counts both integer 2 and float 2.0\nputs nums.count { |num| num == 2 }\n# Output: 2\n# 'eql?' counts only integer 2\nputs nums.count { |num| num.eql? 2 }\n# Output: 1\n1# Array with mixed integer and float\n2nums = [1, 2.0, 3, 2]\n3\n4# '==' counts both integer 2 and float 2.0\n5puts nums.count { |num| num == 2 }\n6# Output: 2\n7\n8# 'eql?' counts only integer 2\n9puts nums.count { |num| num.eql? 2 }\n10# Output: 1\narr = []\nputs arr.nil? # Output: false\nputs arr.empty? # Output: true\n1arr = []\n2puts arr.nil? # Output: false\n3puts arr.empty? # Output: true\nNot Knowing the Difference Between nil?\nand empty?\nnil?\nis a method available on all objects and returns true\nif the object it's called on is the special nil\nobject. nil?\nis particularly useful when you want to check if a variable has been initialized or not. On the other hand, empty?\nis a method that isn't universally available to all objects but is primarily used with collections such as Arrays, Hashes, or Strings. This method checks whether the collection contains any elements (for arrays or hashes) or characters (for strings).\nAssuming Rails Methods Are Built-in Ruby Methods\nRails extends Ruby with several helpful methods. Mistaking these for built-in Ruby methods can lead to unexpected NoMethodError\nexceptions. For instance, the methods blank?\nand present?\nare commonly used in Rails applications to check if an object is empty, a whitespace string, or nil\n. These methods are convenient, but they're not available in a non-Rails Ruby script.\n# This code will work in Rails, but not in plain Ruby\nputs \" \".blank? # In Rails, Output: true\n# Use built-in Ruby methods instead\nputs \" \".empty? # Output: false\n1# This code will work in Rails, but not in plain Ruby\n2puts \" \".blank? # In Rails, Output: true\n3\n4# Use built-in Ruby methods instead\n5puts \" \".empty? # Output: false\nWhen to Use Symbols vs. Strings\nSymbols and strings may look similar, but they are very different and serve different purposes. Symbols are immutable and often used as Hash keys, while strings are mutable and used when the content matters. A common mistake in Ruby is confusing the two, especially when accessing Hash values.\nhash = { a: 1, b: 2, c: 3 }\nputs hash[:a] # Correct, Output: 1\nputs hash['a'] # Incorrect, Output: nil\n1hash = { a: 1, b: 2, c: 3 }\n2puts hash[:a] # Correct, Output: 1\n3puts hash['a'] # Incorrect, Output: nil\nNot Using Instance Variables Correctly\nIn Ruby, a variable's scope is denoted by its prefix.\nInstance variables are declared with an @\nsymbol. Without it, Ruby treats the declaration as a local variable, limiting its scope, which won't have the desired effect.\nclass Person\ndef name=(new\\_name)\n# Creates a local variable instead of an instance variable\nname = new\\_name\nend\nend\nclass Person\ndef name=(new\\_name)\n# Creates an instance variable\n@name = new\\_name\nend\nend\n1class Person\n2 def name=(new\\_name)\n3 # Creates a local variable instead of an instance variable\n4 name = new\\_name\n5 end\n6end\n7\n8\n9class Person\n10 def name=(new\\_name)\n11 # Creates an instance variable\n12 @name = new\\_name\n13 end\n14end\nForgetting @\nchanges a variable's scope from instance-wide to method-specific, causing potential issues in your program.\nWhen to Employ and\n/ or\nvs. &&\n/ ||\nRuby has two sets of logical operators: and\n/ or\nand &&\n/ ||\n. Both sets perform logical operations but have different operator precedences, which can lead to different results if not used carefully. &&\nand ||\nhave higher precedence than and\nand or\n. Moreover, and\nand or\nhave lower precedence than the assignment operator =\n. This can lead to unexpected outcomes if and\nor or\nare used with assignments.\nresult = nil or true\nputs result # Output: nil\n1result = nil or true\n2puts result # Output: nil\nTo avoid such issues, use &&\nand ||\nfor logical operations and reserve and\n/ or\nfor control flow, where the right-hand side is only evaluated if needed.\n# Control flow using 'or'\nfile = File.open('exists.txt') or die \"Can't open file\"\n# Logical operations using '||'\nis\\_tall = is\\_adult || is\\_over\\_six\\_feet\n1# Control flow using 'or'\n2file = File.open('exists.txt') or die \"Can't open file\"\n3\n4# Logical operations using '||'\n5is\\_tall = is\\_adult || is\\_over\\_six\\_feet\n6\nParentheses are Optional\nIn Ruby, parentheses are optional for method calls. However, leaving them out is more nuanced than it may seem and can lead to unexpected behavior if not used carefully. It is recommended to use a community-accepted style guide such as RuboCop to avoid such issues.\n- Use parentheses for method invocations, except for DSL methods, methods with \"keyword\" status, and attribute access methods.\n- Always use parentheses in expressions involving\n&&\nor||\noperators. - Avoid parentheses for methods without arguments.\n# Rails migration method, an example of an internal DSL\nadd\\_column :users, :email, :string\n# Ruby keyword-like methods\nputs \"Hello, world!\" # Output method\ngets # Input method\nclass Person\nattr\\_accessor :name, :age # Defines getter and setter methods for name and age\nend\nperson = Person.new\nperson.name = \"John\" # Setter method for name\nperson.age = 30 # Setter method for age\n# Method invocation when the first argument begins with an open parenthesis\nx = Math.sin(y)\n# Always use parentheses in expressions involving logical operators\nresult = (a && b) || c\n# Avoid parentheses when the method doesn't accept any arguments\narray.empty? # No argument method\n1# Rails migration method, an example of an internal DSL\n2add\\_column :users, :email, :string\n3\n4# Ruby keyword-like methods\n5puts \"Hello, world!\" # Output method\n6gets # Input method\n7\n8class Person\n9 attr\\_accessor :name, :age # Defines getter and setter methods for name and age\n10end\n11\n12person = Person.new\n13person.name = \"John\" # Setter method for name\n14person.age = 30 # Setter method for age\n15\n16# Method invocation when the first argument begins with an open parenthesis\n17x = Math.sin(y)\n18\n19# Always use parentheses in expressions involving logical operators\n20result = (a && b) || c\n21\n22# Avoid parentheses when the method doesn't accept any arguments\n23array.empty? # No argument method\nConcatenating Strings / Strings are Mutable in Ruby\nRuby strings are mutable objects, meaning they can be changed after creation. The <<\nand concat\nmethods take advantage of this by appending to the existing string, resulting in fewer objects and better performance.\nOn the other hand, the +\noperator creates a new string object that combines the original strings, which can result in more memory usage and slower performance when concatenating large strings or performing the operation many times.\nstr1 = \"Hello, \"\nstr2 = \"Ruby!\"\n# This creates a new string\nputs str1 + str2 # Output: \"Hello, Ruby!\"\n# These modify the original string\nstr1 << str2\nputs str1 # Output: \"Hello, Ruby!\"\nstr1.concat(str2)\nputs str1 # Output: \"Hello, Ruby!Ruby!\"\n1str1 = \"Hello, \"\n2str2 = \"Ruby!\"\n3\n4# This creates a new string\n5puts str1 + str2 # Output: \"Hello, Ruby!\"\n6\n7# These modify the original string\n8str1 << str2\n9puts str1 # Output: \"Hello, Ruby!\"\n10\n11str1.concat(str2)\n12puts str1 # Output: \"Hello, Ruby!Ruby!\"\nConfusion between include\nand extend\nThe include\nmethod mixes the module methods into an instance of a class, meaning the methods become instance methods. On the other hand, the extend\nmethod mixes the module methods into the class directly, making them class methods.\nA common mistake is to use include\nwhen you meant to use extend\n, or vice versa, which will not provide the expected functionality.\nmodule Greeting\ndef hello\n\"Hello, Ruby!\"\nend\nend\nclass Person\ninclude Greeting\nend\nclass Robot\nextend Greeting\nend\nperson = Person.new\nputs person.hello # Correct, Output: \"Hello, Ruby!\"\nputs Robot.hello # Correct, Output: \"Hello, Ruby!\"\nrobot = Robot.new\nputs robot.hello # Incorrect, will raise a NoMethodError\n1module Greeting\n2 def hello\n3 \"Hello, Ruby!\"\n4 end\n5end\n6\n7class Person\n8 include Greeting\n9end\n10\n11class Robot\n12 extend Greeting\n13end\n14\n15person = Person.new\n16puts person.hello # Correct, Output: \"Hello, Ruby!\"\n17\n18puts Robot.hello # Correct, Output: \"Hello, Ruby!\"\n19\n20robot = Robot.new\n21puts robot.hello # Incorrect, will raise a NoMethodError\nMisunderstanding throw\n/catch\nand raise\n/rescue\nRuby error handling is often done with raise\nand rescue\n, which are used to throw and handle exceptions, respectively. throw\nand catch\nare used for control flow and are not directly related to exception handling.\nA common mistake is confusing throw\nwith raise\nand catch\nwith rescue\n. While their names suggest similar functionality, they serve different purposes in Ruby.\ndef faulty\\_method\nbegin\nraise \"An error occurred!\"\nrescue => e\nputs \"Rescued from error: #{e}\"\nend\nend\nfaulty\\_method # Output: \"Rescued from error: An error occurred!\"\ncatch :done do\n10.times do |i|\nthrow :done if i > 5\nputs i\nend\nend\n# Output: 0 1 2 3 4 5\n1def faulty\\_method\n2 begin\n3 raise \"An error occurred!\"\n4 rescue => e\n5 puts \"Rescued from error: #{e}\"\n6 end\n7end\n8\n9faulty\\_method # Output: \"Rescued from error: An error occurred!\"\n10\n11\n12catch :done do\n13 10.times do |i|\n14 throw :done if i > 5\n15 puts i\n16 end\n17end\n18# Output: 0 1 2 3 4 5\n19\nNot Using Idiomatic Ruby\nRuby is renowned for its elegance and expressiveness, which are rooted in the language's idioms. The Ruby community largely follows the guidelines put forth by the Ruby Style Guide, which is enforced by linting tools like RuboCop. Here are some common mistakes made when not utilizing idiomatic Ruby, along with their corrections and guidelines.\n| Mistake | Correction | Guideline |\n|---|---|---|\ndef sum(a, b) (a + b) end | def sum(a, b) a + b end | Omit parentheses for the returned expression. |\n{'one' => 1, 'two' => 2} | {one: 1, two: 2} | Use the Ruby hash syntax. |\nif some\\_condition then do\\_something end | do\\_something if some\\_condition | Avoid the use of `then` for single-line `if/unless`. |\nresult = if some\\_condition then something else something\\_else end | result = some\\_condition ? something : something\\_else | Favor the ternary operator(`?:`) over `if/then/else/end` constructs. |\nsome\\_method (some\\_arg) | some\\_method(some\\_arg) | Use `def` with parentheses when there are parameters. |\n\"This string contains #{'interpolation'}\" | 'This string contains interpolation' | Prefer single-quoted strings when you don't need string interpolation or special symbols. |\nmy\\_array.map do |x| x \\* 2 end.sum | my\\_array.map { |x| x \\* 2 }.sum | Prefer `{...}` over `do...end` for single-line blocks. Avoid `do...end` when chaining. |\nRuby Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in Ruby. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose Ruby as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/ruby-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Rust Interview Questions & Tips for Senior Engineers",
      "content": "Rust Interview Questions & Tips\nRust Interview Stats\nWe've hosted over 100k interviews on our platform. Rust was the language of choice in those interviews 0.2% of the time. Rust also had the highest success rates – engineers who chose Rust as their interview language passed their interviews 82% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nRust Idioms & Idiosyncrasies\nAs a modern and advanced language, Rust has a lot of complexity and a lot of still-evolving features. It’s an opinionated language that was designed and continues to be built by people who are morally opposed to hand waving. It’s a language and culture with a fair amount of computer science formality, especially with respect to the type systems.\nCandidates and interviewers may be more or less familiar with Rust’s type systems and other internals. The most important recommendation we can make is to make sure that if you’re using Rust-specific terms to describe what you’re doing that you truly understand what they mean. It’s not expected that you’ll know all the details for an interview – and an understanding of all formal definitions is required – but you should be careful not to overreach, and you definitely shouldn’t try to hand wave your way through any explanations, as you’ll find that the tolerance for hand waving among Rust interviewers is much lower than in other interview contexts.\nWith that in mind, here are some key, idiomatic concepts you’ll want to be very comfortable with:\n- Ownership, borrowing, and lifetimes. Rust's ownership model is central to the language and distinguishes it from other systems languages. Make sure you understand concepts like ownership, borrowing, lifetimes, and how they prevent data races and memory leaks.\n- Pattern matching. Rust provides powerful pattern matching capabilities through the match keyword. Be familiar with pattern matching syntax and its various applications, such as destructuring enums and matching on values.\n- Error handling. Rust emphasizes explicit error handling to prevent unchecked errors. Know the difference between Result and Option types and how to use Result's unwrap, expect, and match methods. Be aware of error propagation techniques, like the ? operator.\n- Collections and iterators. Rust provides a rich set of collection types and powerful iterator functionality. Be comfortable working with vectors, hash maps, and other collections, as well as using iterators to perform transformations, filters, and aggregations.\n- Traits and generics. Traits allow for code reuse and polymorphism in Rust. Understand how to define traits, implement them for custom types, and use generic functions and structs to write flexible and reusable code.\n- Unsafe Rust. While idiomatic Rust encourages safe programming, understanding unsafe Rust is crucial for dealing with low-level operations or interacting with external code. Know how to use unsafe blocks and functions responsibly, ensuring memory safety and avoiding undefined behavior.\n- Cargo and the Standard Library. Familiarize yourself with Cargo, Rust's build system and package manager. Understand how to create, manage, and publish projects using Cargo, as well as how to leverage the standard library's modules and functionality effectively.\nCommon Rust Interview Mistakes\nFirst and foremost, as with any language, you should NOT choose Rust as a way to show off if you don’t know it well. Make sure that you pick a language you are very comfortable with, have used at work recently, and have interviewed before.\nOutside of that, here are some things you should try to avoid when interviewing in Rust specifically.\n- Using a bunch of unsafe blocks. Sometimes that may be handy for temporarily working around a compilation problem or quickly accomplishing a task during an interview, but in general the people interviewing you in Rust are going to want to see you use the language's safety features.\n- Not doing proper error handling. In most cases, the compiler will stop you from not handling an unexpected value/result, but having default panics on almost every line is not idiomatic Rust. In other words, don’t do this:\nuse std::fs::File;\nuse std::io::Read;\nfn read\\_file\\_contents(file\\_path: &str) -> String {\nlet mut file = File::open(file\\_path).unwrap();\nlet mut contents = String::new();\nfile.read\\_to\\_string(&mut contents).unwrap();\ncontents\n}\nfn main() {\nlet file\\_path = \"nonexistent\\_file.txt\";\nlet contents = read\\_file\\_contents(file\\_path);\nprintln!(\"File contents: {}\", contents);\n}\n1use std::fs::File;\n2use std::io::Read;\n3\n4fn read\\_file\\_contents(file\\_path: &str) -> String {\n5 let mut file = File::open(file\\_path).unwrap();\n6 let mut contents = String::new();\n7 file.read\\_to\\_string(&mut contents).unwrap();\n8 contents\n9}\n10\n11fn main() {\n12 let file\\_path = \"nonexistent\\_file.txt\";\n13 let contents = read\\_file\\_contents(file\\_path);\n14 println!(\"File contents: {}\", contents);\n15}\n- Make sure you understand the core principles (e.g., memory allocation, memory safety) and the motivations for why the language is designed the way it is, rather than focusing on the latest Rust nightly feature. This is a common failure mode for people who are coming from higher-level languages.\n- Understand the borrow checker. If you don’t know what the borrow checker is and what kind of problems it’s trying to prevent, you’re going to have trouble building rapport with some Rust interviewers.\n- Use crates that you’re familiar with, even if your interviewer suggests a specific one. For some interview questions, you may find that using a particular crate will make things a lot easier, and that’s fine as long as you’re familiar with it. You might run into a situation, however, where your interviewer proposes that you use a crate that you aren’t familiar with. For example, there are different crates for ORMs, async.io frameworks, and web frameworks – multiple ways of doing the same thing– so it’s entirely possible that you’re more familiar with one and your interviewer is more familiar with another. It’s better to demonstrate mastery over something that you know well rather than coding on your back foot.\nHow to Demonstrate Rust Expertise in Interviews\nTo impress your interviewer, go deep on some of the core ideas behind the Rust type system and the core ideas on the borrow checker and the way it does Rust memory management and why.\nMore senior engineers who are already working in Rust daily and are involved in the community can demonstrate knowledge of the latest Rust language proposals and advanced nightly features. Keep in mind, however, that this demonstration of mastery is only credible if it takes place on top of a strong foundation of fundamentals that you’ve already established earlier in the interview. Otherwise you might come off like you’re hand waving… which we sternly talked about in the beginning.\nRust Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in Rust. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose Rust as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/rust-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Swift Interview Questions & Tips for Senior Engineers",
      "content": "Swift Interview Questions & Tips\nSwift Interview Stats\nWe've hosted over 100k interviews on our platform. Swift was the language of choice in those interviews 1% of the time, and engineers who interviewed in Swift passed their interviews 38% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nSwift Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in Swift. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose Swift as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/swift-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "System Design Interview Questions & Tips for Senior Engineers",
      "content": "About System Design Interviews\nIf you’re a mid-level or senior-level software engineer, regardless of where you interview, you will get asked at least a few system design questions. Most companies will ask system design questions during the onsite, but some may include a system design component in their technical phone screen (more likely if they’re a startup rather than a FAANG).\nSystem design interview questions fall, by and large, into the following 12 categories:\n- APIs\n- Databases (SQL vs NoSQL)\n- Scaling\n- CAP theorem\n- Web authentication and basic security\n- Load balancers\n- Caching\n- Message queues\n- Indexing\n- Failovers\n- Replication\n- Consistent hashing\nThat’s a long list, and system design is a really broad topic. Rather than trying to summarize everything you need to know about these types of interviews in a few paragraphs (an impossible task), we’ve written the best guide to system design interviews out there.\nBy the way, many people believe that in order to pass a FAANG system design interview, you have to have professional experience with distributed systems. We’ll show you that that’s categorically false, and that with the right preparation, you don’t need to fall into the catch-22 of having to have worked at a FAANG in order to get a job at a FAANG.\nCheck out our in-depth guide to system design, developed by the best interviewers in the industry, directly from their experience in thousands of technical interviews:\nSystem Design Interview Replays\nSystem Design Interview Questions and Solutions\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/system-design-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Sorting Interview Questions & Tips for Senior Engineers",
      "content": "Sorting Interview Questions & Tips\nWhat is Sorting?\nSorting, in computer science, is the process of arranging a collection of data in a specific order. This operation is fundamental to many practical scenarios, from ordering a list of contacts by name in your phone's contact list to sorting posts by date on a social media platform. Search engines, databases, and e-commerce websites extensively utilize sorting algorithms to provide faster and more efficient services.\nFrom a coding interview perspective, a strong understanding of sorting algorithms demonstrates your problem-solving abilities, knowledge of time and space complexity, and ability to select the most efficient algorithm for a given situation.\nAt its core, sorting involves taking input data and writing a program that outputs it in a particular order. The input could be an array of numbers, a list of strings, or even complex data structures. The goal is to output this data sorted according to a specific rule, like ascending order for numbers or lexicographically for strings.\nTypes\nSorting algorithms can be broadly divided into two categories: comparison sorts and non-comparison sorts. Comparison sorts work by comparing elements and deciding their order based on the result; examples are Quick Sort, Merge Sort, and Heap Sort. On the other hand, non-comparison sorts do not make decisions based on comparing elements but on distributing the individual items (e.g., Counting Sort and Radix Sort).\nWhile you should know all common sorting algorithms, from a coding interview perspective, you'll see quick sort, merge sort, and heap sort more often than others. Please note that while it's uncommon to be asked to implement these algorithms from scratch in a coding interview, the principles underlying these algorithms often inform the solutions to a variety of complex problems. Therefore, we'll focus on these three algorithms in this section.\nQuick Sort\nQuick Sort is a \"divide and conquer\" sorting algorithm known for its average-case performance. It selects a 'pivot' element from the array and partitions the other elements into two sub-arrays based on whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted.\nQuick Sort in Action (Credit - Wikipedia)\nTime Complexity: The average and best case is O(n log n)\n, but the worst case is O(n^2)\n, when the smallest or largest element is always chosen as the pivot.\nSpace Complexity: O(log n)\ndue to the stack space during recursive calls.\nLet's see its implementation now:\ndef quick\\_sort(arr):\nquick\\_sort\\_helper(arr, 0, len(arr) - 1)\ndef quick\\_sort\\_helper(arr, start, end):\nif start >= end:\nreturn\npivot\\_index = partition(arr, start, end)\nquick\\_sort\\_helper(arr, start, pivot\\_index - 1)\nquick\\_sort\\_helper(arr, pivot\\_index + 1, end)\ndef partition(arr, start, end):\npivot = arr[end]\ni = start\nfor j in range(start, end):\nif arr[j] < pivot:\narr[i], arr[j] = arr[j], arr[i]\ni += 1\narr[i], arr[end] = arr[end], arr[i]\nreturn i\n1def quick\\_sort(arr):\n2 quick\\_sort\\_helper(arr, 0, len(arr) - 1)\n3\n4def quick\\_sort\\_helper(arr, start, end):\n5 if start >= end:\n6 return\n7\n8 pivot\\_index = partition(arr, start, end)\n9 quick\\_sort\\_helper(arr, start, pivot\\_index - 1)\n10 quick\\_sort\\_helper(arr, pivot\\_index + 1, end)\n11\n12def partition(arr, start, end):\n13 pivot = arr[end]\n14 i = start\n15 for j in range(start, end):\n16 if arr[j] < pivot:\n17 arr[i], arr[j] = arr[j], arr[i]\n18 i += 1\n19 arr[i], arr[end] = arr[end], arr[i]\n20 return i\n21\nIn the provided Python implementation of Quick Sort, the function quick\\_sort\\_helper\nserves as the recursive driver. It divides the array around a pivot, selected as the last element within a particular segment, through the partition\nfunction. All elements less than the pivot are moved to its left, and those greater to its right, correctly positioning the pivot within the sorted array. The quick\\_sort\\_helper\nfunction then recursively applies this process to the sections on either side of the pivot.\nMerge Sort\nMerge Sort is another \"divide and conquer\" sorting algorithm. It divides the unsorted list into N sublists, each containing one element (a list of one element is considered sorted). Then, it repeatedly merges these sublists to produce new sorted sublists until only one sublist remains.\nMerge Sort in Action (Credit - Wikipedia)\nTime Complexity: Merge Sort performs consistently well with a time complexity of O(n log n)\nin all cases.\nSpace Complexity: O(n)\n, as it requires auxiliary space to store the temporary arrays.\nLet's look at some example code:\ndef merge\\_sort(arr):\n# base case\nif len(arr) <= 1:\nreturn arr\n# divide the array into two halves\nmid = len(arr) // 2\nleft = arr[:mid]\nright = arr[mid:]\n# sort each half\nreturn merge(merge\\_sort(left), merge\\_sort(right))\ndef merge(left, right):\nresult = []\ni = j = 0\n# merge the two arrays together\nwhile i < len(left) and j < len(right):\nif left[i] < right[j]:\nresult.append(left[i])\ni += 1\nelse:\nresult.append(right[j])\nj += 1\n# add any remaining elements\nresult.extend(left[i:])\nresult.extend(right[j:])\nreturn result\n1def merge\\_sort(arr):\n2 # base case\n3 if len(arr) <= 1:\n4 return arr\n5\n6 # divide the array into two halves\n7 mid = len(arr) // 2\n8 left = arr[:mid]\n9 right = arr[mid:]\n10\n11 # sort each half\n12 return merge(merge\\_sort(left), merge\\_sort(right))\n13\n14def merge(left, right):\n15 result = []\n16 i = j = 0\n17\n18 # merge the two arrays together\n19 while i < len(left) and j < len(right):\n20 if left[i] < right[j]:\n21 result.append(left[i])\n22 i += 1\n23 else:\n24 result.append(right[j])\n25 j += 1\n26\n27 # add any remaining elements\n28 result.extend(left[i:])\n29 result.extend(right[j:])\n30 return result\nHere, the function merge\\_sort\nacts as the primary function, dividing the array into two halves recursively until a base case of a single element array is achieved.\nOnce the array is broken down, the merge function combines these halves back together in sorted order. The merge function initiates by comparing elements at the start of the left and right arrays, appending the smaller one to the result\narray. This process continues until one array is exhausted, after which any remaining elements from the non-empty array are appended to the result\n.\nMerge Sort is particularly effective for sorting linked lists. This is because linked lists have slow access times but efficient insertion and deletion operations. Merge Sort is very efficient with sequential access data like linked lists, and it doesn't require random access to data.\nHeap Sort\nHeap Sort uses a binary heap data structure to sort elements. A binary heap is a complete binary tree, which can be either a max heap or a min-heap. In a max heap, the parent node is always larger than or equal to its children, while in a min-heap, the parent node is less than or equal to its children. The binary heap data structure lets us quickly access the largest (max heap) or smallest (min-heap) element.\nHeap Sort first builds a max heap from the input data, then continuously removes the maximum element from the heap and places it at the end of the sorted array.\nHeap Sort in Action (Credit - Wikipedia)\nTime Complexity: Heap Sort performs consistently with a time complexity of O(n log n)\nin all cases.\nSpace Complexity: O(1)\n, as it does not require extra space beyond what is needed to store the input.\nThe following code shows how to implement Heap Sort:\nimport heapq\ndef heap\\_sort(arr):\nheapq.heapify(arr)\nsorted\\_arr = []\nwhile arr:\nsorted\\_arr.append(heapq.heappop(arr))\nreturn sorted\\_arr\n# Note\n# We use Python's built-in heapq module to implement Heap Sort. In an interview,\n# you can ask the interviewer if you can use this module or if you need to\n# implement the heap data structure yourself.\n1import heapq\n2\n3def heap\\_sort(arr):\n4 heapq.heapify(arr)\n5 sorted\\_arr = []\n6 while arr:\n7 sorted\\_arr.append(heapq.heappop(arr))\n8 return sorted\\_arr\n9\n10\n11# Note\n12# We use Python's built-in heapq module to implement Heap Sort. In an interview,\n13# you can ask the interviewer if you can use this module or if you need to\n14# implement the heap data structure yourself.\n15\nStability of Sorting Algorithms\nImagine you're at a library, organizing books on a shelf. You might first arrange them alphabetically by the author's last name. But then, you notice several books by the same author. To make it easier for readers, you decide to sort these books by publication year. However, you wouldn't want this secondary sort to mix up the primary alphabetical order you've already established. This is the essence of a \"stable\" sort in computer science.\nIn more technical terms, a sorting algorithm is \"stable\" if it maintains the original order of equal elements in the sorted output. Think of it like sorting a deck of cards. Let's say you first sort them by number. Next, you decide to sort by suit—clubs, diamonds, hearts, and spades. A stable sort ensures that the '2' of clubs, diamonds, hearts, and spades maintain their original order even after the suit sort.\nThis characteristic is not just a theoretical concept but has practical implications in various real-world scenarios. Consider sorting entries in a database—preserving the original order of entries with the same key can be critical.\nAs a developer, you'll encounter both stable and unstable sorting algorithms. For example, Merge Sort, Insertion Sort, and Bubble Sort are stable sorting algorithms preserving the original order. In contrast, Heap Sort, Quick Sort, and Selection Sort are not—they might mix up the original order of equal elements. Therefore, understanding the stability of a sorting algorithm is crucial when choosing the right one for your task.\nIn-Place Sorting Algorithms\nAn in-place sorting algorithm sorts the input data within the data structure containing it, using a fixed, small amount of extra space. This \"extra space\" is typically not dependent on the size of the input; hence these algorithms have a space complexity of O(1)\n. These algorithms are beneficial when memory usage is a concern, as they don't require additional storage proportional to the input size.\nQuick Sort, Heap Sort, Insertion Sort, and Bubble Sort are examples of in-place sorting algorithms, while Merge Sort, Counting Sort, Radix Sort, and Bucket Sort require additional space, so they are not in-place.\nCheat Sheet\n| Algorithm | Best Case | Average Case | Worst Case | Space Complexity | When to Use |\n|---|---|---|---|---|---|\n| Quick Sort | O(n log n) | O(n log n) | O(n^2) | O(log n) | When average case performance is important |\n| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) | When stability and worst-case performance are more important than memory usage |\n| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) | When memory is a concern, and worst-case performance is important |\n| Insertion Sort | O(n) | O(n^2) | O(n^2) | O(1) | When the input is small or nearly sorted |\n| Bubble Sort | O(n) | O(n^2) | O(n^2) | O(1) | When the input is small or nearly sorted |\n| Selection Sort | O(n^2) | O(n^2) | O(n^2) | O(1) | When memory is a concern, and the input is small |\n| Counting Sort | O(n + k) | O(n + k) | O(n + k) | O(n + k) | When the range of potential items (k) is known and not too large |\nWhen to Use Sorting in Interviews\nIn coding interviews, you may not often be asked to implement a sorting algorithm from scratch, but understanding the principles behind these algorithms can lead to an efficient solution. Moreover, sorting algorithms are often used as subroutines in other algorithms, such as searching algorithms that require a sorted list as input. In such cases, it's generally accepted that you can leverage existing libraries for this. However, understanding when and how to use sorting effectively within your solutions is a critical skill that interviewers will be looking for.\nPartitioning Problems\nIn a partitioning problem, you are typically asked to rearrange an array so that all array elements satisfying a specific condition are grouped together. The pivot element serves as a boundary for this segregation. Problems that ask you to segregate even and odd numbers, separate negative and positive numbers, or move all zeros to the end of an array fall into this category. Partitioning is a fundamental operation in Quick Sort and can be used to solve these types of problems efficiently.\nHere's an example of a problem: Given an array, move all the negative elements to one side of the array.\nTo solve this problem, we use the partitioning logic from quick sort:\ndef rearrange\\_elements(arr):\npivot = 0 # partition around 0 for positive/negative segregation\ni = -1\nfor j in range(len(arr)):\nif arr[j] < pivot:\ni += 1\narr[i], arr[j] = arr[j], arr[i]\nreturn arr\nprint(rearrange\\_elements([-1, 2, -3, 4, 5, -7]))\n# Output: [-1, -3, -7, 4, 5, 2]\n1def rearrange\\_elements(arr):\n2 pivot = 0 # partition around 0 for positive/negative segregation\n3 i = -1\n4 for j in range(len(arr)):\n5 if arr[j] < pivot:\n6 i += 1\n7 arr[i], arr[j] = arr[j], arr[i]\n8 return arr\n9\n10print(rearrange\\_elements([-1, 2, -3, 4, 5, -7]))\n11# Output: [-1, -3, -7, 4, 5, 2]\nIn the code above, we initialize i\nas -1 and iterate over the array. Whenever we find a negative element, we increment i\nand swap the current element with the element at index i\n. This pushes all negative elements towards the front of the array (or left side if visualized as a line).\nUnderstanding partitioning and how it segregates data based on a condition helps solve a broad range of problems, and it is a typical pattern in many coding interview questions.\nSelection Problems\nSelection problems often involve finding the k\nth smallest or largest element in an array. These problems can take advantage of the selection algorithm used in Quick Sort or Heap Sort. Both methods have their strengths and are suited to different situations. Understanding the difference can lead to more efficient solutions and exhibit your algorithmic knowledge in interviews.\nFor instance, let's consider the problem of finding the k\nth largest element in an unsorted array.\nOne way to solve this problem is to sort the array and then index the k\nth largest element. While this method works, it can be inefficient, especially with large arrays, as the time complexity of sorting is O(n log n)\n.\ndef kth\\_largest(nums, k):\nnums.sort(reverse=True)\nreturn nums[k-1]\n1def kth\\_largest(nums, k):\n2 nums.sort(reverse=True)\n3 return nums[k-1]\n4\nHeap Based Solution\nA more optimal solution than naive sorting involves using a min-heap of size k\n. This reduces the time complexity to O(n log k)\n, which is better when k\nis significantly smaller than n\n.\nimport heapq\ndef kth\\_largest(nums, k):\nheap = []\nfor num in nums:\nheapq.heappush(heap, num)\nif len(heap) > k:\nheapq.heappop(heap)\nreturn heapq.heappop(heap)\n1import heapq\n2\n3def kth\\_largest(nums, k):\n4 heap = []\n5 for num in nums:\n6 heapq.heappush(heap, num)\n7 if len(heap) > k:\n8 heapq.heappop(heap)\n9 return heapq.heappop(heap)\n10\nIn this code, we're maintaining a min heap of size k\n, where the root of the heap is the k\nth largest element so far. We iterate over each element in the array, and for each element, we add it to the heap and remove the smallest element if the heap size exceeds k\n. By the end of the iteration, the root of the heap is our desired k\nth largest element.\nQuickSelect Based Solution\nThe QuickSelect algorithm is another method that can be used to solve selection problems more efficiently. This algorithm, a derivative of the Quick Sort algorithm, uses partitioning to find the k\nth smallest or largest element in an unsorted list.\nHere's a Python implementation of the QuickSelect algorithm to find the k\nth largest element:\ndef partition(nums, low, high):\n# Choose rightmost as pivot\npivot = nums[high]\ni = low\nfor j in range(low, high)\n# Partition array\nif nums[j] <= pivot:\nnums[i], nums[j] = nums[j], nums[i]\ni += 1\n# Finalize pivot position\nnums[i], nums[high] = nums[high], nums[i]\nreturn i\ndef quick\\_select(nums, low, high, k):\nif low == high:\n# Single element base case\nreturn nums[low]\n# Find pivot index\npivot\\_index = partition(nums, low, high)\nif k == pivot\\_index:\n# Pivot matches k\nreturn nums[k]\nelif k < pivot\\_index:\n# Recurse on left partition\nreturn quick\\_select(nums, low, pivot\\_index - 1, k)\nelse:\n# Recurse on right partition\nreturn quick\\_select(nums, pivot\\_index + 1, high, k)\ndef kth\\_largest(nums, k):\n# Translate kth largest to kth smallest\nreturn quick\\_select(nums, 0, len(nums) - 1, len(nums) - k)\n1def partition(nums, low, high):\n2 # Choose rightmost as pivot\n3 pivot = nums[high]\n4 i = low\n5 for j in range(low, high)\n6 # Partition array\n7 if nums[j] <= pivot:\n8 nums[i], nums[j] = nums[j], nums[i]\n9 i += 1\n10\n11 # Finalize pivot position\n12 nums[i], nums[high] = nums[high], nums[i]\n13 return i\n14\n15def quick\\_select(nums, low, high, k):\n16 if low == high:\n17 # Single element base case\n18 return nums[low]\n19\n20 # Find pivot index\n21 pivot\\_index = partition(nums, low, high)\n22 if k == pivot\\_index:\n23 # Pivot matches k\n24 return nums[k]\n25 elif k < pivot\\_index:\n26 # Recurse on left partition\n27 return quick\\_select(nums, low, pivot\\_index - 1, k)\n28 else:\n29 # Recurse on right partition\n30 return quick\\_select(nums, pivot\\_index + 1, high, k)\n31\n32def kth\\_largest(nums, k):\n33 # Translate kth largest to kth smallest\n34 return quick\\_select(nums, 0, len(nums) - 1, len(nums) - k)\n35\nThe QuickSelect algorithm can solve the problem in O(n)\ntime on average, although the worst-case scenario can be O(n^2)\nwhen the pivot is the smallest or largest element in the list. However, the worst case is highly unlikely if we randomly select a pivot.\nComparing this with the heap-based solution, the heap-based solution has a time complexity of O(n log k)\n. The heap-based solution could be more efficient for very large n\nand small k\n. However, if k\nis relatively close to n\n, QuickSelect's O(n)\naverage time complexity can be more efficient. Therefore, it's essential to understand these time complexities and the nature of the problem to select the most efficient solution in a coding interview.\nYou can see a detailed discussion on how to find k\nth smallest element here.\nMerge Based Problems\nMerge-based problems often involve performing operations on sorted arrays or lists. These problems can take advantage of the merging step in MergeSort\n. By understanding the merge operation, you can solve a range of problems that involve merging more efficiently.\nFor instance, a classic problem is \"Merge Intervals\". Given a collection of intervals, merge any overlapping intervals.\nA naive approach to this problem would involve comparing each interval with every other interval, leading to a time complexity of O(n^2)\n.\nHowever, by sorting the intervals and then merging, we can solve this problem in O(n log n)\ntime.\nHere's an example solution in Python:\ndef merge\\_intervals(intervals):\nif not intervals:\nreturn []\n# sort the intervals based on the start time\nintervals.sort(key=lambda x: x[0])\nmerged = [intervals[0]]\nfor current in intervals:\n# compare the current interval with the last merged interval\nlast = merged[-1]\nif current[0] <= last[1]:\n# if they overlap, merge them by updating the end of the last interval\nlast[1] = max(last[1], current[1])\nelse:\n# if they do not overlap, add the current interval to the merged list\nmerged.append(current)\nreturn merged\n1def merge\\_intervals(intervals):\n2 if not intervals:\n3 return []\n4 # sort the intervals based on the start time\n5 intervals.sort(key=lambda x: x[0])\n6 merged = [intervals[0]]\n7 for current in intervals:\n8 # compare the current interval with the last merged interval\n9 last = merged[-1]\n10 if current[0] <= last[1]:\n11 # if they overlap, merge them by updating the end of the last interval\n12 last[1] = max(last[1], current[1])\n13 else:\n14 # if they do not overlap, add the current interval to the merged list\n15 merged.append(current)\n16 return merged\n17\nWe first sort the intervals in the above code based on their start time. We then iterate over the sorted intervals and merge them if they overlap or add them to the result list if they do not.\nUnderstanding merge operations helps deal with problems involving sorted arrays or lists and demonstrates your ability to leverage sorting techniques to simplify complex problems during coding interviews.\nUsing Custom Comparators\nBuilding upon the concept in the last section, a critical aspect that plays an integral role in various sorting-related problems, especially in languages that support it, is custom comparators. A custom comparator is a function that we provide to the sorting function, dictating the sorting order beyond natural ordering.\nWe used a custom comparator in the merge intervals problem we discussed: key=lambda x: x[0]\n. The key\nfunction provided to the sort method determines the attribute upon which the list is sorted. Here, we instruct Python to sort the intervals\narray by the first element of each interval. This allows us to sort the intervals by their start times, enabling us to handle overlaps more efficiently.\nThe sort\nmethod uses the return value of the comparator function to decide the order of elements. If for two intervals a\nand b\n, a[0]\n(the start time of a\n) is less than b[0]\n(the start time of b\n), a\nwill come before b\nin the sorted list. Conversely, if a[0]\nis greater than b[0]\n, a\nwill come after b\nin the sorted list. If both are equal, then the original order is preserved because Python's sort is stable. If we want to sort in descending order, we can simply reverse the comparison: key=lambda x: -x[0]\n.\nUnderstanding and correctly using custom comparators shows your grasp on sorting algorithms and indicates your ability to leverage language-specific features to solve complex problems.\nBelow, we show an example code of how to use custom comparators with Python, Java, and JavaScript.\n# Sorting an array of tuples based on the second element\narr = [(1, 2), (3, 1), (2, 3)]\n# We use the `key` argument in the `sort` method to provide a custom comparator\narr.sort(key=lambda x: x[1])\nprint(arr) # Output: [(3, 1), (1, 2), (2, 3)]\n1# Sorting an array of tuples based on the second element\n2arr = [(1, 2), (3, 1), (2, 3)]\n3# We use the `key` argument in the `sort` method to provide a custom comparator\n4arr.sort(key=lambda x: x[1])\n5print(arr) # Output: [(3, 1), (1, 2), (2, 3)]\nExternal Sorting\nExternal Sorting is a class of algorithms that deal with massive amounts of data that cannot fit entirely into a computer's memory. The idea is to divide the data into chunks that can fit into memory, sort these chunks separately, and then merge them.\nAn instance of a problem that might require external sorting is when you're given a massive log file (several gigabytes) and asked to sort the entries by timestamp. Trying to load the entire file into memory would likely be impractical, if not impossible, given the limitations of your computer's memory.\nA typical approach to this problem would be to use a divide-and-conquer strategy similar to Merge Sort:\n- Divide the log file into smaller chunks that fit into memory.\n- Sort each chunk separately.\n- Merge the sorted chunks.\nThis merging step can be accomplished using a priority queue (min-heap), which always pops the smallest element. The priority queue should be initialized with the smallest element from each chunk. Each time an element is popped from the priority queue, we push the next element from the same chunk into the queue.\nWhile it's rare to ask candidates to write a complete external sorting algorithm during an interview due to its complexity, the concept could come up in system design interviews or discussions about handling large data sets. Understanding this concept would demonstrate your knowledge of handling and processing large data.\n(Note: Actual implementation of an external sort in a coding interview is rare, and most languages or databases offer built-in functionality for handling this sort of problem. However, it's important to understand the principles behind it.)\nEnhancing the Efficiency of Solutions\nIn many coding interview problems, the key to creating an efficient solution often lies in pre-processing the input data. Sorting is one of the most common pre-processing steps that can significantly enhance the efficiency of your solution. This is because operations like searching for elements, finding minimum or maximum elements, and comparing elements can be done much faster on sorted data.\nConsider a problem where you are asked to find a pair of elements in an array that sum up to a target value. A brute force solution would involve a nested loop, comparing each element with every other element, leading to a time complexity of O(n^2)\n.\nHowever, by sorting the array first, we can use a two-pointer approach where one pointer starts from the beginning and the other starts from the end. We then move the pointers inward until they meet, effectively searching the array in O(n)\ntime. This reduces the total time complexity to O(n log n)\nfor sorting plus O(n)\nfor searching, significantly improving the brute force approach.\ndef two\\_sum(nums, target):\nnums.sort()\nleft, right = 0, len(nums) - 1\nwhile left < right:\ncurrent\\_sum = nums[left] + nums[right]\nif current\\_sum == target:\nreturn [nums[left], nums[right]]\nelif current\\_sum < target:\nleft += 1\nelse:\nright -= 1\nreturn []\nprint(two\\_sum([3,5,2,8,1], 10)) # Output: [2, 8]\n1def two\\_sum(nums, target):\n2 nums.sort()\n3 left, right = 0, len(nums) - 1\n4 while left < right:\n5 current\\_sum = nums[left] + nums[right]\n6 if current\\_sum == target:\n7 return [nums[left], nums[right]]\n8 elif current\\_sum < target:\n9 left += 1\n10 else:\n11 right -= 1\n12 return []\n13\n14print(two\\_sum([3,5,2,8,1], 10)) # Output: [2, 8]\nIn this example, sorting the array first allows us to search for the pair in linear time, significantly improving the efficiency of our solution.\nAnother scenario where sorting improves efficiency is when binary search is applied. Sorting the data allows binary search to work, reducing search time from O(n)\nin a linear search to O(log n)\n. You can check our detailed guide on binary search for a more in-depth understanding and application in interview scenarios.\nThe key takeaway here is that understanding how sorting can be used to enhance the efficiency of your solutions will enable you to solve problems more effectively in coding interviews.\nChecking Anagram Strings\nAnagram problems are a common subset of string manipulation problems that often come up in coding interviews. An anagram is a word, phrase, or name formed by rearranging the letters of another, such as \"cinema\", formed from \"iceman\". In the context of coding interviews, anagrams are usually represented as strings of characters.\nSorting can be a highly effective strategy for solving anagram problems because when two strings are anagrams of each other, their sorted forms are identical.\nCommon Mistakes in Interviews Featuring Sorting\nOverlooking the Time Complexity of Sorting\nEven if an approach seems to give you the correct answer, it's crucial to consider its efficiency, particularly in terms of time complexity. A common pitfall is overlooking the added time complexity of sorting when used in a solution.\nFor instance, consider the two-sum problem discussed earlier, where we find a pair in an array that adds up to a particular target value. In a previously discussed approach, we used sorting and two-pointers. This approach does yield correct results; however, the sorting step adds significant time complexity.\nThe sort operation itself has a time complexity of O(n log n)\n, which might overshadow the subsequent two-pointer traversal of the array that only takes O(n)\ntime. If n\nis large, this increased time complexity due to sorting could significantly affect the performance of your solution.\nWhile the sort and two-pointer method is valid, a more time-efficient solution exists. Using a hash map to track the elements you've encountered as you traverse the array, you can check if the complement to the target value has already been seen in constant time. This alternate approach offers a linear time complexity of O(n)\n, sidestepping the need for sorting and its associated time cost. This approach is discussed in detail in our two-sum problem solution.\nThis example illustrates why it's essential to always consider the impact of sorting on your solution's time complexity. In coding interviews, identifying and articulating these trade-offs is a valuable skill, demonstrating your awareness of performance considerations and your ability to optimize your solutions.\nNot Using Quick Select When Appropriate\nAs explained earlier, Quick Select is a selection algorithm to find the kth\nsmallest element in an unordered list. It is an in-place variation of the Quick Sort algorithm. Quick Select and its variants are useful for problems where we need to find an order statistic (kth\nsmallest or largest element) in an array.\nOne common mistake candidates make is resorting to sorting the entire array, which takes O(n log n)\nrunning time when asked to find an order statistic. Although sorting can make the problem easier to conceptualize, it is often not the most efficient solution. In contrast, Quick Select can find the kth\nsmallest or largest element in O(n)\naverage time complexity, which is more efficient than sorting for large datasets.\nIf you use Priority Queue or a Max Heap to find the kth\nsmallest element, the time complexity would be O(n log k)\n, which is better than sorting but still not as efficient as Quick Select.\nNot Using Heap Sort When Appropriate\nOne mistake that candidates often make is overlooking the utility of Heap Sort in problem scenarios involving 'Top k' elements of an array. For example, if you are asked to find the 'k' largest elements from an unsorted array, a sorting algorithm like Quick Sort or Merge Sort would take O(n log n)\ntime. However, if you use a min heap of size k\nto keep track of the largest elements encountered so far, you can solve the problem in O(n log k)\ntime, which is more efficient for large n\nand k\n.\nThe choice of sorting algorithm can significantly impact the efficiency of your solution. Let's discuss some scenarios where one algorithm may be preferred over others.\nNot Realizing the Patterns Emerging from a Sorted Array\nAnother common mistake candidates make is not recognizing patterns that arise from having a sorted array. These patterns, when identified, can often simplify the problem significantly or make seemingly complex problems more manageable.\nOne such pattern is the two-pointer technique, which becomes particularly useful when dealing with sorted arrays. For instance, in the \"two-sum\" problem described in the earlier section, two pointers can find the answer in linear time, making the process much more efficient than other approaches.\nAnother pattern emerges as binary search, a standard tool for efficiently finding an element or determining the insertion position for a new element in a sorted array. Failing to recognize the opportunity to use binary search can result in a significant loss in efficiency. Remembering these patterns when dealing with sorted data is essential, as they can significantly simplify the problem-solving process and increase efficiency.\nNot Considering Counting Sort for Linear Time Complexity\nCounting Sort is a non-comparison-based sorting algorithm that can sort elements in linear time given specific conditions. The efficiency of Counting Sort is due to its unique approach, where it does not compare elements but counts the number of distinct elements and their occurrences. This approach allows it to sort the array in O(n)\ntime, which is significantly faster than comparison-based sorting algorithms.\nThe key to leveraging Counting Sort is recognizing the conditions where it can be applied. It works best when the range of input data (k\n) is not significantly greater than the number of objects (n\n) being sorted. These conditions are often met in problems dealing with small integers, characters, or other discrete types.\nHowever, one common mistake candidates make during interviews is not considering Counting Sort when the problem fits its use case. They often resort to more common but less efficient comparison-based sorting algorithms by overlooking the opportunity to use Counting Sort.\nFor example, if you have an array of positive integers where the maximum value is not significantly larger than the array's length, Counting Sort could provide a more efficient solution than algorithms like Quick Sort or Merge Sort.\nRemember, Counting Sort has its limitations—it's not a comparison-based sort, it's not suitable for sorting an extensive range of numbers, and it's not an in-place algorithm. Despite these limitations, when the problem conditions fit its use case, Counting Sort can be an incredibly efficient tool, providing a linear time solution.\nWhat to Say in Interviews to Show Mastery Over Sorting\nUnderstand and Communicate the Complexity of Native Sorting Algorithms\nMost programming languages have built-in sorting algorithms, each with unique specifications. Knowledge of these is essential, especially in an interview setting where understanding these subtleties can reflect your command over the language and its features.\nLet's consider the default sorting algorithm for three widely used programming languages: Python, Java, and JavaScript:\nPython's Built-in Sorting Algorithm (Tim Sort)\nPython uses Tim Sort, a hybrid, adaptive sorting algorithm derived from Merge Sort and Insertion Sort. Tim Sort excels in handling real-world data, and Python's sort()\nfunction is a practical example of this algorithm. The time complexity is O(n log n)\nin the worst-case scenario, and it is a stable sorting algorithm, which means it maintains the relative order of records with equal keys.\nIf you are feeling curious, you can see a discussion on this topic in Python's source code.\nJava's Built-in Sorting Algorithm (Dual-Pivot Quick Sort & Tim Sort)\nJava's Arrays.sort()\nmethod uses Dual-Pivot Quicksort for primitive data types, which provides O(n log n)\nperformance on many data sets that cause other quicksorts to degrade to quadratic performance. A modified version of Tim Sort is used for objects, which also provides O(n log n)\nperformance and is stable.\nJavaScript's Built-in Sorting Algorithm\nUnlike Python and Java, JavaScript's Array.prototype.sort()\ndoes not specify a particular sorting algorithm to use. Its performance and exact nature can vary across different browsers. Still, most modern browsers, like Chrome and Firefox, use a variant of Tim Sort or Quick Sort, both of which have an average time complexity of O(n log n)\n.\nC++'s Built-in Sorting Algorithm (IntroSort)\nC++'s std::sort()\nuses IntroSort, a hybrid sorting algorithm derived from Quick Sort and Heap Sort. IntroSort begins with Quick Sort and switches to Heap Sort when the recursion depth exceeds a level based on the number of elements being sorted. This makes it a fast sorting algorithm, even on large collections and worst-case scenarios. std::sort()\nhas an average and worst-case time complexity of O(n log n)\n. Note that this sorting is not stable, but C++ provides a stable sorting function, std::stable\\_sort()\n, which has a worst-case time complexity of O(n log ^ 2n)\n.\nIn a coding interview, if you use a built-in sorting function, it's worth mentioning to your interviewer that you understand the underlying algorithm and its time complexity. Confirming whether using built-in functions is okay shows your understanding of the language and your care for providing the most optimal solution.\nAsk the Right Questions\nIn a coding interview, you are expected to solve the problem and ask the right questions to understand the problem's constraints and requirements thoroughly. This step is crucial when sorting is involved in the problem, as different sorting algorithms have different efficiencies depending on the context. In such cases, you might want to consider asking the following:\nWhat is the size of the input data? This could potentially affect the choice of sorting algorithm, as some algorithms are more efficient with smaller datasets, while others are designed for larger ones.\nWhat is the nature of the input data? Is the data mostly sorted or random? Does the data contain many duplicates? Algorithms like Timsort can take advantage of already sorted data, while algorithms like Quick Sort can struggle with many duplicates.\nWhat are the memory constraints? If memory is limited, an in-place sorting algorithm like Quick Sort could be a better choice over Merge Sort, which requires O(n) additional space.\nIs stability required? If yes, you might want to opt for a stable sorting algorithm like Merge Sort or Tim sort over Quick Sort or Heap Sort.\nWhat are the time complexity requirements? If the problem requires a solution with a specific time complexity, it could affect the choice of the sorting algorithm. For example, Radix Sort or Counting Sort might be appropriate for problems requiring linear time complexity and the input data fitting their constraints.\nRemember, asking these questions helps you select the most efficient algorithm and shows the interviewer that you understand the impact of different sorting algorithms on a problem's solution. Be sure to vocalize your thought process as you work through these questions and why you chose a specific sorting algorithm based on your answers.\nDiscussing Time Complexities of Different Sorting Algorithms\nWhen you've identified potential sorting algorithms that could be applied, make it a point to discuss their time complexities with your interviewer. This dialogue isn't just about stating the time complexity of a particular algorithm. It's about understanding and communicating how these complexities would impact the overall performance of your solution, given the specific constraints and requirements of the problem at hand.\nFor instance, it's common knowledge that Quick Sort, Merge Sort, and Heap Sort have an average time complexity of O(n log n)\n. However, how would this play out, given the size and nature of the input data? Or, could non-comparison sorts, which can achieve linear time complexity under certain conditions, be a viable option? If so, are there any trade-offs, such as memory usage, to be considered?\nBy discussing these complexities and potential trade-offs, you demonstrate a breadth of understanding of sorting algorithms, indicating your ability to make informed decisions based on the specific problem constraints. It showcases your ability to think critically about algorithmic efficiency, a quality highly valued in a software engineer.\nLeverage Non-Comparison Sorts When Appropriate\nNon-comparison sorts, such as Counting Sort, Radix Sort, and Bucket Sort, can be powerful tools in your algorithmic toolbox, mainly when applied to achieve linear time complexity under the right circumstances. However, these algorithms are only sometimes applicable, so it's essential to understand when to use them and when not to.\nCounting Sort\nCounting sort is an integer sorting algorithm that counts the number of objects with distinct key values. This sort works best when the range of potential items is small relative to the number of items.\nFor example, if you have a large number of integers between 1 and 10, counting sort could be very efficient. However, if the integers range from 1 to 1,000,000, counting sort could be infeasible due to memory constraints.\nRadix Sort\nRadix sort operates by sorting numbers digit by digit, from the least significant to the most significant. This sorting algorithm is effective when the numbers to be sorted have the same number of digits.\nHowever, if the numbers have varying lengths or are floating-point numbers, radix sort may not be applicable or efficient.\nBucket Sort\nBucket sort works by dividing an array into several buckets. Each bucket is then sorted individually, either using a different sorting algorithm or by recursively applying the bucket sort algorithm.\nThis sort is helpful when the input is uniformly distributed over a range but less so if the input data is heavily skewed or has a wide range.\nIn a coding interview, demonstrating your understanding of when to use these non-comparison sorts can be a great way to show your depth of knowledge and problem-solving abilities. However, be sure to consider these algorithms' constraints and limitations. For instance, while these algorithms can theoretically achieve linear time complexity, they often require specific conditions and can potentially use significant memory. Be prepared to discuss these trade-offs and why you chose (or chose not to use) a non-comparison sort in your solution.\nAbout the Author\nJai is a software engineer and a technical leader. In his professional career spanning over a decade, he has worked at several startups and companies such as SlideShare and LinkedIn. He is also a founder of a saas product used by over 10K companies across the globe. He loves teaching and mentoring software engineers. His mentees have landed jobs at companies such as Google, Facebook, and LinkedIn.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/sorting-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Dynamic Programming Interview Questions & Tips for Senior Engineers",
      "content": "Dynamic Programming Interview Questions & Tips\nWhat is Dynamic Programming?\nDynamic programming is an optimization technique used to efficiently solve problems that are computationally complex. The key characteristic is the way dynamic programming breaks the overall problem into smaller, overlapping subproblems. Often the solutions to subproblems are stored and reused to avoid repeated work. In comparison with other approaches, this greatly improves the efficiency of the solution.\nCompanies That Ask Dynamic Programming Questions\nA Practical Example: Determining the Nth Fibonacci Number\nTo quickly refresh your memory, the Fibonacci Sequence is a sequence of numbers in which every number is the sum of the two previous numbers:\n0, 1, 1, 2, 3, 5, 8, 13, 21, …\nWe should also restate that the Fibonacci sequence is known to start with 0, 1. This represents the \"base case\" which will be covered in more detail later on.\nNow, looking from left-to-right, it is fairly easy to see that each number, along with its predecessor, is needed to determine the next in the sequence. Think of this as a “bottom-up” approach in that it begins with the first example and builds up to the desired solution.\nSaid another way, and this time looking from right-to-left, a given number in the sequence can be derived from the two previous numbers. Think of this as a \"top-down\" approach in that it begins with the desired solution and drills down toward the first example.\nRegardless of which way you look at it, the computation can be formalized as F(n) = F(n-1) + F(n-2). This is known as a recurrence relation and is another important concept that we’ll get back to later.\nLet’s now turn to some code and step through a simple top-down solution that makes use of recursion:\ndef fib(n):\nif n == 0:\nreturn 0\nif n == 1:\nreturn 1\nreturn fib(n - 1) + fib(n - 2)\n1def fib(n):\n2 if n == 0:\n3 return 0\n4 if n == 1:\n5 return 1\n6 return fib(n - 1) + fib(n - 2)\nConsider what happens when invoked as fib(5)\nto determine the fourth Fibonacci number.\nN - 1 = 4\nand N - 2 = 3\nso this function makes recursive calls to return fib(4) + fib(3)\n. Notice that the invocation of fib(4)\nwill in turn make recursive calls fib(3)\nand fib(2)\n. This highlights the overlapping subproblems and where work is being repeated. The function calls can also be represented as a tree to visualize and identify the repeated work:\nIn the end, solving for the fifth Fibonacci number ends up solving for:\n- The fourth Fibonacci number once\n- The third number twice\n- The second number three times\n- The first number five times\nThis is where dynamic programming really shines as it helps avoid repeating work and provides a far more efficient solution.\nIncorporating Memoization to Avoid Repeated Work\nIn the recursive algorithm for this problem the answer to fib(3)\n(and all other subproblems) is immediately discarded; what a waste!\nInstead, we can utilize a hashmap to store the return value of fib(3)\nand later when the same subproblem comes up, the result can be quickly retrieved, with O(1) time complexity, instead of repeating it all over. Summing two numbers a handful of times for low values of N may not seem like a big deal, but as N gets subproblem repetition increases rapidly. This technique of caching the result of a function call, in order to avoid making the same call again in future, is known as memoization.\ndef topDownFib(n):\ndp = [0] \\* (n+1)\nreturn topDownFibHelper(n, dp)\ndef topDownFibHelper(n, dp):\nif n == 0 or n == 1:\nreturn n\n# If value is not set in cache, compute it\nif dp[n] == 0:\ndp[n] = topDownFibHelper(n-1, dp) + topDownFibHelper(n-2, dp)\nreturn dp[n]\n1def topDownFib(n):\n2 dp = [0] \\* (n+1)\n3 return topDownFibHelper(n, dp)\n4\n5def topDownFibHelper(n, dp):\n6 if n == 0 or n == 1:\n7 return n\n8 # If value is not set in cache, compute it\n9 if dp[n] == 0:\n10 dp[n] = topDownFibHelper(n-1, dp) + topDownFibHelper(n-2, dp)\n11 return dp[n]\n12\nWorking Iteratively from the Bottom Up Using Tabulation\nSimilarly, this problem can be solved from the bottom up, calculating and storing each number in the sequence along the way. This style of storing and reusing results is known as “tabulation”.\ndef bottomUpFib(n):\nif n == 0:\nreturn 0\n# Initialize cache\ndp = [0] \\* (n+1)\ndp[1] = 1\n# Fill cache iteratively\nfor i in range(2, n+1):\ndp[i] = dp[i-1] + dp[i-2]\nreturn dp[n]\n1def bottomUpFib(n):\n2 if n == 0:\n3 return 0\n4 # Initialize cache\n5 dp = [0] \\* (n+1)\n6 dp[1] = 1\n7\n8 # Fill cache iteratively\n9 for i in range(2, n+1):\n10 dp[i] = dp[i-1] + dp[i-2]\n11\n12 return dp[n]\n13\nAlthough an array can be used for tabulation when solving for Fibonacci (and in fact is excessive since at most 2 previous previous results are ever needed), it demonstrates a concept that often needs to be extended as far as using multi-dimensional arrays to solve more complex problems.\nA Quick Recap on What We Learned via Fibonacci\nAfter considering Fibonacci from different perspectives and seeing two contrasting approaches, we’ve now been introduced to all the core concepts associated with dynamic programming:\n- Base cases and the sub-problems that give light to a recurrence relation\n- Top-down approaches which typically involve recursion and memoization\n- Bottom-up approaches that are usually iterative and use tabulation\nLet’s move on to look at when and how to apply Dynamic programming in interviews.\nUsing Dynamic Programming in Interviews\nBefore getting to the more formal concepts that determine whether dynamic programming can be applied, let's look at some basic heuristics to use in an interview to determine whether to even consider dynamic programming.\nHeuristics for Identifying Dynamic Programming Problems\nThe first heuristic comes from considering the problem statement. Does it ask for the min/max out of a set of possible options, the best/worst of a set of possible options, or perhaps the total number of options? This isn't confirmation that dynamic programming is suitable, or even that's the best approach, but it is a good signal that DP is worth exploring.\nAs always in a technical interview, it's good practice to discuss and work through one or two simple-ish examples. Doing so helps to clarify the interviewer's requirements and expectations, plus it provides test cases for later. While working through the examples you likely identified a brute-force approach. And in explaining how the brute force work leads to the result, did you find yourself mentioning that the more complex example \"follows on from\" or \"makes use of\" the simpler example? This is a second heuristic and it's a great indication that there are sub-problems and repeated work which means a dynamic programming approach could work well.\nDoes a programmatic solution involving recursion become apparent? Where does the recursion lead? Eventually it must \"bottom out\" and this is likely to be the base case. What are the branches or conditional paths that trigger recursive calls? They will likely form part of the recurrence relation. The availability of a recursive solution is a third heuristic you can look for.\nWith one or more of these heuristics present, you can be confident spending time and looking hard for a dynamic programming solution.\nOptimal Substructure and Overlapping Subproblems\nMore formally, in order to apply dynamic programming to a problem two conditions must be present:\n- Optimal substructure\n- Overlapping subproblems\nOptimal Substructure\nOptimal substructure requires that you can solve a problem based on the solutions of subproblems. For example, if you want to calculate the 5th Fibonacci number, it can be solved by computing fib(5) = fib(4) + fib(3). It is not necessary to know any more information other than the solutions of those two subproblems in order to determine the solution.\nA useful way to think about optimal substructure is whether a problem can be easily solved recursively. Recursive solutions inherently solve a problem by breaking it down into smaller subproblems. If you can solve a problem recursively, it most likely has an optimal substructure.\nOverlapping Subproblems\nOverlapping subproblems means that when you split your problem into subproblems, you sometimes get the same subproblem multiple times. With the Fibonacci example, if we want to compute fib(5)\n, we need to compute fib(4)\nand fib(3)\n. However, to compute fib(4)\n, we need to compute fib(3)\nagain. This is a wasted effort, since we’ve already computed the value of fib(3)\n.\nDynamic programming relies on overlapping subproblems, and it uses memory to save the values that have already been computed to avoid computing them again. The more overlap there is, the more computational time is saved.\nThe FAST Method\nFAST is an acronym that stands for Find the first solution, Analyze the solution, identify the Subproblems, and Turn around the solution.\nIt isn’t the only way to work through problems to reach a dynamic programming solution, but aims to be easy to remember and apply while being broadly applicable.\nLet’s break down each of these steps.\nFind the First Solution\nThe first step to solving any dynamic programming problem using The FAST Method is to find an initial brute force recursive solution. Solve the problem without concern for efficiency, just as a starting point. Though there are a couple of constraints on how this brute force solution should look:\n-\nRecursive functions should be self-contained. Storing results by updating global variables may make it impossible to introduce memoization later on. Craft a function that is solely dependent on its parameters and not affected by outside factors.\n-\nAvoid unnecessary recursive function arguments. Subproblem results will eventually be memoized based on the arguments; the fewer the better.\nAnalyze the First Solution\nAnalyze the initial brute force solution. This involves determining the time and space complexity and determining if there are any obvious areas for improvement.\nAs part of the analytical process, confirm that the first solution fits the rules for problems with Dynamic programming solutions:\n- Does it have an optimal substructure?\n- Are there overlapping subproblems?\nSubproblem Identification\nIf there is indeed a Dynamic programming solution, the appropriate subproblems can now be identified and coded. Apply memoization to avoid unnecessary repeated work. At this point the problem is solved with a top-down solution that likely exhibits optimal complexity and no does not repeat any work.\nTurn the Solution Around\nSince we understand the problem well, we can go further. This involves coding the alternate bottom-up approach that iteratively computes and uses tabulation to store the results of successive subproblems, until the overall solution is reached. Turning the solution to bottom-up is generally desired as it avoids pitfalls associated with recursion and the call stack.\nDeciding on Top-down/Memoization vs. Bottom-up/Tabulation\nIn an interview, the choice of top-down or bottom-up approaches should be balanced with other factors beyond performance: How easily can the bottom-up solution be coded, is it as easily reasoned about and discussed with the interviewer? Which approach are you most comfortable with? That may be the most important factor of all!\nCommon Mistakes in Interviews Featuring Dynamic Programming\n-\nJumping too quickly to conclude dynamic programming is necessary. When you have a hammer, everything starts to look like a nail. If the problem doesn’t require an optimal solution but rather any correct solution, a greedy approach will likely be simpler to identify and implement.\n-\nConversely, looking too hard for a greedy solution and failing to recognize a dynamic programming problem. A way to determine which solution is more appropriate is to know whether a sub-solution helps lead to the final solution. If a sub-solution (a solution with a part of the input) helps, then dynamic programming is probably the way to go!\n-\nFailing to identify how to break the problem into subproblems so that the recurrence relation and base case(s) become clear. When you have a strong intuition (or have been told) that a problem needs a Dynamic programming solution, this is the major challenge. Reviewing plenty of questions and gaining practice is essential.\n-\nStruggling to define and work with a suitable result matrix. Many problems (such as Longest Common Subsequence) involve two- or multi-dimensional arrays to store sub-problem results. These can be difficult to conceive and may be tricky to work with in code. Again it’s all about practice.\n- Lack of clarity in communicating your dynamic programming logic. Visualizations can help a great deal here. As we’ve seen in this article, sketching a recursive tree or a matrix table can be helpful tools to gain shared understanding with your interviewer.\nWhat to Say in Interviews to Show Mastery Over Dynamic Programming\n- Articulate why dynamic programming is applicable (overlapping subproblems and optimal substructure) for a given problem\n- Refer to the recurrence relation and base case(s). Reason about and justify that the subproblem dependencies are acyclic.\n- Discuss and ask the interviewer if they have a preference when it comes to the tradeoffs between top-down (recursive) and bottom-up approaches.\nAbout the Authors\nTom has four years of experience developing software professionally, including experience at both Amazon and Pinterest. He is experienced both as an interviewer, conducting interviews on behalf of the companies he's worked for, and interviewee, as he has landed software engineering offers from Google, Twitter, Stripe, Airtable and Doordash during previous job searches.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/dynamic-programming-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Linked List Interview Questions & Tips for Senior Engineers",
      "content": "Linked Lists Interview Questions & Tips\nWhat is a Linked List?\nA linked list is a data structure consisting of a sequence of nodes, where each node contains a reference to either the next node in the sequence, itself, or the node prior to it. They are designed to be efficient when performing insertions and deletions. The key to their efficiency as we will discuss further is the use of pointers to capture the order of the nodes.\nLinked lists come in different variations such as singly linked (nodes only point to the next node or the previous node in a reverse linked list), doubly linked, self-linked lists, and circular linked lists.\nTypes of Linked Lists\nSingly and doubly linked lists are the two major types based on the direction of linkage. That said, we will also expand on circular linked lists and self-linked lists. This is because they tend to be a major source of headaches when implementing Linked Lists thus understanding their properties will help avoid these pitfalls.\n-\n- Singly-linked lists: each node has a link to the next node in the list, but not to the previous node.\n- Doubly linked lists: each node has links to both the next node and the previous node in the list.\n- Circular linked lists: the last node in the list points to the first node, creating a circular structure. This allows for efficient traversal of the list in both directions.\n- Self-referential linked lists or self-linked lists: each node contains a pointer or reference to itself. This type of linked list is not commonly used in practice but can be used in certain specialized scenarios such as implementing circular queues or resolving collisions by chaining in hashmaps.\nCommon Operations on Linked Lists\nTo effectively understand when to use a linked list, it helps to understand how we use them first.\nLinked List Traversal\nHere is some pseudocode for forward and backward traversals of a linked list:\nForward Traversal\nBoth doubly and singly linked lists allow for a simple forward traversal. Do note the None check.\n# class Node:\n# def \\_\\_init\\_\\_(self, data=None, next=None):\n# self.data = data\n# self.next = next\ncurrent\\_node = head\nwhile current\\_node is not None:\n// Do something with the current node\ncurrent\\_node = current\\_node.next\n1# class Node:\n2# def \\_\\_init\\_\\_(self, data=None, next=None):\n3# self.data = data\n4# self.next = next\n5\n6current\\_node = head\n7while current\\_node is not None:\n8 // Do something with the current node\n9 current\\_node = current\\_node.next\nBackward Traversal\nDoubly linked lists will usually allow you to travel backward following the prev\npointers.\ncurrent\\_node = tail\nwhile current\\_node is not None:\n// Do something with the current node\ncurrent\\_node = current\\_node.prev\n1current\\_node = tail\n2while current\\_node is not None:\n3 // Do something with the current node\n4 current\\_node = current\\_node.prev\nInsertion Into a Singly Linked List\nThe process for inserting an element into a singly linked list is as follows:\n- Create a new node containing the value to be inserted.\n- Determine the position where the new node will be inserted.\n- If the insertion position is at the front of the list, set the next in the new node to the current head of the list.\n- If the insertion position is somewhere in the middle of the list, find the node immediately preceding (prev) the position where the new node will be inserted. You can determine this by simply checking if the next node is in the position you want to insert. Your current node thus becomes your preceding node and the node following it becomes the previous next node.\n- Update the link in the preceding node to point to the new node.\n- Update the link in the new node to point to the node that was previously at the insertion position (The previous next node).\n- If the insertion position is at the end of the list, set the link in the preceding node to the new node, and set the link in the new node to None.\nInsertions into doubly-linked lists would entail also updating the previous pointer of the new node to the preceding node and the previous of the next node to the new node in addition to the updates required for inserting into a singly linked list.\nHead Insertion\nSimply set the new node’s next pointer to the current head. In case the list is empty, the new node becomes the head and tail, with its next pointing to None.\nInsertions into the Middle\nThese usually entail slicing the linked list and then setting pointers to the new node in preceding nodes and from the new node to the next nodes. The reverse also applies for doubly linked lists.\nTail Insertion\nPoint the next pointer of the last node to the new node, and point the new node to None.\nThe time complexity for inserting an element in a singly linked list is O(n)\nin the worst-case scenario, where n is the number of nodes in the list. This is because finding the node immediately preceding the insertion position requires traversing the list, which can take up to O(n)\ntime. The space complexity of inserting a new node into a singly linked list is O(1)\n, as only one new node is created and no additional memory is allocated.\nDeletion from a Singly Linked List\nThe process for deleting an element from a singly linked list is as follows:\n- Find the node to be deleted. If they exist, Keep track of the node pointing to it (preceding node) and the node immediately following the node we are deleting (next node).\n- If the node to be deleted is the head of the list, update the head to the next node of the head.\n- If the node to be deleted is in the middle of the list, point the preceding node link to the next node link, bypassing the node to be deleted.\n- Update the link in the preceding node to point to the node immediately following the node to be deleted.\n- If the node to be deleted is the tail of the list, update the link in the preceding node to point to None.\nThe time complexity for deleting an element from a singly linked list is also O(n)\nin the worst-case scenario, where n is the number of nodes in the list. This is because finding the node immediately preceding the deletion position requires traversing the list, which can take up to O(n)\ntime. The space complexity is also O(1)\n.\nHead Deletion\nMake the new head the next node of the current head. This could be a node or None\nDeletions in the Middle\nTail Deletion\nMake the next of the second to last node point to None (Bypass the last non-None node)\nInsertion into Doubly Linked Lists\nInserting an element into a doubly linked list is similar to inserting an element into a singly linked list, only that the operations done to point next have to be repeated from the opposite direction. The following steps break down how we achieve this.\n- Create a new node containing the value to be inserted.\n- Determine the position where the new node will be inserted.\n- If the insertion position is at the front of the list, set the next in the new node to the current head of the list, and set the previous node’s next pointer to the new node.\n- If the insertion position is somewhere in the middle of the list, find the node immediately preceding the position where the new node will be inserted. You can determine this by simply checking if the next node is in the position you want to insert. Your current node thus becomes your preceding node and the node following it becomes the previous next node.\n- Update the next link in the preceding node to point to the new node.\n- Update the previous link in the new node to point to the preceding node.\n- Update the previous link in the previous next node to point to the new node.\n- Update the next link in the new node to point to the previous next node.\nSimilar to the singly linked list case, the time complexity for insertions is O(n)\nin the worst-case scenario. This is because finding the node immediately preceding the insertion position requires traversing the list, which can take up to O(n)\ntime. The space complexity of inserting a new node into a doubly linked list is still O(1)\n.\nDeletion from a Doubly Linked List\nDeletion is a bit more straightforward.\n- Find the node to be deleted. Take note of the node preceding it and the node following it.\n- If the node to be deleted is the head of the list, update the head to the next node of the head, and set the previous link in the new head to None.\n- If the node to be deleted is in the middle of the list, update the next link in the preceding node to point to the next node (bypassing the node to be deleted).\n- Update the previous link in the next node to point to the preceding node.\n- If the node to be deleted is the tail of the list, update the previous link in the preceding node to point to None.\nThe time complexity and space complexity for this operation is also O(n)\nand O(1)\nrespectively. This is again due to the traversal needed to locate the node we want to delete.\nInsertions and Deletions into Circular and Self-Linked Lists\nThese flavors will usually have linkage styles resembling either a singly or doubly linked list. In the case of circularly linked lists, the process resembles breaking, shortening, and reconnecting a chain. One note is that linear but self linked lists have the cycle occuring anywhere along the linked list. Circular linked lists will have the tail of the linked list point to the head. A special case is a single node, circular linked list which also can be considered a self linked list. The steps remain the same as above depending on the linking logic in the nodes affected.\nLinked List implementation strategies\nTraditional Implementation (Using Nodes)\nThe classic way of implementing linked lists involves defining a Node class that contains a data attribute and a next attribute, which is a reference to the next node in the list. The data attribute contains the value stored in the node.\nclass Node:\ndef \\_\\_init\\_\\_(self, data=None, next=None):\nself.data = data\nself.next = next\n1class Node:\n2 def \\_\\_init\\_\\_(self, data=None, next=None):\n3 self.data = data\n4 self.next = next\nTo create a linked list, we define a LinkedList class that contains a head attribute, which is a reference to the first node in the list. Initially, the head attribute is set to None to indicate an empty list.\nclass LinkedList:\ndef \\_\\_init\\_\\_(self):\nself.head = None\n1class LinkedList:\n2 def \\_\\_init\\_\\_(self):\n3 self.head = None\nTo insert a new node at the beginning of the list, we create a new Node object containing the new value and set its next attribute to the current head of the list. We then set the head attribute of the list to the new node.\ndef insert\\_at\\_beginning(self, data):\nnew\\_node = Node(data, self.head)\nself.head = new\\_node\n1 def insert\\_at\\_beginning(self, data):\n2 new\\_node = Node(data, self.head)\n3 self.head = new\\_node\nTo insert a new node at the end of the list, we first check if the list is empty. If it is, we simply set the head attribute to a new Node object containing the new value. Otherwise, we traverse the list until we reach the last node, and then set its next attribute to a new Node object containing the new value.\ndef insert\\_at\\_end(self, data):\nif self.head is None:\nself.head = Node(data, None)\nreturn\ncurrent\\_node = self.head\nwhile current\\_node.next is not None:\ncurrent\\_node = current\\_node.next\ncurrent\\_node.next = Node(data, None)\n1 def insert\\_at\\_end(self, data):\n2 if self.head is None:\n3 self.head = Node(data, None)\n4 return\n5\n6 current\\_node = self.head\n7 while current\\_node.next is not None:\n8 current\\_node = current\\_node.next\n9\n10 current\\_node.next = Node(data, None)\nTo delete a node from the list, we first check if the list is empty. If it is, we simply return. Otherwise, we traverse the list until we find the node to be deleted, keeping track of the preceding node. We then update the next attribute of the preceding node to point to the node following the node to be deleted.\ndef delete\\_node(self, data):\nif self.head is None:\nreturn\nif self.head.data == data:\nself.head = self.head.next\nreturn\ncurrent\\_node = self.head\nwhile current\\_node.next is not None:\nif current\\_node.next.data == data:\ncurrent\\_node.next = current\\_node.next.next\nreturn\ncurrent\\_node = current\\_node.next\n1 def delete\\_node(self, data):\n2 if self.head is None:\n3 return\n4\n5 if self.head.data == data:\n6 self.head = self.head.next\n7 return\n8\n9 current\\_node = self.head\n10 while current\\_node.next is not None:\n11 if current\\_node.next.data == data:\n12 current\\_node.next = current\\_node.next.next\n13 return\n14 current\\_node = current\\_node.next\nA doubly linked list is similar to a singly linked list, but each node also contains a reference to the previous node in addition to the next node. This allows for more efficient traversal of the list in both directions.\nclass Node:\ndef \\_\\_init\\_\\_(self, data=None, prev=None, next=None):\nself.data = data\nself.prev = prev\nself.next = next\nclass DoublyLinkedList:\ndef \\_\\_init\\_\\_(self):\nself.head = None\ndef insert\\_at\\_beginning(self, data):\nif self.head is None:\nnew\\_node = Node(data, None, None)\nself.head = new\\_node\nelse:\nnew\\_node = Node(data, None, self.head)\nself.head.prev = new\\_node\nself.head = new\\_node\ndef insert\\_at\\_end(self, data):\nif self.head is None:\nnew\\_node = Node(data, None, None)\nself.head = new\\_node\nelse:\ncurrent\\_node = self.head\nwhile current\\_node.next is not None:\ncurrent\\_node = current\\_node.next\nnew\\_node = Node(data, current\\_node, None)\ncurrent\\_node.next = new\\_node\ndef delete\\_node(self, data):\nif self.head is None:\nreturn\ncurrent\\_node = self.head\nwhile current\\_node is not None:\nif current\\_node.data == data:\nif current\\_node.prev is not None:\ncurrent\\_node.prev.next = current\\_node.next\nelse:\nself.head = current\\_node.next\nif current\\_node.next is not None:\ncurrent\\_node.next.prev = current\\_node.prev\nreturn\ncurrent\\_node = current\\_node.next\n1class Node:\n2 def \\_\\_init\\_\\_(self, data=None, prev=None, next=None):\n3 self.data = data\n4 self.prev = prev\n5 self.next = next\n6\n7class DoublyLinkedList:\n8 def \\_\\_init\\_\\_(self):\n9 self.head = None\n10\n11 def insert\\_at\\_beginning(self, data):\n12 if self.head is None:\n13 new\\_node = Node(data, None, None)\n14 self.head = new\\_node\n15 else:\n16 new\\_node = Node(data, None, self.head)\n17 self.head.prev = new\\_node\n18 self.head = new\\_node\n19\n20 def insert\\_at\\_end(self, data):\n21 if self.head is None:\n22 new\\_node = Node(data, None, None)\n23 self.head = new\\_node\n24 else:\n25 current\\_node = self.head\n26 while current\\_node.next is not None:\n27 current\\_node = current\\_node.next\n28 new\\_node = Node(data, current\\_node, None)\n29 current\\_node.next = new\\_node\n30\n31 def delete\\_node(self, data):\n32 if self.head is None:\n33 return\n34\n35 current\\_node = self.head\n36 while current\\_node is not None:\n37 if current\\_node.data == data:\n38 if current\\_node.prev is not None:\n39 current\\_node.prev.next = current\\_node.next\n40 else:\n41 self.head = current\\_node.next\n42 if current\\_node.next is not None:\n43 current\\_node.next.prev = current\\_node.prev\n44 return\n45 current\\_node = current\\_node.next\nArray Implementation\nLinked lists can be implemented using arrays, where each element of the array represents a node in the linked list. Every element contains a value and a link to the next node in the list, represented by the index of the next element in the array. The last element in the array contains a special value, usually None, to indicate the end of the list. For example, consider the following array:\n[(2, 1), (5, 2), (7, 3), (4, None)]\nIn the above, the head is the first element, with the tuple representing the value as well as the next node’s index. The corresponding linked list would be as follows:\n2 -> 5 -> 7 -> 4 -> None\nLinked lists implemented with arrays have some advantages over traditionally implemented ones, such as better cache locality and the ability to preallocate memory. Array gives an additional benefit of constant time access to its element if the index is already known. This can speed up the retrieval of a node's value if its index in the array is already known. They come with some cons though, such as the need to allocate a fixed amount of memory, which can lead to wasted space or insufficient space for large lists, and the need to update links in the surrounding nodes as the pointers reference specific indices in the array. This shifting around means that the Insertion complexity is O(n)\n, in addition to the traversal cost. It doesn't really change the overall complexity in this regard, but it is less efficient.\nHashmap Implementation\nGiven the implementation above using arrays, we can see how the hashmap implementation would work. Simply put, the representation for the above example would be as follows:\n{\n0: {'value': 2, 'next': 1},\n1: {'value': 5, 'next': 2},\n2: {'value': 7, 'next': 3},\n3: {'value': 4, 'next': None}\n}\nThe rest of the logic remains the same.\nDo note, in some cases, an array itself can be used to represent the pointers. This is a key insight to solve questions such as the Linked List Cycle problem.\nThe values are not taken into account in the array representation, but noting them is as simple as using the tuple notation above or maintaining a separate list with the values ordered by the indices.\nInbuilt Types\nIn some languages like Java and C++, LinkedLists are offered out of the box as part of the language. Here are examples in Java and C++.\nCompanies That Ask Linked List Questions\nWhen to Use Linked Lists in Interviews\n- Implementing a stack or queue data structure. Stacks and queues only add or remove from the ends, this can be achieved in a linked list the same way by adding or removing nodes from the head or tail of the list. A simple array-based implementation would suffice for this as we would be popping or appending to the array at the head or tail, but with constant time operations. Keep in mind, Appending an element at the beginning of the array (e.g. .shift() in JS) could be a costly O(n) operation as it requires shifting of all the array elements. As a result, array-based implementation for a queue could be costly. Linked List mitigates that cost.\n- Maintaining a sorted list of values. In this case, we can maintain a sorted list of values by inserting nodes in the correct position based on their value. With an array based implementation, searching for the position to insert nodes can be done in logarithmic time using binary search which improves the efficiency further. A Linked Hashmap implementation (See appendix) would be useful in this case.\n- Implementing a hash table. We can implement a hash table by storing key-value pairs in nodes and using a hash function to determine the index of the linked list where the node should be stored with colliding nodes all pointing to the same index.\n- Implementing a graph data structure. Fundamentally, linked lists are unary trees/ graphs.\n- Implementing a priority queue. Linked lists are most commonly used to implement priority queues by maintaining the list in sorted order based on priority and inserting new nodes in the correct position. This is owing to the ease and efficiency of insertions and deletions.\nCommon Interview Mistakes Featuring Linked Lists\n- Not knowing how to traverse the list. a. It is key to know which direction, forward (to next node) or backward (to previous node) traversal. b. Check for None before trying to access the next or previous nodes. Interviewees often fail to account for the tail node being None. They thus try to perform node operations the same way they would with non-None nodes.\n- Not using a dummy node when traversing or performing insertions and deletions. See the dummy nodes section below to see how dummy nodes can simplify the code.\n- Infinite loops with circular linked lists or self-linked lists. These occur when nodes self-reference or we have a circular linked list. Caching seen nodes or using Floyd’s algorithm (Tortoise and Hare) can be useful for cycle detection. We go into detail on the algorithm in the mastery section.\n- Overly complicated implementation. Most people know to use nodes and pointers. However, most linked lists are usually simple enough to be implemented using an array or a hashmap.\n- Complexity analysis fails to account for traversal. The advantages of linked lists are many, including efficient insertions and deletions that have a reference to the location. However, finding the correct position for these operations, or searching for a specific node, can be costly as it requires traversing the list. When doing complexity analysis, it is key to account for this when doing the overall performance analysis. That said, the hashmap approach to implementation can help resolve the search inefficiency.\n- Confusion with the insertion and deletion steps. We go into extensive detail on this above.\n- Failing to account for edge cases eg. insertions to the head or tail of the linked list. Head and Tail insertions tend to be the most common insertion and deletion operations hence why it is important to remember how to deal with them.\nClarifying Questions to Ask Your Interviewer About Linked Lists\n- What operations do we need to perform? If the core focus is the linked list implementation, otherwise infer from the case study and list these.\n- Do we have a defined node structure? If the class format is provided, implement a traditional linked list. If the case is simple enough, a hashmap or array may suffice.\n- Is the linked list singly linked or doubly linked? Clarify this. Don't be afraid to use a doubly linked list for the efficiency gains traversing forward and backward. If memory is not a constraint, see if you can use the Linked Hashmap implementation.\n- Is there a limit to the size of the linked list? This can be an issue especially if we are dealing with data streams. It may be easier and more efficient to use arrays or hashmaps with very large linked lists. Arrays are usually native (complex) data structures in most languages and thus are usually efficient to manipulate at scale.\n- Do we want to account for the traversal complexity when doing the complexity analysis? This is key as it shows mindfulness of an operation that overhauls a lot of the efficiency gains when using linked lists.\nHow to Show Mastery of Linked Lists in Interviews\nUsing a Dummy Node\nUsing a dummy node/ sentinel node in a linked list can simplify the code by eliminating the need to handle the edge case where the list is empty or the node to be deleted is the head of the list separately. This can make the code cleaner and easier to understand, and can also help to avoid bugs that may arise from handling edge cases inconsistently. However, using a dummy node does come with some overhead, as an extra node must be allocated and maintained. Whether or not to use a dummy node depends on the specific requirements of the application and the personal preference of the developer.\nIn the below example, we insert a node at the beginning of a linked list with a dummy node:\nclass Node:\ndef \\_\\_init\\_\\_(self, data=None, next=None):\nself.data = data\nself.next = next\nclass LinkedList:\ndef \\_\\_init\\_\\_(self):\nself.head = Node()\ndef insert\\_at\\_beginning(self, data):\nnew\\_node = Node(data, self.head.next)\nself.head.next = new\\_node\n1class Node:\n2 def \\_\\_init\\_\\_(self, data=None, next=None):\n3 self.data = data\n4 self.next = next\n5\n6class LinkedList:\n7 def \\_\\_init\\_\\_(self):\n8 self.head = Node()\n9\n10 def insert\\_at\\_beginning(self, data):\n11 new\\_node = Node(data, self.head.next)\n12 self.head.next = new\\_node\nAnd here's an example of inserting a node at the beginning of a linked list without a dummy node, where we have to handle the edge case where the list is empty separately:\nclass Node:\ndef \\_\\_init\\_\\_(self, data=None, next=None):\nself.data = data\nself.next = next\nclass LinkedList:\ndef \\_\\_init\\_\\_(self):\nself.head = None\ndef insert\\_at\\_beginning(self, data):\nif self.head is None:\nself.head = Node(data, None)\nelse:\nnew\\_node = Node(data, self.head)\nself.head = new\\_node\n1class Node:\n2 def \\_\\_init\\_\\_(self, data=None, next=None):\n3 self.data = data\n4 self.next = next\n5\n6class LinkedList:\n7 def \\_\\_init\\_\\_(self):\n8 self.head = None\n9\n10 def insert\\_at\\_beginning(self, data):\n11 if self.head is None:\n12 self.head = Node(data, None)\n13 else:\n14 new\\_node = Node(data, self.head)\n15 self.head = new\\_node\nAs you can see, using a dummy node simplifies the code by eliminating the need to handle the edge case where the list is empty separately.\nSimilarly, to deleting a node from a linked list with a dummy node:\nclass Node:\ndef \\_\\_init\\_\\_(self, data=None, next=None):\nself.data = data\nself.next = next\nclass LinkedList:\ndef \\_\\_init\\_\\_(self):\nself.head = Node()\ndef delete\\_node(self, data):\ncurrent\\_node = self.head\nwhile current\\_node.next is not None:\nif current\\_node.next.data == data:\ncurrent\\_node.next = current\\_node.next.next\nreturn\ncurrent\\_node = current\\_node.next\n1class Node:\n2 def \\_\\_init\\_\\_(self, data=None, next=None):\n3 self.data = data\n4 self.next = next\n5\n6class LinkedList:\n7 def \\_\\_init\\_\\_(self):\n8 self.head = Node()\n9\n10 def delete\\_node(self, data):\n11 current\\_node = self.head\n12 while current\\_node.next is not None:\n13 if current\\_node.next.data == data:\n14 current\\_node.next = current\\_node.next.next\n15 return\n16 current\\_node = current\\_node.next\nAnd here's a similar example without the dummy node::\nclass Node:\ndef \\_\\_init\\_\\_(self, data=None, next=None):\nself.data = data\nself.next = next\nclass LinkedList:\ndef \\_\\_init\\_\\_(self):\nself.head = None\ndef delete\\_node(self, data):\nif self.head is None:\nreturn\nif self.head.data == data:\nself.head = self.head.next\nreturn\ncurrent\\_node = self.head\nwhile current\\_node.next is not None:\nif current\\_node.next.data == data:\ncurrent\\_node.next = current\\_node.next.next\nreturn\ncurrent\\_node = current\\_node.next\n1class Node:\n2 def \\_\\_init\\_\\_(self, data=None, next=None):\n3 self.data = data\n4 self.next = next\n5\n6class LinkedList:\n7 def \\_\\_init\\_\\_(self):\n8 self.head = None\n9\n10 def delete\\_node(self, data):\n11 if self.head is None:\n12 return\n13\n14 if self.head.data == data:\n15 self.head = self.head.next\n16 return\n17\n18 current\\_node = self.head\n19 while current\\_node.next is not None:\n20 if current\\_node.next.data == data:\n21 current\\_node.next = current\\_node.next.next\n22 return\n23 current\\_node = current\\_node.next\nAgain, using a dummy node simplifies the code by eliminating the need to handle the edge case where the node to be deleted is the head of the list separately.\nLinked HashMap\nFurther reading here.\nWe can take advantage of the O(1) lookup time hashmaps offer to efficiently implement LinkedLists. This can come in handy when tackling problems such as LRU cache where the order of insertion is not guaranteed to be sorted thus we need to constantly look back at the cache to update the frequency of occurrence of entries or update the next and previous pointers.\nTake note of the previous and next nodes alongside each current node. This is memory inefficient of course as it needs a separate structure but it only scales out the total space complexity linearly thus the space complexity overall does not change while guaranteeing O(1)\ninsertions and deletions. This implementation would look as follows:\nlinked\\_map = {\ncur\\_node: \nprev\\_node: ...\nnext-node: ...\n}\n1linked\\_map = {\n2 cur\\_node: \n3 prev\\_node: ...\n4 next-node: ...\n5}\nFloyd’s Algorithm (Tortoise and Hare)\nFloyd's algorithm is a heuristic algorithm that detects the presence of a cycle in a linked list and returns the starting node of the cycle. The algorithm works by using two pointers, one that moves at a slower pace (the tortoise) and one that moves at a faster pace (the hare), to traverse the linked list.\nThis algorithm takes advantage of the concept of overlapping. On a circular race track, should one vehicle/ racer be faster, they will eventually overlap the slower racers as they continuously put some distance between them and the competitors. Similarly, when traversing linked lists that have cycles, if we have two pointers with one being faster (typically twice the speed of the slower pointer), then they will eventually converge somewhere along the cycle.\nAssuming that the linked list has a cycle, the hare pointer will eventually catch up to the tortoise pointer and they will meet at a point in the cycle, which we will refer to as the meeting point. The distance traveled by the hare pointer will be twice the distance traveled by the tortoise pointer at the meeting point, since the hare moves twice as fast as the tortoise.\nNow let's consider the distance between the head of the linked list and the starting point of the cycle, which we will refer to as the loop start. Let this distance be denoted as \"x\", and let the length of the cycle be denoted as \"y\". We can express the distance traveled by the hare and tortoise pointers in terms of \"x\" and \"y\" as follows:\n- Distance traveled by tortoise pointer = x + m \\* y (where m is an integer representing the number of complete cycles made by the pointer)\n- Distance traveled by hare pointer = x + n \\* y (where n is an integer representing the number of complete cycles made by the pointer)\nSince the hare pointer moves twice as fast as the tortoise pointer, we can express the distance traveled by the hare pointer as twice the distance traveled by the tortoise pointer:\n2 \\* (x + m \\* y) = x + n \\* y\nSimplifying this expression, we get:\nx = (n - 2m) \\* y\nThis equation tells us that the distance between the head of the linked list and the loop start is a multiple of the length of the cycle. If we reset the tortoise pointer to the head of the linked list and move both pointers at the same pace, the distance between the head of the linked list and the loop start will be equal to the distance between the meeting point and the loop start. Therefore, if we move the tortoise pointer and hare pointer at the same pace until they meet again, they will meet at the loop start. In conclusion, Floyd's algorithm will usually find the start of the linked list cycle because it takes advantage of the fact that the distance between the head of the linked list and the loop start is a multiple of the length of the cycle, and uses this fact to determine the location of the loop start.\n# define a Node class\nclass Node:\ndef \\_\\_init\\_\\_(self, val):\nself.val = val\nself.next = None\n# define a function to detect cycles in a linked list\ndef detect\\_cycle(head):\n# initialize pointers\nslow = head\nfast = head\n# move pointers through linked list\nwhile fast and fast.next:\nslow = slow.next\nfast = fast.next.next\n# check for cycle\nif slow == fast:\n# reset slow pointer\nslow = head\n# move pointers until they meet again\nwhile slow != fast:\nslow = slow.next\nfast = fast.next\n# return starting node of cycle\nreturn slow\n# return None if no cycle is detected\nreturn None\n1# define a Node class\n2class Node:\n3 def \\_\\_init\\_\\_(self, val):\n4 self.val = val\n5 self.next = None\n6\n7# define a function to detect cycles in a linked list\n8def detect\\_cycle(head):\n9 # initialize pointers\n10 slow = head\n11 fast = head\n12\n13 # move pointers through linked list\n14 while fast and fast.next:\n15 slow = slow.next\n16 fast = fast.next.next\n17\n18 # check for cycle\n19 if slow == fast:\n20 # reset slow pointer\n21 slow = head\n22\n23 # move pointers until they meet again\n24 while slow != fast:\n25 slow = slow.next\n26 fast = fast.next\n27\n28 # return starting node of cycle\n29 return slow\n30\n31 # return None if no cycle is detected\n32 return None\n33\nAbout the Author\nGithire (Brian) is a backend and ML engineer with 7 YoE ranging from startups to major corporations. He has worked on tech serving a wide demographic ranging from mobile money in his homeland Kenya, embedded tech with Kakao in South Korea to MLE at Microsoft. Brian has also worked as a teacher and has a knack for writing technical articles\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/linked-lists-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Arrays Interview Questions & Tips for Senior Engineers",
      "content": "Arrays Interview Questions & Tips\nDespite their simplicity, arrays in coding interviews can be surprisingly intricate. This article explores their various forms and patterns, helping candidates navigate common pitfalls and effectively demonstrate mastery of this essential data structure.\nWhat are Arrays?\nArrays are a fundamental data structure comprising a collection of elements. They represent a contiguous block of memory and are often used to store collections of data of the same type. If we know the address of an array in memory, we can calculate the address of each element by adding an offset to the base address. Arrays are very efficient with respect to memory usage and provide fast access to individual elements. They are so useful that most programming languages natively incorporate them.\nArrays are usually fixed in size and have a specific number of elements. Some languages like Ruby and JavaScript offer dynamic arrays that can grow or shrink in size. However, these dynamic arrays are still implemented under the hood as fixed-size arrays. When they reach capacity, new arrays are created with double the capacity, and the old array is copied over. This is an expensive operation. Therefore we use an array when we know the collection size in advance.\nTypes of Arrays\nArrays come in different shapes and sizes. Let's use an analogy to understand the different types of arrays.\nThe simplest and most common type is the one-dimensional array, similar to a row of houses on the street. This type of array consists of elements stored in a contiguous block of memory, much like houses lined up side by side. Each house, like an array element, has its unique address or index. The 'length' of this street or array is simply the count of houses or elements it hosts.\nElevating complexity, a two-dimensional array mirrors a city grid. Streets and avenues form a grid, each housing numerous homes. Each home's location can be identified using its street and house number, similar to a two-dimensional array's pair of indices. The total count of houses across the city grid corresponds to the total elements in the array.\nFor a three-dimensional array, picture a towering skyscraper in the city grid. Each floor is its own grid of streets and houses. Every apartment (element) is located using a floor number, street number, and house number, much like multiple indices in a multidimensional array. The total number of apartments across all the floors reflects the total elements within the array. While you can have an array with an arbitrary number of dimensions, in coding interviews it is rare to see more than three dimensions used.\nArray Operations\nArrays are best used when accessing an element by its index. This is a constant time O(1)\noperation. This is the primary benefit of arrays over other data structures like linked lists, where finding a specific element necessitates traversing the list, resulting in a linear time O(n)\noperation. However, the insertion or deletion of elements might not be as efficient, given that all the elements to the right or left of the insertion or deletion point must be shifted. This is also a linear time O(n)\noperation. Similarly, if you’re searching for an element in an unsorted array, you’ll have to examine the entire array, which is also a linear time O(n)\noperation. However, the story changes if the array is sorted. We'll delve into this facet later in the article.\nCompanies That Ask Array Questions\nWhen to Use Arrays in Interviews\nAn array, at its core, is a very simple data structure. However, its versatility lies in its simplicity. It's akin to human cells: simple in isolation, yet they form complex organisms when combined.\nArrays form the backbone of many interview questions, whether they revolve around sorting, searching, dynamic programming, or other algorithmic concepts. They are often employed in scenarios where storing and accessing elements in a sequential or ordered manner is required. This includes strings, which are fundamentally just arrays of characters under the hood. Arrays also prove helpful when there's a need for constant-time access to elements based on their index.\nHere are some instances when you can use arrays in interviews.\nIterating Over a Collection of Elements in a Specific Order\nArrays are the go-to data structure when you need to iterate over a collection of elements in a specific order. Since elements in an array are laid out contiguously and have a unique index, iterating over them in any given order (forward, backward, or even at irregular intervals) is quite straightforward.\nSuppose you are given a coding challenge during an interview where you are asked to square every array element in place. Such operations can be performed efficiently thanks to arrays, as we can access and modify each element via its index.\nHere's how you might implement this in Python:\ndef square\\_array(arr):\nfor i in range(len(arr)):\narr[i] = arr[i] \\* arr[i]\nreturn arr\n1def square\\_array(arr):\n2 for i in range(len(arr)):\n3 arr[i] = arr[i] \\* arr[i]\n4 return arr\nHowever, it's worth noting that when the order of elements doesn't matter, other data structures such as sets or maps can be more appropriate, offering unique benefits like constant-time lookups and insertions, depending on the specific scenario.\nSorting a Collection of Elements\nSorting is a typical operation performed on arrays. In interview scenarios, understanding various sorting algorithms and their efficiencies is critical. An array can be an intuitive choice when we need to sort elements, whether integers or objects, in a specific order.\nConsider an example where you have an array of integers; the task is to sort this array in ascending order. Most languages provide a built-in function that can be used to sort arrays. In Python, we have both the sort()\nand sorted()\nfunctions available for this purpose. The sort()\nmethod sorts the array in-place, meaning it modifies the original array:\ndef sort\\_elements(arr):\narr.sort()\nreturn arr\n1def sort\\_elements(arr):\n2 arr.sort()\n3 return arr\nOn the other hand, the sorted()\nfunction returns a new sorted list from the elements of any sequence, leaving the original sequence unaffected. It's beneficial when you want to keep the original array intact and need a sorted version of it.\nRead more about sorting algorithms in our Sorting guide.\nSearching for an Element in a Sorted Collection\nWhen you are given a sorted collection, binary search may be an effective solution. Binary search is a divide-and-conquer algorithm used for searching in a sorted array. It halves the search space at every step, making it highly efficient with O(log n)\ntime complexity. It compares the target value to the middle element of the array; if they are unequal, the half in which the target cannot lie is eliminated, and the search continues on the remaining half until it is successful or the remaining half is empty.\nArrays are particularly useful when performing a binary search, as they provide constant-time access to the item in the middle of the array. Compare this to a linked list, where you'd have to traverse the list to find the middle element, which would take linear time.\ndef binary\\_search(arr, x):\nlow = 0\nhigh = len(arr) - 1\nmid = 0\nwhile low <= high:\nmid = (high + low) // 2\n# If x is greater, ignore left half\nif arr[mid] < x:\nlow = mid + 1\n# If x is smaller, ignore right half\nelif arr[mid] > x:\nhigh = mid - 1\n# x is present at mid\nelse:\nreturn mid\n# If we reach here, then the element was not present\nreturn -1\n1def binary\\_search(arr, x):\n2 low = 0\n3 high = len(arr) - 1\n4 mid = 0\n5\n6 while low <= high:\n7\n8 mid = (high + low) // 2\n9\n10 # If x is greater, ignore left half\n11 if arr[mid] < x:\n12 low = mid + 1\n13\n14 # If x is smaller, ignore right half\n15 elif arr[mid] > x:\n16 high = mid - 1\n17\n18 # x is present at mid\n19 else:\n20 return mid\n21\n22 # If we reach here, then the element was not present\n23 return -1\nBinary search seems straightforward in concept, but questions on this topic come in various forms and complexities. Some problems ask you to find the first or last occurrence of a number, and others require you to find the smallest or largest number that meets a specific condition. Thus, it is essential to practice a diverse set of problems on binary search to recognize its patterns and application in different scenarios.\nTwo Pointers\n\"Two Pointers\" is a common technique for solving array problems, especially when dealing with sequential access or when there's a need to keep track of two places in the array simultaneously. The two pointers might move in the same direction, opposite directions, or one might remain stationary while the other moves; the specific pattern depends on the problem.\nA classic example is reversing an array in-place. We position pointers at the start and end of the array and swap the corresponding elements. These pointers then converge towards the center, effectively reversing the array in-place.\nHere's the Python code:\ndef reverse\\_array(arr):\nstart = 0\nend = len(arr) - 1\nwhile start < end:\narr[start], arr[end] = arr[end], arr[start]\nstart += 1\nend -= 1\nreturn arr\n1def reverse\\_array(arr):\n2 start = 0\n3 end = len(arr) - 1\n4\n5 while start < end:\n6 arr[start], arr[end] = arr[end], arr[start]\n7 start += 1\n8 end -= 1\n9\n10 return arr\nIt is worth nothing that this approach is applicable to strings as well. However, as strings are treated as immutable in many languages, including Python, we can't perform in-place operations on them directly. In such scenarios, we can convert the string to a list (which is mutable), perform the in-place reversal, and then convert it back to a string.\nThe utility of this technique is quite broad,for instance, in detecting palindromes or solving the two-sum problem. Mastery of this approach not only aids in array-related queries but also extends to solving linked list related problems, such as identifying the middle element or detecting a cycle within the list.\nSliding Window Problems\nSliding window problems often require tracking a subset of an array. In these problems, you deal with a 'window' of elements, adjusting its size or shifting its position based on the problem's requirements, all while maintaining the desired property in this window.\nFor example, if asked to find the maximum sum of any size k subarray, we could use a sliding window approach. Here's a simplified Python solution:\ndef max\\_sum\\_subarray(arr, k):\n# Compute sum of the first window of size k\n# arr[:k] slices the array from index 0 to k\nwindow\\_sum = sum(arr[:k])\nmax\\_sum = window\\_sum\nfor i in range(k, len(arr)):\n# Compute sum of next window of size k by\n# removing the first element of the previous\n# window and adding the next element\nwindow\\_sum = window\\_sum - arr[i - k] + arr[i]\nmax\\_sum = max(max\\_sum, window\\_sum)\nreturn max\\_sum\n1def max\\_sum\\_subarray(arr, k):\n2 # Compute sum of the first window of size k\n3 # arr[:k] slices the array from index 0 to k\n4 window\\_sum = sum(arr[:k])\n5 max\\_sum = window\\_sum\n6\n7 for i in range(k, len(arr)):\n8 # Compute sum of next window of size k by\n9 # removing the first element of the previous\n10 # window and adding the next element\n11 window\\_sum = window\\_sum - arr[i - k] + arr[i]\n12 max\\_sum = max(max\\_sum, window\\_sum)\n13\n14 return max\\_sum\nImplementing Other Data Structures\nArrays are often the foundational building blocks for more complex data structures. Their simplicity and efficient characteristics make them ideal for this role. For instance, stacks and queues, data structures that manage elements in a specific order, often use arrays to organize their elements. Arrays offer the advantage of efficient access, making them a popular choice for these structures.\nAlso, arrays are critical in depicting complex structures such as heaps and graphs. Graphs can be implemented using arrays through an adjacency matrix or list. Particularly with an adjacency list, arrays store adjacent vertices, offering a space-efficient method for representing sparse graphs. We'll learn more about implementing graphs using arrays later in this article.\nCommon Mistakes in Interviews Featuring Arrays\nArray-related questions can be trickier than they appear due to their simple structure, often causing interviewees to stumble. Arrays are a fundamental topic that also serves as a stepping stone to more advanced concepts. Consequently, understanding them thoroughly and being aware of common mistakes is vital. This section will highlight these common pitfalls and offer strategies to avoid them effectively.\nOff-by-One Errors and Array Out of Bounds\nOff-by-one errors, also known as OBOEs, are among the most common errors. These typically happen when indexing arrays, especially in languages that use zero-based indexing, like Python and Java (There are a number of languages that use one-based indexing as well, such as Lua, R, Julia, COBOL, etc.) For example, suppose you are given an array; and you need to access the last element. It’s common to see mistakes like this:\ndef access\\_last\\_element(nums):\nreturn nums[len(nums)] # Raises IndexError\n1def access\\_last\\_element(nums):\n2 return nums[len(nums)] # Raises IndexError\nThis code raises an IndexError because it attempts to access an index that is one past the end of the array. The correct approach is to subtract one from the length.\ndef access\\_last\\_element(nums):\nreturn nums[len(nums) - 1] # Correct\n1def access\\_last\\_element(nums):\n2 return nums[len(nums) - 1] # Correct\nIn programming languages with static arrays, like C++ or Java, an array out of bounds is a common issue. However, Python's dynamic arrays (lists) mostly circumvent this issue. Still, you can encounter similar problems if you try to insert or update an element at an index that does not exist in the list.\ndef insert\\_at\\_index(nums, index, value):\nnums[index] = value # Raises IndexError if index > len(nums) - 1\n1def insert\\_at\\_index(nums, index, value):\n2 nums[index] = value # Raises IndexError if index > len(nums) - 1\nA better solution would be to use the list.insert()\nmethod, which automatically handles these cases. If the provided index is beyond the current list length, the insert()\nmethod appends the element to the end of the list.\ndef insert\\_at\\_index(nums, index, value):\nnums.insert(index, value) # Inserts at correct index or appends if index > len(nums) - 1\n1def insert\\_at\\_index(nums, index, value):\n2 nums.insert(index, value) # Inserts at correct index or appends if index > len(nums) - 1\n3\nInadequate Complexity Analysis\nNeglecting the analysis of time and space complexity is a common mistake. This can lead to suboptimal solutions or even solutions that exceed the time limit for larger inputs. For example, suppose you are given an array of numbers and asked to return an array of the same length where each element is the product of all numbers in the original array except the number at that index. The brute-force approach would look something like this:\ndef product\\_except\\_self(nums):\noutput = []\nfor i in range(len(nums)):\nproduct = 1\nfor j in range(len(nums)):\nif i != j:\nproduct \\*= nums[j]\noutput.append(product)\nreturn output\n1def product\\_except\\_self(nums):\n2 output = []\n3 for i in range(len(nums)):\n4 product = 1\n5 for j in range(len(nums)):\n6 if i != j:\n7 product \\*= nums[j]\n8 output.append(product)\n9 return output\nThis naive solution has a time complexity of O(n^2)\n, which could be too slow for larger inputs. An optimal solution with a time complexity of O(n)\ncan be achieved by using two passes of the array: one pass to calculate the product of elements to the left of each element and a second pass to calculate the product of elements to the right of each element.\ndef product\\_except\\_self(nums):\nn = len(nums)\noutput = [1] \\* n\nleft\\_product = right\\_product = 1\nfor i in range(n):\noutput[i] \\*= left\\_product\nleft\\_product \\*= nums[i]\noutput[~i] \\*= right\\_product\nright\\_product \\*= nums[~i]\nreturn output\n1def product\\_except\\_self(nums):\n2 n = len(nums)\n3 output = [1] \\* n\n4 left\\_product = right\\_product = 1\n5 for i in range(n):\n6 output[i] \\*= left\\_product\n7 left\\_product \\*= nums[i]\n8 output[~i] \\*= right\\_product\n9 right\\_product \\*= nums[~i]\n10 return output\nMishandling Special Cases and Input Assumptions\nFailing to handle special cases, like empty inputs, null values, or duplicate values, is a frequent pitfall. This can lead to unintended exceptions or incorrect outputs.\nFor instance, if you're writing a function to find the maximum element in an array and you do not consider the case where the array is empty, your function may throw an error.\ndef find\\_max(nums):\nreturn max(nums) # Raises ValueError if nums is empty\n1def find\\_max(nums):\n2 return max(nums) # Raises ValueError if nums is empty\nSimilarly in JavaScript, the following code will return -Infinity\nif the input array is empty:\nfunction max\\_element(nums) {\nreturn Math.max(...nums);\n}\nconsole.log(max\\_element([])); // prints -Infinity\n1function max\\_element(nums) {\n2 return Math.max(...nums);\n3}\n4\n5console.log(max\\_element([])); // prints -Infinity\nAnother example, if you were asked to write a function that takes an array and returns a new array with duplicates removed, you might write something like this:\ndef remove\\_duplicates(nums):\nreturn list(set(nums))\n1def remove\\_duplicates(nums):\n2 return list(set(nums))\nThis works well for most cases, but the solution doesn't preserve the original order of elements, which could be a requirement in some cases. This highlights the importance of asking clarifying questions about the input and output requirements before implementing your solution.\ndef remove\\_duplicates(nums):\nseen = set()\nresult = []\nfor num in nums:\nif num not in seen:\nseen.add(num)\nresult.append(num)\nreturn result\n1def remove\\_duplicates(nums):\n2 seen = set()\n3 result = []\n4 for num in nums:\n5 if num not in seen:\n6 seen.add(num)\n7 result.append(num)\n8 return result\nMisuse of Built-in Functions\nMost programming languages have many helpful built-in functions and methods for working with arrays. However, it's crucial to understand their time complexities to avoid performance issues. One common misconception is thinking that searching for an element in an array (or list in Python) is an O(1)\noperation when in reality it's O(n)\ndue to linear search.\nA particularly common example of this misunderstanding involves the use of the in\nkeyword in Python, which is frequently used in array operations:\nif x in my\\_list: # this might appear O(1), but it's actually O(n)!\npass\n1if x in my\\_list: # this might appear O(1), but it's actually O(n)!\n2 pass\n3\nAnother example is the misuse of the list.remove()\nfunction in Python, which has a time complexity of O(n)\nbecause it has to shift all the elements after the removed element. If you are unaware of this, you might incorrectly assume it's an O(1)\noperation, leading to inefficient code.\ndef remove\\_all\\_instances(nums, val):\nwhile val in nums: # Each 'in' check is O(n) and 'remove' is also O(n)\nnums.remove(val)\n1def remove\\_all\\_instances(nums, val):\n2 while val in nums: # Each 'in' check is O(n) and 'remove' is also O(n)\n3 nums.remove(val)\nTo resolve this, you could use a different approach, such as filtering the array using list comprehension, which results in a single pass over the array (i.e., O(n)\n):\ndef remove\\_all\\_instances(nums, val):\nreturn [num for num in nums if num != val] # Single pass, hence O(n)\n1def remove\\_all\\_instances(nums, val):\n2 return [num for num in nums if num != val] # Single pass, hence O(n)\nUnderutilizing Language Helpers\nWe have talked about misuse of built-in functions, but when to use them is also important to know. For example, suppose you are given an array of integers and asked to return the sum of all the elements. You might be tempted to write a for loop to iterate over the array and calculate the sum. However, Python has a built-in function called sum()\nthat does exactly that. Using this function is not only more concise, but it also results in better performance because it's implemented in C.\ndef sum\\_array(nums):\ntotal = 0\nfor num in nums:\ntotal += num\nreturn total\n# Can be written as\ndef sum\\_array(nums):\nreturn sum(nums)\n1def sum\\_array(nums):\n2 total = 0\n3 for num in nums:\n4 total += num\n5 return total\n6\n7# Can be written as\n8\n9def sum\\_array(nums):\n10 return sum(nums)\nAnother example could be when you want to reverse an array. You could write a for loop to iterate over the array and swap the elements, but Python has built-in functions that let you do this in a single line. You can choose between in-place reversal with my\\_list.reverse()\nor creating a new reversed list with mylist[::-1]\n. Knowing the language helpers available to you and using them when appropriate is important.\nUsing Array as a Queue\nArrays are efficient for accessing elements at specific indices but inefficient when removing or inserting elements at arbitrary positions. This is because these operations typically require shifting many elements, which is a linear time operation. For instance, using an array like a queue and popping from the front involves shifting all the remaining elements each time an element is popped, a O(n)\noperation.\nIn Python, the pop()\nmethod without any arguments efficiently removes the last element (O(1)\n) because Python maintains a pointer to the end of the list. However, using pop(0)\nto remove from the front leads to a linear-time operation (O(n)\n), as all remaining elements need to be shifted to fill the gap left by the removed element.\ndef pop\\_front(nums):\nreturn nums.pop(0) # Inefficient if nums is large\n1def pop\\_front(nums):\n2 return nums.pop(0) # Inefficient if nums is large\nA better approach would be to use a data structure that supports efficient removal from the front, like a deque in Python.\nfrom collections import deque\ndef pop\\_front(nums):\ndq = deque(nums)\nreturn dq.popleft() # Efficient\n1from collections import deque\n2\n3def pop\\_front(nums):\n4 dq = deque(nums)\n5 return dq.popleft() # Efficient\n6\nAnother example could be taken from JavaScript where built-in support for Queue is not available. In such cases, you can use an array as a queue, but you should be aware of the trade-offs and mention them to your interviewer. If they ask, you should know how to implement a Queue in JavaScript, which is efficient for both enqueue and dequeue operations.\nArray Resizing Misconceptions\nIn many programming languages, dynamic arrays or lists automatically resize when elements are appended beyond their current capacity. This, however, is not a constant time O(1)\noperation as one might initially believe. When a resize occurs, what typically happens under the hood is the creation of a new, larger array, and all the elements from the old array are copied over to this new one.\ndef append\\_elements(nums, elements\\_to\\_add):\nfor element in elements\\_to\\_add:\nnums.append(element) # Most of the time O(1), but sometimes O(n)\n1def append\\_elements(nums, elements\\_to\\_add):\n2 for element in elements\\_to\\_add:\n3 nums.append(element) # Most of the time O(1), but sometimes O(n)\nThis example, although written in Python, mirrors the same principle in other languages that support dynamic arrays, such as JavaScript and Java (with ArrayList\n). If you are unaware of this concept, you might wrongly assume that appending is always an O(1)\noperation. It's worth noting that on average we can say it is an amortized O(1)\nbut this means occasionally we will pay a linear cost for this.\nBeing mindful of this underlying detail can help you write more efficient code and make better decisions about which data structures to use for specific problems. For instance, if you often need to add elements to an array, and the total number of elements is known in advance, it might be more efficient to preallocate the array with a fixed size if your language supports it. This knowledge can also assist in understanding the trade-offs between dynamic and static arrays.\nLimited Familiarity with Constructing Graphs Using Arrays\nGraphs are a versatile and essential data structure in computer science, often used to model various real-world problems. They are typically represented in two common ways: adjacency matrices and adjacency lists. A common pitfall is not fully understanding how to construct and manipulate these graph representations using arrays.\nAn adjacency matrix, a 2D array, represents a finite graph. The matrix elements indicate whether pairs of vertices are adjacent or not in the graph. However, adjacency matrices can be inefficient for large graphs with many vertices but few edges due to the storage of many zero values.\n# Graph represented as an adjacency matrix\n# 0 1 2 3\ngraph = [[0, 1, 0, 0], #0\n[1, 0, 1, 1], #1\n[0, 1, 0, 1], #2\n[0, 1, 1, 0]] #3\n1# Graph represented as an adjacency matrix\n2# 0 1 2 3\n3graph = [[0, 1, 0, 0], #0\n4 [1, 0, 1, 1], #1\n5 [0, 1, 0, 1], #2\n6 [0, 1, 1, 0]] #3\nOn the other hand, an adjacency list uses a more space-efficient approach, especially for sparse graphs. It comprises an array of lists. The array's index represents the node, and each entry in its list represents the nodes it's connected to.\n# Graph represented as an adjacency list\ngraph = [[1],\n[0, 2, 3],\n[1, 3],\n[1, 2]]\n1# Graph represented as an adjacency list\n2graph = [[1],\n3 [0, 2, 3],\n4 [1, 3],\n5 [1, 2]]\nFinally, a matrix itself can be thought of as a graph in problems like Number of Islands or Rotting Oranges.\n# Graph represented by each cell being a thought of as a \"node\"\n# so (0,0) has three neighbors (0,1), (1,0), and (1,1)\ngraph = [[1, 1, 1],\n[0, 0, 0],\n[1, 0, 1],\n[1, 1, 1]]\n1# Graph represented by each cell being a thought of as a \"node\"\n2# so (0,0) has three neighbors (0,1), (1,0), and (1,1)\n3graph = [[1, 1, 1],\n4 [0, 0, 0],\n5 [1, 0, 1],\n6 [1, 1, 1]]\nClarifying Questions to Ask Your Interviewer About Arrays\nUsing an In-place Algorithm\nIn-place operations refer to modifying the input data structure directly, instead of creating a new one. This tactic can significantly cut down the memory footprint of an algorithm, a distinct advantage when handling large data sets. However, in-place operations also modify the original data, which might not always be desirable. This is especially true if the original data is needed elsewhere in the program or if the problem requires maintaining the original input for future reference or backtracking purposes.\nTherefore, if you see a problem that can be solved in-place, a good question to ask your interviewer could be:\n\"Can I modify the original array to save space, or should I maintain the original input?\"\nThis shows that you know the trade-offs and are thinking about the problem holistically.\nPro tip: You can specifically ask \"if the data structure is thread-safe or if we want to have our function avoid side effects as we might in the functional programming paradigm.\" These tend to be the two main objections why we would not modify a data structure in-place and also provide an interviewer with good signal that you understand why direct modification isn't always a good idea.\nProactive Edge-Case Handling and Understanding Input Specifics\nWhen you are dealing with numbers, always ask about their nature. Understanding the specifics of numerical input is key to formulating a robust solution. Are the numbers positive, negative, odd, or even, or could there be null values? What is the range of the numbers? Are there any other constraints? It's essential to establish these details upfront or to state these assumptions at the beginning clearly. This habit can help avoid common errors, even the most glaring one – trying to solve the wrong problem.\nEqually critical is the proactive exploration of edge cases. Think of zero values, empty arrays, or unexpected data types. It's not just about solving the problem but also about how you handle every possible scenario. Ignoring edge cases can indicate a lack of attention to detail, impacting your interview results.\nMemory Management\nIn real-world applications, you may need to handle arrays that are too large to fit into memory. You need to design a strategy to process such arrays in chunks, ensuring that only a manageable portion of the array is loaded into memory at any time. An example could be importing data from a large file.\nYou could ask, \"What is the maximum size of the array? Should I design the solution to handle very large arrays?\" These clarifications can help you understand the scale at which your solution will be applied.\nAlgorithm Selection and Time-Space Complexity\nSelecting the right algorithm is crucial to solving a problem effectively. This decision often involves trading off between time and space complexity. For example, if you're tasked with finding a target sum from any two numbers in an array, different approaches offer different trade-offs. A brute-force approach has O(n^2)\ntime complexity but doesn't require extra space. Using a hash table improves the time complexity to O(n)\nbut requires additional space.\nYou can ask your interviewer, \"Can I use extra space to speed up the computation?\" These clarifications can help guide your algorithm selection.\nUnderstanding the Problem's Characteristics / Is the Array Sorted?\nA deep understanding of the problem's constraints and characteristics can guide you toward a more effective and efficient solution. An essential part of this is understanding the nature of the array you're working with. Is it sorted? Are there duplicates? Can it be sorted, and if so, does that offer any benefits for your specific problem?\nAsking these questions can lead to insights that significantly optimize your solution. For example, if the array is already sorted, or if you have the freedom to sort it, you could use binary search for various operations, which is typically more efficient than linear search.\nTake a problem where you need to find if a target value exists in an array. If the array is not sorted, you would typically resort to a linear search with a time complexity of O(n)\n. However, if the array is sorted or can be sorted, you can utilize a binary search algorithm, which reduces the time complexity to O(log n)\n.\nUnderstanding Data Structures: Arrays vs Linked Lists\nA common question that comes up when discussing arrays is: \"Why are arrays commonly used in vector implementations despite the high cost of resizing?\" The answer lies in their efficiency for certain operations, especially accessing elements. However, the trade-off is the high cost during resizing, which involves copying all elements to a new array.\nUnlike arrays, linked lists, despite lacking efficient random access and causing cache locality issues, excel when frequent insertions and deletions occur. Understanding when to employ arrays versus linked lists, like in an LRU cache scenario, is a mark of mastery. It is crucial to recognize these nuances to make optimal problem-solving decisions.\nConclusion\nIn essence, arrays are foundational data structures that are pivotal when dealing with fixed-size data sets. Indeed, arrays, in their simplicity, can present complex challenges that require careful navigation. By understanding common mistakes, one can deftly avoid pitfalls. Additionally, demonstrating mastery in an interview isn't just about solving problems - it involves asking the right clarifying questions and understanding the implications of algorithm choices. Mastery comes from deep understanding, keen attention to detail, and a practiced ability to apply this knowledge in diverse scenarios.\nAbout the Author\nJai is a software engineer and a technical leader. In his professional career spanning over a decade, he has worked at several startups and companies such as SlideShare and LinkedIn. He is also a founder of a saas product used by over 10K companies across the globe. He loves teaching and mentoring software engineers. His mentees have landed jobs at companies such as Google, Facebook, and LinkedIn.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/arrays-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Binary Search Interview Questions & Tips for Senior Engineers",
      "content": "What Is Binary Search?\nBinary search is an efficient divide and conquer algorithm for finding an item from a sorted list of items. It works by repeatedly dividing the search interval in half, narrowing down the potential locations of the item until either the item is found or it's established that the item isn't in the list. This method of halving the interval is what gives the algorithm its name – “binary” refers to the “two directions” we can choose to go during the algorithm.\nAt each step, the algorithm compares the middle element in the search space with the target value. If they are equal, it returns the index of the middle element. If the target value is less than the middle element, the search continues on the lower half of the array. If the target value is greater, the search continues on the upper half. The process continues until the search space is empty or the target element is found.\nThe beauty of binary search is in its time complexity - O(log n)\n, which makes it highly efficient for large datasets, significantly outperforming linear search methods that have a time complexity of O(n)\n.\nWhat's the Difference Between Binary Search and a Binary Search Tree?\nBinary search is an algorithm used to find an element in a sorted array. A binary search tree, on the other hand, is a type of data structure that maintains elements in a manner where they can be searched, inserted, and deleted using the principles of binary search. Binary Search Trees aren't very common in interviews, but are worth knowing in case they show up.\nLogarithms\nWhy They Matter\nScared of logarithms? If you like most people, you probably haven't worked with logarithms for a very long time if you ever even did it in the first place!That's okay! All you really need to know is a small number of facts to be comfortable talking about them in interviews.\n- Logarithms are expressed in this format: $log\\_b(n) = x$, where b is the base number, n is the number you want to transform, and x is the result. It says b raised to the power x equals n.\n- In computer science, we pretty safely ignore the \"b\" (base) since it is likely to always be base 10 that we are working with. So instead of saying log\\_10(N), we just say log (N).\n- The last and most important thing to know is that logs are an infinitesimally small number compared to the number you're taking the log of. For instance, take the number 1 trillion. That's a huge number, but log (1 trillion) is just 12!\nThe reason this is worth discussing is because many candidates don't appreciate the difference between time complexities involving logs. You've probably seen an example of time complexities plotted on a graph before, something like this:\nThe graph illustrates three time complexities: O(log N)\n, O(N)\n, and O(N log N)\n. The difference in scale between O(log N)\nand O(N)\nis massive, not slight, as input sizes increase. This means if you can use a logarithmic algorithm it isn't \"slightly better than linear\" it is massively better. The operations needed for a logarithmic algorithm are infinitesimal compared to a linear algorithm.\nO(N log N)\nrepresents log-linear time complexity. Candidates occasionally find it difficult to remember where it falls on the spectrum of complexities, but it helps to remember the implicit multiplication in the notation. It isn't O(N log N)\nit is O(N \\* log N)\n. Thus, O(N log N)\nis larger than O(N)\nsince we are multiplying it by something, yet it is still relatively small, as it's multiplied by the significantly smaller O(log N)\n.\nWhy Is Binary Search Logarithmic?\nRepeatedly dividing something creates a logarithmic function (note the emphasis on the word repeated here). If you divide something once, it does not change the asymptotic nature of the function. This code below would still be considered linear, not logarithmic:\ndef linear(n):\nfor i in range(n/2):\nprint(i)\n1def linear(n):\n2 for i in range(n/2):\n3 print(i)\n4\nBut if we are repeatedly dividing something, we are doing something inherently logarithmic with it. See the below code as an example:\ndef logarithmic(n):\nwhile n > 1:\nn = n / 5\nprint(n)\n1def logarithmic(n):\n2 while n > 1:\n3 n = n / 5\n4 print(n)\n5\nNote we use the word \"division\" and not \"half\", because you don't need to divide by two in order to get logarithmic functions. In fact, the larger the divisor, the faster the logarithmic operation is. In the example above, we don't halve the input, we divide it by 5.\nSo in binary search, we can see that we are repeatedly dividing the array in half and exploring smaller and smaller sections of it. This gives us a logarithmic runtime for binary search.\ndef binary\\_search(nums, target):\nleft, right = 0, len(nums) - 1\nwhile left <= right:\nmid = left + (right - left) // 2 # ← repeated division in a loop!\nif nums[mid] == target:\nreturn mid\nelif nums[mid] < target:\nleft = mid + 1\nelse:\nright = mid - 1\nreturn -1\n1def binary\\_search(nums, target):\n2 left, right = 0, len(nums) - 1\n3 while left <= right:\n4 mid = left + (right - left) // 2 # ← repeated division in a loop!\n5 if nums[mid] == target:\n6 return mid\n7 elif nums[mid] < target:\n8 left = mid + 1\n9 else:\n10 right = mid - 1\n11 return -1\n12\n13\nWhen to Use Binary Search in Interviews\nBinary search is a vital tool for software engineering interviews, especially when dealing with problems involving sorted arrays or lists. The scenario of using binary search can be broken down into several categories – let's start with the usual ones before moving to the advanced uses:\n- Searching an element in a sorted array or list: This is the most direct use case for binary search. If the problem involves finding an element in a sorted list or array, binary search should be your first instinct. Usually you won't get a question as direct as \"given a sorted array, find if X is in the array.\" However, you will often need to find Note the word \"sorted\" here. Binary search will not work if the input isn't sorted, since the sorting determines the direction we can choose to move.\n- Rotated Arrays: Problems involving rotated sorted arrays often lend themselves to solutions using binary search, for example finding a target value in a rotated array.\n- Finding boundaries: Binary search can be used to find the first or last occurrence of a value in a sorted array, or to determine the lower or upper bound of a range.\n- Optimization problems: Some optimization problems can be solved using binary search, especially those which require finding a specific threshold or breakpoint within a given range.\nThree Sum Example\nLet's discuss binary search in the context of a specific problem: Three Sum.\nThis problem is presented as the following:\nFind a unique triplet in an array that sums up to 0.\nAn example input and output could look like this:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [-1,-1,2] or [-1, 0, 1]\nWhile it is not the most optimal solution to solve the 3Sum problem, this problem can be solved with a binary search. At first glance, it might not be immediately clear how binary search fits into this problem though! The immediate solution most people consider is a brute force and involves three nested loops trying every possible combination of 3 numbers until one results in a valid solution. However, binary search can be incredibly useful when you want to reduce the search space and increase the speed of your algorithm. The brute force is cubic O(N^3)\nbecause of the three nested loops.\nAfter some thought, we might realize that the 3rd loop is just a linear search for a specific number. If the goal is for the three numbers to sum to zero and the first two numbers from the first two loops are -3 and -2 then we are using the 3rd and final loop to look specifically for the number 5 in the array. This is known as finding the complement of the first two numbers.\nHere's the general approach for the 3Sum problem using binary search:\n- Sort the array: This is the initial step which will facilitate the use of binary search and ensure the output triplets are not duplicates. Sorting the array will have a time complexity of\nO(n log n)\n. - Iterate over the array: For each index 'i' of the array, we'll try to find two other indices 'j' and 'k', such that the sum of the values at these indices equals zero. 'j' starts as the next index after 'i', and 'k' starts as the last index of the array.\n- Binary Search: For each 'i' and 'j', we calculate the required value to reach the target as\n(0 - nums[i] - nums[j])\n. Now, we perform binary search on the array to find this value.\nThe sorting operation gives us a time complexity of O(n log n)\n, the two nested loops contribute a time complexity of O(n^2)\n, and within the innermost loop, we perform a binary search contributing a time complexity of O(log n)\n. Thus, the overall time complexity for this solution is O(n^2 log n)\n. Although this isn't the most efficient solution for the 3Sum problem (there's an O(n^2)\nsolution using two pointers), it demonstrates how binary search can be applied in scenarios where it may not be immediately obvious to do so.\nAdvanced Binary Search\nBinary Search on 2D Matrices\nAfter you understand Binary Search on a one-dimensional array, you can explore multi-dimensional array binary search. This is a favorite type of question that Google asks. The most common multidimensional array binary search is a 2D matrix search, but there do exist three and even four dimensional search questions.\nReal Problem Example: Search a 2D Matrix\nBinary Search on a Continuous Search Space\nThis version of binary search is used in problems where the “search space” is continuous rather than discrete. This can be useful for certain optimization problems. By continuous we mean the solutions could take on any value within a certain range, not just certain specific values. The range between 0 and 1, for instance, is infinite so finding an exact decimal in an infinite search space is tricky.\nThis can also apply in multidimensional continuous spaces. For example, if we are trying to find the minimum value of a continuous function, we might use a variant of binary search known as the \"binary search on two points,\" where we divide our current range into three subranges and eliminate the subrange that has the highest function value.\nOverall, binary search in continuous spaces can be a powerful tool for finding solutions to problems that involve continuous ranges or functions.\nReal Problem Example: Find Minimum in Rotated Sorted Array\nBinary Search with Doubling\nThis is a variant of binary search where the bounds of the search are not known in advance. An initial range is established by repeatedly doubling the upper bound until it is beyond the target, then binary search is applied within the determined bounds. The key idea is to start with a small subarray size and to exponentially expand the subarray size until the subarray end exceeds the target value or the end of the full array.\nExponential search can be particularly efficient when searching for an item near the beginning of the array. If the target element is near the start, the algorithm will find it in O(log i)\ntime where i\nis the position of the target.\nReal Problem Example: Search in a Sorted Array of Unknown Size\nSpot the Bug!\nNow you might feel empowered with knowledge and new-found appreciation for the wide range of uses with binary search, but unfortunately with these problems, the biggest issue tends to be in the implementation. It is really hard to tell just by looking at your code if it is correct or not. Let's illustrate with an example – give yourself a minute and see if you can spot the error in the binary search code below!\ndef binarySearch(arr, target):\nl , r = 0, len(arr)\nwhile l < r:\nmid = (l + r) / 2\nif arr[mid] == target:\nreturn mid\nif target > arr[mid]:\nl = mid\nelse:\nr = mid\nreturn -1\n1def binarySearch(arr, target):\n2 l , r = 0, len(arr)\n3 while l < r:\n4 mid = (l + r) / 2\n5 if arr[mid] == target:\n6 return mid\n7 if target > arr[mid]:\n8 l = mid\n9 else:\n10 r = mid\n11 return -1\nOk, did you spot the error? Trick question – depending on the language you're using and the way we count them there are actually anywhere between 4-6 errors in the above code! 🤯 Hopefully this illustrates the point that they are easy to miss! Let's walk through these errors together, one at a time.\nError 1: Right Index\ndef binarySearch(arr, target):\nl , r = 0, len(arr) - 1 # <- FIXED!\nwhile l < r:\nmid = (l + r) / 2\nif arr[mid] == target:\nreturn mid\nif target > arr[mid]:\nl = mid\nelse:\nr = mid\nreturn -1\n1def binarySearch(arr, target):\n2 l , r = 0, len(arr) - 1 # <- FIXED!\n3 while l < r:\n4 mid = (l + r) / 2\n5 if arr[mid] == target:\n6 return mid\n7 if target > arr[mid]:\n8 l = mid\n9 else:\n10 r = mid\n11 return -1\nError 2: Conditional\nConsider the edge case where we have a single element in the array which is the target that we are looking for.\narr = [5]\ntarget = 5\nl = 0\nr = 0\nIn this test case, you'll see that both the left and right pointers end up being 0 and we skip the while\nloop conditional, never going inside it, and just return -1! That's wrong! Let's fix that by making the conditional <=\nrather than just <\n.\ndef binarySearch(arr, target):\nl , r = 0, len(arr) - 1\nwhile l <= r: # <- FIXED!\nmid = (l + r) / 2\nif arr[mid] == target:\nreturn mid\nif target > arr[mid]:\nl = mid\nelse:\nr = mid\nreturn -1\n1def binarySearch(arr, target):\n2 l , r = 0, len(arr) - 1\n3 while l <= r: # <- FIXED!\n4 mid = (l + r) / 2\n5 if arr[mid] == target:\n6 return mid\n7 if target > arr[mid]:\n8 l = mid\n9 else:\n10 r = mid\n11 return -1\nError 3: Middle Index Calculation\nThe calculation of the middle index is incorrect. We need to find the center between the left and right pointers, but as it currently is coded we end up with a decimal number not a whole number. Since we are using this value to index into arrays, we need a whole number (there is no meaning in trying to access index 3.2 in an array, only whole indices like 3 and 4). So we need to make sure to either consistently round up or down – we recommend rounding down.\ndef binarySearch(arr, target):\nl , r = 0, len(arr) - 1\nwhile l <= r:\nmid = (l + r) // 2 # <- FIXED!\nif arr[mid] == target:\nreturn mid\nif target > arr[mid]:\nl = mid\nelse:\nr = mid\nreturn -1\n1def binarySearch(arr, target):\n2 l , r = 0, len(arr) - 1\n3 while l <= r:\n4 mid = (l + r) // 2 # <- FIXED!\n5 if arr[mid] == target:\n6 return mid\n7 if target > arr[mid]:\n8 l = mid\n9 else:\n10 r = mid\n11 return -1\nError 4: Middle Index Calculation Again\nAdmittedly, this next error is a bit niche, and only applies to statically typed languages like Java & C++, but it is worth knowing as a developer for historical reasons. Even after rounding down in our previous rendition this still could result in an error.\nWhenever we add two large numbers together in a statically typed language we risk potentially causing an integer overflow. Since statically typed languages allocate a specific amount of memory and no more, if you try to store a number that is too large in pre-allocated memory and you don't have enough room to store it all the value will \"overflow.\"\nThis error is not binary search specific, but for historical reasons it is well known for needing to be avoided in Binary Search specifically. This is due to an infamous bug in the Java library's implementation of binary search back in 2006.\nTo fix it, we can avoid adding two large numbers together by using a slightly different formula that accomplishes the same thing. Notice how we first make the number significantly smaller through subtraction and division before adding?\ndef binarySearch(arr, target):\nl , r = 0, len(arr) - 1\nwhile l <= r:\nmid = l + ((r - l) // 2) # <- not a problem, in python, but still a better formula\nif arr[mid] == target:\nreturn mid\nif target > arr[mid]:\nl = mid\nelse:\nr = mid\nreturn -1\n1def binarySearch(arr, target):\n2 l , r = 0, len(arr) - 1\n3 while l <= r:\n4 mid = l + ((r - l) // 2) # <- not a problem, in python, but still a better formula\n5 if arr[mid] == target:\n6 return mid\n7 if target > arr[mid]:\n8 l = mid\n9 else:\n10 r = mid\n11 return -1\n12\nError 5 & 6: Infinite Loop\nConsider the edge case where we have a single element in the array (again) but it is not the target. We will enter the second if-statement, but we set the left pointer to the middle pointer and the middle pointer is 0.\narr = [2]\ntarget = 5\nl = 0\nr = 0\nm = 0\nIn this test case, all three pointers now are 0 and since our conditional checks if l <= r this will always be the case and we will loop infinitely. 😩\nWe don't really want to change the loop conditional because we already changed it in Error 2, to avoid a different problem so instead we can set the left and right pointers to a number less than or greater than the middle (depending on the direction).\ndef binarySearch(arr, target):\nl , r = 0, len(arr) - 1\nwhile l <= r:\nmid = l + ((r - l) // 2)\nif arr[mid] == target:\nreturn mid\nif target > arr[mid]:\nl = mid + 1 # <- FIXED!\nelse:\nr = mid - 1 # <- FIXED!\nreturn -1\n1def binarySearch(arr, target):\n2 l , r = 0, len(arr) - 1\n3 while l <= r:\n4 mid = l + ((r - l) // 2)\n5 if arr[mid] == target:\n6 return mid\n7 if target > arr[mid]:\n8 l = mid + 1 # <- FIXED!\n9 else:\n10 r = mid - 1 # <- FIXED!\n11 return -1\nFinally! A working binary search! This painful walkthrough hopefully helps illustrate a key point – binary search is extremely difficult to get right just by doing it in your head and staring at the code. Since binary search is prone to so many problems the level of scrutiny your code will be given is higher than for other problems. Be sure your binary search works!\nCommon Mistakes in Interviews Featuring Binary Search\nMissing a Test Case\nIt is so easy to mess up binary search by missing a test case. This usually leads to an out-of-bounds error. This is the most common mistake in binary search questions, so take your time and test that the code works. The most common test cases that get missed are:\n- Empty Array: An empty array is a basic edge case. Your function should handle this gracefully and return an appropriate value, such as -1 for a function expected to return an index, or False for a function determining the presence of an element.\n- Single Element Array: This is the smallest non-empty array. Make sure your function can handle this, whether the single element matches the target or not.\n- Array with Two Elements: This scenario tests if your function correctly moves the left or right pointer when there are just two elements. Both cases, where the target is and is not in the array, should be considered.\n- Array with Duplicates: Duplicates can complicate a binary search, especially if you are supposed to find the first or last occurrence of the target. Test your function with an array that has duplicate values.\n- Target is the First or Last Element: This tests whether your function correctly handles cases where the target is at the boundaries of the array.\n- Target is the Middle Element: This tests where you calculate the middle element in your algorithm to make sure you don't skip it on the first iteration.\n- Target is Not in the Array: Check how your function behaves when the target is not in the array. This could include targets that are smaller than all array elements, larger than all array elements, or fall between array elements.\n- Array with Negative Numbers: If the problem statement doesn't restrict the array values to be positive, test your function with negative numbers to ensure it handles them correctly.\n- Array with All Identical Elements: This tests whether your function can correctly report the position of an element when all elements in the array are identical, and also if it correctly reports that a target is not found when the target differs from the repeated element.\n- Array is Even/Odd: This ensures you land on the target and correctly calculate the midpoint regardless of even or odd array sizes.\n- Large Arrays: Test your function with a large array to ensure that it performs well and does not lead to any issues, such as stack overflow for recursive implementations.\nHoly smokes, that's a lot of tests! At interviewing.io we have found that even after interviewees know they might be missing a test case, they aren't sure which one it is and definitely don't have time to go down such an exhaustive checklist like this, so we've come up with an easy to remember acronym that will help you cover your bases. Just ask yourself, \"Is my solution FINDABLE?\" This reminds you to check these key edge cases to ensure your binary search solution is robust.\n- First/Final: The target is the first element or last (final) element in the array.\n- Identical: The array contains multiple identical targets.\n- Non-existent: The target is not in the array.\n- Delete: The array contains only duplicate elements.\n- Alone: The array has a single element.\n- Binary: The array has two elements.\n- Large: The array is quite large.\n- Empty: The array is empty.\nWe don't explicitly call out every test case in this acronym, but when it is combined with the testing process shown below you end up covering tests that are not explicitly mentioned (i.e. we don't have a letter in the acronym that calls out testing even/odd elements or that we successfully return the middle element on the first iteration, but in following the below process we do end up testing these cases in tandem with other test cases).\nAt a glance this may seem like a lot of tests to run through, but we can make the process very fast by building up our tests in a specific order. Some tests may also not apply in a problem so they are also easy to skip over entirely. The ideal order to check your solution would be to build up from an empty array and work towards a large (well, large for a test by-hand case) number of four total elements like below:\nThis order allows us to double up testing multiple things at the same time. We can test two elements in the array while testing the final element boundary. We test identical elements (duplicates) while testing for the target being in the middle and testing a non-trivial odd number of elements. And we can test a large four-element array while testing an even number of elements.\nThe first four test cases should be able to be breezed through in 30 seconds or less with the remaining four taking slightly longer than that. While this isn't an exhaustive set of test cases, they are the ones most likely to catch bugs, so you can spend less than 2 minutes on this process in total and still feel very confident that your answer is correct.\nForgetting Sorting Adds to the Time Complexity\nMost candidates are familiar with the fact that standard comparison-based sorting takes O(N log N)\ntime complexity, but forget to account for it in their solution. In the Three Sum question above, sorting the array takes just one line in the solution and candidates end up missing it in their overall time complexity analysis because it is so easy to skip over.\nLogically Deduce Binary Search with Big-O\nAn advanced strategy for discovering the optimal solution to a problem is to discuss the time complexity with the interviewer. If you suggest a linear solution to a problem and try to confirm if it is optimal with the interviewer, you might get pushback on it or be told that \"it's decent for now, maybe we can optimize later.\" This is actually a large hint towards binary search.\nWalking through the time complexities, if we are told we can optimize a linear time algorithm, this points directly to a logarithmic algorithm and binary search is the most common algorithm with this time complexity. Being able to logically deduce binary search given the constraints of the problem shows mastery over the topic.\nDiscuss Edge Cases Proactively\nAbove we outline many edge cases for binary search. While you could go through them all in your head, you demonstrate mastery by communicating these edge cases. Checking these test cases quietly will bore your interviewer, but explaining the many test cases you are doing simultaneously shows mastery in the interview.\nBinary Search Frequently Asked Questions (FAQ)\nHere are some commonly asked questions about binary search that you might encounter or want to consider:\nShould I Use Recursive or Iterative Binary Search?\nUsually when we have the \"recursive versus iterative\" debate with an algorithm it is with DFS and BFS. For these algorithms it mostly doesn't matter which one you pick because you don't save any space by solving the problem iteratively versus recursively. In an iterative DFS you need to explicitly create a Stack just as you explicitly create a Queue in BFS. Recursive DFS uses the built in call stack, so you still end up using space for the stack.\nIn binary search, you don't need a stack so using recursion (and the implicit call stack) uses more space than the iterative approach. With that said, the difference between space complexities isO(1)\nvs O(log N)\n. It's a small amount of space, so it doesn't really matter much from this perspective. Here at interviewing.io we prefer the iterative approach less because of the space savings and more because it is easier to walk through the plethora of test cases and not get lost. At the end of the day, pick what works best for you!\nWhy Is Binary Search Preferred Over Linear Search?\nHopefully this isn't a question you still have at this point! Binary search is preferred because of its time efficiency. It has a time complexity of O(log n)\nwhich makes it significantly faster than linear search (O(n)\n) on large datasets.\nHow Do You Handle Duplicates in Binary Search?\nThis depends on the specific requirements of the problem. If the problem is simply to find if an element exists, then any occurrence can be returned. If the problem specifies finding the first or last occurrence, then the binary search algorithm can be slightly modified to handle these cases.\nCan I Use Binary Search on a Linked List?\nTechnically, yes, but it's not efficient. Binary search requires random access to elements, which is not possible with linked lists. Hence, using binary search on a linked list would still require O(n)\ntime to access elements (specifically the \"right pointer\"), negating the benefits of using binary search in the first place.\nAbout the Author\nMike Mroczka, a former senior SWE (Google, Salesforce, GE), is the primary author of Beyond Cracking the Coding Interview—the official sequel to Gayle McDowell's original CTCI. He works as a tech consultant and has a decade of experience helping engineers land their dream jobs. He’s a top-rated mentor (interviewing.io, Karat, Pathrise, Skilled.inc) and the author of viral technical content on system design and technical interview strategies featured on HackerNews, Business Insider, and Wired. He also sometimes writes technical content for interviewing.io (like this piece) and was one of the authors of interviewing.io’s A Senior Engineer's Guide to the System Design Interview.\nYou can find him online at mikemroczka.com, LinkedIn, and X.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/binary-search-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Binary Trees Interview Questions & Tips for Senior Engineers",
      "content": "Binary Trees Interview Questions & Tips\nWhat is a Binary Tree?\nA binary tree is a type of tree data structure where each node can have at most two children, typically referred to as the left child and the right child. This binary structure allows for efficient searching, insertion, and deletion operations, especially when further rules are applied to the tree to express different types of binary trees.\nHere's an example of a binary tree node implementation:\nclass BinaryTreeNode {\nInteger data = null;\nBinaryTreeNode left = null;\nBinaryTreeNode right = null;\nBinaryTreeNode(Integer value) {\ndata = value;\n}\n}\n1class BinaryTreeNode {\n2 Integer data = null;\n3 BinaryTreeNode left = null;\n4 BinaryTreeNode right = null;\n5\n6 BinaryTreeNode(Integer value) {\n7 data = value;\n8 }\n9}\nGiven that not all nodes need to have two children, binary trees can be tall or wide, and everything in between. If each node in a binary tree only has one child (except for leaves), the tree would be much taller than it is wide. On the other hand, if most or all the nodes in a binary tree have two children, then the tree would be considered balanced.\nSpecifically, we can view binary trees as being balanced or unbalanced by this measure: a binary tree is balanced when the heights of the left and right subtrees of any node differ by at most one. \\*\\*The height of a tree is determined by the number of edges in the longest path from the root to a leaf. \\*\\*\nThe main advantage of a balanced binary tree is that we can achieve optimal performance for searching, adding and deleting operations - by maintaining logarithmic height, these operations can be performed in O(log n) time complexity on average.\nExamples of balanced binary trees are AVL trees and Red-Black trees. These are considered advanced topics, sometimes found in database implementations along with other use-cases, and rarely come up in interview questions. More often, when discussing binary tree optimizations, we encounter binary search trees.\nWhat is a Binary Search Tree (BST)?\nA common implementation of a binary tree is a binary search tree. Right there in the name, the binary search tree enables efficient implementation of the binary search algorithm thanks to the way the binary tree is organized: for each node in the tree, the value of the node is greater than the value of all the nodes in its left subtree and smaller than the value of all the nodes in its right subtree.\nDue to the tree's binary search property, this structure enables a systematic and efficient search process. When searching for a target value, comparisons are made at each node to determine whether to process the left or the right subtree. This allows for the elimination of half of the remaining search space at each step, resulting in a worst-case time complexity of O(log n) for searching, where n is the number of nodes in the tree.\nThe height of a binary search tree affects the efficiency of the operations. Balanced binary search trees, such as AVL trees or Red-Black trees, maintain a balanced structure to ensure logarithmic time complexity for operations.\nImplementing a Binary Search Tree\nTo create a binary search tree, the insertNode method will enforce the binary search property. Traversing from the root, insertNode will recursively search for the correct position to add the new node by checking the binary condition: if the currentNode is larger than the new node, traverse left, if the currentNode is smaller than the new node, traverse right. Search will apply the same logic, but return if the target is found.\nInsert\nprivate BinaryTreeNode insertNode(BinaryTreeNode root, int key) {\nif (root == null) {\nreturn new BinaryTreeNode(key);\n}\nif (key < root.data) {\nroot.left = insertNode(root.left, key);\n} else if (key > root.data) {\nroot.right = insertNode(root.right, key);\n}\n// if the input key already exists, we don't do anything.\nreturn currentNode;\n}\n1private BinaryTreeNode insertNode(BinaryTreeNode root, int key) {\n2 if (root == null) {\n3 return new BinaryTreeNode(key);\n4 }\n5\n6 if (key < root.data) {\n7 root.left = insertNode(root.left, key);\n8 } else if (key > root.data) {\n9 root.right = insertNode(root.right, key);\n10 }\n11\n12 // if the input key already exists, we don't do anything.\n13 return currentNode;\n14 }\nprivate BinaryTreeNode deleteNode(BinaryTreeNode root, Integer key) {\nif (root == null) {\nreturn root;\n}\nif (key < root.data) {\nroot.left = deleteNode(root.left, key);\n} else if (data > root.data) {\nroot.right = deleteNode(root.right, key);\n} else {\n// Node to be deleted is found\n// Case 1: Node has no child or only one child\nif (root.left == null) {\nreturn root.right;\n} else if (root.right == null) {\nreturn root.left;\n}\n// Case 2: Node has two children\nroot.data = minValue(root.right);\nroot.right = deleteNode(root.right, root.data);\n}\nreturn root;\n}\nprivate Integer minValue(BinaryTreeNode root) {\nInteger minValue = root.data;\nwhile (root.left != null) {\nminValue = root.left.data;\nroot = root.left\n}\nreturn minValue;\n}\n1private BinaryTreeNode deleteNode(BinaryTreeNode root, Integer key) {\n2 if (root == null) {\n3 return root;\n4 }\n5\n6 if (key < root.data) {\n7 root.left = deleteNode(root.left, key);\n8 } else if (data > root.data) {\n9 root.right = deleteNode(root.right, key);\n10 } else {\n11 // Node to be deleted is found\n12\n13 // Case 1: Node has no child or only one child\n14 if (root.left == null) {\n15 return root.right;\n16 } else if (root.right == null) {\n17 return root.left;\n18 }\n19\n20 // Case 2: Node has two children\n21 root.data = minValue(root.right);\n22 root.right = deleteNode(root.right, root.data);\n23 }\n24\n25 return root;\n26 }\n27\n28private Integer minValue(BinaryTreeNode root) {\n29 Integer minValue = root.data;\n30 while (root.left != null) {\n31 minValue = root.left.data;\n32 root = root.left\n33 }\n34 return minValue;\n35}\nTraversal Order in a Binary Tree\nA common task with binary trees is traversing the data structure, since without random access, this is the only way to do anything with our data: search, add, delete, print, etc. In addition to selecting an appropriate traversal algorithm, we also need to determine the order in which we want to visit the nodes.\nAt a high level, there are two types of traversals: depth-first search (DFS) and breadth-first search (BFS). To explore these algorithms generally, you should read more about DFS and BFS. But in this article, we'll specifically discuss how traversal order is important for binary tree traversal.\nDFS is a search algorithm that traverses a tree data structure by prioritizing exploring deeper paths from from child node to child node until a leaf node is finally visited or some condition is met. When visiting each node in a binary tree, the DFS algorithm has three operations it needs to perform in some order: \"visit the node\", which means perform some work (eg. print the value, add to some counter, delete it, etc), traverse down the left subtree, and traverse down the right subtree. The order of these three operations has a huge impact on the ultimate traversal order, so we further subdivide DFS into preorder, inorder, and postorder traversal.\nAs an alternative to DFS, the BFS algorithm prioritizes visiting all the direct children at the same level before moving deeper into the tree. With this pattern, there is only one possible traversal order, which is called level-order traversal.\nLet's explore these traversal orders more closely.\nDepth-First Search (DFS)\nConsider an example where we are printing all the nodes of the binary search tree from before using a DFS traversal.\nInorder Traversal\nInorder traversal is a process for visiting each node in a binary tree by first visiting the left subtree, then the node itself, and then the right subtree. With inorder traversal, the path always favors the leftmost tree before traversing the rest.\nThe sequence produced with inorder traversal: 1, 3, 4, 6, 7, 8, 10, 13, 14.\nIn a binary search tree, inorder traversal results in visiting the nodes in ascending order. This is because by favoring resolving the left subtree at each node, at each node we are always moving toward the smallest value available and returning the inorder successor.\nvoid inorderTraversal(BinaryTreeNode node) {\n// base case: if node is null, do nothing\nif (node != null) {\n// recurse on left child\ninorderTraversal(node.left);\n// visit current node\nSystem.out.print(node.data + \" \");\n// recurse on right child\ninorderTraversal(node.right);\n}\n}\n1void inorderTraversal(BinaryTreeNode node) {\n2 // base case: if node is null, do nothing\n3 if (node != null) {\n4 // recurse on left child\n5 inorderTraversal(node.left);\n6\n7 // visit current node\n8 System.out.print(node.data + \" \");\n9\n10 // recurse on right child\n11 inorderTraversal(node.right);\n12 }\n13}\nPreorder Traversal\nPreorder traversal visits each node in the tree by first visiting the node itself, then traversing the left subtree, and finally traversing the right subtree. In each recursive call, the function first prints (or \"visits\") the current node, then calls the recursive function on the left subtree, and finally on the right subtree.\nThe sequence produced with preorder traversal: 8, 3, 1, 6, 4, 7, 10, 14, 13\nvoid preorderTraversal(BinaryTreeNode node) {\n// base case: if node is null, do nothing\nif (node != null) {\n// visit current node\nSystem.out.print(node.data + \" \");\n// recurse on left child\npreorderTraversal(node.left);\n// recurse on right child\npreorderTraversal(node.right);\n}\n}\n1void preorderTraversal(BinaryTreeNode node) {\n2 // base case: if node is null, do nothing\n3 if (node != null) {\n4 // visit current node\n5 System.out.print(node.data + \" \");\n6\n7 // recurse on left child\n8 preorderTraversal(node.left);\n9\n10 // recurse on right child\n11 preorderTraversal(node.right);\n12 }\n13}\nPostorder Traversal\nIn each recursive call, the function first performs DFS on the left subtree, then performs DFS on the right subtree, and finally visits the current node.\nThe sequence produced with postorder traversal: 7, 6, 4, 1, 3, 13, 14, 8\nvoid postorderTraversal(BinaryTreeNode node) {\n// base case: if node is null, do nothing\nif (node != null) {\n// recurse on left child\npostorderTraversal(node.left);\n// recurse on right child\npostorderTraversal(node.right);\n// visit current node\nSystem.out.print(node.data + \" \");\n}\n}\n1void postorderTraversal(BinaryTreeNode node) {\n2 // base case: if node is null, do nothing\n3 if (node != null) {\n4 // recurse on left child\n5 postorderTraversal(node.left);\n6\n7 // recurse on right child\n8 postorderTraversal(node.right);\n9\n10 // visit current node\n11 System.out.print(node.data + \" \");\n12 }\n13}\nPostorder traversal is often used to delete the nodes of a tree in a specific order, because we can easily reconstruct the node references. We are basically marking the exact path of the recursive calls by immediately printing each node as it is visited.\nBreadth-First Search (BFS)\nLevel Order Traversal\nAs an alternative to using DFS we can also traverse a binary tree using Breadth-First Search (BFS), where we visit each node belonging to the same level before moving deeper into the tree. BFS uses a queue data structure (instead of a stack or recursion), in order to maintain the level-order traversal.\nThe sequence produced with level order traversal: 8, 3, 10, 1, 6, 14, 4, 7, 13\nLevel order traversal in a binary tree is often applied to problems where we need to process tree nodes by level, or if we want to find the shortest distance between two nodes.\npublic static void levelOrderTraversal(TreeNode root) {\nif (root == null)\nreturn;\nQueue < TreeNode > queue = new LinkedList < > ();\nqueue.offer(root);\nwhile (!queue.isEmpty()) {\nTreeNode node = queue.poll();\nSystem.out.print(node.val + \" \");\nif (node.left != null)\nqueue.offer(node.left);\nif (node.right != null)\nqueue.offer(node.right);\n}\n}\n1public static void levelOrderTraversal(TreeNode root) {\n2 if (root == null)\n3 return;\n4\n5 Queue < TreeNode > queue = new LinkedList < > ();\n6 queue.offer(root);\n7\n8 while (!queue.isEmpty()) {\n9 TreeNode node = queue.poll();\n10 System.out.print(node.val + \" \");\n11\n12 if (node.left != null)\n13 queue.offer(node.left);\n14\n15 if (node.right != null)\n16 queue.offer(node.right);\n17 }\n18}\nTime and Space Complexity\nTime complexity: O(n)\n, where n is the number of nodes. If we're not explicitly performing binary search, we will visit every node at worst in a traversal.\nSpace complexity: O(n)\n, additional space is needed on the call stack when performing recursion.\nWhen to Use Binary Trees In Technical Interviews\nMost of the time, interview questions involving trees will be explicitly stated as such. The problem will come in the form of “Given a tree, do X”. Sometimes, the task may be challenging but not very ambiguous, for example validating a binary search tree. The most important thing when you see problems like this is to make sure that you understand what type of tree you’re dealing with. If it’s a BST, that has different implications than a binary tree that is not sorted, and could provide valuable clues for arriving at an optimal solution.\nIn other cases, we might be asked to store data efficiently - this could be an opportunity to implement a BST. A common interview task is to implement the insertion and search functions of a BST, as this is a great way to demonstrate one's understanding of the data structure, so be sure to practice these. Deleting a node from a BST can be asked as well but is often considered an advanced topic.\nFor generic binary trees, questions often involve assessing the dimensions of the tree, for example the height or diameter of the tree, or searching specific conditions between two or more nodes in the tree, like LCA or path sum. Here are some areas that come up often in interviews:\n- Height: Calculate the height of a binary tree (the number of edges on the longest path from the root to a leaf node).\n- Find Mirror Image: Determine if a binary tree is a mirror image of itself (symmetric).\n- Lowest Common Ancestor (LCA): Given two nodes in a binary tree, find their lowest common ancestor node.\n- Diameter of a Tree: Calculate the diameter of a binary tree (the length of the longest path between any two nodes).\n- Path Sum: Check if there exists a root-to-leaf path in a binary tree that adds up to a given sum. 6.Serialize and Deserialize: Serialize a binary tree into a string representation and deserialize it back to a binary tree.\nCommon Mistakes in Interviews Featuring Binary Trees\n- Mistaking a Binary Tree for a Binary Search Tree. Remember that an interviewer might intentionally leave information out of their problem description to leave room for your inquiries. The difference between a general binary tree and a BST will greatly influence the solution you propose.\n- Forgetting to consider duplicate keys when implementing a BST. Paying close attention to implementation details will help demonstrate your familiarity with the data structure.\n- Not using visual aids. Binary tree logic can become very complex, given its recursive nature. Using tree diagrams can help you work through the problem and communicate more effectively with your interviewer.\n- Misusing BFS or DFS. In some binary tree problems, where we don't have a sorted tree or we simply need to visit every node to perform some operation, both traversal algorithms are applicable without any meaningful complexity tradeoff. But a candidate needs to be confident about which situations call for a specific traversal. A common use-case for BFS, for example, is searching for the shortest path between two nodes. DFS on the other hand, is useful to perform on a binary search tree when we want to traverse the nodes in their sorted order.\n- Forgetting to set min/max bounds when validating binary search trees. An incorrect implementation just checks whether node.right.data > node.left.data and node.left.data < node.right.data\n- Not knowing how to use recursion within trees. Trees are inherently recursive data structures, so it's important to be familiar with recursive traversal. It may be obvious how to traverse from parent to child, but using recursive to traverse from child to parent (with return statement) is essential.\n- Incorrectly stating space complexity for recursive traversal. It is easy to forget that recursion doesn't use additional space since we are not introducing a new data structure. But in fact, we are taking advantage of an existing stack call the call stack, which must grow linearly with the number of nodes we are recursing on.\n- Forgetting to handle edge cases. Binary tree nodes can still have zero or one child, so be sure to explicitly check for edge cases. We also need to include base cases for recursive traversals.\nClarifying Questions to Ask Your Interviewer About Binary Trees\n- Is the input binary tree or a binary search tree? Clarifying the parameters offered by the interviewer is a great problem-solving skill to demonstrate. In some cases, interviewers will intentionally omit that the binary tree you're working with is actually sorted, so be sure to ask! This of course will have a huge impact on the approach you'll end up taking for your solution.\n- Will the input contain duplicate values? Whether you are streaming values or getting a tree as input, make sure to specify if duplicates need to be handled, as this complicates binary search tree implementation. For binary search trees, this is especially complicated, and will likely be the crux of the problem if the tree contains them. Alternatively, you might be building a BST from a stream of values, and you'll want to be sure you can omit duplicates if its appropriate in the problem.\n- How do we handle scenarios where a binary tree is empty or has null nodes? It is always encouraged to ask about how edge cases should be handled, as some interviewers will be happy enough that you communicated that you are aware of them, and will offer to let you skip implementation.\n- What operations need to be supported? If you'll be implementing a binary tree, make sure to ask your interviewer what operations to prioritize during the interview. In some cases, they can allow you to skip the implementation of some less-important operations.\n- What are the characteristics of the input tree? Be sure to determine if there are any constraints that the input binary tree adheres to, such as balancing or sorting, max height, weighted branches, etc. If so, this would be a clue as to what kind of tree data structure you should focus on during the interview.\nHow to Show Mastery of Trees in Interviews\nKnow Your BST\nOne of the most common topics in software engineering interviews is the Binary Search Tree. You want to be able to showcase your ability to implement binary trees efficiently and correctly. Make sure to practice implementing tree construction, node insertion, deletion, and traversal algorithms.\nSpeaking of traversal algorithms - many interview problems test your understanding of the traversal order, especially when working with binary search trees, since the output sequence order is not arbitrary. Be sure to understand the use-cases for preorder, inorder, postorder, and level-order traversals.\nBe Familiar with Recursive and Iterative Implementations of DFS\nAlthough trees are inherently recursive, and thus lend themselves to recursive traversal implementations, a candidate should be comfortable with the iterative implementation as well. This helps demonstrate your strong understanding of recursion as well, since we can mimic the recursive mechanism we get from the call stack with a stack we implement ourselves. The above traversals are all recursive - here's an example of an iterative DFS:\nIterative DFS\npublic static void iterativeDFS(BinaryTreeNode root) {\nif (root == null)\nreturn;\nStack < BinaryTreeNode > stack = new Stack < > ();\nstack.push(root);\nwhile (!stack.isEmpty()) {\nBinaryTreeNode node = stack.pop();\nSystem.out.print(node.val + \" \");\n// Push right child first (since it needs to be processed after left child)\nif (node.right != null)\nstack.push(node.right);\n// Push left child\nif (node.left != null)\nstack.push(node.left);\n}\n}\n1public static void iterativeDFS(BinaryTreeNode root) {\n2 if (root == null)\n3 return;\n4\n5 Stack < BinaryTreeNode > stack = new Stack < > ();\n6 stack.push(root);\n7\n8 while (!stack.isEmpty()) {\n9 BinaryTreeNode node = stack.pop();\n10 System.out.print(node.val + \" \");\n11\n12 // Push right child first (since it needs to be processed after left child)\n13 if (node.right != null)\n14 stack.push(node.right);\n15\n16 // Push left child\n17 if (node.left != null)\n18 stack.push(node.left);\n19 }\n20}\nAbout the Author\nKenny is a software engineer and technical leader with four years of professional experience spanning Amazon, Wayfair, and U.S. Digital Response. He has taught courses on Data Structures and Algorithms at Galvanize, helping over 30 students land new software engineering roles across the industry, and has personally received offers from Google, Square, and TikTok.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/binary-trees-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Breadth-first search (BFS) Interview Questions & Tips for Senior Engineers",
      "content": "An essential aspect of working with graphs and trees is understanding how to traverse the search space. Traversal is the process of systematically visiting each node exactly once following a specific order or pattern. This allows us to search for a node or to trace a specific path through the data structure.\nUnlike a linear data structure like an array or a linked list - where each node points to only one subsequent node - graphs and trees offer multiple distinct paths to take through the structure. The example below illustrates the many paths that exist through a tree and the single path through a linked list.\nDifferent traversal algorithms will produce different traversal orders - knowing which to deploy and when enables us to solve problems more efficiently, and sometimes offers the only way to solve a particular problem. Let's look at how a specific traversal algorithm can be used! At the highest level, there are two main traversal algorithms: Depth-First Search (DFS), which is further distinguished with pre-order, in-order, and post-order traversal when specifically considering DFS in a binary tree, and Breadth-First Search (BFS). In this article, we'll focus on BFS.\nKeep in mind that while we can manipulate the traversal path with different algorithms, unless the data structure is ordered in a particular way (like a BST) or our algorithm applies additional logic to omit certain paths, each traversal algorithm will ultimately visit each node once. DFS and BFS are considered blind search algorithms as they do not apply any domain-driven heuristic. Instead, the algorithms only apply traversal rules and a terminal case to determine if a goal state is reached.\nNote: Since trees are merely directional, acyclic graphs, we'll just refer to both as graphs in the remainder of this article. Everything discussed below is relevant to trees as well as generic graphs, and in cases where that's not true, it will be pointed out as such.\nWhat is Breadth-First Search (BFS)?\nBreadth-first search (BFS) is an algorithm for traversing tree or graph data structures. Given a node, the algorithm explores all the neighbor nodes first before moving to the next level neighbors, repeating this process until there are no more nodes to visit.\nUnlike depth-first search, which traverses as far as possible down a branch as it processes nodes, breadth-first search explores the graph level by level - it's often also referred to as level-order traversal. The result is that all the nodes on a single level are visited at once and grouped together.\nStarting at the root node, the algorithm visits all the neighbor nodes of a particular node, as well as all the neighbor nodes of the parents at the same level as our current node, before moving to the next level.\nCompanies That Ask Breadth-First Search (BFS) Questions\nBFS Implementation\nBFS typically uses a queue data structure to store the nodes that are waiting to be explored, guaranteeing a FIFO processing order. When a node is visited, all its neighbors are added to the queue in the order they are found. The next node that is visited is grabbed from the front of the queue, whose neighbors are also added to the queue - the queue ensures that nodes are visited in the order they were added. The process continues until all the nodes have been explored or a target state is found.\nHere's an overview of the BFS algorithm:\n- Create a visited set to keep track of visited nodes to avoid revisiting them.\n- Create a queue data structure (FIFO) to store the nodes to be processed.\n- Enqueue the starting node onto the queue and mark it as visited.\n- While the queue is not empty, perform the following steps:\n- Dequeue a node from the front of the queue.\n- Process the dequeued node (e.g., print or perform operations).\n- Enqueue all unvisited neighbors of the dequeued node onto the queue and mark them as visited.\n- Repeat step 4 until the queue becomes empty.\nImagine we have a graph with the following node structure:\nclass Node:\ndef \\_\\_init\\_\\_(self, id):\nself.\\_id = id\nself.\\_neighbors = []\n1class Node:\n2 def \\_\\_init\\_\\_(self, id):\n3 self.\\_id = id\n4 self.\\_neighbors = []\n5\nBFS will iteratively add elements to a queue processing all the neighbor nodes until none are left.\nfrom collections import deque\nclass Graph:\ndef \\_\\_init\\_\\_(self):\nself.visited = set()\ndef bfs(self, start\\_node):\nqueue = deque([start\\_node])\n# Mark the starting node as visited\nself.visited.add(start\\_node)\nwhile queue:\n# Dequeue a node from the front of the queue\ncurrent\\_node = queue.popleft()\n# Process the dequeued node\nprint(current\\_node.id)\nfor neighbor in current\\_node.neighbors:\nif neighbor not in self.visited:\n# Enqueue unvisited neighbors\nqueue.append(neighbor)\n# Mark the neighbor as visited\nself.visited.add(neighbor)\n# Create Nodes and add neighbors\nnode1 = Node(1)\nnode2 = Node(2)\nnode3 = Node(3)\nnode1.add\\_neighbor(node2)\nnode2.add\\_neighbor(node3)\n# Create a Graph object and perform BFS\ng = Graph()\ng.bfs(node1)\n1from collections import deque\n2\n3class Graph:\n4 def \\_\\_init\\_\\_(self):\n5 self.visited = set()\n6\n7 def bfs(self, start\\_node):\n8 queue = deque([start\\_node])\n9\n10 # Mark the starting node as visited\n11 self.visited.add(start\\_node)\n12\n13 while queue:\n14 # Dequeue a node from the front of the queue\n15 current\\_node = queue.popleft()\n16\n17 # Process the dequeued node\n18 print(current\\_node.id)\n19\n20 for neighbor in current\\_node.neighbors:\n21 if neighbor not in self.visited:\n22 # Enqueue unvisited neighbors\n23 queue.append(neighbor)\n24 # Mark the neighbor as visited\n25 self.visited.add(neighbor)\n26\n27# Create Nodes and add neighbors\n28node1 = Node(1)\n29node2 = Node(2)\n30node3 = Node(3)\n31node1.add\\_neighbor(node2)\n32node2.add\\_neighbor(node3)\n33\n34# Create a Graph object and perform BFS\n35g = Graph()\n36g.bfs(node1)\n37\nBFS is useful for finding the shortest path between two nodes in a graph or finding the shortest path from a source node to all other nodes in a graph. It is also used for finding all nodes in a graph that are at a certain distance from a given node.\nTime and Space Complexity\nTime and Space Complexity\nTime complexity: O(V + E)\n, where V\nis the number of vertices and E\nis the number of edges.\nSpace complexity: O(V)\n, where V\nis the number of vertices. This primarily depends on the storage of the visited vertices and the queue used for traversal\nTime and Space Complexity\nTime complexity: O(V + E)\n, where V\nis the number of vertices and E\nis the number of edges, as it must process each vertex and each edge exactly once.\nSpace complexity: O(V\n), where V\nis the number of vertices, as it requires a position in the stack for each vertex.\nWhen to Use BFS in Technical Interviews\n- Finding the shortest distance between two nodes: Problems that require finding the shortest path between nodes are surely meant to test your understanding of BFS. This is often implemented in problems that involve a matrix or a graph that models some physical space, where we are asked to find the shortest distance between two particular cells. BFS prioritizes the nearest nodes first when traversing, which means we can use it to find the shortest path between two nodes, or the minimum number of steps required to reach a goal node or condition.\n- When we need to compare a parent to its direct children: Since BFS explores all neighbors of a node before moving on to the next level, this algorithm is useful in scenarios where we want to consider all the children before moving on. This is useful in problems where we need to analyze the relationship between all parents and their direct children.\n- When we need to print or analyze data by level in the graph or tree: BFS is also sometimes referred to as \"level-order traversal\", since we can track all the nodes at a given level. It's useful when we need to batch together all nodes that are at a given level in a tree, or at a given level in a graph relative to some starting node.\n- When we want to visit nodes in increasing order of their distance from a start node: Since BFS allows us to track the depth of the algorithm relative to the starting node, it is useful in scenarios where we need to systematically visit nodes at increasing depths from a start node.\nCommon Mistakes in Interviews Featuring BFS\n- Misunderstanding the tradeoffs and benefits between DFS and BFS: Remember that in many cases both will do just fine, with little to no tradeoffs, but there are specific cases when we should use BFS (finding the shortest distance between two nodes, for example).\n- Not using the correct supporting data structure: BFS is made possible with a queue data structure, while DFS relies on a stack. It's important to be able to identify this when implementing, and to be sure not to use the wrong supporting data structure.\n- Forgetting to track visited nodes: When dealing with a graph that is not guaranteed to be directed and acyclic, it is essential to track visited nodes in order to avoid an infinite loop. Interviewers will be looking for this as a common pitfall. One way to ensure you don't forget is to perform a manual dry-run of your algorithm.\n- Choosing BFS over DFS when it's not needed: Although in many cases these are both interchangeable, one big benefit of using DFS for backtracking algorithms is that memoization can be implemented easily.\nAbout the Authors\nKenny is a software engineer and technical leader with four years of professional experience spanning Amazon, Wayfair, and U.S. Digital Response. He has taught courses on Data Structures and Algorithms at Galvanize, helping over 30 students land new software engineering roles across the industry, and has personally received offers from Google, Square, and TikTok.\nMike Mroczka, a former senior SWE (Google, Salesforce, GE), is the primary author of Beyond Cracking the Coding Interview—the official sequel to Gayle McDowell's original CTCI. He works as a tech consultant and has a decade of experience helping engineers land their dream jobs. He’s a top-rated mentor (interviewing.io, Karat, Pathrise, Skilled.inc) and the author of viral technical content on system design and technical interview strategies featured on HackerNews, Business Insider, and Wired. He also sometimes writes technical content for interviewing.io (like this piece) and was one of the authors of interviewing.io’s A Senior Engineer's Guide to the System Design Interview.\nYou can find him online at mikemroczka.com, LinkedIn, and X.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/breadth-first-search-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Buckets Interview Questions & Tips for Senior Engineers",
      "content": "About interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/buckets-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Depth-First Search (DFS) Interview Questions & Tips for Senior Engineers",
      "content": "An essential aspect of working with graphs and trees is understanding how to traverse the search space. Traversal is the process of systematically visiting each node exactly once following a specific order or pattern. This allows us to search for a node or to trace a specific path through the data structure.\nUnlike a linear data structure like an array or a linked list - where each node points to only one subsequent node - graphs and trees offer multiple distinct paths to take through the structure. The example below illustrates the many paths that exist through a tree and the single path through a linked list.\nDifferent traversal algorithms will produce different traversal orders - knowing which to deploy and when enables us to solve problems more efficiently, and sometimes offers the only way to solve a particular problem. Let's look at how a specific traversal algorithm can be used! At the highest level, there are two main traversal algorithms: Depth-First Search (DFS), which is further distinguished with pre-order, in-order, and post-order traversal when specifically considering DFS in a binary tree, and Breadth-First Search (BFS). In this article, we'll focus on DFS.\nKeep in mind that while we can manipulate the traversal path with different algorithms, unless the data structure is ordered in a particular way (like a BST) or our algorithm applies additional logic to omit certain paths, each traversal algorithm will ultimately visit each node once. DFS and BFS are considered blind search algorithms as they do not apply any domain-driven heuristic. Instead, the algorithms only apply traversal rules and a terminal case to determine if a goal state is reached.\nNote: Since trees are merely directional, acyclic graphs, we'll just refer to both as graphs in the remainder of this article. Everything discussed below is relevant to trees as well as generic graphs, and in cases where that's not true, it will be pointed out as such.\nWhat is Depth-First Search (DFS)?\nDepth-First Search (DFS) is a type of search algorithm that explores a graph by traversing as far as possible along each branch before backtracking. It's considered \"depth-first\" because at each node, if there are children, the algorithm always explores deeper paths until a leaf node is finally visited or some condition is met. The algorithm starts at the root node and explores the left and right subtrees by going deeper into the tree as it processes nodes, instead of visiting all the children of a given node before moving on.\nThere are many paths that DFS can take, given that each node can have multiple children. In fact, DFS is commonly used as a fundamental technique for backtracking algorithms - backtracking involves exploring all possible solutions to a problem (represented as paths through the data structure) by incrementally building a candidate path and undoing or \"backtracking\" when a solution is found to be invalid.\nFor binary trees, a very specific kind of graph, the order of the DFS has a big impact on the ultimate traversal order, and is very important when considering a DFS implementation. Learn more about pre-order, in-order, or post-order traversal in a binary tree here.\nCompanies That Ask DFS Questions\nDFS Implementation\nRecursive DFS\nDFS is typically implemented with recursion, which works naturally with the recursive structure of a graph. We define a function that takes a node as an argument, which handles doing work on the current node (eg. printing the value) and initiating subsequent recursive calls on its children. Note that in some implementations, we will also use a set to track already visited nodes - this is important if we don't know if the graph is acyclic, otherwise we'll cause an infinite loop.\nHere are the algorithm steps:\n- Create a\nvisited\nset to keep track of visited nodes to avoid revisiting them. - Define a recursive function (\ndfs\n) that takes the currentNode\nas a parameter. - Mark the current node as visited by adding it to the\nvisited\nset. - Process the current node. This could involve performing any desired operations on the node or checking if it matches some search criteria.\n- Iterate through the\nneighbors\nof the current node. For each unvisited neighbor, recursively call thedfs\nfunction with that neighbor as the argument. - Repeat steps 3 to 5 for all unvisited neighbors until there are no more unvisited neighbors or the search criteria are met.\nImagine we have a graph with the following node structure:\nclass Node:\ndef \\_\\_init\\_\\_(self, id):\nself.\\_id = id\nself.\\_neighbors = []\n1class Node:\n2 def \\_\\_init\\_\\_(self, id):\n3 self.\\_id = id\n4 self.\\_neighbors = []\n5\nDFS will recursively call itself on each neighbor of the node. Below, we implement the algorithm using this adjacency list graph, but the same idea would apply for graphs represented using an adjacency matrix or a Von Neumann neighborhood. The neighbor retrieval would only be different.\nAdditionally, changing the order in which we iterate over the neighbors will also change the ultimate traversal order. This is especially important when dealing with binary search trees, where the nodes are sorted in some way.\nclass Graph:\ndef \\_\\_init\\_\\_(self):\nself.visited = set()\ndef dfs(self, node):\n# Mark the current node as visited\nself.visited.add(node)\n# Process the current node\nprint(node)\n# Iterate through neighbors\nfor neighbor in node.\\_neighbors:\nif neighbor not in self.visited:\n# Recursive call with unvisited neighbors\nself.dfs(neighbor)\n# Create a Graph object\ng = Graph()\n# Assuming that startNode is already defined\ng.dfs(startNode)\n1class Graph:\n2 def \\_\\_init\\_\\_(self):\n3 self.visited = set()\n4\n5 def dfs(self, node):\n6 # Mark the current node as visited\n7 self.visited.add(node)\n8\n9 # Process the current node\n10 print(node)\n11\n12 # Iterate through neighbors\n13 for neighbor in node.\\_neighbors:\n14 if neighbor not in self.visited:\n15 # Recursive call with unvisited neighbors\n16 self.dfs(neighbor)\n17\n18# Create a Graph object\n19g = Graph()\n20# Assuming that startNode is already defined\n21g.dfs(startNode)\n22\nWe begin the traversal by passing the root in as an argument. The function calls itself by passing in the current node's neighbors as arguments for subsequent calls, and a new instance of the function is instantiated as a new frame on the call stack.\nBy using a recursive function, the algorithm keeps track of the nodes that need to be visited with the use of the call stack. When each call eventually returns – meaning, all child nodes have been traversed – the algorithm is effectively transported back to the moment that a given call was initialized.\nIterative DFS\nAlthough the structure of graphs lend themselves to recursive algorithms, this does not mean that one cannot also use iteration to traverse. Recursion is used in order to take advantage of the call stack - but we can also implement a stack of our own, removing the need for recursion.\nIterative approaches to DFS traversal involve using a loop and a stack for traversal. Using a while loop to iterate, a stack can be used to keep track of the nodes that still need to be visited, ensuring that the most recently added nodes, the closest parents, are visited first. This approach allows for efficient traversal of the tree and requires slightly less memory than recursive approaches, albeit no asymptotic change occurs.\nclass Graph:\ndef \\_\\_init\\_\\_(self):\nself.visited = set()\ndef dfs(self, node):\nstack = [node]\nwhile stack:\n# Pop the top node from the stack\ncurrent\\_node = stack.pop()\nif current\\_node not in self.visited:\n# Mark the current node as visited\nself.visited.add(current\\_node)\n# Process the current node\nprint(current\\_node)\nfor neighbor in current\\_node.\\_neighbors:\n# Push unvisited neighbors onto the stack\nstack.append(neighbor)\n# Create a Graph object\ng = Graph()\n# Assuming that startNode is already defined\ng.dfs(startNode)\n1class Graph:\n2 def \\_\\_init\\_\\_(self):\n3 self.visited = set()\n4\n5 def dfs(self, node):\n6 stack = [node]\n7\n8 while stack:\n9 # Pop the top node from the stack\n10 current\\_node = stack.pop()\n11\n12 if current\\_node not in self.visited:\n13 # Mark the current node as visited\n14 self.visited.add(current\\_node)\n15\n16 # Process the current node\n17 print(current\\_node)\n18\n19 for neighbor in current\\_node.\\_neighbors:\n20 # Push unvisited neighbors onto the stack\n21 stack.append(neighbor)\n22\n23# Create a Graph object\n24g = Graph()\n25# Assuming that startNode is already defined\n26g.dfs(startNode)\n27\nTime and Space Complexity\nTime complexity: O(V + E)\n, where V\nis the number of vertices and E\nis the number of edges, as it must process each vertex and each edge exactly once.\nSpace complexity: O(V\n), where V\nis the number of vertices, as it requires a position in the stack for each vertex.\nWhen to Use DFS in Technical Interviews\nRecall that in an acyclic graph, or a tree, all traversal algorithms will visit each node at least once, so for many problems that require basic search, both DFS and BFS will suffice. But there are certain problems where DFS is preferable:\n- DFS is particularly useful for backtracking algorithms: When we need to explore all possible paths, and reverse course when a leaf node or some other condition is met, DFS allows for a convenient way to analyze various paths. Examples of problems like this are those where we are calculating the path sum - adding together the values of the nodes - either searching for the max or optimal sum.\n- When there could be an opportunity to cache duplicate operations: If you're dealing with a graph or a tree that might include overlapping subproblems, you'll want to implement your traversal with DFS so it's easy to cache or memoize the sub-solutions. A classic example of a memoization use-case is when solving fibonacci with recursion - this algorithm effectively imagines the fibonacci resolution as a decision tree which is traversed with a DFS-like recursive algorithm.\n- If there is an exponential branching factor: Memoized DFS is also important to consider if the branching factor of the recursion is exponential, as the volume of computations could be costly.\n- In most cases, DFS is slightly more memory efficient than BFS, (though not always): This is worth mentioning if you're in a situation where both algorithms are applicable. In a tree, the space usage for DFS is defined as\nO(height)\n, where height is effectively the number of levels in the tree. BFS, on the other hand, usesO(branching factor ^ height)\n, wherebranching factor\nis the max or average number of children per node. As such, ifheight < branchingFactor ^ height\n, then DFS is more space efficient. This is rarely not the case. The absolute time complexity is unlikely to change here though, so the difference in an asymptotic sense is negligible.\nCommon Mistakes in Interviews Featuring DFS\n- Misunderstanding the tradeoffs and benefits between DFS and BFS: Remember that in many cases both will do just fine, with little to no tradeoffs, but there are specific cases when we should use BFS (finding the shortest distance between two nodes, for example).\n- Not using the correct supporting data structure: BFS is made possible with a queue data structure, while DFS relies on a stack. It's important to be able to identify this when implementing, and to be sure not to use the wrong supporting data structure.\n- Forgetting to track visited nodes: When dealing with a graph that is not guaranteed to be directed and acyclic, it is essential to track visited nodes in order to avoid an infinite loop. Interviewers will be looking for this as a common pitfall. One way to ensure you don't forget is to perform a manual dry-run of your algorithm.\n- Choosing BFS over DFS when it's not needed: Although in many cases these are both interchangeable, one big benefit of using DFS for backtracking algorithms is that memoization can be implemented easily.\nAbout the Authors\nKenny is a software engineer and technical leader with four years of professional experience spanning Amazon, Wayfair, and U.S. Digital Response. He has taught courses on Data Structures and Algorithms at Galvanize, helping over 30 students land new software engineering roles across the industry, and has personally received offers from Google, Square, and TikTok.\nMike Mroczka, a former senior SWE (Google, Salesforce, GE), is the primary author of Beyond Cracking the Coding Interview—the official sequel to Gayle McDowell's original CTCI. He works as a tech consultant and has a decade of experience helping engineers land their dream jobs. He’s a top-rated mentor (interviewing.io, Karat, Pathrise, Skilled.inc) and the author of viral technical content on system design and technical interview strategies featured on HackerNews, Business Insider, and Wired. He also sometimes writes technical content for interviewing.io (like this piece) and was one of the authors of interviewing.io’s A Senior Engineer's Guide to the System Design Interview.\nYou can find him online at mikemroczka.com, LinkedIn, and X.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/depth-first-search-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Graph Interview Questions & Tips for Senior Engineers",
      "content": "What Are Graphs?\nGraphs are a powerful and flexible data structure in computer science, comprising nodes (also known as vertices), and edges that establish connections between these nodes. This structure can represent any binary relationship, making it highly versatile and adaptable to various contexts.\nEach node in a graph can hold data and maintain connections to other nodes, signifying the edges. Unlike other data structures such as trees which impose how data can be linked (one direction parent-to-children relationships), graphs do not necessarily impose any restrictions, offering a more general data structure. There's no hierarchy or limit to the number of connections a node can have, and the connections can be either directed, signifying a one-way link, or undirected, indicating a two-way relationship.\nSocial Media Is A Graph (image credit: https://dev.to/tamerlang/data-structures-graphs-2960)\nThe abstraction of a graph allows for the application of the same algorithms across diverse scenarios. For instance, in the realm of networking, graphs facilitate the analysis and optimization of transportation, computer, and communication networks by representing cities as nodes and highways as edges. Similarly, in social networks, individuals are depicted as nodes, and their friendships as edges. This versatility extends to computer networks where computers or routers are nodes, and cables form the edges.\nFurthermore, graphs play a significant role in various domains of computer science and software engineering. They are instrumental in modeling social behaviors, driving recommendation systems, and enabling graph-based machine learning. In bioinformatics, graphs are utilized to illustrate genetic relationships, underscoring their wide-ranging applications. When you think about some of the biggest tech companies today, you'll see how they solve large scale problems that can fundamentally be thought of as graph problems.\n| Company | Use of Graphs |\n|---|---|\n| Uber | Uses graphs to route drivers to their destinations. The nodes represent locations and the edges represent possible paths between locations. |\n| Google's search engine uses graphs to connect users to webpages. The PageRank algorithm, which is based on graph theory, helps determine the importance of different webpages. | |\n| Uses graphs to represent social networks. Each user is a node and each friendship is an edge. This graph is used for features like \"People You May Know\". | |\n| Uses graphs for their \"People You May Know\" feature and job recommendations. The nodes represent users and companies, and the edges represent connections and job applications. | |\n| Uses graphs to represent follower relationships. Each user is a node and each follow is an edge. This graph is used for features like \"Who to Follow\". | |\n| Amazon | Uses graphs for their recommendation system. The nodes represent users and products, and the edges represent purchases and product views. |\n| Netflix | Uses graphs for their movie recommendation system. The nodes represent users and movies, and the edges represent user ratings. |\nGraph Terminology\nGraph theory itself can be an entire class, but don't think you need stuffy college lectures to be good enough to pass a technical interview. There are a handful of commonly used terms you should be aware of and once you internalize these five bullet points you should be ready for almost any problem thrown at you!\nAs mentioned above, nodes are also sometimes called vertices.\nEdges can be either directed or undirected. The former indicates a one-way relationship from a particular node to vertex, whereas the latter indicates the edge as bi-directional.\nTwo nodes are adjacent (aka neighbors) if an edge connects them together. And a path is a particular permutation of edges in the graph.\nGraphs sometimes can have loops in them. If the graph contains a loop, we call the loop a cycle and if it has no loops it is known as acyclic.\nUsually in more complicated graph problems, we might see weights assigned to our edges to illustrate different costs associated with traveling along a particular edge. In the example below, it costs more to travel from node a to node c if we go directly to it (a total cost of 100), but it is much cheaper to go through node b and node d and still reach the same destination (for a cost of just 45). Weights are especially useful in path finding algorithms.\nFinally, degree is a term that comes up in the time and space complexity analysis of graph algorithms. The degree simply refers to the number of edges that are attached to a particular node and is expressed in the form deg(V). Because this is node-specific terminology, the degree can change in the same graph depending on what node we are referring to. Occasionally we will need to know what the overall degree of a graph is, which can be expressed as the average degree – this is just what it sounds like, averaging out the degree across nodes and usually written as avg deg(V). In a binary tree, for instance, we can have 0, 1, or 2 edges attached to any node. The worst case degree of the tree is 2 since the worst case is that the tree is complete and contains a maximum of two children at every level except at the final terminal level.\nUnlike in a binary tree, in graphs, we can have an arbitrary number of edges attached to a given node, so the degree can vary wildly depending on which node we are talking about in the graph.\nThere exist many other terms for graphs, but these terms tend to be more academic and less applicable to interview questions. If you have extra time in your interview prep you might consider also studying:\n- Connected and disconnected graphs along with the related idea of connected components\n- Sparse and dense graphs\n- In-degree and out-degrees of graphs\n- Big-O notation of graphs, specifically in relation to their vertices and edges\nGraph Math\nIf you are unfamiliar with graph nomenclature, you might be frightened by how some Computer Science egg-heads chose to represent graphs… mathematically. 🙄\nYou'll typically see mathematical notations representing graphs that look something like this…\n- G = (V, E)\n- V = {a,b,c,d}\n- E = {{a, b}, {a, c}, {a, d}, {b, d}, {c, d}}\nIn the paragraphs above, we have already learned everything we need to know to understand this jargon. The first bullet point simply states that a Graph is composed of Vertices and Edges. The second bullet denotes the Vertices in the graph are labeled a, b, c, and d. The last bullet describes the Edges that exist in the graph. In this case vertex a connects to vertex b, a connects to c, etc. If we were to visualize this graph described above, it would look like this:\nDifferent Graph Representations\nSo we now understand why graphs are important and many of the key terms associated with them. You've probably seen trees in the past and how they are represented, but how are graphs represented in code? Trees are hierarchical by definition and have the root as an obvious starting point for doing graph problems. Graphs differ from trees in that they don't have an obvious place to start an algorithm. There is no \"beginning\" node to work from. As a result, all the nodes in a graph are often assigned a key and listed in a data structure that allows for random access and for tracking the connections between nodes. The \"real\" data stored in a node is often mapped to an additional object based on the vertex key.\nLet's look at a couple of ways that the below graph can be represented in code.\nEdge List\nThis is one of the most common ways you will be given a graph in an interview question. You can describe a graph completely by listing out the edges associated with the graph. If you have all the edges, then you can logically understand how the graph is connected together.\nNotice by default we assume that the graph is undirected. This is an assumption you should always clarify with your interviewer. For instance, they could tell you that the exact same edge list is a directed edge list with node-neighbor relationships. We read the relationship from left-to-right, i.e. for (x, y) node x is directly connected to node y. Graphically, that same edge list would represent a slightly more precise graph with directions like the one below.\nReal problem example: A good interview problem example with a directed edge list would be the Course Schedule problem.\nObjects & References\nIf you come from an Object-Oriented background, it may feel natural to represent a graph as objects and then lists of references to other objects. You can make a node class, store node data in that class, and then store a list of references to other nodes that are neighbors to that node. While this may seem natural, storing graphs as nodes and list references has a lot of data overhead associated with it and we will learn better methods to represent graphs below. However, this costly graph representation does show up occasionally in interviews, so it is still worth mentioning:\nReal problem example: Clone Graph\nAdjacency List\nBy far the most common way to use a graph is to make an adjacency list. An adjacency list is a way of representing a graph using an array or some key-value store. Key-value data structures are called by different names in each language, so be sure to get familiar with your language's version of the data structure which could be a Map, Dictionary, HashMap or even just a plain object. See the Hash Table guide for more details on this!\nAn adjacency list is a list of vertices with references to the edges of each vertex. We can enumerate the nodes as keys in an object (or as indices in an array) and set the value to each key as a list of associated edges. This allows us to easily find all the nodes that any given node connects to, which makes accessing connected nodes fast. If we were trying to see all nodes that were connected to node A using an edge list, it would take linear time to the number of vertices in the graph. An adjacency list lets us access the connected neighbors in constant time.\nAn example adjacency list in python can be seen below using a dictionary where the node is stored as the key and the neighbors for the node are stored as the values for the key. For additional speed, you can store values in the hash table as sets instead of lists assuming order does not matter and duplicates are not possible. This allows you to additionally ask questions like \"does node X have node Y as a neighbor\" in constant time. The below example just stores values in a python list.\nAnother common way to represent an adjacency list is just as a list of lists. The first element in the list represents the first node, the second element represents the second node and so on. Here's what that would look like:\nReal problem example: Keys and Rooms\nAdjacency Matrix\nAn adjacency matrix is similar to our adjacency list except that it explicitly defines every possible edge in the graph. Using a 2D matrix of size O(V \\* V)\n, where V\nis the number of vertices in the graph, each cell in the matrix represents an edge between vertex one (the row) and vertex two (the column).\nRather than only tracking the edges that do exist, an adjacency matrix is a boolean matrix that contains every possible edge and tells us either 1 (it exists) or 0 (it does not exist). Checking for the existence of an edge between two vertices can be done in O(1)\n(constant) time since we can index directly into adj\\_matrix[v1][v2]\n.\nThis is arguably one of the most confusing graph representations to look at, so if this is confusing to you, check out a more detailed explanation of 2D matrices in Arrays! Don't stress because this graph representation type is generally uncommon to occur in real interviews for reasons outlined below.\nReal problem example: Find the Town Judge\n2D Matrix\nThe last and arguably most common way graphs are represented in interview questions are through 2D matrices (nested lists). This differs from the adjacency matrix mentioned above, because the adjacency matrix specifically iterates all possible connections between all possible vertices whereas 2D matrices on their own express edges by their location relative to one another. Conceptually, there is nothing special about 2D matrix graphs.\nReal problem example: Count Islands\nBest Graph Representation\nAfter looking at this list, you may question which graph representation is \"best\", but the truth is that it just depends on how we plan to reference the data structure in our code. In most interview problems, you'll find that an adjacency list tends to be a preferred for a few reasons: 1) it is more compact for sparse graphs and 2) if a node has a small degree, it is much faster to iterate through its neighbors. In contrast, the main advantage of the adjacency matrix is being able to check if two nodes are adjacent in constant time. Sometimes, it even makes sense to use both in the same algorithm, but usually not in coding interviews.\n| Edge List | Objects & References | Adjacency List | Adjacency Matrix | 2D Grid as a Graph | |\n|---|---|---|---|---|---|\n| Pros | Simple to implement. Good for sparse graphs. | Intuitive, especially for object-oriented programming. Good for representing complex data. | Efficient for many operations. Good for sparse graphs. | Very efficient for checking if an edge exists between two nodes. Good for dense graphs. | Intuitive for grid-based problems. Easy to calculate neighbors. |\n| Cons | Inefficient for many operations, such as checking if an edge exists between two nodes. | Can be memory-intensive. Not as straightforward for certain algorithms. | Not as efficient for dense graphs. | Can be memory-intensive, especially for large, sparse graphs. | Only suitable for grid-based problems. Not as flexible as other representations. |\n| Space Complexity | O(E) | O(V + E) | O(V + E) | O(V^2) | O(R \\* C) |\n| Insert Node | O(1) | O(1) | O(1) | O(V^2) | N/A |\n| Insert Edge | O(1) | O(1) | O(1) | O(1) | N/A |\n| Remove Node | O(E) | O(E) | O(E) | O(V^2) | N/A |\n| Remove Edge | O(E) | O(E) | O(E) | O(1) | N/A |\n| Check If v1 & v2 are Adjacent | O(E) | O(deg(V)) | O(deg(V)) | O(1) | O(1) |\n| Iterate v1's Neighbors | O(E) | O(deg(V)) | O(deg(V)) | O(V) | O(1) |\n| Check If Edge Exists | O(E) | O(E) | O(deg(V)) | O(1) | O(1) |\nV = # of vertices (nodes), E = # of edges, deg(V) = degree of a vertex\nR = # of rows in grid, C = # of columns in grid\nNote that these complexities are average cases and can vary based on the specific implementation and the nature of the graph. Operations for the 2D grid are not applicable in the traditional sense because nodes and edges don't have the same meaning in a grid problem and it is more common to express complexities in terms of the number of Rows and Columns in the grid.\nWhen to Use Graphs in Interviews\nGraphs are used for representing relationships between data - so graph algorithms most frequently come up in those contexts. Oftentimes graphs are used in coding interviews to compute something that isn’t explicitly in a graph.\nFor example, you might see a problem that asks you to find the path between node A and node B. Or you might have to come up with the correct series of moves to solve some sort of game. Even though the problem might not directly frame itself as such, these are both graph problems. If you are playing chess, you have the current game state on the chess board. Visualizing the board as a graph (usually a 2D matrix) makes it easier to solve these problems.\nCommon examples of problems involving graphs include:\n| Problem Type | Example | Notes |\n|---|---|---|\n| Board games / puzzle games | Sudoku, Chess, Go, Mazes, N-Queens, etc | Usually represented as a 2D matrix |\n| Dependency problems (aka topological sort problems) | Course scheduling, task scheduling, todo scheduling, etc | Tends to be given in the form of an edge list or an adjacency list |\n| Connectivity | Island count in a grid, Number of provinces | Can be represented in various ways. Depth-first search (DFS) or breadth-first search (BFS) are commonly used. |\n| Shortest path problems | Minimum moves to get Knight from point A to B, shortest path from A to B, etc | Graph representation varies for these problems, but the optimal traversal choice tends to be a BFS. Advanced options include Dijkstra's algorithm or (rarely) Bellman-Ford. |\n| Route based problems | Getting from point A to B (not necessarily the shortest path) | Graph representation varies for these problems, but these algorithms tend to be difficult to optimize and usually end up being a DFS + Backtracking combo |\n| Cycle detection | Detecting a cycle in a linked list, Finding a cycle in a directed graph | Can be represented in various ways. Depth-first search (DFS) or breadth-first search (BFS) are commonly used. |\n| Network flow | Maximum flow, Minimum Cut | Typically represented as an adjacency matrix. Often involve weighted edges. |\nCommon Mistakes in Interviews Featuring Graphs\nNot Using (Or Misusing) a Visited Locations Data Structure\nHands down the most common mistake in graph questions is for a candidate to forget entirely or just misuse the visited locations data structure in a graph traversal. This data structure (usually represented as a 2D matrix or a hash table) keeps track of the nodes we have already visited in our graph traversal.\nWe use this data structure in both a BFS and DFS, yet it is incredibly common for candidates to entirely forget to track visited locations, forget to add newly visited locations to their visited data structure, and/or forget to check their visited locations before exploring a new location.\nA final common mistake with this data structure is passing it around when making function calls. Candidates tend to accidentally create copies of a path that is not changing, leading to an ever-growing complexity in graph exploration. The key here is to use the same variable across all function calls unless the problem truly requires each path to have its own visited data structure.\nAny of these rookie mistakes will result in an infinite loop and will likely lead to a rejection. This is so common that Googlers have internal memes about this mistake, so definitely don't make this mistake in your interview!\nCoding Helper Functions Instead of the Main Algorithm\nIn most graph problems (especially board game/puzzle problems), you'll need helper methods to help you solve the problem. In the N-Queens problem, you'll need a helper function to check if a queen at a current row and column is under attack. In Sudoku you might need a helper function that determines if the current cell already has the chosen number in the row, column or surrounding area. These types of helper functions are considered \"fluff\" in the problem.\nThe mistake is that many people get bogged down in coding these helper functions first and wind up with a half working helper function and no main algorithm. At this point the interviewer is forced to give you a rejection because they don't know if you can code the algorithm or not because all the time was wasted on the meaningless helper function.\nFocus on the algorithm and show you can code that. If you show that you can code the recursive backtracking DFS to solve the problem, then even if you don't have time to implement the helper functions you proposed the interviewer will know you're capable of it because you tackled the hardest part of the question first. Liberally define helper functions and leave them unimplemented until you're done solving the main parts of the algorithm.\nNot Seeing the Problem as a Graph Problem\nThe infamous Alien Dictionary problem is a classic example of a problem where it is not intuitive at first glance that the problem is a graph problem. Be aware that sometimes it will take some critical thinking before realizing a problem can be thought of as a graph. For this particular problem, it takes lots of thought to construct rules that turn into dependencies in the form of an edge list and eventually give enough information to construct a graph.\nNot Asking About the Characteristics of the Graph\n- Can the graph have cycles?\n- Is the graph directed or undirected?\n- Is it possible that the graph is disconnected?\n- Is the graph sparse or dense?\nWhat to Say in Interviews to Show Mastery Over Graphs\nDiscuss Graph Representation\nSometimes we are given a graph in a \"bad format\" like an edge list and we will need to transform it into a different graph representation to solve the problem efficiently. In these circumstances, it's worthwhile to pause and discuss what graph representation you will choose. It's the sign of a senior engineer that discusses different ways to build the graph in these types of problems rather than just jumping into a single graph representation because that is what they are familiar with.\nDiscuss The Algorithm\nThe benefit to graph problems is that you wind up coding, one of two algorithms in 80% of all of the problems. These two graph algorithms are depth first search and breadth first search. Get comfortable with both! Before diving in and coding, discuss the trade-offs associated with each. In many problems either algorithm can work. Show mastery of the topic by briefly proposing both options and thoughtfully choosing one. When there is no obvious chose and either one seems appropriate, still give a justification for why you're coding the algorithm you've chosen, i.e. \"It looks like either could work, but I'm going to go with a recursive DFS since it is easy to follow, easy to code, and easy to maintain.\"\nOccasionally, in the remaining 20% of graph problems we might need a more niche algorithm to get the job done. The next most important algorithms to learn – in order – include:\n- Topological sort (for those dependency problems!)\n- Dijkstra's algorithm (when BFS isn't enough and we don't have negative edge weights)\n- Union-Find (for the 1% of problems that can't use DFS instead)\nHere at interviewing.io, we generally recommend avoiding spending time on more complicated algorithms including Bellman-Ford, A\\*, Prim's, etc. While some questions on leetcode do require an understanding of these algorithms, they are too niche for a general SWE to be expected to know off hand. Keep in mind you likely will need to know these algorithms if you are applying for a position that has graph theory requirements attached to it or if you have a background in graphs (like you have a graduate degree in graph theory, for instance).\nAbout the Author\nMike Mroczka, a former senior SWE (Google, Salesforce, GE), is the primary author of Beyond Cracking the Coding Interview—the official sequel to Gayle McDowell's original CTCI. He works as a tech consultant and has a decade of experience helping engineers land their dream jobs. He’s a top-rated mentor (interviewing.io, Karat, Pathrise, Skilled.inc) and the author of viral technical content on system design and technical interview strategies featured on HackerNews, Business Insider, and Wired. He also sometimes writes technical content for interviewing.io (like this piece) and was one of the authors of interviewing.io’s A Senior Engineer's Guide to the System Design Interview.\nYou can find him online at mikemroczka.com, LinkedIn, and X.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/graphs-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Hash Tables Interview Questions & Tips for Senior Engineers",
      "content": "Hash Table Interview Questions & Tips\nWhat is a Hash Table?\nA hash table is a key-value data structure. Keys are typically able to be accessed in amortized constant time and values can be single items or more commonly a list of items.\nHashtables, Hashmaps, and Dictionaries. Oh My!\nMost languages have built-in key-value pair data structures, but each language will have different names, terminology, and even different implementations associated with them. All languages provide efficient ways to store, retrieve, and manipulate data because they allow for near-instant access to the data associated with a specific key. While there is little consistency for what a key-value data structure is called between languages, for the sake of this article we will use the term \"hash table\" to encompass the following:\n- Hash Table (sometimes a single word: \"Hashtable\")\n- Hash Map (sometimes a single word: \"Hashmap\")\n- Map\n- Dictionary\nIn Python, these structures are referred to as dictionaries (or \"dicts\"). In JavaScript, before ES6 these were represented as a general Object but after ES6 we now have a dedicated Map object. C++, on the other hand, includes both map and unordered\\_map in its Standard Template Library (STL), the latter being equivalent to a hash table. In Java, they are usually called Maps, represented by the Map interface which has several implementations including HashMap and TreeMap (but many more exist). Confusingly, Java has both a Hashtable and a HashMap. The main differences between them are that HashMap is multi-threaded and therefore not thread-safe and also allows for a null key & null values. The Hashtable implementation is thread safe and doesn't allow null keys or values.\nComparing Hash Tables, Arrays, and Sets\nIt's not uncommon for candidates to understand the differences between these three data structures yet fail to select the correct data structure in an interview context. Here is a brief comparison of these data structures and how they relate to one another. In general we should…\n- Use Arrays when we need to store elements of the same type, in a particular order, or we need to frequently access them by their index.\n- Use Hash tables when we need to store key-value pairs and perform frequent lookup, insert, or delete operations.\n- Use Sets when we need to store unique elements, don't care about duplicates, and just need to perform operations like checking if an element is in the set or not.\n| Arrays | Hash Tables | Sets | |\n|---|---|---|---|\n| Access | O(1) | O(1) avg, O(n) worst-case | O(1) avg, O(n) worst-case |\n| Search | O(n) | O(1) avg, O(n) worst-case | O(1) avg, O(n) worst-case |\n| Insertion | O(n) | O(1) avg, O(n) worst-case | O(1) avg, O(n) worst-case |\n| Deletion | O(n) | O(1) avg, O(n) worst-case | O(1) avg, O(n) worst-case |\n| Key-Value Pairs | No | Yes | No |\n| Unique Elements | No | Keys are unique | Yes |\n| Additional Metadata | No | Yes | Yes |\n| Memory Usage | Low | High | High |\nn\nrepresents the size of the data structure\nHow Does a Hash Table Work?\nDid you know that a hash table is actually just an array under the hood with some helper methods? It's true! Picture a super-organized parking lot (our array) and a hard-working valet (our hash function). You hand the valet your car keys, and he decides where to park your car. The valet has a unique system where he uses the key to choose a parking spot. That's exactly what a hash table does!\nA good hashing function can make a big difference in how efficiently we can look up data. For example, what if two cars (keys) are assigned the same spot? That's a collision! In the programming world, we have some neat strategies to handle those.\nWith \"separate chaining\", the parking spot just grows a little garage (a linked list) and parks the cars (hash table \"keys\") one behind the other.\n\"Open addressing\", on the other hand, is like the valet looking for the next available spot. If we are parking the cars right next to one another then that's \"linear probing\". If the valet starts hopping around in a specific pattern then it is quadratic probing or double hashing in the CS world.\nImagine our valet is having a bad day and just trying to park all the cars as close together in the same spot as possible, causing a traffic jam, or putting all the cars so far away it takes forever to get to them. This will result in a lot of collisions and will make a mess! That's like a poor hash function in coding. A good hash function, like a top-notch valet, parks the cars in a way that they're spread out evenly (avoiding traffic jams or \"collisions\") and are easy to retrieve when needed.\nNow imagine that our parking lot is getting filled up. This is when \"rehashing\" comes in. It's like the valet suddenly puts in an order for a bigger parking lot, moves all the cars around to space them out more, reducing the chances of assigning two cars to the same spot.\nEven though finding a parking spot (or an array index!) might sometimes take longer than expected, over many trips to the lot (or \"amortized over time\"), our valet (hash function) usually gets us there pretty quickly, averaging out to constant time. Here's a little python code as an example. The code supports a fixed size table of 10 elements and does not rehash when the table gets full and just continues to use separate chaining to avoid collisions (eventually degrading performance).\nclass HashTable:\ndef \\_\\_init\\_\\_(self):\n# Restricts the initial size of our hash table\nself.size = 10\n# Create array with 10 empty lists in it (one for each index)\nself.table = [[] for \\_ in range(self.size)]\ndef hash\\_function(self, key):\n# This is a simple hash function that uses the modulo operator\n# In a real-world use case, we would use a more complex function\nreturn key % self.size\ndef insert(self, key, value):\n# Calculate index in array where this key/value pair should be stored\nhash\\_index = self.hash\\_function(key)\n# Variable to track if key already exists in the current bucket\nkey\\_exists = False\n# Get bucket corresponding to the hashed index\nbucket = self.table[hash\\_index]\n# Iterate bucket collisions and check if we've previously added the key\nfor i, kv in enumerate(bucket):\nk, v = kv\nif key == k:\nkey\\_exists = True\nbreak\n# Add key if it's new, append to existing bucket collisions list if not\nif key\\_exists:\nbucket[i] = ((key, value))\nelse:\nbucket.append((key, value))\n1class HashTable:\n2 def \\_\\_init\\_\\_(self):\n3 # Restricts the initial size of our hash table\n4 self.size = 10\n5 # Create array with 10 empty lists in it (one for each index)\n6 self.table = [[] for \\_ in range(self.size)]\n7\n8 def hash\\_function(self, key):\n9 # This is a simple hash function that uses the modulo operator\n10 # In a real-world use case, we would use a more complex function\n11 return key % self.size\n12\n13 def insert(self, key, value):\n14 # Calculate index in array where this key/value pair should be stored\n15 hash\\_index = self.hash\\_function(key)\n16 # Variable to track if key already exists in the current bucket\n17 key\\_exists = False\n18 # Get bucket corresponding to the hashed index\n19 bucket = self.table[hash\\_index]\n20\n21 # Iterate bucket collisions and check if we've previously added the key\n22 for i, kv in enumerate(bucket):\n23 k, v = kv\n24 if key == k:\n25 key\\_exists = True\n26 break\n27 # Add key if it's new, append to existing bucket collisions list if not\n28 if key\\_exists:\n29 bucket[i] = ((key, value))\n30 else:\n31 bucket.append((key, value))\nWhen to Use a Hash Table in an Interview?\nWhen it comes to technical interviews, problems often revolve around manipulating and processing data. One of the most common ways to speed up an algorithm is to trade time for space. Phrased differently, we can increase the speed of many algorithms if we are willing to store some extra data in memory to avoid an expensive lookup operation later. This is the primary use for hash tables.\nHash tables tend to be used in conjunction with other techniques to solve a problem, rather than being a solution in themselves. Figuring out what to save as the key and value and then how to use that information once saved is more difficult than understanding the concept itself. Here are some well-known scenarios where these structures tend to be most useful:\nFrequency Counts\nIt's a fairly common requirement in interview problems to count the frequency of something. We use the key to hold the unique element we are tracking (whether it is a letter, string, or even an entire object) and the value is used to hold the number of times we've seen it. This usually allows us to eliminate the need for a nested loop, thereby saving us time. Here are a few example problems showcasing this.\n- Top K Frequent Elements: A hash table can be used to count the frequency of each element, then a heap or another sorting algorithm can be used to select the top k.\n- Ransom Note: A hash table can be used to count the frequency of each character in the magazine.\n- Find All Anagrams in a String: A hash table can be used to count the frequency of each character in p, and then a sliding window can be used to track the frequency of characters in s.\n- First Unique Character In a String: A hash map can be used to count the frequency of each character, though a set may be a slightly better data structure here to save a small amount of space.\nPro Tip: In Python, there are two common tools you can utilize in collections\nto save yourself time in an interview.\nA Counter\ncan count the frequency of elements occurring in a list (note the capitalization!)\nfrom collections import Counter\nwords = \"i love love love interviewing.io\"\nCounter(words.split()) # ({i': 1, 'love: 3, 'interviewing.io: 1})\n1\n2from collections import Counter\n3words = \"i love love love interviewing.io\"\n4Counter(words.split()) # ({i': 1, 'love: 3, 'interviewing.io: 1})\n5\nMore generally, a defaultdict\ncan initialize default values for you when adding a new key to your hash table (aka dictionary).\nfrom collections import defaultdict\nwords = \"i love love love interviewing.io\"\n# initialize every key with a default integer of 0\ndictionary = defaultdict(int)\nfor word in words.split():\ndictionary[word] += 1\nprint(dictionary) # {i': 1, 'love: 3, 'interviewing.io: 1}\n1from collections import defaultdict\n2words = \"i love love love interviewing.io\"\n3\n4# initialize every key with a default integer of 0\n5dictionary = defaultdict(int)\n6for word in words.split():\n7 dictionary[word] += 1\n8print(dictionary) # {i': 1, 'love: 3, 'interviewing.io: 1}\nData Tracking and Organization\nSometimes it's easier to track data when it is logically grouped together. This tends to also increase the efficiency of your lookups of the data but is useful on its own even if you don't need that efficiency. This may be the most common way to use hash tables – in problems where we need to track the location of something like a character, index, or node.\n- Classic examples would be problems like Two Sum and Three Sum where we track the number with the key and track where the number occurred in the array with the value.\n- This common pattern can also apply to index ranges where you keep track of something between a particular start and end index. This is the basic idea behind a more advanced strategy known as prefix & suffix array tracking.\n- A final index location problem example is the popular Least Recently Used (LRU) Cache problem. This is the most popular question on LeetCode and well worth your time to look at if you aren't familiar with it. The clever optimal solution involves a doubly-linked list and a hash table to track the locations of the elements in the linked list.\nGraph Representations\nSimilar to the above, but worth calling out on its own, hash tables can efficiently represent a graph by storing vertices as keys and their adjacency list as values. This allows quick access to each vertex's adjacent vertices, facilitating traversal and other operations. Additionally, extra information such as vertex weight can be stored in the value, enabling a wide range of graph algorithms.\nUsing a hash table for this purpose offers several benefits. The primary advantage is the O(1)\naverage time complexity for lookups, insertions, and deletions that hash tables offer. This means that accessing a vertex's adjacency list, adding a new vertex, or deleting a vertex can be done very quickly, regardless of the size of the graph.\nFor instance, if you want to find all the vertices adjacent to a specific vertex, you can access the adjacency list directly using the hash table. Similarly, if an edge is added or removed, updating the adjacency list is quick. Here's an example hash table in Python representing a simple undirected graph in the form of an adjacency list. The graph has four vertices (A, B, C, and D) and 5 edges ((A-B), (B-C), (C-D), (A-D), and (A-C)).\ngraph = {\n'A': ['B', 'C', 'D'],\n'B': ['A', 'C'],\n'C': ['A', 'B', 'D'],\n'D': ['A', 'C'],\n}\n\"\"\"\ngraph visualization\nA --- B\n| \\ |\n| \\ |\n| \\ |\nD --- C\n\"\"\"\n1graph = {\n2 'A': ['B', 'C', 'D'],\n3 'B': ['A', 'C'],\n4 'C': ['A', 'B', 'D'],\n5 'D': ['A', 'C'],\n6}\n7\n8\"\"\"\n9graph visualization\n10 A --- B\n11 | \\ |\n12 | \\ |\n13 | \\ |\n14 D --- C\n15\"\"\"\nHash tables handle sparse graphs in a particularly efficient way. Unlike an adjacency matrix representation of a graph, which requires space proportional to the square of the number of vertices, an adjacency list representation only needs space proportional to the number of edges. This is especially beneficial when dealing with graphs where the number of edges is significantly less than the total possible edges, thus saving memory.\nMemoization (Top-Down Dynamic Programming)\nHash tables are a key part of top-down dynamic programming, commonly referred to as memoization. Dynamic programming is a technique used to solve complex problems by breaking them down into simpler sub-problems, solving each of those sub-problems just once, and storing their results for when the same sub-problem occurs again. This strategy of storing sub-problem solutions is known as memoization.\nA hash table is a perfect data structure for implementing memoization due to its fast access times. It can store the results of sub-problems using problem parameters as keys. This is crucial for efficiency as it ensures that each sub-problem is computed only once, rather than repeatedly. When encountering a sub-problem, we first check the hash table to see if we've already calculated the result of this problem. If we find it, we use the stored result directly. If we don't find it, we solve the problem and store the result in the hash table. The key represents the current subproblem and the value represents the previously calculated subproblem's answer.\nCommon Mistakes in Interviews Featuring Hash Tables\nNull keys in languages that don't support them\nPicture this: you've got a huge, hungry dog (our hash table), and you're trying to feed it an invisible, scentless treat (a null key). That just won't work, right? The dog won't know what to do with it. That's pretty much what happens when you try to put a null key into a hash table in languages that don't support them.\nMany languages' hash tables don't support null keys because their hash functions don't know how to handle 'nothing'. It's like trying to find a place in our car park for a car that doesn't exist. Things get messy, and you'll likely end up with an error, or worse, a program crash.\nSo, what's the big mistake here? Programmers sometimes forget to check for nulls or they assume that their hash table can handle null keys. It's like they're absent-mindedly trying to feed the dog that invisible treat, not realizing it won't work.\nSo remember, before you try to add a key to your hash table, always make sure it's not null (or that your hash table can handle it) to keep your program running smoothly.\nTrying to Hash Unhashable Objects\nAnother common mistake is trying to put a mutable object as the key for a hash table.\nPython will throw a fit (a TypeError, to be exact) because lists are mutable, meaning they can be changed after they're created. Lists can't be hashed because who knows what they'll look like in the future?\nIn JavaScript, it's technically allowed to use an array as a key in an object, but it doesn't behave as you might expect. JavaScript will convert the array to a string to use as a key, and changes to the array after the fact won't affect the object.\nJava allows you to use a list as a key in a map because Java lists are immutable, but changes to the list after it's been used as a key won't affect the map. This is because Java uses the original list's hashCode at the time it was inserted into the map, and that doesn't change if you assign a new list to the myList variable.\n# Create a list\nmy\\_list = [1, 2, 3]\n# Try to use it as a key in a dictionary (which is a hash table in Python)\nmy\\_dict = {my\\_list: 'value'} # This will raise a TypeError!\n# Above won't work, because what if we now did this…\nmy\\_list = [4, 5, 6]\n# Python wouldn't recognize that it is the same list since it has\n# entirely different values in it!\n1# Create a list\n2my\\_list = [1, 2, 3]\n3\n4# Try to use it as a key in a dictionary (which is a hash table in Python)\n5my\\_dict = {my\\_list: 'value'} # This will raise a TypeError!\n6\n7# Above won't work, because what if we now did this…\n8my\\_list = [4, 5, 6]\n9\n10# Python wouldn't recognize that it is the same list since it has\n11# entirely different values in it!\nSo, how do you get around it if you were looking to store a list as the key? In Python, one way is to use a tuple instead of a list if your data doesn't need to change. Tuples are immutable, meaning they can't be changed after they're created, so they're safe to hash:\n# Create a tuple\nmy\\_tuple = (1, 2, 3)\n# Use it as a key in a dictionary\nmy\\_dict = {my\\_tuple: 'value'} # This is fine!\n1# Create a tuple\n2my\\_tuple = (1, 2, 3)\n3\n4# Use it as a key in a dictionary\n5my\\_dict = {my\\_tuple: 'value'} # This is fine!\n6\nIf your language doesn't have tuples, another way to accomplish the same thing would be to sort the list and then convert the sorted list into a string. Be aware that this adds more time to your algorithm due to the O(N log N) sorting, but it can work in a pinch.\n# Create a list\nmy\\_list = [1, 2, 3]\n# Sort the list and convert it to a string\nmy\\_key = ', '.join(str(i) for i in sorted(my\\_list)) # \"1,2,3\"\n# Use it as a key in a dictionary\nmy\\_dict = {my\\_key: 'value'} # This works!\nprint(my\\_dict) # Prints: {\"1,2,3\": 'value'}\n# Now, create another list with the same values but in a different order\nmy\\_other\\_list = [3, 2, 1]\n# Sort this list and convert it to a string\nmy\\_other\\_key = str(sorted(my\\_other\\_list))\nprint(my\\_other\\_key in my\\_dict) # Prints: True\n1# Create a list\n2my\\_list = [1, 2, 3]\n3\n4# Sort the list and convert it to a string\n5my\\_key = ', '.join(str(i) for i in sorted(my\\_list)) # \"1,2,3\"\n6\n7# Use it as a key in a dictionary\n8my\\_dict = {my\\_key: 'value'} # This works!\n9\n10print(my\\_dict) # Prints: {\"1,2,3\": 'value'}\n11\n12# Now, create another list with the same values but in a different order\n13my\\_other\\_list = [3, 2, 1]\n14\n15# Sort this list and convert it to a string\n16my\\_other\\_key = str(sorted(my\\_other\\_list))\n17\n18print(my\\_other\\_key in my\\_dict) # Prints: True\nIn both JavaScript and Java, you can sort a list/array and then convert it to a string to use as a key in an object/map. You can then check if a key exists in the object/map. In JavaScript, you use in\n, and in Java, you use containsKey()\n. Note that Java's List.sort()\nmodifies the list in place, so you need to sort a copy of the list if you want to keep the original list unchanged.\nWhat to Say in Interviews to Show Master Over Hash Tables\nLogically Walk Through Which Data Structure Should Be Used\nIt is the sign of a senior engineer to not jump to conclusions. Avoid suggesting a hash table just because you need a constant time lookup! You should think out loud and come to the conclusion on whether or not a Set or even an Array could do the job before deciding on a hash table.\n- \"For this Two Sum problem, it would be helpful to quickly look up the numbers I have access to. I don't just need to know the number though, I need a number and the location of what index the number was at. I can store this information in a hash table with the key as the number and the value as the index where that number was seen.\"\n- \"In my DFS I need to track every node I've visited previously. I could store it in a hash table with the key as the node and I could just set the value to 1 or true… but that's storing more information than I need. I guess I just need to track the key without a value so a set would be a better data structure here.\"\nDiscuss Hash Table Implementation Details When Appropriate\nTo show mastery of hash tables, you should demonstrate knowledge of how they work under-the-hood and mention it organically. There is a balancing act here – we don't want to go off on unnecessary tangents, but providing extra details without taking extra time can give tremendously different impressions. Imagine three candidates that all talk tell the interviewer about how they are going to use a hash table.\n- [Junior] \"I'll use a hash table here\": Not great. You've identified the data structure you might need, but haven't explained why it is a good choice.\n- [Intermediate] \"I'll use a hash table here so we can leverage the constant time lookups\": Better! Here we say what we are going to do, but also why we are doing it with a little implementation knowledge added.\n- [Senior] \"I'll use a hash table here so we can leverage their amortized constant time lookups\": Stellar. Here you say what you're going to do, why you're going to do it, and demonstrate a deep understanding of hash tables under the hood with the key word \"amortized\"\nThe full implementation details of a hash table are too much to get into in this article, but you should be able to describe in detail how a hash table works. Here are some key words and concepts to review and consider adding to the conversation where appropriate.\n- Review how hash tables are just Arrays under-the-hood.\n- Understand what collisions are and why they are a problem.\n- Internalize strategies used to deal with collisions including: linear probing, double-hashing, open-chaining, and quadratic hashing.\n- Review what makes a good hash function.\n- Familiarize yourself with why lookups are amortized constant time, but occasionally are not due to the need to deal with collisions and also rehashing when we resize the hash table.\nDiscuss Language-Specific Details to Show You Know Your Stuff\n- In Java, discuss which implementation to use. As mentioned earlier, there are many key-value data structures available in Java, so being aware of all of them and their specific use-cases makes you look like a pro. Can you discuss the differences between HashMap, TreeMap, LinkedHashMap, and HashTable classes? If you can, this is a great signal for your interviewer.\n- In JavaScript, discuss the newer Map object. Many developers still use JavaScript objects as hash tables for LeetCode-style problems. Highlighting your knowledge of the ES6 Map object shows you've worked in more modern JavaScript applications and aren't stuck in old JavaScript paradigms.\n- In C++, discuss\nstd::map\n&std::unordered\\_map\nunder-the-hood differences. Many casual C++ users don't realize thatmap\nis implemented as a Red-Black tree in C++ not a hash table and therefore has logarithmic lookups – not constant time lookups! Withstd::map\nwe get ordering guarantees at the cost of using more memory and slightly slower lookups. If you don't care about order and want faster access definitely use std::unordered\\_map and tell your interviewer why you chose it! - In Python, show technical depth by mentioning the\nOrderedDict\nin thecollections\nmodule when appropriate. It should be no shock that Python (which is built on C++) has its key-value container which is similar to C++'sstd::unordered\\_map\n.OrderedDict\nis closer to C++'sstd::map\nbut still is implemented as a hash table (not a Red-Black tree). It has the useful extra guarantee of remembering the insertion order of elements. Python 3.7 introduced this guarantee into their standard dictionary implementation, but it is an implementation detail that is better not to rely on.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/hash-tables-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Heaps Interview Questions & Tips for Senior Engineers",
      "content": "What Is a Heap?\nA heap is a special kind of tree-based data structure that satisfies the heap property. In a max heap, for any given node 'i', the value of 'i' is greater than or equal to the values of its children. In a min heap, the value of 'i' is less than or equal to the values of its children.\nAn interesting aspect of heaps is their shape: they're always complete or almost complete binary trees – by complete, we mean \"not missing any children.\" This characteristic allows us to represent heaps in a compact manner using arrays.\nHeap Representation - Arrays!\nA heap represented as an array follows this simple rule: if a parent node is at index i\n, then its left child is at index 2i+1\nand the right child is at index 2i+2\n. Similarly, for a given child node at index i\n, its parent node is at index (i-1)/2\n. This calculation is specific to 0-based arrays and is a common one among several variations. It isn't important to know multiple implementations, just to know a specific one for interviews.\nLet's take an example. Suppose we have a max heap as follows:\n5\n/ \\\n4 8\n/ \\ / \\\n9 7 10 9\n/ \\ /\n15 20 13\nThis heap can be represented as an array like this:\n[5, 4, 8, 9, 7, 10, 9, 15, 20, 13]\nA full side by-side is shown below for convenience of understanding:\nSo, if you see the first element of the array which is 5 (index 0), its left child is 4 which we get by calculating (0\\*2)+1=1\nand the right child is 8 which we get by calculating (0\\*2)+2=2\n. This pattern continues for the rest of the array, maintaining the heap structure.\nAre Heaps Included in Your Language?\nSome languages provide support for heaps in additional modules or libraries. Each language is unique and has its own nuances to heaps. Study the sections below to see how heaps differ between core languages.\nPython\nHere's a simple way to create a heap in Python using the heapq\nmodule:\nimport heapq\n# Min Heap\nmin\\_heap = [13, 9, 8, 9, 20, 10, 4, 15, 7, 5]\nheapq.heapify(min\\_heap) # [5, 4, 8, 9, 7, 10, 9, 15, 20, 13]\n# Add to heap\nheapq.heappush(min\\_heap, 30) # [5, 7, 8, 9, 9, 10, 4, 15, 20, 13, 30]\n# Remove from heap\nheapq.heappush(min\\_heap) # [7, 9, 8, 9, 13, 10, 4, 15, 20, 30]\n1import heapq\n2\n3# Min Heap\n4min\\_heap = [13, 9, 8, 9, 20, 10, 4, 15, 7, 5]\n5heapq.heapify(min\\_heap) # [5, 4, 8, 9, 7, 10, 9, 15, 20, 13]\n6\n7# Add to heap\n8heapq.heappush(min\\_heap, 30) # [5, 7, 8, 9, 9, 10, 4, 15, 20, 13, 30]\n9\n10# Remove from heap\n11heapq.heappush(min\\_heap) # [7, 9, 8, 9, 13, 10, 4, 15, 20, 30]\n12\nA fun fact about Python's heapq\nmodule is that it only supports a min heap officially. This is because you can get a max heap using the same module by multiplying the contents of each inserted element by -1\nto achieve. This effectively makes the largest elements now the smallest and vice versa. See more details here\nJava\nJava provides a built-in PriorityQueue\nclass which is essentially a min heap. For a max heap, you can modify the comparator during the PriorityQueue class instantiation.\nHere's an example of creating a min heap and a max heap in Java:\n// Min Heap\nPriorityQueue minHeap = new PriorityQueue();\n// Max Heap\nPriorityQueue maxHeap = new PriorityQueue(Collections.reverseOrder());\n1// Min Heap\n2PriorityQueue minHeap = new PriorityQueue();\n3\n4// Max Heap\n5PriorityQueue maxHeap = new PriorityQueue(Collections.reverseOrder());\n6\nInserting and deleting elements, finding the min/max element can all be performed using inbuilt methods such as add()\n, poll()\n, and peek()\n.\nC++\nC++ also provides a built-in priority\\_queue\nclass in the queue\nlibrary for creating max heap. To create a min heap, you have to use a greater comparator.\nHere's an example:\n// Max Heap\npriority\\_queue maxHeap;\n// Min Heap\npriority\\_queue, greater > minHeap;\n1// Max Heap\n2priority\\_queue maxHeap;\n3\n4// Min Heap\n5priority\\_queue, greater > minHeap;\n6\nThe push()\n, pop()\n, and top()\nmethods are used to insert, delete, and find the max/min element.\nJavaScript\nUnfortunately for JavaScript developers, there is not a built-in heap data structure in our language. However, this doesn't mean that we can't solve heap-related problems in JavaScript. We have two options here:\n- We can mimic a heap using an array and manually maintaining the heap property, though this can be a bit complex and is time consuming in interviews.\n- We can create the heap methods once on our own during practice to understand how they work, but then in an actual interview we would simply pretend we have the implementation built already. To be clear, by \"pretend\" we don't mean to try and pull one over on your interviewer, feel free to let them know that JavaScript doesn't have a built-in data structure for heaps and you're just going to mock the interview as if it does. When stated confidently most interviewers will not ask you to actually build an entire heap from scratch, \"JavaScript doesn't have heaps built in by default, so I'll just mock calling an API for now to save time.\"\nCreating a heap isn't particularly difficult in JavaScript, but again, it can be time consuming. Here is a simple example of how to create a min heap in JavaScript:\nclass MinHeap {\nconstructor() {\nthis.heap = [];\n}\n// Insert\ninsert(val) {\nthis.heap.push(val);\nthis.bubbleUp();\n}\n// Bubble Up\nbubbleUp() {\nlet index = this.heap.length - 1;\nwhile (index > 0) {\nlet element = this.heap[index];\nlet parentIndex = Math.floor((index - 1) / 2);\nlet parent = this.heap[parentIndex];\nif (parent >= element) break;\nthis.heap[index] = parent;\nthis.heap[parentIndex] = element;\nindex = parentIndex;\n}\n}\n// ... (additional methods like remove, heapify can be implemented similarly)\n}\n1class MinHeap {\n2 constructor() {\n3 this.heap = [];\n4 }\n5\n6 // Insert\n7 insert(val) {\n8 this.heap.push(val);\n9 this.bubbleUp();\n10 }\n11\n12 // Bubble Up\n13 bubbleUp() {\n14 let index = this.heap.length - 1;\n15 while (index > 0) {\n16 let element = this.heap[index];\n17 let parentIndex = Math.floor((index - 1) / 2);\n18 let parent = this.heap[parentIndex];\n19\n20 if (parent >= element) break;\n21 this.heap[index] = parent;\n22 this.heap[parentIndex] = element;\n23 index = parentIndex;\n24 }\n25 }\n26\n27 // ... (additional methods like remove, heapify can be implemented similarly)\n28}\n29\nRemember, due to JavaScript's lack of a built-in heap structure, it is beneficial for JavaScript developers to familiarize themselves with Python's heapq\nmodule, to understand the heap data structure's fundamental behaviors and methods. This understanding can then be translated into JavaScript by creating a custom heap class or object as shown above.\nBy translating the basic concepts of heaps into various programming languages, you can further enhance your understanding of this versatile data structure and become better prepared for any heap-related questions you might encounter in technical interviews.\nHeapify Method Details\nHeapify is an essential operation used to maintain the heap property. It's a process of building a heap from an array. It ensures that the parent node is always maintaining the heap property with respect to its children.\nHere is a simple implementation of the heapify function:\ndef heapify(arr, n, i):\nlargest = i # Initialize largest as root\nl = 2 \\* i + 1 # left child\nr = 2 \\* i + 2 # right child\n# check if left child exists and is greater than root\nif l < n and arr[i] < arr[l]:\nlargest = l\n# check if right child exists and is greater than root\nif r < n and arr[largest] < arr[r]:\nlargest = r\n# change root if needed\nif largest != i:\narr[i], arr[largest] = arr[largest], arr[i] # swap\n# Heapify the root again.\nheapify(arr, n, largest)\n1def heapify(arr, n, i):\n2 largest = i # Initialize largest as root\n3 l = 2 \\* i + 1 # left child\n4 r = 2 \\* i + 2 # right child\n5\n6 # check if left child exists and is greater than root\n7 if l < n and arr[i] < arr[l]:\n8 largest = l\n9\n10 # check if right child exists and is greater than root\n11 if r < n and arr[largest] < arr[r]:\n12 largest = r\n13\n14 # change root if needed\n15 if largest != i:\n16 arr[i], arr[largest] = arr[largest], arr[i] # swap\n17\n18 # Heapify the root again.\n19 heapify(arr, n, largest)\n20\nThe heapify operation works by identifying the largest (in case of a max heap) among the root, left child and right child, and swapping it with the root. Then, it recursively calls the heapify method on the affected subtree. The time complexity of the heapify method is O(log n)\nbecause we're essentially traversing a tree of height log n\n.\nHeap Time Complexities\nHeap complexities are part of what make this data structure so worthwhile! Be sure to understand the complexities of each operation below.\n| Operation | Description | Time Complexity |\n|---|---|---|\n| Build Heap (Heapify all elements) | Construct a heap from an array | `O(n)` |\n| Heapify | Restore heap property by sifting down from a node | `O(log n)` |\n| Insertion | Add a new element to the heap and sift it up | `O(log n)` |\n| Deletion | Remove the root and sift up the last element | `O(log n)` |\n| Peek | Access the root element (max or min) | `O(1)` |\n| Search | Find a specific element in the heap | `O(n)` |\nA common misconception is the time complexity of heapifying all elements. If you have N\nelements and you need to add them all to the heap and we know that inserting a single element takes O(log N)\ntime, it is natural to assume heapifying an entire array would take O(N log N)\ntime. This, however, is not true. We can heapify a full array in just O(N)\n, because we would use the heapify method to process the elements.\nWhen to Use Heaps in Interviews\nHeaps are particularly useful in scenarios where you have to maintain a 'running maximum' or 'minimum' or when you're asked to extract the maximum or minimum elements frequently. Some scenarios where heaps are useful include:\n- Implementing a priority queue\n- Finding the 'k' largest or smallest elements in an array\n- Sorting an array (HeapSort)\n- Median finding problems\nThe power of a heap lies in its efficiency. Operations like insertion, deletion, and retrieval of the maximum/minimum element can be done in O(log n)\ntime. Oftentimes you'll see them crop up as optimal solutions for problems that typically can only be done in O(n log n)\nand with the heap can be solved in either O(k log n)\nor O(n log k)\ntime by restricting the size of your heap.\nCommon Mistakes in Interviews Featuring Heaps\nWhile working with heaps, interviewees often make the following mistakes:\n- Not choosing the right type of heap: Heaps can be max-heaps or min-heaps. Make sure to choose the correct type for your problem.\n- Incorrectly indexing children and parents: In a heap represented as an array, remember the formula to find the parent and child nodes. If\ni\nis a parent,2i+1\nand2i+2\nare its children. Ifi\nis a child,(i-1)/2\n(integer division) is its parent. - Not maintaining heap property while inserting/deleting: When you insert or delete an element, make sure to 'heapify' the heap again to maintain the heap property.\n- Ignoring heap's time complexity: Although heaps offer efficient operations, keep in mind the time complexity. Heap operations are\nO(log n)\n, and building a heap isO(n)\n.\nWhat to Say in Interviews to Show Mastery Over Heaps\nHere are a few things you can mention in your interviews to demonstrate your understanding of heaps:\n- Discuss the internal working of heap operations, such as insertion, deletion, and heapify.\n- Talk about how the choice of a heap (min-heap or max-heap) affects the solution.\n- Discuss the efficiency of heap operations and how they provide an edge over other data structures in certain problems.\n- Mention how heaps can be used in a variety of problems, like sorting, finding kth smallest/largest elements, implementing a priority queue, etc.\n- Talk about how heaps are represented in memory as arrays for efficient use of space.\nHeap Frequently Asked Questions (FAQs)\nWhy Are Heaps Preferred Over BST for Priority Queue?\nHeaps are preferred because they offer constant time retrieval and logarithmic time insertion and deletion, which makes it a better choice for a priority queue.\nWhat Is the Difference Between a Heap and a Priority Queue?\nA priority queue is an abstract concept that defines the behavior and operations of a collection of elements with priorities, while a heap is a specific implementation of a priority queue that satisfies the heap property. Stated differently, heaps are priority queues, but not all priority queues are heaps.\nAre Heaps Always Sorted?\nNo, while the parent nodes will always be less than or greater than their child nodes in a min heap and max heap respectively, this doesn't mean the data structure is sorted.\nWhat Is a Heap Overflow?\nA heap overflow can occur when we try to insert an element into a heap that's already full.\nHow Can Heaps Be Used in Sorting?\nHeaps can be used to create a sorting algorithm known as HeapSort. This algorithm works by first organizing the data into a max heap, and then swapping the top element (the max) with the last element, decreasing the heap size by one, and finally heapifying the root again. Repeat these steps until the heap size is one, and voila, your array is sorted!\nRemember, understanding heaps requires both theoretical knowledge and practical experience. Try to implement heaps from scratch and solve various heap-based problems to get a thorough understanding of the concept.\nAbout the Author\nMike Mroczka, a former senior SWE (Google, Salesforce, GE), is the primary author of Beyond Cracking the Coding Interview—the official sequel to Gayle McDowell's original CTCI. He works as a tech consultant and has a decade of experience helping engineers land their dream jobs. He’s a top-rated mentor (interviewing.io, Karat, Pathrise, Skilled.inc) and the author of viral technical content on system design and technical interview strategies featured on HackerNews, Business Insider, and Wired. He also sometimes writes technical content for interviewing.io (like this piece) and was one of the authors of interviewing.io’s A Senior Engineer's Guide to the System Design Interview.\nYou can find him online at mikemroczka.com, LinkedIn, and X.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/heaps-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Inorder Traversal Interview Questions & Tips for Senior Engineers",
      "content": "Inorder Traversal Interview Questions & Tips\nYou can find our information about Inorder Traversal here:\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/inorder-traversal-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "MapReduce Interview Questions & Tips for Senior Engineers",
      "content": "MapReduce Interview Questions & Tips\nWhat is MapReduce?\nMapReduce is an algorithm dating back to the early 2000s when Google was looking for an efficient way of processing large amounts of data. They were kind enough to share their findings with the rest of the world and open-source projects like Apache Hadoop were born. This algorithm takes a large dataset and breaks it into lots of small pieces which are processed in parallel and then combined. Since its initial introduction, MapReduce has found its way into many companies dealing with Big Data.\nWhile the algorithm has gained popularity in the Big Data space, the ideas can be used to solve smaller-scale problems as well. In this article, we will start simply with the core algorithm, give some examples of how the algorithm can be used and then talk about the extra machinery necessary for this algorithm to be deployed and effectively used in the real world.\nHow MapReduce Works\nAt its core MapReduce consists of two algorithms: a mapper and a reducer algorithm. The mapper can be thought of as a worker which will be assigned a chunk of the total data that needs to be processed. There will typically be lots of mapper jobs all simultaneously working on unique chunks which form the entire dataset. In contrast, there is only a single reducer job. The reducer job is responsible for receiving the processed output from the mapper jobs and performing any final processing. I like to think of this algorithm as a big funnel taking chunks of data and reducing them into tasty, distilled data.\nExample (Batman)\nHonestly, everything's better with Batman...\nRecently Batman has become aware that the level of crime in Gotham City has reached an all-time high. The problem is he is having trouble tracking which citizens of Gotham are committing these heinous crimes. Batman forms a clever plan:\n- Perform a thorough scan of each person in Gotham using the bat computer and give them a badness rating.\n- Track the citizens with the highest badness rating.\nUnfortunately for Batman, the bat computer, while powerful, can only process one person per second and Gotham has a population of one million! Holy frustration, that's over a week! Batman can't sit idle, he needs answers now!\nFortunately for Batman, Alfred has installed a network of one thousand consumer-grade machines (the \"bat cluster\", naturally). Batman wonders if there isn't a way to leverage this network of machines. He remembers his instruction in data engineering from college and brushes up on the MapReduce algorithm. Here's Batman's new approach:\n- On the bat computer split the citizens into chunks of 1000.\n- Send each chunk to a separate node in the bat cluster.\n- Each node will scan all the citizens in that chunk and create a badness rating.\n- The badness ratings will be returned to the bat computer\n- The bat computer will sort the returned pairs by badness rating.\n- Batman will track citizens with the highest badness rating.\nThe nodes in the bat cluster are not nearly as powerful as the bat computer. It takes each node 3 seconds to process a citizen, but because of the parallelization, the process takes less than an hour. Holy tandem Batman, it works!\nIn this example, the map algorithm is analyzing a chunk of 1000 citizens and assigns a badness rating. The reducer algorithm is sorting the resulting badness ratings and produces a list of villains.\nA couple of things of note:\n-\nThe nodes used in the bat cluster are less powerful than the bat computer; they don't need to be super powerful! By splitting up the work into these smaller pieces we can take advantage of much weaker (and cheaper) hardware.\n-\nThrowing a more powerful machine at the first algorithm (vertical scaling) would help, but it isn't a sustainable solution. In contrast, it is much easier to increase the number of nodes (horizontal scaling). Note MapReduce can be applied to a single machine by leveraging multiple cores (and in practice, this is often done). Typically multiple mappers will run on each node.\nWhen to Use MapReduce in Interviews\nIt is unlikely that you will be directly presented with a prompt to use the MapReduce algorithm, rather you may see opportunities to use this algorithm. Consider MapReduce as a design pattern that can be leveraged for processing large amounts of data.\nCoding Interviews\nAs we all know coding interviews often revolve around optimization. How close can we get to O(1)? For some problems, this naturally leads to questions about parallelization. If you think your solution is as good as it can be on a single node, it might be worth exploring multithreaded or multiprocessor solutions. This is where MapReduce comes in.\nNote: Parallelization does not reduce the total compute time and it will not change the Big-O estimates (in fact the overhead from orchestration and the transfer of data could bring these up!), rather it lowers the wait time. Don't try using MapReduce to bring down your Big-O!\nSystem Design Interviews\nWhen stepping into a system design interview how we leverage MapReduce is taken to another level. In this space it isn't enough to just have an idea of the core algorithm, you need to be able to apply the algorithm to an ambiguous problem and then consider all the details and tradeoffs of the implementation.\nMultifaceted Data\nAgain, consider this pattern when you have lots of data to process and it is easy to split the data into chunks but keep in mind you will need a strategy for how to split up data. The data you are working with may have many possible splits (think of how a GROUP BY can be applied across any column of a SQL table). Parallelization will likely make more sense when the data is split intelligently. In the example below we can start to see how MapReduce and sharding (or horizontal partitioning) in a database are related. We need to be careful how we store our data so it's easy to work with down the line!\nExample (Top Performers in a School)\nThe principal of Data-Driven High wants to figure out the top performer of each grade in the school and is determined to use MapReduce to find the answer. The mappers will calculate the top grade per cohort and the reducer will order the top performers by grade.\nIf the principal splits the data into chunks without being careful, students from different grades could be compared which would result in the wrong answer. Instead, the principal needs to make sure mappers are given chunks of data where all entries belong to the same cohort.\nBatching vs. Streaming\nOne final consideration is how data is moving through your design. We will consider two different ways data could be processed:\nBatch Processing - Data is allowed to accumulate. After a certain amount of data has been collected (or a certain time threshold has been reached) the batch of data is processed together. MapReduce lends itself very well to batch processing.\nStream Processing - Data is processed as it comes in one event at a time. When we want to process data in real-time (like device telemetry data, for instance) we don't have batches to break into chunks for our mappers. In a case like this, a tool like Apache Kafka would be more appropriate. It is worth noting that solutions like Kafka do offer parallelization when dealing with vast amounts of data, but the overall approach is very different from MapReduce.\nCommon Mistakes in Interviews Featuring MapReduce\nKeeping Partitions Straight\nWhen breaking a data set into chunks it is important to keep track of which partitions have been processed. You do not want to do double work or double count! Leveraging a partition cache can help with this.\nCheck for Parallelization\nThere's a saying \"When you've got a MapReduce… I mean a hammer, everything looks like a nail\". All joking aside, it is easy to want to apply this algorithm any time there is a large amount of data. The most important question you need to answer is \"How easy is it to break this problem into smaller units of work?\". Before moving on to implementation make sure you have a clear picture of this!\nData Skew and Starvation\nWith coding interviews this will likely be less of a concern, but this is especially worth paying attention to in a systems design interview. If certain mappers are being fed more data than others you will end up with some mappers burning the midnight oil while others are on vacation. This is not ideal! It is worth discussing how to ensure your mappers are being fed properly. In the worst-case scenario, only one mapper could be working while the rest are supervising at which point you have an over-engineered, single-threaded solution. To address this you will want to discuss monitoring strategies and load balancing.\nNote: Some scenarios require the data to be skewed, but we should always strive to use our resources as wisely as possible. Take for instance the example above. The amount of data being processed by each mapper is dependent on class sizes.\nMapReduce Adds Complexity\nKeep in mind this advice from the Zen of Python: \"Simple is better than complex.\" While the MapReduce algorithm is a powerful tool, it does add a fair bit of complexity to a design (both in a coding interview and a systems design interview). Always keep in mind the constraints of the problem in front of you and ask \"do I really need this?\". As you get closer to a real-world example, the devilish details about how to make this algorithm robust will rear their ugly heads. In coding interviews, you can frequently dust these details under the rug, but you always want to have an eye on this trade-off. How much data are you actually dealing with? Is this added complexity really worth it?\nReinventing the Wheel\nBefore jumping in and designing MapReduce, talk about existing solutions such as Hadoop. This isn't a replacement for understanding how MapReduce works, the interviewer may still want to see a demonstration of how these systems work, rather it shows prudence on your part. We always want to see if a solution to a problem exists since this saves precious engineering time!\nMake sure you have a basic understanding of any tools you recommend. You don't want to suggest Spark without understanding it only to have the interviewer ask you \"What kind of machines would be needed to effectively use Spark\" (it needs a lot of RAM). It's also good to build out a list of pros and cons so you can effectively talk through the tradeoffs of your solution compared to other solutions.\nWhat to Say in Interviews to Show Mastery Over MapReduce\nWhen we talk about MapReduce we can mean just the core algorithm or we can be discussing how it fits into a large production system. Because of this our considerations and how we demonstrate mastery varies drastically depending on the context. With that in mind, we have broken this section down according to interview type.\nCoding Interviews\nFor coding interviews, it will be important to first know when to apply the MapReduce algorithm but it is equally important to know how to apply the algorithm. Brush up on how multithreading and multiprocessing are handled in your language of choice. Once you feel like you have a grasp on how to use these tools, try implementing practice problems using a leader thread and worker threads.\nNote: It is highly advisable to pick a language that lends itself well to interviewing. When considering multithreaded problems look for a language that doesn't get in your way. Some common suggestions are Python, Java, and Go.\nNote: If you choose to use Python or Ruby be aware of the danger imposed by the Global Interpreter Lock (GIL). If you don't grasp the limitations imposed by the GIL with respect to multithreading you can end up wasting time writing a less performant solution! See https://en.wikipedia.org/wiki/Global\\_interpreter\\_lock for more details.\nSystem Design Interviews\nFor systems design interviews it is important to step beyond how the basic algorithm works and understand what additional machinery is necessary for MapReduce to be used in production. Understanding the following topics will show your interviewer that you really know your stuff!\n- How are retries handled? What happens if one of your mappers fails?\n- How are logs stored? When there is a failure how do you investigate?\n- What is the cost of transferring data to/from nodes?\n- How do you track the status of the job?\n- What implementations/alternatives exist?\n- Spark, Tez, Hadoop\n- What are the tradeoffs of the various implementations?\n- When should it be implemented?\n- How big should the data be before we consider a distributed solution?\n- How are resources managed?\n- See Apache YARN as an example.\nClarifying Questions to Ask Your Interviewer About MapReduce\nWhen it comes to MapReduce, you will likely need to ensure that the algorithm fits your scenario. It is important to ask about the design requirements and the system constraints. Here are some examples:\n- How much data are we processing? Is a single node able to handle this data in a timely manner? Some back-of-the-envelope calculations on your part will go a long way. How do we expect our needs to scale over time?\nFurther Reading and Practice\nWhat we have covered in this article is only the tip of the iceberg. MapReduce is an incredibly rich topic that is connected to much of the modern architecture for data-intensive applications. If you are expecting systems design interviews or are interested in a data-heavy role we would encourage you to spend some more time learning more.\n- [MapReduce: Simplified Data Processing on Large Clusters\" by Jeffrey Dean and Sanjay Ghemawat\n- [Designing Data-Intensive Applications - Chapter 10 Batch Processing\nAbout the Authors\nJared is a software engineer with nine years of development experience. Jared has worked in a variety of fields including power systems engineering and actuarial science. Jared is currently working at Dropbox in data infrastructure.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.](https://dataintensive.net/)](https://research.google/pubs/pub62/)",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mapreduce-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Maps Interview Questions & Tips for Senior Engineers",
      "content": "Maps Interview Questions & Tips\nYou can find our information about Maps here:\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/maps-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Matrix Interview Questions & Tips for Senior Engineers",
      "content": "Matrices Interview Questions & Tips\nWhat is a Matrix?\nMost of us already have familiarity with matrices, but for completeness, let's go through a brief introduction. A matrix is simply a two-dimensional grid of values (like a bunch of stacked cubbies). In mathematics, an n by m matrix would be represented as follows:\nWhere each of the a's is one of the elements in the matrix. In software engineering, we would typically encode this information into an array of arrays. For example, in Python, it would look something like this:\nmatrix = [\n[a\\_1\\_1, a\\_1\\_2, ..., a\\_1\\_m],\n[a\\_2\\_1, a\\_2\\_2, ..., a\\_2\\_m],\n...,\n[a\\_n\\_1,a\\_n\\_2, ..., a\\_n\\_m]\n]\n1matrix = [\n2 [a\\_1\\_1, a\\_1\\_2, ..., a\\_1\\_m],\n3 [a\\_2\\_1, a\\_2\\_2, ..., a\\_2\\_m],\n4 ...,\n5 [a\\_n\\_1,a\\_n\\_2, ..., a\\_n\\_m]\n6]\nAs defined, matrices could include any type of value under the sun (including mixed types), but for the sake of this article, we will restrict our definition to numeric values. Expanding our focus to include all types would put us squarely in the realm of databases and tabular data, a topic for another day.\nNote: there is nothing limiting us to a 2d array. We could expand this to a n-dimensional matrix. Many matrix libraries also allow us to do this.\nWhen to Use Matrices in Interviews\nAs with most data structures, it is unlikely that an interviewer will directly prompt you to use a matrix. With that said it is generally pretty obvious when a matrix should be considered. Oftentimes a problem will be framed on a two-dimensional plane or a grid. You will be asked to extract some information from the grid or to transform the grid in some way.\nExample: Conway's Game of Life\nA classic example of this is Conway's Game of Life.\nYou are presented with an n by m grid of 0s and 1s (or a binary matrix). This grid represents the state of the world at a point in time. The 1s are live cells and the 0s represent dead cells. The question is: what will the grid look like at the next timestep? To figure that out we are given the following rules:\n- If a cell is dead and…\n- If there are exactly 3 live neighbors (surrounding cells, including corners), the cell becomes alive\n- Otherwise the cell remains dead\n- If a cell is alive and…\n- If there are less than 2 or more than 3 neighbors, then the cell dies\n- Otherwise the cell keeps on living.\nFor more information see:\n- Problem https://leetcode.com/problems/game-of-life/\n- Interesting Numberphile Video: https://www.youtube.com/watch?v=R9Plq-D1gEk\nNote: Classically Conway's Game of Life is played on an infinite grid.\nExample: Solve a Sudoku\nGiven a sudoku board (or a matrix partially populated with integers between 1 and 9), use the rules of sudoku to fill in the board.\nThis problem has a matrix as an underpinning but relies on dynamic programming techniques like recursion and backtracking. Our matrix manipulation and traversal techniques need to be in excellent condition so we can bake them into these more complex algorithms.\nFor more information see: https://leetcode.com/problems/valid-sudoku/ https://leetcode.com/problems/sudoku-solver/ Example: Count the Islands on a Map You are given a grid where each element of the grid is either a 0 (water) or a 1 (land). How many islands are there?\nThis is a very common type of problem and comes in a number of flavors. At its heart is a graph-inspired search problem. Again, matrix traversal and manipulation are essential to effectively produce a solution.\nFor more information see: https://leetcode.com/problems/number-of-islands/ https://leetcode.com/problems/number-of-closed-islands/ https://leetcode.com/problems/island-perimeter/\nCommon Mistakes in Interviews Featuring Matrices\nMessy Code\nWhen done carefully, traversing and manipulating matrices can be a very smooth experience, but in the turbulent sea of a coding interview, it is easy to get swept into a wave of ugly syntax! Because of this, it is well worth your time to construct helper functions to interact with the matrix directly. Consider methods to help… Look at all neighboring elements Swap rows or columns Get all elements of a row or column\nCreating helper functions like this helps to isolate the sticky bits of your algorithm. This way if something goes wrong, you don't have to hunt for the broken logic; you will have only one place to look! It's a great practice to go through a matrix-related problem and create some of these helper functions to get a sense of this before the big day.\nNote: always make sure you are specifying dimensions in the correct order! It is a common practice to need to access an element by specifying the y index and then the x index.\nAltering Values In Place\nMany coding questions will want you to alter values in place. Take the example of Conway's Game of Life (detailed above). Finding the state of the board from time step i to i+1 can be done by constructing a new matrix, but this costs additional space. An interviewer could easily ask you to use a single matrix and update values in place. This seems reasonable, right? The problem is each cell needs to look at the surrounding cells to figure out what state it should have. If you are updating the state of surrounding cells you begin losing information! One solution is to use values outside of 0 and 1 to encode additional information. For instance, we could update cells as follows:\n- 0 - Was previously 0 and is still 0\n- 1 - Was previously 1 and is still 1\n- 3 - Was previously 1 and is now 0\n- 4 - Was previously 0 and is now 1\nNow you might be thinking to yourself, \"But we don't want 3s and 4s in our new state!\" and you'd be right. We will need to do a second pass on our solution to convert the 3s and 4s into 0s and 1s respectively. Here's an implementation in Python:\nfrom itertools import product\ndef count\\_live\\_neighbors(x: int, y: int, grid: list[list[int]]) -> int:\n\"\"\"\nGiven a position in a grid, count all live neighbors\n\"\"\"\ncount = 0\n# product allows us to take all combinations of two lists.\n# this allows us to get all combinations of offsets of our element\nfor i, j in product([-1,0,1],[-1,0,1]):\n# when i and j are 0 we are looking at element and not a neighbor of the element\nif (i == 0 and j == 0):\ncontinue\nneighbor\\_y = y + i\nneighbor\\_x = x + j\ngrid\\_height = len(grid)-1\ngrid\\_width = len(grid[0])-1\n# don't look past the grid\nif (neighbor\\_y < 0 or neighbor\\_y > grid\\_height) or (neighbor\\_x < 0 or neighbor\\_x > grid\\_width):\ncontinue\n# mod by 2 to account for 3s and 4s (updated elements)\ncount += grid[neighbor\\_y][neighbor\\_x] % 2\nreturn count\ndef get\\_next\\_state(grid: list[list[int]]) -> None:\n\"\"\"\nGiven a binary grid representing a state in Conway's Game of Life,\nfind the state at the next timestamp\nModify the grid in place!\n\"\"\"\nfor y, row in enumerate(grid):\nfor x, entry in enumerate(row):\ncount = count\\_live\\_neighbors(x, y, grid)\n# encode some additional information into our updated grid\n# 1: was a 1 is now a 1\n# 0: was a 0 is now a 0\n# 3: was a 1 is now a 0\n# 4: was a 0 is now a 1\nif entry == 0 and count == 3:\ngrid[y][x] = 4\nelif entry == 1 and (count < 2 or count > 3):\ngrid[y][x] = 3\n# shift 3s and 4s to their proper value for the new grid state\nfor y, row in enumerate(grid):\nfor x, entry in enumerate(row):\nif entry > 1:\nentry -= 3\ngrid[y][x] = entry\nreturn grid\n1from itertools import product\n2\n3def count\\_live\\_neighbors(x: int, y: int, grid: list[list[int]]) -> int:\n4 \"\"\"\n5 Given a position in a grid, count all live neighbors\n6 \"\"\"\n7 count = 0\n8\n9 # product allows us to take all combinations of two lists.\n10 # this allows us to get all combinations of offsets of our element\n11 for i, j in product([-1,0,1],[-1,0,1]):\n12 # when i and j are 0 we are looking at element and not a neighbor of the element\n13 if (i == 0 and j == 0):\n14 continue\n15\n16 neighbor\\_y = y + i\n17 neighbor\\_x = x + j\n18\n19 grid\\_height = len(grid)-1\n20 grid\\_width = len(grid[0])-1\n21\n22 # don't look past the grid\n23 if (neighbor\\_y < 0 or neighbor\\_y > grid\\_height) or (neighbor\\_x < 0 or neighbor\\_x > grid\\_width):\n24 continue\n25\n26 # mod by 2 to account for 3s and 4s (updated elements)\n27 count += grid[neighbor\\_y][neighbor\\_x] % 2\n28\n29 return count\n30\n31def get\\_next\\_state(grid: list[list[int]]) -> None:\n32 \"\"\"\n33 Given a binary grid representing a state in Conway's Game of Life,\n34 find the state at the next timestamp\n35\n36 Modify the grid in place!\n37 \"\"\"\n38 for y, row in enumerate(grid):\n39 for x, entry in enumerate(row):\n40 count = count\\_live\\_neighbors(x, y, grid)\n41\n42 # encode some additional information into our updated grid\n43 # 1: was a 1 is now a 1\n44 # 0: was a 0 is now a 0\n45 # 3: was a 1 is now a 0\n46 # 4: was a 0 is now a 1\n47 if entry == 0 and count == 3:\n48 grid[y][x] = 4\n49 elif entry == 1 and (count < 2 or count > 3):\n50 grid[y][x] = 3\n51\n52 # shift 3s and 4s to their proper value for the new grid state\n53 for y, row in enumerate(grid):\n54 for x, entry in enumerate(row):\n55 if entry > 1:\n56 entry -= 3\n57\n58 grid[y][x] = entry\n59\n60 return grid\nNotice here how the in-place constraint reduced our space complexity but required us to go through our matrix an additional time. While this doesn't increase our big-O time complexity, it does cost real-time. Always keep these tradeoffs in mind!\nBeing careless with space\nThe problems we have talked about up to this point all involved a matrix-like object being manipulated. It isn't hard to imagine a scenario where a matrix is one possible data structure that could be used to solve the problem. Keep in mind that using a matrix can be costly both in terms of time and space! As an example, consider a graph. A typical way to represent a graph is with a Node object which contains pointers to other nodes (this is very similar to how a linked list is constructed). Alternatively, we could represent a graph with an \"incidence matrix\" where each row/column represents a node in the graph. Connections are represented as a 1 in the matrix (everything else is a 0). A matrix can encode this same information but it is not a very good use of space!\nEven if a matrix is necessary for your solution keep in mind how costly operations are both in terms of time and space. Adding a single element to a new row or column will cost O(max(n, m)) space. If you need this kind of flexibility a linked structure may be a better tool for the job.\nWhat to Say in Interviews to Show Mastery Over Matrices\nGenerally avoiding the pitfalls above will be enough to demonstrate mastery to your interviewer. With that said, learning about the matrix libraries available in your preferred language is important. For example, In Python Pandas and Numpy are available. Now, it is important to note that while you might be able to implement the same sort of logic from scratch, it will be difficult to squeeze out the same sort of performance that well-established libraries can achieve. These libraries are using low-level tricks to pack values into memory and the CPU cache which can make a big difference to performance! Additionally, many of these libraries can leverage a GPU or TUP to improve performance (see Tensorflow). A full explanation of how these low-level languages achieve their performance can be found in the introductory chapter of Parallel Scientific Computing in C++ and MPI.\nMachine Learning and Artificial Intelligence\nIt is reasonable to say machine learning algorithms would not be where they are today without the help of matrices. Matrices allow calculations rooted in multi-dimensional calculus to be computed quickly. Because of their structure, they fit nicely into memory, and CPUs, GPUs or TPUs can efficiently calculate values rapidly. If you are interested in pursuing a data-focused or machine learning-focused job, diving deeper into this topic will serve you well. Gilbert Strang's treatment of this subject is particularly excellent. An old edition of his book Introduction to Linear Algebra or his MIT open course ) would be a great place to start.\n(Credit https://xkcd.com/1838/)\nAbout the Author\nJared is a software engineer with nine years of development experience. Jared has worked in a variety of fields including power systems engineering and actuarial science. Jared is currently working at Dropbox in data infrastructure.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/matrices-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Memoization Interview Questions & Tips for Senior Engineers",
      "content": "What Is Memoization?\nMemoization is a programming technique used to speed up the execution time of a function by caching its results. Oftentimes, the term is confused with ‘memorization’. Conceptually, they allude to the same idea, except that memoization entails caching the results of a function while memorization entails committing data of any type to memory. That said, it is fair to think of memoization as a type of memorization.\nWhen a function is called with a set of parameters, the result is stored in a cache with the input parameters being keys to the result values. The next time the function is called with the same parameters, instead of recomputing the result, it is retrieved from the cache. This can result in significant performance gains, especially for functions that are called repeatedly with the same inputs.\nWhen to Use Memoization in Interviews\nIf dynamic programming is the Yin, Memoization is the Yang. These two go hand in hand. Dynamic programming problems are characterized by the existence of optimal substructure and overlapping subproblems. See our dynamic programming article for an in-depth discussion on this.\n- Optimal Substructure: Dynamic programming problems have optimal substructure, which means that the optimal solution to a problem can be constructed from the optimal solutions of its subproblems. In other words, if we can solve the subproblems optimally, we can solve the main problem optimally as well.\n- Overlapping Subproblems: Dynamic programming problems also have overlapping subproblems, which means that the same subproblems are often solved multiple times. By storing the solutions to these subproblems and reusing them as needed, we can greatly improve the efficiency of our algorithm.\nAny time a problem satisfies the above criteria, it becomes a candidate for memoization. We will center around the good old Fibonacci problem in this article to demonstrate this.\nFibonacci Problem\nThe Fibonacci problem is a mathematical sequence where each number is the sum of the two preceding ones, starting from 0 and 1. The sequence goes as follows: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, and so on. It is a popular problem in computer programming and is often used to test algorithm efficiency. The Fibonacci sequence can be generated using a recursive function or a loop. It has many applications in real-life scenarios such as biology, economics, and music theory. The problem is often used as an introduction to dynamic programming and recursion.\nBelow is a short script showing how we can compute any Fibonacci number recursively.\ndef fibonacci(n):\nif n <= 1:\nreturn n\nelse:\nreturn fibonacci(n-1) + fibonacci(n-2)\n1def fibonacci(n):\n2 if n <= 1:\n3 return n\n4 else:\n5 return fibonacci(n-1) + fibonacci(n-2)\n6\nCommon Mistakes in Interviews Featuring Memoization\nFailure to identify sub-problems\nMemoization works best when the function being memoized has repeated calls with the same input values. However, problems that involve random or non-deterministic computations may not be good candidates for memoization. In such cases, memoization may not result in significant performance improvements and may even increase the execution time. The problems will usually have optimal substructure and overlapping subproblems, which ought to be called out explicitly in an interview. A simple way to identify these problems is by drawing a call tree. When you see the same parameters repeatedly passed to the same function with the same output, it means this is a memoization problem\nBelow is a simple call tree example with the Fibonacci problem of finding the Fibonacci(5):\nWith the naive solution (The implementation above), it is clear that some calls are made more than once. Observe that Fib(4), Fib(3), Fib(2), Fib(1) are all computed at least twice. Each time a call is repeated, the lower-order calls have to be repeated. As such, the recursive solution scales exponentially O(2^n)\nsince each call has to perform two more calls resulting in a call tree of size O(2^n)\n. Identifying this repeated work is key to justifying introducing memoization.\nFailing to Flesh Out the Naive Solution\nBuilding on the point above, understanding how the naive solution would work is key to drawing the call tree. In an interview, make sure to detail how a naive approach would work before jumping into the optimal solution. This not only gives you a fallback solution to demonstrate your coding ability, but it eliminates any suspicion that you may have simply crammed the solution to the interview problem or that you have seen it before but did not point it out. Most dynamic programming problems will usually have a naive approach similar to the Fibonacci one above.\nImproper Key Selection\nThe memo\nis usually an object like a hash table, but it could be any key-value data structure that provides fast access (ideally O(1)\n) to values. When selecting the keys, a simple heuristic is to select all the NON-STATIC parameters of the function call and use them in the key either when generating a hash or directly adding them to a formatted string. Key selection is a complex process but for most interview problems, this approach will usually suffice. If you are having to pass in a whole object or array for access in the subsequent function calls, unless the object is changing, it is inefficient to incorporate this input when generating the key. Other changing parameters though like index values, string inputs and such will usually make for good candidate parameters for the key.\nIn our Fibonacci problem, there is only one parameter for each call. This makes it easy to identify the key. We can thus store intermediate results in some sort of cache as follows:\nmemo = {0:0, 1:1}\ndef fibonacci(n):\nif n not in memo:\nmemo[n] = fibonacci(n-1) + fibonacci(n-2)\nreturn memo[n]\n1memo = {0:0, 1:1}\n2\n3def fibonacci(n):\n4 if n not in memo:\n5 memo[n] = fibonacci(n-1) + fibonacci(n-2)\n6 return memo[n]\n7\nWith the optimizations, the call tree will be as follows:\nRather than blindly computing the result, we first check if we have seen the computation before. If we have, we simply return it from the memo. Otherwise, we actually compute it and store it in the memo. Notice that we use n\nas the key.\nUnnecessary Memoization\nDepending on the problem, a memoized value may only need to be accessed once or a few times. In such cases, it would be inefficient to keep them in memory once they have served their purpose. Take the Fibonacci problem for example, it does not make sense to store all Fibonacci numbers in memory unless you are asked to generate the full sequence. You only need to have two preceding Fibonacci numbers to compute the current one. Doing this can reduce the space complexity from O(n)\nto O(1)\nThe above is more efficient than the naive approach, but there is a problem, the space complexity scales linearly to O(n)\n. We have to store all the Fibonacci numbers in memory in case we need them again. The time complexity is now linear O(n)\nsince we only need to compute each result once. In this example, we start by defining how we compute the ‘final answer’, fib(n)\n, and then rely on some form of computational dark magic (recursion) to compute the preceding states all the way down to the base case. This is a top-down approach. At this point, it is worth asking what the flip would look like, how could we compute this starting from the bottom? We know that Fib(0)\nand Fib(1)\nare 0\nand 1\nrespectively. We know Fib(2)\nwill be the sum of the two. If we were to ‘build up’, it would entail:\n- Compute\nfib(0)\n= 0 - Compute\nfib(1)\n= 1 - Compute\nfib(2)\n=fib(0)\n+fib(1)\n= 0 + 1 = 1 - …. And so on\n# Initialize with the base cases\ndef fibonacci(n):\nif n <= 1: return n\nfirst, second = 0, 1\nfor \\_ in range(n-1):\nfirst, second = second, first + second\nreturn second\n1# Initialize with the base cases\n2\n3def fibonacci(n):\n4 if n <= 1: return n\n5 first, second = 0, 1\n6 for \\_ in range(n-1):\n7 first, second = second, first + second\n8 return second\n9\nBy thinking through how a bottom-up approach works, we end up eliminating the larger memo all together and only keep the values we need at any given stage, which is the two preceding values. The time complexity is now O(n) while the space complexity is O(1).\nFailure to Make State Updates\nIn the context of dynamic programming, state can be represented by a set of variables that produce the specified outcome. You can update these variables using a set of transition rules that define how the system changes over time. The transition rules are based on the current state of the system and the deterministic output given the input parameters. As function calls are made, it is really important to keep them updated. Candidates often fail to correctly keep up with the state of the system either by incorrectly setting the keys or overlooking the update step altogether. Be mindful of this during interviews as it can lead to ineffective memoization.\nNote that this step involves defining and manipulating the return values of recursive calls when following a naive approach or the actual operands when following the bottom-up approach. When using the top-down approach, defining the recursive relationship can almost feel like a leap of faith. In an interview, it can be tempting to dwell on this piece to try and understand it fully, but doing so will most likely trip you up. Take the leap! Once the high-level relationship is clearly defined, proceed to set your base cases so that you are not stuck making recursive calls that may cause stack overflow errors.\nfib(n) = fib(n-2) + fib(n-1) # State transition for top-down approach\nfirst, second = second, first + second # State transition for bottom up approach\nWhat to Say in Interviews to Show Mastery Over Memoization\nClearly Identifying the Optimal Substructure and Overlapping Subproblem\nSee our dynamic programming article for an in-depth breakdown of what these two concepts entail.\nIn an interview, make sure you talk about how the problem exhibits these two properties. Overlapping subproblems can be identified by looking for repeated function calls. Spend some time talking about the expected output from the calls. It is importan that inputs matching input parameters produce similar output. This is what justifies the use of memoization. Often, candidates are quick to label the process of storing intermediate results as memoization even when it is just regular caching. Keep in mind that memoization only occurs when we are storing the return values of repeat function calls. Caching is an overarching term describing the storage of data for future use, regardless of whether it has the characteristics of a dynamic programming problem or not. It does not impose the requirement that what is being cached has to be the output of repeated function calls.\n| Caching | Memoization |\n|---|---|\n| Path/ Decision Tree Pruning: Storing ‘seen’ nodes when path finding to avoid going down the same path (Note, these values will not be used in subsequent calls). | Storing Intermediate Fibonacci Numbers: To compute new numbers in the sequence eg. storing fib(0) and fib(1) to compute fib(2). |\n| HTTP Caching: Storing web pages on the browser for finite durations to avoid retrieving them from the server with every unique request for the same page. | Generating All Possible Combinations of a Set of Items: This will usually involve storing the intermediate subsets and then strategically inserting new values at different positions of the collection to generate a new combination. |\n| API Response Caching: This technique is commonly used to make throttling and rate limiting a more pleasant experience. The same payload can result in different outputs depending on whether the request is made before or after the cache results have expired. | Random Number Seeding: Using a seed to store random numbers generated by a random number generator such that when a similar input is provided to the generator, the same collection of random numbers is generated. |\n| Shortest Path Finding: When finding the shortest path, you have to explore most of the possible paths in a tree before committing to one being the shortest. This usually involves storing intermediate values representing the ‘shortest path so far’. As such, a function call checking for the shortest path can have varying output and only becomes deterministic once all ‘qualifying’ paths are explored. |\nRemember, memoization is a form of caching, but not all caching is necessarily memoization.\nJustifying the “Key” Selection to Your Memo\nWhen selecting this key, your primary goal is to ensure it remains unique for each function call. This is why simply selecting all the unique parameters of the function calls will usually suffice, since our functions are deterministic. We expect to have consistent output from the same inputs. By selecting the non-static values, we also are assured of having unique keys to map to each of the function calls and subsequently, the output of the calls. Justifying the key selection involves assuring the interviewer that each of your key-value pairs in your memo maps to a unique function call.\nClearly Defining the Carried-Over State During State Transition\nOnce you have highlighted the bits that make the problem a dynamic programming candidate, you then need to showcase how the output of the function calls are input to subsequent calls. It is easy to point out the transition if you start the problem-solving by implementing the top-down. The recursive function is literally the state transition. Simply explaining what the function does will usually be enough to check this box. The granular subproblems will usually produce output that can be used to compute the higher-order problems, and it is important that a candidate calls this process out explicitly.\nWith the bottom-up approach, your state transition function captures how the values change for the next state. How the new values will be used in the higher-order subproblems is usually not as clear as it is in the top-down approach, however. Take a few seconds to talk about what you are computing and how it will carry on as input to the next set of operations.\nDiscussing Trade-Offs Between Top-Down and Bottom-Up Solutions\nGenerally speaking, solutions to dynamic programming problems fall into one of these two categories. One of the key trade-offs to be mindful of is just how much you actually need to memoize. For most problems, you can use both approaches. Top-down is usually easier to implement but consumes more memory. Bottom-up is usually harder to identify on its own without the top-down solution. That said, it usually is orders of magnitude more memory efficient. In our Fibonacci case, it reduces the memory requirement from O(n)\nto O(1)\n.\nFollowing a Step-By-Step Framework When Finding the Solution\nFrameworks such as FAST have been proposed to help capture the general steps followed when solving dynamic programming problems. At a high level, it entails the following steps:\n- Find the First/ Naive Solution: This entails finding the non-optimized solution to the problem.\n- Analyze the First Solution: At this step, pinpoint the repeated work (Overlapping subproblems) and how the solutions to these Subproblems are reused to answer the solution (Optimal substructure) follows.\n- Subproblem Identification: From here, define a solution to the subproblems as these are the ‘fundamental units’ of the final solution. At this stage, you also define the keys as well as introduce the memo.\n- Turn Around The Solution: At this stage, you need to clearly Analyze both the bottom-up and top-down variants of the solution.\nSee our dynamic programming article for a more in-depth discussion of the FAST framework.\nAbout the Author\nGithire (Brian) is a backend and ML engineer with 7 YoE ranging from startups to major corporations. He has worked on tech serving a wide demographic ranging from mobile money in his homeland Kenya, embedded tech with Kakao in South Korea to MLE at Microsoft. Brian has also worked as a teacher and has a knack for writing technical articles\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/memoization-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Ordered Maps Interview Questions & Tips for Senior Engineers",
      "content": "Ordered Maps Interview Questions & Tips\nYou can find information about Ordered Maps here:\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/ordered-maps-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Parsing Interview Questions & Tips for Senior Engineers",
      "content": "Parsing Interview Questions & Tips\nWhat is Parsing?\nParsing problems are a very special subset of string problems. Here we are reading a file or a file-like object and using syntax rules to convert the file into a data structure. This process is commonly used by compilers and interpreters, but it can also be used for other things, such as natural language processing.\nThe process of parsing is typically broken up into two separate processes: tokenization and parsing. Notice that parsing both refers to the whole process and one of the steps.\nTokenization is when the file is processed and consecutive characters are grouped together to form tokens. A token can be thought of as a word. These can be a single character or a group of characters and will later, in the parsing process, have meaning inside of the context of the file's syntax. For instance the code for i in range(1, 100)\ncould be broken up into the following tokens: for\n, i\n, in\n, range\n, (\n, 1\n, ,\n, 100\n, )\n. The tokenizer strips out the white spaces and determines which characters should be clumped together.\nOnce the tokens have been processed, the parser will build out a hierarchy tree of expressions. At each level of the hierarchy, we have an expression containing a bunch of tokens. We will continue breaking expressions down until we cannot divide them anymore. When we cannot divide an expression further it is known as a terminal expression. Take this example from Wikipedia (https://upload.wikimedia.org/wikipedia/commons/a/ac/Python\\_add5\\_parse.png). Here the following Python function is displayed as a syntax tree:\ndef add5(x):\nreturn x + 5\n1def add5(x):\n2 return x + 5\n(credit: https://upload.wikimedia.org/wikipedia/commons/a/ac/Python\\_add5\\_parse.png)\nAs we will see in the next section, having a comprehensive knowledge of parsing is not necessary to pass a coding interview. With that said, this knowledge will help you to frame the problem and make the mountain feel much more climbable.\nWhen to Use Parsing in Interviews\nThere are a couple of places where you might need to use parsing in a coding interview. In the first case, you are presented with a file that needs to be parsed and you must write the parsing engine from the ground up. For a problem like this, it is likely that the grammar rules will be very simple since more complex examples will require time you don't have.\nYou might also need to parse a file when you’re ingesting a file, as part of a larger process. In cases where the parser isn't the star of the show, it is unlikely that the interviewer will want you to spend time standing something up, rather you will be expected to recommend a library, e.g., using Python’s built-in json module when parsing a JSON file.\nIn the context of a systems design interview, it is unlikely that you will need parsing and you will certainly not need the details of the algorithm. If anything it will be a footnote of your design, something like \"this node will handle the parsing of incoming files.”\nExample (Mini Parser)\nLink: https://leetcode.com/problems/mini-parser/\nIn this problem, you are given a serialized string s containing nested lists of integers (for example: \"[1,[1,2,[5,6]],[3,4]]\"\n). You need to turn this into the corresponding data structure. The most challenging part of this problem is tracking scope as you process the string. To do this, consider using an int to track scope depth. Every time you encounter a \"[\"\n, add 1 to the depth, and every time you encounter a \"]\"\n, subtract 1. This also gives you an excellent way of looking for malformed strings.\nCommon Mistakes in Interviews Featuring Parsing\nReinventing the Wheel\nIf you are given the problem of parsing an arbitrary file, you will likely need to build a parser from the ground up. However, if you need to parse a config file specifically and getting what you need out of that file is just part of a bigger problem, always check if you can use existing machinery. Leveraging existing libraries shows that you are thinking of the most efficient solution.\nDefining Scope\nParsing a file can be a very involved task. Depending on the grammar that you are creating a parser for, your job may take weeks or even months. With this in mind, it is important to establish exactly what your interviewer is looking for and to call out expected limitations.\nHandling Edge Cases/Errors\nWhen processing input that can take so many forms, it is easy for edge cases to sneak in. Make sure to spend some time quizzing your interviewer about what the input could look like. Establishing this upfront will ensure your solution is flexible enough. Some examples of edge cases include:\n- Whitespace - Most of the time we want to ignore whitespaces but languages like Python also use whitespace to define scope. Quoted Text - In many files, you will want to treat anything inside quotes like a single token.\n- Comments - Many languages allow comments to be added to the code. Depending on the needs of your parser this may be ignored, or you may have rules for how to handle it. For instance, if your parser is responsible for generating documentation, comments could be very important.\nAdditionally, spend some time discussing how errors should be handled. Do you want the program to halt or, like HTML, do you want your program to pretend like everything is fine and proceed as best you can?\nWhat to Say in Interviews to Show Mastery Over Parsing\n(credit: https://xkcd.com/1090/)\nShowing expertise in the domain of parsing means going beyond handling the simple examples you are most likely to see. While you will not be expected to come up with a robust solution on the spot, understanding parsing at a deeper level will aid you greatly when talking through your solution. You will be able to pull concepts that communicate to the interviewer your expertise in this area. With that in mind, it would be worth diving deeper. Here are some resources to get you started:\nAbout the Author\nJared is a software engineer with nine years of development experience. Jared has worked in a variety of fields including power systems engineering and actuarial science. Jared is currently working at Dropbox in data infrastructure.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/parsing-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Queues Interview Questions & Tips for Senior Engineers",
      "content": "Queues Interview Questions & Tips\nUnderstanding queues, a fundamental data structure, is crucial to preparing for technical interviews. Queues, designed around the FIFO (First-In, First-Out) principle, play an essential role in various real-world scenarios, from managing print jobs in a printer to handling requests in a web server. They facilitate operations in operating systems, network traffic management, and memory allocation, and they’re also integral to certain algorithms in data science and machine learning.\nThe key to acing technical interviews lies in not just understanding the theory behind queues but also being able to apply that knowledge practically. It sets the stage for impressive, comprehensive responses instead of just adequate answers. In the upcoming sections, we'll deep-dive into the concept of queues, their implementation, usage scenarios, and common pitfalls in interviews. We aim to equip you with the knowledge to tackle any queue-related questions in your interviews confidently.\nWhat is a Queue?\nYou may not have realized it, but we interact daily with queues. Have you ever been to a coffee shop during rush hour? That's your real-world experience with a queue. The first person who arrives early (hopefully, after a good morning jog) gets their coffee first, and you, who hit the snooze button one too many times, must wait for your turn at the end. Just like in programming, nobody likes a queue jumper!\nIn technical terms, a queue is a collection of items we maintain in a specific order. Items are added (we call this 'enqueue') at one end - the 'rear', and removed ('dequeue') from the other end - the 'front', following the principle of \"First In First Out\" (FIFO).\nQueue Compared to a Stack\nSimilar to a queue, a stack is also an abstract data type that stores a collection of elements. However, unlike a queue, a stack follows the LIFO (Last In First Out) principle – the last element added to the stack is the first to be removed. If a queue is like a line at a coffee shop, a stack is like a stack of plates. You can only add or remove plates from the top of the stack.\nQueue Operations\nA queue supports the following operations:\nenqueue\n: Add an element to the end of the queuedequeue\n: Remove an element from the front of the queuepeek\n: Return the first element in the queue without removing itisEmpty\n: Check if the queue is emptysize\n: Return the number of elements in the queue\nAll of these operations are performed in constant time - O(1)\n.\nQueues in Different Programming Languages\nLet's see how we can create and manipulate a queue in three programming languages - Java, Python, and JavaScript.\nJava\nJava provides a Queue\ninterface that can be implemented using various classes like LinkedList\n, PriorityQueue\n, and ArrayDeque\n. For instance:\nQueue queue = new LinkedList<>();\nqueue.add(1); // enqueue\nqueue.remove(); // dequeue\nqueue.peek(); // peek\nqueue.isEmpty(); // check if the queue is empty\nqueue.size(); // get the queue size\n1Queue queue = new LinkedList<>();\n2queue.add(1); // enqueue\n3queue.remove(); // dequeue\n4queue.peek(); // peek\n5queue.isEmpty(); // check if the queue is empty\n6queue.size(); // get the queue size\nJava also provides the ArrayDeque\nclass that can serve as a queue. LinkedList\nimplements Queue as a doubly-linked list, and ArrayDeque\nuses a resizable array or circular buffer. While both are efficient, using ArrayDeque\nis often faster for queues as it does not have to maintain separate references for next\nand previous\nnodes like LinkedList\n, making it more memory efficient.\nPython\nIn Python, the most recommended way to implement a queue is by using the built-in collections.deque\ndata structure, which is designed to allow fast appends and pops from both ends. It is implemented with a doubly-linked list under the hood, providing efficient queue operations. Another option, though less commonly used, is Python's queue.Queue\nclass, which is designed for multi-threading and includes locking semantics for concurrent producers and consumers.\nfrom collections import deque\nqueue = deque()\nqueue.append('a') # enqueue\nqueue.append('b')\nqueue.append('c')\nprint(queue.popleft()) # dequeue, prints 'a'\n1from collections import deque\n2\n3queue = deque()\n4queue.append('a') # enqueue\n5queue.append('b')\n6queue.append('c')\n7print(queue.popleft()) # dequeue, prints 'a'\n8\nThough you can use a Python list\nto perform queue-like operations with append()\nand pop(0)\n, it is not efficient because popping the first element requires shifting all other elements by one. Therefore, it's not recommended for queue implementations.\nOn the other hand, if you are working in a language that doesn't offer native queue support or you need to implement a queue for learning or specific customization purposes, you can do so using an array or a linked list.\nJavaScript\nJavaScript doesn't have a native queue implementation. So, similar to Python's list\n, you can use an array to implement a queue in JavaScript. However, it is not recommended for the same reason as Python - popping the first element requires shifting all other elements by one. This results in a time complexity of O(n)\nfor dequeue operations, which is not ideal. However, if you are working with a few elements, this might not be a problem.\nconst queue = [];\nqueue.push('a'); // enqueue\nqueue.push('b');\nqueue.push('c');\nqueue.shift(); // dequeue, returns 'a'\n1const queue = [];\n2queue.push('a'); // enqueue\n3queue.push('b');\n4queue.push('c');\n5queue.shift(); // dequeue, returns 'a'\n6\nArray vs. Linked List Implementation\nIf you are working in a language that doesn't offer native queue support, or you need to implement a queue for learning or specific customization purposes, you can do so using an array or a linked list.\nArray Implementation (Circular Buffer)\nA simple way to implement a queue is by using a circular buffer technique with an array. The technique is an example of the \"Two Pointers\" approach often seen in interview questions.\nThis method treats the array as if it were connected end-to-end. Once the end of the array is reached, the next element to be inserted goes at the beginning of the array, thus forming a 'circle'. We use two pointers (one for the front and the other for the rear) to track where to enqueue\nand dequeue\n. When the queue is full, and we want to add more elements, we can either throw an error or resize the array. The resize operation is expensive, so it's better to use a linked list implementation if the size of the queue is unknown.\nLinked List Implementation\nA queue can also be implemented using a linked list, with the front of the queue represented by the head of the list and the rear of the queue represented by the tail of the list. Enqueue operations add elements to the end (tail\n), and dequeue operations remove elements from the start (head\n). Unlike the array-based implementation, linked list implementation doesn't require size definition at the onset, making it more memory efficient. However, it is not cache-friendly and can result in frequent memory allocation and deallocation, which can be expensive.\nI would recommend reading this Stack Overflow thread, which provides a detailed discussion on implementing queues and stacks using arrays and linked lists.\nWhen to Use Queues in Interviews\nQueues can be handy in many types of problems in coding interviews. Below, we'll discuss the most common categories where queues are utilized:\nGraph Algorithms (Breadth-First Search and Level Order Traversal)\nQueues are fundamental for graph traversal algorithms, especially Breadth-First Search (BFS) and level order traversal of trees. Unlike Depth-First Search (DFS) that utilizes a stack (or recursion) for traversal, BFS specifically employs a queue. In a queue, the first element we add (enqueue) is the first one we remove (dequeue). This approach is ideal for BFS because it mirrors how BFS visits nodes: the first node discovered is the first one explored.\nAs BFS moves through each level, it uses a queue to keep track of the next nodes to visit. When it finishes with one node, it simply dequeues it. As it discovers new nodes, it enqueues them. This system ensures that BFS explores all nodes on one level before moving to the next, precisely the behavior we want.\nExample: Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\nfrom collections import deque\ndef levelOrder(root):\nif not root:\nreturn []\n# initialize a queue with the root node\nresult, queue = [], deque([root])\nwhile queue:\nlevel = []\nfor \\_ in range(len(queue)):\n# pop the first element from the queue\nnode = queue.popleft()\nlevel.append(node.val)\nif node.left:\n# append left child\nqueue.append(node.left)\nif node.right:\n# append right child\nqueue.append(node.right)\n# append the current level list to the final result\nresult.append(level)\nreturn result\n1from collections import deque\n2def levelOrder(root):\n3 if not root:\n4 return []\n5 # initialize a queue with the root node\n6 result, queue = [], deque([root])\n7 while queue:\n8 level = []\n9 for \\_ in range(len(queue)):\n10 # pop the first element from the queue\n11 node = queue.popleft()\n12 level.append(node.val)\n13 if node.left:\n14 # append left child\n15 queue.append(node.left)\n16 if node.right:\n17 # append right child\n18 queue.append(node.right)\n19 # append the current level list to the final result\n20 result.append(level)\n21 return result\nUsing queues for BFS in this way is clean, efficient, and intuitive, demonstrating why this combination is so common in coding interviews.\nSliding Window Problems\nIn these problems, we are given an array or list of elements, and we need to find or calculate something among all contiguous subarrays of a given size. Here, a queue\n(or deque\n, i.e., double-ended queue) can efficiently keep track of the elements in the current window, adding new ones to the end and removing old ones from the front. For a more comprehensive understanding of sliding window problems using queues, please refer to our guide on sliding window questions.\nExample: Given an array of integers and a number x\n, determine the smallest subarray with a sum greater than the given value.\nfrom collections import deque\ndef smallest\\_subarray\\_with\\_sum(arr, target):\nqueue = deque()\nmin\\_length = float('inf')\ncurrent\\_sum = 0\nfor num in arr:\nqueue.append(num)\ncurrent\\_sum += num\nwhile current\\_sum > target:\nmin\\_length = min(min\\_length, len(queue))\ncurrent\\_sum -= queue.popleft()\nreturn min\\_length if min\\_length != float('inf') else -1\n1from collections import deque\n2\n3def smallest\\_subarray\\_with\\_sum(arr, target):\n4 queue = deque()\n5 min\\_length = float('inf')\n6 current\\_sum = 0\n7\n8 for num in arr:\n9 queue.append(num)\n10 current\\_sum += num\n11\n12 while current\\_sum > target:\n13 min\\_length = min(min\\_length, len(queue))\n14 current\\_sum -= queue.popleft()\n15\n16 return min\\_length if min\\_length != float('inf') else -1\n17\nIn this solution, we iterate over the array, maintain a running sum and continuously add numbers to a queue. When the sum exceeds the target, we remove elements from the front of the queue until it's no longer the case, keeping track of the smallest length of such a subarray. This approach uses O(n)\ntime and O(n)\nspace.\nThis problem can also be solved using a sliding window approach with two pointers, which does not require extra space for a queue and has a space complexity of O(1). This would be a more space-efficient solution, especially for larger inputs.\nAdvanced Queue Structures (Priority Queues)\nPriority Queues are a type of queue where instead of being FIFO, elements are removed based on their priority. They are used in more complex algorithms like Dijkstra's and Heap Sort. Priority queues are often implemented using heaps where every enqueue, and dequeue operation takes O(log n)\ntime. The element with the highest priority is always at the front of the queue.\nPriority Queues Across Languages\nThe methods for implementing priority queues can differ across programming languages. In Python, the heapq\nlibrary is a popular choice for creating binary heaps and, thus, implementing priority queues. This library provides functions like heapify\nto convert a regular list into a heap, heappush\nto add an element to the heap, and heappop\nto remove the smallest element from the heap.\nJava, on the other hand, offers a PriorityQueue\nclass, which provides similar functionality. It's part of Java's Collections Framework and can be conveniently used out of the box to handle heap-like structures.\nJavaScript, however, does not have a built-in Priority Queue implementation. During interviews, candidates using JavaScript often simulate a priority queue for problem-solving. It's crucial to note this during the interview and clarify that your solution is simulating priority queue functionality, not using a native language feature.\nExample: Given an array of integers, return the k smallest elements in the array.\nIn the following Python solution, we use a max heap to keep track of the k smallest elements. We iterate over the array and add the first k elements to the heap. For each subsequent element, we check if it is smaller than the maximum element in the heap. If so, we remove the maximum element and add the new element to the heap. In the end, we return the heap as a list.\nimport heapq\ndef k\\_smallest(nums, k):\n# Create a max heap\nheap = [-num for num in nums[:k]]\nheapq.heapify(heap)\n# For each number in the array\nfor num in nums[k:]:\n# If the number is smaller than the maximum number in the heap\nif -heap[0] > num:\n# Remove the maximum number and insert the new number\nheapq.heappop(heap)\nheapq.heappush(heap, -num)\n# The heap now contains the k smallest numbers, return them as a list\nreturn [-num for num in heap]\n1import heapq\n2\n3def k\\_smallest(nums, k):\n4 # Create a max heap\n5 heap = [-num for num in nums[:k]]\n6 heapq.heapify(heap)\n7\n8 # For each number in the array\n9 for num in nums[k:]:\n10 # If the number is smaller than the maximum number in the heap\n11 if -heap[0] > num:\n12 # Remove the maximum number and insert the new number\n13 heapq.heappop(heap)\n14 heapq.heappush(heap, -num)\n15\n16 # The heap now contains the k smallest numbers, return them as a list\n17 return [-num for num in heap]\nIn this example, heapify\ntransforms the list into a heap in O(n)\ntime. This operation is crucial to enable the efficient extraction of minimum elements (in the case of a min-heap) or maximum elements (in the case of a max-heap). Subsequent removal of the maximum element (heappop\n) and insertion of a new element (heappush\n) both take O(log k)\ntime.\nA naive solution to this problem would be to sort the array and return the first k elements. However, this would take O(n log n)\ntime. We can solve this problem using a priority queue in O(n log k)\ntime.\nQueues in Multi-threaded Environments\nQueues are often used in multi-threaded environments as a safe way to exchange data between threads. They are used to implement buffers, task queues, etc. The queue\nmodule in Python, provides the Queue\nclass that is thread-safe.\nExample: Implement a multi-threaded program where one thread generates data and puts it in a queue, and another thread takes data from the queue and processes it.\nfrom queue import Queue\nfrom threading import Thread\nimport time\n# Producer function: generates data and puts it on a queue\ndef producer(q):\nfor i in range(5):\nprint('Produced:', i)\nq.put(i)\ntime.sleep(1) # Simulates time taken to produce the data\nq.put(None) # Adds poison pill to the queue to signal the consumer to stop\n# Consumer function: consumes data from a queue\ndef consumer(q):\nwhile True:\ndata = q.get()\nif data is None: # If the poison pill is found, terminate the loop\nbreak\nprint('Consumed:', data)\nq = Queue()\nt1 = Thread(target=producer, args=(q,))\nt2 = Thread(target=consumer, args=(q,))\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n1from queue import Queue\n2from threading import Thread\n3import time\n4\n5# Producer function: generates data and puts it on a queue\n6def producer(q):\n7 for i in range(5):\n8 print('Produced:', i)\n9 q.put(i)\n10 time.sleep(1) # Simulates time taken to produce the data\n11 q.put(None) # Adds poison pill to the queue to signal the consumer to stop\n12\n13# Consumer function: consumes data from a queue\n14def consumer(q):\n15 while True:\n16 data = q.get()\n17 if data is None: # If the poison pill is found, terminate the loop\n18 break\n19 print('Consumed:', data)\n20\n21q = Queue()\n22\n23t1 = Thread(target=producer, args=(q,))\n24t2 = Thread(target=consumer, args=(q,))\n25\n26t1.start()\n27t2.start()\n28\n29t1.join()\n30t2.join()\nIn this example, we create a queue and pass it to two threads. The producer thread generates data and puts it in the queue, while the consumer thread consumes data from the queue. The queue handles all the necessary locking to ensure multiple threads can safely add or remove items.\nQueues in System Design Interviews\nIn system design interviews, we use queues to ensure reliable processing and sequencing of messages in distributed systems. Queues also play a role in asynchronous processing, load balancing, batch processing, and resilience against failure. For example, in designing a messaging app like WhatsApp, you could use a queue to hold messages for delivery, ensuring they are sent in the order they were created, even if the user is temporarily offline.\nMany popular software solutions, such as RabbitMQ, Apache Kafka, Amazon SQS, and Redis, are used in the industry for queue management.\nWe have published a detailed guide on system design interviews. You can read more about queues and other system design concepts here.\nCommon Mistakes in Interviews Featuring Queues\nUsing an Array Like a Queue and Popping from the Front\nWhile arrays can be used to implement a queue, using array methods such as shift\n(JavaScript), pop\n(Python) or remove\n(Java) to pop an item from the front can be inefficient. This is because such operations require shifting all elements to fill the gap, resulting in a time complexity of O(n)\n.\nlet queue = [1, 2, 3, 4, 5];\nqueue.shift(); // removes the first element, but has to shift all other elements\n1let queue = [1, 2, 3, 4, 5];\n2queue.shift(); // removes the first element, but has to shift all other elements\nInstead, do the following:\nQueue queue = new LinkedList<>();\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\nqueue.add(4);\nqueue.add(5);\nqueue.remove(); // removes the first element in O(1) time\n1Queue queue = new LinkedList<>();\n2\n3queue.add(1);\n4queue.add(2);\n5queue.add(3);\n6queue.add(4);\n7queue.add(5);\n8queue.remove(); // removes the first element in O(1) time\nPlease note that JavaScript does not have a built-in queue data structure. You can use an array as a queue, but you should always say it upfront and mention that you know the performance implications. The alternative is implementing a custom queue class using a linked list.\nTrying to Use Libraries Without Knowing the API Methods Well\nCandidates often attempt to use library functions without understanding their underlying mechanisms. Knowing which methods are available and when to use them is important.\nFor example, in Java, when implementing queues, you must be aware of a few potential pitfalls or errors:\n-\nQueue is Empty: When a queue is empty, invoking\nremove()\nthrows aNoSuchElementException\n. To avoid this, usepoll()\norpeek()\n, which returns null when the queue is empty. -\nnull\nElements: In Java, you cannot add null to a queue (forArrayDeque\nandPriorityQueue\nimplementations). Trying to addnull\nthrows aNullPointerException\n.LinkedList\nimplementations allow null elements, but it's best to avoid them. -\nCapacity Restrictions: If you're using a bounded queue implementation like\nArrayBlockingQueue\n, you must be careful about capacity restrictions. Theadd()\nmethod throws anIllegalStateException\nwhen you try to add an element to a full queue. To avoid this, use theoffer()\nmethod, which simply returnsfalse\nwhen the queue is full.\nSimilarly, in Python, when a queue is empty, invoking popleft()\nthrows an IndexError\n. To avoid this, check if the queue is empty with len\nbefore calling popleft()\n.\nIn JavaScript, it's worth noting that there isn't a native heap data structure or priority queue implementation in the language. However, during an interview, you might be asked to solve problems as if there were. It can be challenging to pretend a working heap when unfamiliar with its interface. In such situations, you can refer to Python's heapq\nlibrary or Java's PriorityQueue\nclass to get an idea of the methods and behaviors a heap implementation might provide. For example, Python's heapq.heappush()\nto add an item, heapq.heappop()\nto remove and return the smallest item, and in Java's PriorityQueue\n, add()\nto insert elements, peek()\nto view the head element, poll()\nto remove and return the head element.\nNot Knowing How to Implement a Queue from Scratch\nRegardless of the language, understanding how to create a basic queue from scratch is a key skill. Some candidates might not be able to implement a queue without the help of built-in methods or classes. For example, a queue can be implemented from scratch in JavaScript using an object and two pointers (there could be other implementations as well).\nclass Queue {\nconstructor() {\nthis.storage = {};\nthis.head = 0;\nthis.tail = 0;\n}\nenqueue(item) {\nthis.storage[this.tail] = item;\nthis.tail++;\n}\ndequeue() {\nlet removed = this.storage[this.head];\ndelete this.storage[this.head];\nthis.head++;\nreturn removed;\n}\n}\nlet queue = new Queue();\nqueue.enqueue(\"first\");\nqueue.enqueue(\"second\");\nconsole.log(queue.dequeue()); // outputs \"first\"\n1class Queue {\n2 constructor() {\n3 this.storage = {};\n4 this.head = 0;\n5 this.tail = 0;\n6 }\n7\n8 enqueue(item) {\n9 this.storage[this.tail] = item;\n10 this.tail++;\n11 }\n12\n13 dequeue() {\n14 let removed = this.storage[this.head];\n15 delete this.storage[this.head];\n16 this.head++;\n17 return removed;\n18 }\n19}\n20\n21let queue = new Queue();\n22queue.enqueue(\"first\");\n23queue.enqueue(\"second\");\n24console.log(queue.dequeue()); // outputs \"first\"\nNot Using an Array When It's Easier and More Efficient\nThere are scenarios where simple array operations can lead to a more efficient and cleaner solution compared to a queue. A classic example is the problem of finding a continuous subarray in an array that sums up to a given target. This can be solved more efficiently using two pointers instead of a queue, leading to the space complexity of O(1)\n, which is more optimal than using a queue.\ndef find\\_subarray\\_with\\_sum(nums, target):\nleft, right = 0, 0\ncurrent\\_sum = 0\nwhile right < len(nums):\ncurrent\\_sum += nums[right]\nwhile current\\_sum > target and left <= right:\ncurrent\\_sum -= nums[left]\n# move the left pointer forward\nleft += 1\n# check if current sum equals target\nif current\\_sum == target:\nreturn (left, right)\n# move the right pointer forward\nright += 1\nreturn None\nprint(find\\_subarray\\_with\\_sum([1, 4, 20, 3, 10, 5], 33))\n# outputs (2, 4)\n1def find\\_subarray\\_with\\_sum(nums, target):\n2 left, right = 0, 0\n3 current\\_sum = 0\n4\n5 while right < len(nums):\n6 current\\_sum += nums[right]\n7\n8 while current\\_sum > target and left <= right:\n9 current\\_sum -= nums[left]\n10 # move the left pointer forward\n11 left += 1\n12\n13 # check if current sum equals target\n14 if current\\_sum == target:\n15 return (left, right)\n16\n17 # move the right pointer forward\n18 right += 1\n19\n20 return None\n21\n22print(find\\_subarray\\_with\\_sum([1, 4, 20, 3, 10, 5], 33))\n23# outputs (2, 4)\nNot Knowing How to Use Queues for BFS\nBreadth-First Search (BFS) is a core algorithm in computer science, and it's a staple in many coding interviews. It is crucial in solving problems such as finding the shortest path in an unweighted graph, serializing and deserializing a tree, or even spreading infection in a grid.\nWithout a firm grasp of how to use queues for BFS, a candidate can miss out on efficiently solving these problems and more, which can make all the difference in a competitive interview scenario.\nWhen heading into coding interviews, it's always a good idea to have a standard BFS algorithm using a queue, coded up and well-practiced, in your mental toolbox.\nWhat to Say in Interviews to Show Mastery Over Queues\nUnderstanding the Time Complexity Depending on the Underlying Structure\nDiscuss the time complexity of different queue operations, such as enqueuing and dequeuing, and how these complexities can change depending on the underlying structure (array, linked list, etc.) used to implement the queue. Demonstrating this understanding shows that you can consider and select the most appropriate data structure for a given problem.\nAsk Clarifying Questions\nAsking clarifying questions during the interview will help you better understand the problem and demonstrate your analytical skills and attention to detail. For example:\n- Is the queue bounded or unbounded?\n- What is the maximum size of the queue?\n- What are the elements of the queue?\n- Are they integers, strings, or objects?\n- What is the maximum size of the elements?\n- Are there any other constraints?\nThese questions are not exhaustive, but they are a starting point. Tailoring your questions based on the specific problem discussed in the interview will demonstrate your problem-solving approach and ability to focus on the finer details.\nDemonstrate Knowledge of Use Cases\nDemonstrating knowledge of where and why queues are used can set you apart. If the problem involves traversing a graph or a tree, mention that a queue would be perfect for a Breadth-First Search (BFS) because it naturally facilitates level-by-level traversal.\nIf the problem hints towards processing elements in a rolling window of a certain size, articulate that a queue can help manage this 'sliding window' scenario effectively. Additionally, while discussing the implementation, highlight the reasons to use a singly-linked list over a doubly-linked list (saving memory, simpler implementation) unless backward traversal is required.\nConsider Optimal Solutions\nDemonstrate a willingness to question your initial solution and strive for optimality. If you propose a solution using a queue, take a moment to evaluate whether a queue is necessary. Sometimes, problems can be solved more efficiently without queues or by using a simpler data structure. For example, many sliding window problems can be solved using a simple array and two-pointers. This is more efficient than using a queue, which would require additional space and operations.\nShowcase Your Advanced Knowledge\nDemonstrating knowledge beyond the basics always earns extra points. If you understand more complex data structures or concepts like XOR-deques (which use XOR operations to save memory) or ring buffers (which are perfect for handling 'recent activity' in a fixed amount of memory), bring them up in the interview. Explain why they're efficient and the specific scenarios where they can be advantageous.\nAbout the Author\nJai is a software engineer and a technical leader. In his professional career spanning over a decade, he has worked at several startups and companies such as SlideShare and LinkedIn. He is also a founder of a saas product used by over 10K companies across the globe. He loves teaching and mentoring software engineers. His mentees have landed jobs at companies such as Google, Facebook, and LinkedIn.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/queue-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Recursion Interview Questions & Tips for Senior Engineers",
      "content": "Recursion Interview Questions & Tips\nWhat is Recursion?\nRecursion is a strategy used in computer science where a function invokes itself to solve a problem. This self-referential nature of recursion helps to solve problems that can be broken down into simpler, similar problems. In other words, recursion is a strategy where the solution to a problem depends on solutions to smaller instances of the same problem.\nRecursion is a potent tool when dealing with problems related to data structures, such as traversing trees or graphs, sorting arrays, or exploring permutations and combinations. Functional languages like Haskell, Scala, and Erlang, among others, tend to favor recursion for control flow since they lack traditional looping constructs present in imperative languages.\nHow Recursion Works\nLet's understand recursion with an analogy. Suppose you're standing at the bottom of a staircase and want to reach the top. The staircase has many steps, and your task is to climb them all. A non-recursive way of thinking would be to count each step as you climb, one after the other, until you reach the top.\nHowever, a recursive approach would be different. Instead of thinking about all the steps you need to climb, in a recursive way, you wouldn't consider each step separately. Instead, you would break down the problem. How do you reach the top? You climb one step, and then you are left with a staircase that is shorter by one step.\nThis is your recursive step: climbing to the top of a staircase is the same as climbing one step and then climbing to the top of a smaller staircase.\nBut we're missing an important part - what if there's only one step? Or what if there are no steps at all? This brings us to the concept of a base case. In recursion, a base case acts as a stopping signal, telling the function when to stop calling itself and start returning.\nIn our analogy, the base case is when there are no more steps to climb. If there's only one step, you climb it, and you're done. If there are no steps, you're already at the top!\nfunction climb\\_steps(n):\n# Base case: if there are no more steps, stop recursion\nif n == 0:\nprint(\"You're at the top! All steps climbed.\")\nreturn\n# Recursive step: climb one step\nprint(\"Climb one step. Remaining steps: \", n-1)\n# Recursive call: continue climbing the remaining steps\nclimb\\_steps(n - 1)\n1function climb\\_steps(n):\n2 # Base case: if there are no more steps, stop recursion\n3 if n == 0:\n4 print(\"You're at the top! All steps climbed.\")\n5 return\n6\n7\n8 # Recursive step: climb one step\n9 print(\"Climb one step. Remaining steps: \", n-1)\n10 # Recursive call: continue climbing the remaining steps\n11 climb\\_steps(n - 1)\nLet's see what the output will look like when we call climb\\_steps(3)\n:\nClimb one step. Remaining steps: 2\nClimb one step. Remaining steps: 1\nClimb one step. Remaining steps: 0\nYou're at the top! All steps climbed.\n1Climb one step. Remaining steps: 2\n2Climb one step. Remaining steps: 1\n3Climb one step. Remaining steps: 0\n4You're at the top! All steps climbed.\nThis might seem like a mind-bender, but that's the nature of recursion! The process involves two key aspects: a recursive step, where the function calls itself to solve a smaller problem, and a base case, where the function knows to stop. Most looping operations can be expressed recursively, which is part of the reason why functional programming languages often favor recursion. These principles can be applied to a wide range of problems in computer science, which we'll explore further in the following sections.\nCall Stack\nBefore we move on, let's take a moment to understand how recursion works under the hood.\nThink of each recursive call to climb\\_steps\nas sending a climber to ascend the staircase. When the function calls itself, it's like it's sending another climber to ascend a slightly smaller staircase. The original climber waits at his step until the climber he sent finishes his climb.\nIn terms of a call stack, each climber represents a function call placed on the stack. The call at the top of the stack is the current step being climbed, and the calls below it are the steps waiting to be completed. Each call waits for the calls above it (the steps yet to be climbed) to complete before it can finish.\nSo, when you call climb\\_steps(n)\n, you place n\ncalls (climbers) on the stack. As each call completes (each climber reaches the top of their staircase), it's removed from the stack. The process continues until the stack is empty—all steps are climbed, and all climbers have finished.\nIn essence, the call stack is crucial to managing the flow of execution in recursive calls, ensuring that each function call is addressed correctly and executed in the correct order, no matter how many recursive calls are made. It is also important to note that the call stack is finite, and every recursive call takes up space on the stack. If you have too many recursive calls, you will eventually run out of space on the stack, resulting in a stack overflow error.\nTail Call Optimization\nWhile we did tell you that recursion takes space on the call stack, some modern compilers are smart, and canuse a cheeky trick called tail call optimization (TCO) to reduce the space used by recursion. In essence, if the very last act of a function is to call itself, the compiler can skip adding a new climber and simply let the current one climb further. In other words, the compiler can reuse the current stack frame for the next recursive call instead of adding a new one.\nHowever, not all programming languages support this optimization, but when they do, it's like having a single, tireless climber that efficiently completes the climb without causing a queue on the staircase. Scheme, Erland, and Scala are some of the languages that support TCO, while Python and Java do not. JavaScript also supports TCO in the spec, starting with ES6, but it's not yet implemented in most browsers.\nSo what’s the point? Recursive implementations are often more concise and readable when compared with iterative alternatives. But they may be undesirable in production workloads because of the potential for stack overflows. Tail call recursion unlocks the benefits and avoids the downsides.\nWhen to Use Recursion in Interviews\nThe beauty of recursion lies in its ability to express complex problems in a few lines of code. While iterating with loops can achieve the same results, the ability to decompose a problem into smaller instances of itself makes recursion a favorite technique in problem-solving. In interviews, you may use recursion when the problem fits into one of the following patterns.\nDivide and Conquer\nIn the divide and conquer approach, we break down a problem into smaller subproblems, solve each subproblem independently, and combine the solutions to answer the main problem. This approach works best when the subproblems are independent, meaning the solution to one does not depend on the solution to another.\nFor example, problems like Merge Sort and Quick Sort are quintessential divide-and-conquer problems where you continually divide the array into smaller pieces until you reach a trivially solvable size. We have written about Merge and Quick Sort in detail in our guide on sorting algorithms. Binary Search is another example of a divide-and-conquer problem where you divide the array into two halves and search for the target element in one of the halves.\nTree and Graph Traversal\nRecursion naturally models the hierarchical structure of trees and graphs. It allows you to explore all possibilities from a given node by moving deeper into the structure until a base case is met, in other words, using Depth-First Search (DFS). In the context of a binary tree, the process often involves visiting the root, the left subtree, and finally, the right subtree. Depending on how you visit the root, you can perform pre-order, in-order, or post-order traversal in a binary tree.\nLet's look at an example of pre-order traversal in a binary tree. In this case, we visit the root first, the left subtree, and finally the right subtree. The following code snippet shows how we can perform pre-order traversal using recursion.\nclass Node:\ndef \\_\\_init\\_\\_(self, value):\nself.value = value\nself.left = None\nself.right = None\ndef dfs(node):\nif node is None:\nreturn\nprint(node.value) # Visit the node\ndfs(node.left) # Visit left subtree\ndfs(node.right) # Visit right subtree\n1class Node:\n2 def \\_\\_init\\_\\_(self, value):\n3 self.value = value\n4 self.left = None\n5 self.right = None\n6\n7def dfs(node):\n8 if node is None:\n9 return\n10\n11 print(node.value) # Visit the node\n12 dfs(node.left) # Visit left subtree\n13 dfs(node.right) # Visit right subtree\n14\nIn this dfs\nfunction, we first visit the node (in this case, we just print its value). Then, we recursively visit the left and right subtrees. If a node is None\n, meaning we've reached a leaf node's child, we return and continue with the other nodes.\nAnother example is finding the leaves of a binary tree. You can see how we can use recursion to find the leaves of a binary tree in this detailed guide.\nBacktracking\nProblems requiring exploring all possible configurations to find a solution can be tackled using recursion. Backtracking often involves a sequence of choices, where each choice leads you down a path, and if that path does not lead to a solution, you backtrack and explore another path. It is like navigating a maze; you start at a point and take a step in a chosen direction. If you reach a dead end, you backtrack to your previous position and try a different path.\nHowever, it's essential to note that while backtracking can solve a wide variety of problems, it can also lead to performance issues, particularly in cases where the number of possible configurations is vast. Recursion-heavy backtracking can result in stack overflows (out-of-memory errors) or time-out issues due to the potentially massive number of recursive calls. In such cases, employing techniques such as caching or memoization can significantly improve performance by avoiding repetitive computation.\nBacktracking-related problems appear quite frequently in technical interviews. Some famous examples include N-Queens, Sudoku Solver, Word Search, Permutations and Subsets.\nDynamic Programming\nDynamic programming (DP) is a strategic approach employed for efficient problem-solving. Think of it as a well-organized toolkit that solves complex problems with ease. DP decomposes the main problem into simpler, smaller subproblems, which are solved only once. Their solutions are stored for future use. This unique approach is beneficial, especially when we encounter problems having overlapping subproblems and optimal substructure.\nOverlapping subproblems imply that the same smaller problems reappear multiple times during the computation. On the other hand, optimal substructure suggests that we can construct an optimal solution to the overall problem from the optimal solutions to its subproblems. These two conditions make a problem well-suited for a DP solution.\nNow, where does recursion fit into all this? Fundamentally, recursion helps us to break down the problem into manageable subproblems. However, unlike conventional recursion, where some calculations can be performed repeatedly, dynamic programming takes it a notch higher. DP stores the results of the subproblems by using a technique known as [memoization](https://interviewing.io/memoization-interview-questions, thus avoiding re-computation and increasing efficiency.\nRecursion vs Dynamic Programming\nLet's dive a little deeper into the distinction between dynamic programming and other recursion-based problems. When using dynamic programming with recursion, we introduce a memory function or a lookup table, known as memoization. This idea of \"remembering\" the results of solved subproblems separates DP from other recursive problems. By avoiding re-computation, we drastically reduce the time complexity, making DP a formidable tool to tackle complex problems efficiently.\nConsider the famous Fibonacci sequence, where each number is the sum of the preceding two. The naive recursive function to calculate Fibonacci numbers might lead to many redundant calculations. For instance, to calculate the 5th Fibonacci number, you would need to calculate the 3rd Fibonacci number twice.\ndef fibonacci(n):\nif n <= 1:\nreturn n\nelse:\nreturn (fibonacci(n-1) + fibonacci(n-2))\n1def fibonacci(n):\n2 if n <= 1:\n3 return n\n4 else:\n5 return (fibonacci(n-1) + fibonacci(n-2))\n6\nBut with dynamic programming and memoization, we store each result as we compute it, sidestepping the need to repeat our work:\ndef fibonacci(n, memo = {}):\nif n <= 1:\nreturn n\nelif n not in memo:\nmemo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\nreturn memo[n]\n1def fibonacci(n, memo = {}):\n2 if n <= 1:\n3 return n\n4 elif n not in memo:\n5 memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n6 return memo[n]\nThe impact is evident. By remembering the results of previously computed Fibonacci numbers, we avoid the inefficiency of redundant computation, and our program runs faster and smoother. This is the essence and beauty of combining recursion with dynamic programming.\nTop-down vs Bottom-up approaches\nThe recursive DP approach we have discussed here is also known as top-down dynamic programming. This method starts with the original problem and breaks it down into subproblems, storing the results of each along the way to avoid redundant computation. However, there's also a bottom-up approach, or tabulation, which solves all the subproblems first and uses their results to build up to the solution of the overall problem.\nWhile both methods leverage the principles of DP, they differ in space usage. Top-down methods can sometimes use more space due to the recursive call stack, especially for deep recursion trees. In contrast, bottom-up methods typically use iterative structures and are more space-efficient. Therefore, while choosing an approach, it's essential to consider the space requirements and tailor your solution accordingly.\nIn an interview, it's important to recognize when a problem fits into these patterns, as it strongly indicates that recursion could be a practical approach to finding the solution. As you gain more experience with recursion, you'll find it easier to spot these patterns and implement recursive solutions quickly and efficiently.\nCommon Mistakes in Interviews Featuring Recursion\nMisunderstanding Recursion Flow\nUnderstanding recursion flow is fundamental to writing and debugging recursive algorithms effectively. A crucial part of recursion is how it involves a function calling itself with a modified argument, progressing toward the base case. Many candidates can reason through the recursive flow but struggle with passing data between recursive calls, especially when they have to modify the data at each level or aggregate information from recursive calls.\nConsider a simple task of computing the depth of a binary tree, where depth is the number of nodes along the longest path from the root node down to the farthest leaf node. A common mistake is to neglect to pass information from child nodes back up to parent nodes:\ndef depth(node):\nif node is None:\nreturn 0\ndepth(node.left)\ndepth(node.right)\nreturn 1\n1def depth(node):\n2 if node is None:\n3 return 0\n4 depth(node.left)\n5 depth(node.right)\n6 return 1\nIn this example, the function correctly makes recursive calls to node.left\nand node.right\n, but it doesn't do anything with the results of these calls.\nTo avoid this mistake, always consider what information needs to be passed to each recursive call and what information needs to be returned from each recursive call. Make sure to aggregate or utilize the information returned from recursive calls properly. For the tree depth problem, the correct approach would be to use the depths of the left and right subtrees to compute the depth of the current node:\ndef depth(node):\nif node is None:\nreturn 0\nleft\\_depth = depth(node.left)\nright\\_depth = depth(node.right)\nreturn max(left\\_depth, right\\_depth) + 1\n1def depth(node):\n2 if node is None:\n3 return 0\n4 left\\_depth = depth(node.left)\n5 right\\_depth = depth(node.right)\n6 return max(left\\_depth, right\\_depth) + 1\nIn this corrected version, the function properly uses the recursive calls' results to calculate the tree's depth.\nNot Setting Base/Stop Conditions Correctly\nBase cases form the foundation of any recursive algorithm. They determine the conditions under which the recursion should terminate, preventing the program from entering an infinite loop. A common oversight, however, is the incorrect setting of these base cases, which might result in skipping certain conditions, leading to incomplete or incorrect results. Let's look at some examples.\nForgetting to Set a Base Condition\nA common mistake is diving into a problem's recursive logic without first setting a base condition. Without it, the function can become an endless loop, consuming more and more memory until the system runs out of resources.\nConsider the problem of finding the factorial of a number. If we forget to set a base condition:\ndef factorial(n):\n# No base condition\nreturn n \\* factorial(n-1)\n1def factorial(n):\n2 # No base condition\n3 return n \\* factorial(n-1)\nWithout base condition, the function will keep calling itself indefinitely until the system runs out of resources. To avoid this, when working on a recursive problem, always begin by setting a base condition.\nMissing Multiple Base Cases\nIn a problem like calculating the Fibonacci sequence, you might account for n == 0\nbase condition but forget to account for n == 1\n:\ndef fibonacci(n):\nif n == 0:\nreturn 0\n# Missing base case for n == 1\nreturn fibonacci(n-1) + fibonacci(n-2)\n1def fibonacci(n):\n2 if n == 0:\n3 return 0\n4 # Missing base case for n == 1\n5 return fibonacci(n-1) + fibonacci(n-2)\nTo stay away from such mistakes, think about all the possible base cases and make sure to account for each of them in your code.\nBase Case Too Broad\nIn a problem where you're tasked with reversing a linked list using recursion, a common mistake is to set a base case condition that is too broad. For instance, setting the base case as if not head or not head.next\n, would also halt the recursion when the function reaches the last node, not just when it's initially called with an empty list.\ndef reverseList(head):\n# Too broad base case\nif not head or not head.next:\nreturn head\np = reverseList(head.next)\nhead.next.next = head\nhead.next = None\nreturn p\n1def reverseList(head):\n2 # Too broad base case\n3 if not head or not head.next:\n4 return head\n5 p = reverseList(head.next)\n6 head.next.next = head\n7 head.next = None\n8 return p\nIn this code, the base case halts the recursion too early, and the last node's link isn't properly reversed. The correct base case should be if not head\n, which would only halt the recursion when the function is called with an empty list.\nIncorrect Order of Base Cases\nThe order in which base cases are presented in a recursive function matters significantly. If we check a less restrictive base case before a more restrictive one, we may encounter a situation where the function makes incorrect or unnecessary computations.\nLet's illustrate this point with an example from a classic algorithmic problem: the subset sum problem. This problem requires determining whether a subset of a given set of numbers exists that sums up to a specific target value k\n.\ndef subset\\_sum\\_incorrect(nums, target, i=0):\n# Incorrect order of base cases\nif target == 0:\nreturn True\nif i == len(nums) or target < 0:\nreturn False\nreturn subset\\_sum\\_incorrect(nums, target - nums[i], i + 1) or subset\\_sum\\_incorrect(nums, target, i + 1)\ndef subset\\_sum\\_correct(nums, target, i=0):\n# Correct order of base cases\nif i == len(nums) or target < 0:\nreturn False\nif target == 0:\nreturn True\nreturn subset\\_sum\\_correct(nums, target - nums[i], i + 1) or subset\\_sum\\_correct(nums, target, i + 1)\n1def subset\\_sum\\_incorrect(nums, target, i=0):\n2 # Incorrect order of base cases\n3 if target == 0:\n4 return True\n5 if i == len(nums) or target < 0:\n6 return False\n7 return subset\\_sum\\_incorrect(nums, target - nums[i], i + 1) or subset\\_sum\\_incorrect(nums, target, i + 1)\n8\n9def subset\\_sum\\_correct(nums, target, i=0):\n10 # Correct order of base cases\n11 if i == len(nums) or target < 0:\n12 return False\n13 if target == 0:\n14 return True\n15 return subset\\_sum\\_correct(nums, target - nums[i], i + 1) or subset\\_sum\\_correct(nums, target, i + 1)\nOverlooking Space Complexity\nOne of the often overlooked aspects of recursion is its space complexity. Each recursive call adds a new layer to the system's call stack, which can lead to high space complexity for deeply recursive algorithms. This space complexity often manifests as a Stack Overflow error, especially in languages that don't optimize for tail recursion. Candidates often forget to account for this in their complexity analysis.\nFor instance, using recursion for Depth-First Search in graph traversal problems can lead to extensive use of the call stack, resulting in high space complexity. A non-recursive approach like Breadth-First Search (BFS) might be more suitable in some cases.\nTo understand this better, let's return to the example of calculating the nth Fibonacci number.\ndef fibonacci(n):\nif n <= 1:\nreturn n\nelse:\nreturn fibonacci(n-1) + fibonacci(n-2)\n1def fibonacci(n):\n2 if n <= 1:\n3 return n\n4 else:\n5 return fibonacci(n-1) + fibonacci(n-2)\nThis function, while correct, has an exponential time complexity because of the repeated computations, and it also has a linear space complexity due to the maximum depth of the recursion, which is n\n. However, candidates often miss out on accounting for the space complexity and state that the space complexity is constant, which is incorrect.\nTo avoid this mistake, it's essential to consider the depth of recursion while analyzing space complexity. The recursion depth equals the maximum number of nested calls, and each call adds a new layer to the system's stack, contributing to the space complexity.\nAn iterative approach or memoization can help optimize time and space complexity in the Fibonacci example. Here's the Fibonacci function implemented iteratively, which has a constant space complexity:\ndef fibonacci(n):\ncurrent, next = 0, 1\nfor \\_ in range(n):\ncurrent, next = next, current + next\nreturn current\n1def fibonacci(n):\n2 current, next = 0, 1\n3 for \\_ in range(n):\n4 current, next = next, current + next\n5 return current\n6\nThere are no recursive calls in this iterative version of the Fibonacci function, so the space complexity is constant, O(1)\n, which is more space-efficient.\nFailing to Apply Memoization\nMemoization is crucial for recursive algorithms where the same subproblems are solved multiple times. Unfortunately, during interviews, candidates often forget to apply it, resulting in unnecessary computation and increased time complexity. You should always watch for cases where the same computation is performed multiple times, as these are opportunities for memoization to improve both performance and efficiency.\nWhat to Say in Interviews to Show Mastery Over Recursion\nDemonstrating mastery of recursion in interviews requires more than just solving the problem. You must also articulate your thought process, explain your problem-solving approach, and showcase your understanding of recursion. Let's look at some points to consider while dealing with problems related to recursion in a coding interview.\nUnderstanding Base Cases and the Recursive Step\nThe cornerstone of every recursive algorithm is its base case(s) and the recursive step. These two elements work together to solve a larger problem by systematically breaking it down into more manageable parts.\nDiscussing Base Cases\nA base case is the simplest instance of a problem that can be answered directly without any further recursive calls. When solving recursive problems, always start by identifying the base case. This could sound like, \"The base case for this problem is when we have an empty array, at which point we can directly return 0 as there are no elements to sum.\"\nAddressing the Recursive Step\nOnce the base case is established, you can delve into the recursive step, the part of the function that breaks the problem into smaller subproblems. Express your thought process out loud: \"Now, let's think about the recursive step. We want to divide our problem into smaller parts that look similar to the original problem. We could do this by taking one element from the array and recursively calling our function on the rest of the array.\"\nBy clearly explaining the base case(s) and the recursive step(s), you demonstrate a solid understanding of recursion and communicate your problem-solving approach effectively to your interviewer. This will set a strong foundation for the rest of your solution.\nOptimizing Recursive Solutions\nOptimizing Recursive Solutions\nWhile a brute-force recursive solution might be a good starting point, it's equally important to demonstrate how to optimize it. This often involves identifying and eliminating overlapping subproblems, a common issue in naive recursive solutions.\nStarting with a Simple Recursive Solution\nBegin by outlining a straightforward recursive solution. Articulate your approach like this: \"The immediate approach that comes to mind is a simple recursion where we break down the problem into smaller subproblems. However, I notice that this approach might lead to repeated calculations, thereby increasing the time complexity.\" While discussing the basic recursive solution, this might also be a good time to state the input and output of the function clearly.\nIdentifying Optimizations\nIdentify potential inefficiencies in your solution. A common issue with recursive solutions is that they often end up solving the same subproblems multiple times. Share your observations with the interviewer: \"I see that we're solving the same subproblems multiple times, which is inefficient.\"\nApplying Optimizations\nNext, suggest improvements to the solution. For example, if your solution involves solving overlapping subproblems, suggest using memoization or dynamic programming to store and reuse solutions to subproblems. This could be phrased as, \"To make this solution more efficient, we could use memoization to store the results of subproblems. This way, we avoid redundant calculations, and if a subproblem needs to be solved again, we can just fetch its result from our memoization table.\"\nBy thinking critically about your initial recursive solution and applying optimization strategies like memoization or dynamic programming, you can show your interviewer that you're capable of developing efficient code, a critical skill for any software engineer.\nHandling Deep Recursion\nShowing your awareness of recursion limits and how different languages handle them can demonstrate your depth of knowledge. Say something like, \"Given the problem's constraints, the depth of the recursion might become an issue because it could lead to a stack overflow.\" You might want to suggest using an iterative approach involving a stack.\nTo show mastery over recursion, you can also discuss the idea of tail call optimization (explained above) and whether your language of choice supports it.\nAsking the Right Questions\nWhen it comes to implementing recursion in graph or tree structures, asking the right questions is crucial to fully grasp the problem and create an efficient solution.\nAddressing the Nature of Nodes\nStart by understanding the nature of the nodes in the graph or tree. You could ask, \"Are the nodes in the graph directional or bidirectional? This impacts whether we treat the graph as a directed or undirected, subsequently affecting our recursive approach.\"\nConsidering Possible Edge Cases\nAlso, anticipate edge cases, which can drastically change how your recursion unfolds. Ask questions like, \"Can there be loops in the graph? Is it possible to have a null or empty graph/tree? These scenarios need to be considered in our base case to avoid infinite recursion and null pointer exceptions.\"\nBy asking these critical questions upfront, you demonstrate your analytical thinking and attention to detail and ensure that your recursive solution is robust and well-rounded, capable of handling a wide range of scenarios.\nJai is a software engineer and a technical leader. In his professional career spanning over a decade, he has worked at several startups and companies such as SlideShare and LinkedIn. He is also a founder of a saas product used by over 10K companies across the globe. He loves teaching and mentoring software engineers. His mentees have landed jobs at companies such as Google, Facebook, and LinkedIn.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/recursion-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Search Interview Questions & Tips for Senior Engineers",
      "content": "MEDIUM\nData Structures and Algorithms\nMEDIUM\nData Structures and Algorithms\nMEDIUM\nData Structures and Algorithms\nMEDIUM\nData Structures and Algorithms\nEASY\nData Structures and Algorithms\nMEDIUM\nData Structures and Algorithms\nMEDIUM\nData Structures and Algorithms\nMEDIUM\nData Structures and Algorithms\nMEDIUM\nData Structures and Algorithms\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/search-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Sets Interview Questions & Tips for Senior Engineers",
      "content": "What Are Sets?\nA set is a collection of distinct objects of similar type. They are a fundamental construct in mathematics. Groups of elements, such as numbers, be it integers, real numbers, floats, and even null types, are commonly grouped as sets when discussing set theory.\nGiven their fundamental stature in the world of integers and floats, it was only natural that programming languages would have data structures that reflect set properties in the world of bits and bytes. In Python, you can define sets ({}\n) using curly braces or the set() function. Sets in Python are mutable and can be modified using various built-in methods. Java also provides a built-in Set interface, with variant implementations such as HashSet, TreeSet, and LinkedHashSet. In C++, the Standard Template Library (STL) provides the set container, which allows for efficient insertion, deletion, and searching of elements. Similarly, in C#, the HashSet and SortedSet classes can be used to implement sets.\nProperties of Sets\n- Uniqueness: Sets contain only unique elements, meaning that there are no duplicate elements within a set.\n- Unordered: Sets do not have any inherent order to their elements, meaning that the elements can be listed in any order.\n- Mutability: Fundamentally, sets should be mutable. Most programming languages have base set implementations that allow you to add or remove elements from a set.\n- Subsets: A set can be a subset of another set if all of its elements are also contained within the other set. The empty set is a fundamental subset of all sets. It is mathematically defined as\n∅\n- Equality: Two sets are equal if they contain the same elements, regardless of the order in which they are listed.\nCommon Set Operations\n| Operation | Description | Time Complexity |\n|---|---|---|\n| union(set1, set2) | Returns a set containing all elements from both set1 and set2 | O(len(set1) + len(set2)) |\n| intersection(set1, set2) | Returns a set containing only elements that are in both set1 and set2 | O(min(len(set1), len(set2))) |\n| difference(set1, set2) | Returns a set containing only elements that are in set1 but not in set2 | O(len(set1)) |\n| symmetric\\_difference(set1, set2) | Returns a set containing only elements that are in set1 but not in set2 | O(len(set1) + len(set2)) |\n| insertion(element, set) | Returns a set containing only elements that are in either set1 or set2, but not both | O(1) |\n| deletion(element, set) | Removes element from set | O(1) |\n| lookup(element, set) | Returns True if element is in set, False otherwise | O(1) |\n| update(set1, set2) | Updates set1 with elements from set2 | O(len(set2)) |\nThe examples below illustrate these operations:\n| Operation | Set 1 | Set 2 | Result |\n|---|---|---|---|\n| union | {1, 2, 3} | {3, 4, 5} | {1, 2, 3, 4, 5} |\n| intersection | {1, 2, 3} | {3, 4, 5} | {3} |\n| difference | {1, 2, 3} | {3, 4, 5} | {1, 2} |\n| symmetric\\_difference | {1, 2, 3} | {3, 4, 5} | {1, 2, 4, 5} |\n| insertion | 4, {1, 2, 3} | - | {1, 2, 3, 4} |\n| deletion | 3, {1, 2, 3, 4} | - | {1, 2, 4} |\n| lookup | 3, {1, 2, 3, 4} | - | True |\n| update | {1, 2}, {2, 3, 4} | - | {1, 2, 3, 4} |\nSets Implementation in Various Programming Languages\nEnglish: According to Shakespeare, …Okay, I’m kidding!\nOverall, set implementation in programming languages varies slightly, but the basic principles and functionality remain the same.\n| Language | Syntax |\n|---|---|\n| Python | set1 = {1, 2, 3} or set1 = set([1, 2, 3]) |\n| Java | Set set1 = new HashSet<>(); |\n| C++ | std::set set1; |\n| C# | HashSet set1 = new HashSet(); |\n| Javascript | let set1 = new Set([1, 2, 3]); |\nWhen to Use Sets in Interviews\nTwo common scenarios should always trigger your set antennas:\n- Quick lookups: Sets have an amortized constant lookup, insertion, and deletion time complexity. Any time you have to track elements, be it when pathfinding or performing deduplication tasks, requiring a look back to what elements you have seen before, use sets. Their lookup, insertion, and deletion complexities guarantee excellent performance.\n- Unique elements: Homogeneity entails all elements being of the same type. Be it Integers, strings, floats, etc, any time you have a collection of similar element types and need to ensure no duplicates, using a set is the way to go.\nCommon Mistakes in Interviews Featuring Sets\nUsing Hashtables Instead of Sets\nBy far the most common mistake candidates make is simply failing to use sets. Hashtables also give you quick lookups, but they come with a lot of overhead. Each insertion requires both a key and a value; thus, a hashtable, by default, will always use at least twice the memory a set would track the same unique collection of elements. Similarly, a single insertion operation into a set would require two in a hashtable, as they require both the key and values set. Anytime you need to track unique elements and do not need to save values, occurrence frequencies, or such, a set should be the go-to data structure.\nUsing List/Array Operations on Sets\nLists will usually allow you to append elements to the end of the list. They also allow you to perform splices and even mix element types. This is because lists have an inherent order. Sets, however, do not. Any operations that leverage the order of elements will usually not be available in base set implementations. You can add elements to a set, but unless it is an ordered set, you are not guaranteed that it will be at the end. As such, you cannot pop from a set. Instead, you delete\nan element from the set. Below is a table of common operations on sets and lists that get mixed up and set specific idiosyncrasies to keep an eye out for.\n| List Operation | Set Operation | Notes |\n|---|---|---|\n| list.append(elem) | set.add(elem) | list.append() adds an element to the end of the list. set.add() will add elem to the set but does not guarantee order, only presence. |\n| list.pop() | set.pop() | list.pop() removes and returns the last element of the list. set.pop() removes and returns an arbitrary element of the set. |\n| list.extend(lst) | set.update(other\\_set) | list.extend() appends the elements of list to the end of the list. set.update() adds the elements of other\\_set to the set in no inherent order. |\n| list.remove(elem) | set.remove(elem) | list.remove() removes the first occurrence of elem from the list. set.remove(elem) removes elem from the set, or raises an error if elem is not in the set. |\nDo note that the above is based on Python, but the behavior tends to be similar in most languages. Confirm the nuances by reading through the documentation of your preferred language. This section primarily aims to spotlight how differently common operations behave.\nTrying to Use an Index as a Look Up Element\nCandidates often make the mistake of trying to access elements in the set using indices because lists and sets are similar. Inherently, sets do not have an order, and so elements aren’t assigned an index. As such, you cannot retrieve elements by their position. That said, lookups in sets are O(1)\n, so simply searching for the element should be performant enough.\nMixing Element Types\nWhen working with sets, it is important to ensure that you add elements of the same type. Candidates often forget to check the data types of the elements they add to the set or to standardize the data type when type-casting elements. This is especially common when converting lists to sets. Adding elements of different types to a set can result in unpredictable behavior or type errors. Sets are designed to contain only elements of a single data type. To avoid this mistake, make it a habit to explicitly cast elements to a standard type (The string type is a good fallback as most objects and data types can be cast to string).\nWhat to Say in Interviews to Show Mastery Over Sets\nClarify Element Type\nDuring interviews, ensure you explicitly declare what data type you will be adding to your set. Type check or even cast when inserting if necessary, but make sure the type is clear. The goal is to avoid type errors while also showcasing a fundamental understanding of the data type homogeneity property of sets.\nComplexity of Operations\nIn your interviews, be mindful of set operation complexities. Most “advanced” set operations are expensive, but candidates don’t realize it. Talk to your interviewer about the worst-case as this is the expected benchmark when discussing performance. An example:\nTo perform the intersection operation, we need to see if each element in one set is in the other set. Lookup being O(1)\nmeans that the intersection will cost at least O(min(len(set1), len(set(2))))\n, assuming we are going through elements of the smaller set and looking up their presence in the larger set. The space complexity is also O(min(len(set1), len(set(2))))\nas in the worst case, all elements of the smaller set will be in the large set.\nKnowing When to Use Sets vs. Hash Tables\nWhile you can get away with using either of these two in most situations, try to use the right structure for the job. A simple heuristic to use is:\nDo I need to remember any values? Examples are frequency counting or tracking occurrences or positions. If yes, a hashtable is the way to go. Otherwise, a set should suffice.\nAbout the Author\nGithire (Brian) is a backend and ML engineer with 7 YoE ranging from startups to major corporations. He has worked on tech serving a wide demographic ranging from mobile money in his homeland Kenya, embedded tech with Kakao in South Korea to MLE at Microsoft. Brian has also worked as a teacher and has a knack for writing technical articles\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/sets-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Sliding Window Interview Questions & Tips for Senior Engineers",
      "content": "Sliding Window Interview Questions & Tips\nThe sliding window technique is a powerful and frequently used algorithmic technique in coding interviews. It offers an elegant way to solve a broad array of problems, often related to subarrays or substrings, with maximum efficiency. This article aims to provide a deep dive into this technique, highlighting when it's beneficial, common pitfalls, and how to demonstrate proficiency in interviews.\nWhat is a Sliding Window?\nThe sliding window technique provides an efficient method for handling subarrays and substrings. It is a specialized subtype in the broader umbrella of Two Pointer problems. This approach involves creating a 'window' that slides over the data to compute a desired result. It uses the result of the previous window position to calculate the result of the position of the window. Sliding Window is potentially one of the most common patterns you'll come across during a coding interview to solve array or string-related questions.\nPicture yourself aboard a train, where the view from your window continually changes. You can see a part of the scenery outside, but as the train advances, the portion of the scene you can observe changes. You're not moving within the train; instead, the train (and thus the window) is moving over the landscape.\nThis is precisely how the sliding window technique works in algorithmic problems. Consider the 'landscape' as your array or list of data. The 'train window' is your 'sliding window', which moves over the data, taking a subset of it into consideration at any given moment. As the window slides over the data, it helps to focus on a specific portion, analyze it, and find particular properties of the elements in that section.\nThe brilliance of the sliding window technique comes from its strategy of decomposing a larger problem into smaller, manageable sub-problems.\nFor instance, consider the problem of finding subarray sums of size k\nfor an array. A straightforward interpretation might view it as n\nseparate problems of adding up k\nelements. However, the sliding window technique reframes this into a single, flowing problem. As the window of size k\nslides over the array, the sum of the k\nelements is continually adjusted by adding the new incoming element and subtracting the outgoing one. In this way, a larger problem—is decomposed into a simpler, ongoing task —updating a single sum as the window slides. This approach significantly reduces redundant computations and enhances efficiency.\nThe technique is especially beneficial when the solution can be iteratively constructed from contiguous sections of larger data sets, where the order of data plays a crucial role, such as strings, arrays, or linked lists. The advantage of the sliding window is its efficiency—often bringing the complexity down to O(n)\n.\nWhen to Use Sliding Window\nThe Sliding Window technique is a great fit for problems where you're working with linear data structures like arrays or strings, and you need to find something specific within a subarray or substring. This \"something specific\" could be a maximum or minimum value, a target sum, or a specific pattern. Essentially, if your problem involves sequentially scanning through the data and the task is focused on contiguous portions of this dtaa, the Sliding Window technique can often provide an efficient solution.\nIt's important to note here the distinction between subarrays and subsequences. Subarrays and substrings refer to contiguous segments of the original data. For example, in the array [1, 2, 3, 4, 5]\n, [1, 2, 3]\nand [4, 5]\nare subarrays—notice how the elements are adjacent to each other. On the other hand, subsequences can contain elements that are not contiguous. In the same array [1, 3, 5]\nis a subsequence—the elements are not adjacent but they maintain the original order. To further clarify, the Sliding Window technique lends itself well to the \"Longest Common Substring\" problem, but it is not suitable for the \"Longest Common Subsequence\" problem due to the non-contiguous nature of subsequences.\nHow to Use Sliding Window in an Interview\nThere are two main types of sliding window problems: fixed-size and variable-size sliding windows. The distinction lies in whether the window's size remains constant as it slides or changes based on certain conditions. In this section, we'll see how to work with both types.\nFixed-Size Sliding Window\nIn a fixed-size sliding window problem, we maintain a window of a fixed-size 'k' that slides through the data structure.\nApproach\n- First, we compute the desired result (like sum, average, count) for the initial size 'k' window.\n- Then, we slide the window one element at a time. For every slide, we adjust our result by adding a new element and removing the last element of the previous window.\n- While sliding the window, we keep track of the desired outcome (like maximum sum, longest sequence, and minimum average).\nThis approach can be seen in many fixed-size sliding window problems.\nExample\nGiven an integer array nums\n, find a contiguous subarray whose length is 'k' with the maximum/minimum average value. Also, output the maximum/minimum average value.\nSolution\nWe use a fixed-size sliding window to tackle this problem. After initializing variables for window start and window sum, we calculate the sum of the initial window size 'k'. Moving the window by one element at each step, we adjust our window sum by subtracting the outgoing element and adding the incoming element. We continuously calculate the average and track the maximum average found so far.\ndef find\\_max\\_average(nums, k):\nwindow\\_start, window\\_sum = 0, 0.0\nmax\\_avg = float('-inf')\nfor window\\_end in range(len(nums)):\n# Add the incoming element to the window sum\nwindow\\_sum += nums[window\\_end]\n# If we've hit the window size, start sliding\nif window\\_end >= k - 1:\n# Calculate average of current window and compare with max\\_avg\nmax\\_avg = max(max\\_avg, window\\_sum / k)\n# Subtract the outgoing element from window sum\nwindow\\_sum -= nums[window\\_start]\n# Slide the window\nwindow\\_start += 1\nreturn max\\_avg\n1def find\\_max\\_average(nums, k):\n2 window\\_start, window\\_sum = 0, 0.0\n3 max\\_avg = float('-inf')\n4\n5 for window\\_end in range(len(nums)):\n6 # Add the incoming element to the window sum\n7 window\\_sum += nums[window\\_end]\n8 # If we've hit the window size, start sliding\n9 if window\\_end >= k - 1:\n10 # Calculate average of current window and compare with max\\_avg\n11 max\\_avg = max(max\\_avg, window\\_sum / k)\n12 # Subtract the outgoing element from window sum\n13 window\\_sum -= nums[window\\_start]\n14 # Slide the window\n15 window\\_start += 1\n16\n17 return max\\_avg\nVariable-Size Sliding Window\nIn variable-size sliding window problems, the window's size changes based on certain conditions.\nApproach\n- Start with a window that includes the first element.\n- Expand the window until it no longer satisfies the problem's condition.\n- Contract the window from the left, continuously checking if it satisfies the condition.\n- Repeat expanding and contracting the window while keeping track of the minimum/maximum size or other desired outcomes.\nThis approach can be generalized for a variety of variable-size sliding window problems.\nExample\nLongest Substring Without Repeating Characters: Given a string, find the length of the longest substring without repeating characters.\nSolution\nThis is a variable-size sliding window problem. We maintain a dictionary to keep track of the characters and their latest indices in the window. We expand the window from the right, adding the rightmost character to the window. If this character is already in the dictionary (which means it's a repeated character), we slide the window start to the right of the previous occurrence of the character. This way, we ensure the window always contains unique characters. Meanwhile, we continuously calculate and track the maximum length of substrings we've found so far.\ndef length\\_of\\_longest\\_substring(s):\nwindow\\_start, max\\_length = 0, 0\nchar\\_index\\_map = {}\nfor window\\_end in range(len(s)):\nright\\_char = s[window\\_end]\nif right\\_char in char\\_index\\_map: # If the character is repeated in the window\n# Slide the start of the window to the right of\n# the previous occurrence of the right\\_char\nwindow\\_start = max(window\\_start, char\\_index\\_map[right\\_char] + 1)\nchar\\_index\\_map[right\\_char] = window\\_end # Store the current index of the character\n# Compute the current window size and compare with max\\_length\nmax\\_length = max(max\\_length, window\\_end - window\\_start + 1)\nreturn max\\_length\n1def length\\_of\\_longest\\_substring(s):\n2 window\\_start, max\\_length = 0, 0\n3 char\\_index\\_map = {}\n4\n5 for window\\_end in range(len(s)):\n6 right\\_char = s[window\\_end]\n7\n8 if right\\_char in char\\_index\\_map: # If the character is repeated in the window\n9 # Slide the start of the window to the right of\n10 # the previous occurrence of the right\\_char\n11 window\\_start = max(window\\_start, char\\_index\\_map[right\\_char] + 1)\n12\n13 char\\_index\\_map[right\\_char] = window\\_end # Store the current index of the character\n14\n15 # Compute the current window size and compare with max\\_length\n16 max\\_length = max(max\\_length, window\\_end - window\\_start + 1)\n17\n18 return max\\_length\n19\nAdditional Problems\nCommon Mistakes in Interviews Featuring Sliding Window\nUnderstanding common pitfalls can significantly improve your performance in interviews. Here are some to watch out for when employing the Sliding Window technique:\nOff-by-One Errors\nOff-by-one errors, a common stumbling block in programming, occur when an element is missed or processed more than necessary due to an incorrect condition in the loop or a wrongly set boundary. In the context of the sliding window technique, this often involves miscalculating the window's start or end indices.\nLet's take an example. Suppose we have an array nums = [1, 2, 3, 4, 5]\nand we need to compute the sum of every subarray of size 3. A common off-by-one mistake would be incorrectly setting the loop condition, leading to missing an entire window:\nwindow\\_size = 3\nfor i in range(len(nums) - window\\_size): # Off-by-one error\nprint(sum(nums[i: i + window\\_size]))\n1window\\_size = 3\n2for i in range(len(nums) - window\\_size): # Off-by-one error\n3 print(sum(nums[i: i + window\\_size]))\n4\nIn this example, the loop terminates one step earlier than required, so the sum for the last window [3, 4, 5]\nis never computed. The correct approach would be to adjust the loop to range(len(nums) - window\\_size + 1)\n.\nTo avoid such off-by-one errors, always carefully consider the indices of your window and ensure that your loop conditions accommodate the entire array or list. It's beneficial to dry-run your code with simple test cases to ensure you aren't missing any elements or windows.\nJumping Directly to the Optimized Solution\nA common mistake during interviews is jumping directly to the most optimized solution. While it's important to aim for optimization, it's equally crucial to demonstrate your problem-solving journey to the interviewer. Start with a simple brute force solution, highlighting its inefficiencies, and discuss why a more optimal solution is required. Then, introduce the Sliding Window technique as a more efficient alternative, illustrating the improvements in time complexity.\nFor instance, in a problem where you have to find a maximum sum subarray of a specific size k\n, you might say, \"An initial brute force approach could involve generating all possible subarrays of size k\nand calculating their sums. This would lead to a time complexity of O(n\\*k)\n. By implementing the Sliding Window approach, we can maintain a running sum within a 'window' of elements, sliding this window across our array to find subarray sums in O(n)\ntime, significantly improving our algorithmic performance.\"\nOverlooking Edge Cases and Not Asking Clarifying Questions\nWhile dealing with sliding window problems, it's essential to consider edge cases that could lead to bugs or incorrect answers. Edge cases are unusual or extreme situations, such as an empty input, a single-element array, or a window size larger than the array itself. Handling these scenarios appropriately in your code is crucial.\nAsking insightful, clarifying questions during the process of understanding the problem can help you identify edge cases. Let's consider the problem \"Find the longest substring with at most k\ndistinct characters\".\nTo start, you might ask, \"Are upper and lower case characters considered distinct or the same for this problem?\"\nThen, you could inquire about the nature of k\nas well. For example, you might ask, \"Can k\nbe zero? If so, should the function return an empty string?\", or \"Can k\nbe negative?\". You could also ask, \"What should happen if the string is empty?\"\nBy asking these questions, you demonstrate a comprehensive understanding of the problem, a keen eye for edge cases, and a desire to produce an accurate, optimized solution. This approach ensures you understand all facets of the problem before diving into code, potentially saving you from having to backtrack.\nNot Testing Enough\nThe insights from understanding edge cases and asking clarifying questions should inform the tests you use to validate your code. After coding your solution, you should conduct dry runs with a variety of test cases. This includes 'normal' scenarios, edge cases that you've identified, and scenarios based on the clarifying questions you've asked.\nFor instance, if you've handled a case in your code where k\ncan be zero or negative, ensure to include these situations in your tests. Similarly, if you've considered scenarios where the input string is empty, your tests should reflect this as well.\nThis phase of testing your solution validates your code and demonstrates to your interviewer that you understand the importance of thorough testing and quality assurance.\nWriting Messy Code\nClear, well-structured code signals your expertise. When applying the sliding window technique, your code should accurately represent the “window”. Use descriptive variable names like 'window\\_start' and 'window\\_end' instead of 'i' and 'j'. Be mindful of potential off-by-one errors when moving the window or updating its state.\nwindow\\_start, max\\_length = 0, 0\nfor window\\_end in range(len(input)):\n# Code to update the window's state goes here...\nwhile # condition to shrink the window:\n# Code to shrink the window goes here...\nwindow\\_start += 1\n1window\\_start, max\\_length = 0, 0\n2for window\\_end in range(len(input)):\n3 # Code to update the window's state goes here...\n4 while # condition to shrink the window:\n5 # Code to shrink the window goes here...\n6 window\\_start += 1\nNeglecting Complexity\nIt's crucial to discuss the time and space complexity of your solution. Ideally, the sliding window portion of your solution should aim for O(n)\ntime complexity since each element in the array or string should be visited only once by the 'window'. However, remember that other factors and operations, such as sorting an unsorted array before applying the sliding window, may increase the overall time complexity.\nAs you discuss complexity, don't forget to consider any auxiliary data structures, like dictionaries, used in your solution. These contribute to space complexity, which is also an important part of the efficiency of your code. For instance:\n# For example, this dictionary contributes to space complexity:\nchar\\_index\\_map = {}\n1# For example, this dictionary contributes to space complexity:\n2char\\_index\\_map = {}\nOverlooking Improvements\nLastly, discuss how your solution could bbe further optimized or adapted to different problems. For instance, if the input only contains certain characters, you could use a fixed-size array instead of a dictionary to track the window's contents.\n# If the input only contains ASCII characters:\nwindow\\_contents = [0] \\* 128\n1# If the input only contains ASCII characters:\n2window\\_contents = [0] \\* 128\n3\nAbout the Author\nJai is a software engineer and a technical leader. In his professional career spanning over a decade, he has worked at several startups and companies such as SlideShare and LinkedIn. He is also a founder of a saas product used by over 10K companies across the globe. He loves teaching and mentoring software engineers. His mentees have landed jobs at companies such as Google, Facebook, and LinkedIn.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/sliding-window-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Stacks Interview Questions & Tips for Senior Engineers",
      "content": "Stacks Interview Questions & Tips\nWhat is a Stack?\nA stack is a linear data structure that permits access to its underlying data through two primary operations: 'push' (to add) and 'pop' (to remove).\nLet's visualize how a stack operates with an analogy. Consider the desk of my history professor, always brimming with a pile of books. The most recently acquired book occupies the top spot in this stack. If he wants to revisit an older book, he must take off all the books above it, one at a time. Once he retrieves his desired book, he has to replace the rest, with the latest one reclaiming its position on top. This act of taking off a book from the top mirrors the 'pop' operation while placing a new book onto the stack is akin to 'push'. The stack data structure uniquely allows for the addition or removal of data from only one end, much like this pile of books.\nStack Compared to a Queue\nA queue provides a similar linear data structure that differs from a stack only in how it is accessed. A stack adds and removes items from the same end, while in the case of a queue, an item is added to one end and removed from the other. This is why a queue is commonly called a FIFO structure (First In First Out).\nStack Operations\nA stack supports the following operations:\npush\n: adds an item to the top of the stackpop\n: removes the top item from the stackpeek\n: returns the top item from the stack without removing itisEmpty\n: returns true if the stack is empty, false otherwisesize\n: returns the number of items in the stack\nThe stack is a key player in computer science, powering many core algorithms. It's behind everyday tasks like clicking a 'back' button in a browser or using 'undo' and 'redo' in a document. Operating systems use stacks to keep track of running processes and to store local variables. Compilers use them to evaluate expressions and parse syntax. And, as we'll see in this article, interviewers love to ask questions about stacks.\nWhen to Use Stacks in Interviews\nStacks are a great way to test a candidate's understanding of fundamental data structures, so the topic is frequently covered in interviews, although chances are the interviewer won't directly spell out a 'stack' for you to implement. Instead, they'll present you with a problem that can be solved using a stack. So, it's important to be able to recognize such problems and to know how to apply a stack to solve them. Some things which should trigger the use of a stack are: changing the order of a given sequence, dealing with nested structures like parentheses, or a recursive algorithm. Let's look at some examples below.\nWhen you are asked to reverse the order of a given sequence\nYou are given a string, and you need to reverse it. For example, given the string \"hello\", you should return \"olleh\".\nWhenever you encounter a problem that involves reversing the order of something, such as a string or an array, the stack data structure should be your go-to solution. In such scenarios, the approach would be to push each character of the string or each element of the array onto a stack, and then pop them off one by one. This will result in the elements being reversed, demonstrating the power and usefulness of stacks in such situations.\nNote that most of the time, when you’re asked to reverse a string, you’ll be doing it in place. While the in-place solution offers superior space complexity, sometimes you might have to NOT do it in place, and that’s when a stack-based approach still serves as an excellent starting point.\ndef reverse\\_string(string):\nstack = []\nfor char in string:\n# iterate over each character in the string and push\n# it onto the stack\nstack.append(char)\nreversed\\_string = []\nwhile len(stack) > 0:\n# pop each character off the stack and append to the\n# reversed\\_string list. The list will later be joined\n# to form a string\nreversed\\_string.append(stack.pop())\nreturn \"\".join(reversed\\_string)\nprint(reverse\\_string(\"hello\")) # prints: olleh\n1def reverse\\_string(string):\n2 stack = []\n3 for char in string:\n4 # iterate over each character in the string and push\n5 # it onto the stack\n6 stack.append(char)\n7 reversed\\_string = []\n8 while len(stack) > 0:\n9 # pop each character off the stack and append to the\n10 # reversed\\_string list. The list will later be joined\n11 # to form a string\n12 reversed\\_string.append(stack.pop())\n13 return \"\".join(reversed\\_string)\n14\n15print(reverse\\_string(\"hello\")) # prints: olleh\nAlthough this might look like a good answer, the interviewer may want to probe you further to see if you can come up with a more optimal solution. The above solution has a space complexity of O(n)\nbecause we use an extra stack to store the characters. The in-place solution does it all without using extra space, bringing the space complexity down to O(1)\n.\nWhen You're Asked to Validate a Sequence of Brackets\nYou are given a string containing only parentheses, brackets, and curly braces. You need to determine if the string is valid. A string is considered valid if all the brackets are closed in the correct order. For example, \"([])\" is valid, but \"([)]\" is not.\nThis is another classic stack question. The solution is to push each opening bracket onto a stack and then pop them off when a closing bracket is encountered. If the closing bracket doesn't match the opening bracket at the top of the stack, the string is invalid.\ndef is\\_balanced(s):\nstack = []\nbrackets = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\nfor char in s:\n# If the character is an opening bracket, push it onto the stack\nif char in brackets:\nstack.append(char)\nelse:\n# If the stack is empty, it means there is no opening bracket\n# for the current closing bracket, so return False\nif not stack:\nreturn False\n# If the top of the stack doesn't match the current character, return False\nelif brackets[stack.pop()] != char:\nreturn False\nreturn not stack\nprint(is\\_balanced(\"({[]})\")) # prints: True\nprint(is\\_balanced(\"({[}))\")) # prints: False\n1def is\\_balanced(s):\n2 stack = []\n3 brackets = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n4\n5 for char in s:\n6 # If the character is an opening bracket, push it onto the stack\n7 if char in brackets:\n8 stack.append(char)\n9 else:\n10 # If the stack is empty, it means there is no opening bracket\n11 # for the current closing bracket, so return False\n12 if not stack:\n13 return False\n14 # If the top of the stack doesn't match the current character, return False\n15 elif brackets[stack.pop()] != char:\n16 return False\n17\n18 return not stack\n19\n20print(is\\_balanced(\"({[]})\")) # prints: True\n21print(is\\_balanced(\"({[}))\")) # prints: False\nTakeaway: When you are asked to validate a nested structure (like parentheses in this case), think of using a stack.\nWhen You're Asked to Implement a Recursive Algorithm Iteratively\nIn a recursive algorithm, a function calls itself until it reaches a base case. The recursive calls are stored in a stack, although this stack is implicitly maintained by the system and is invisible to the programmer. So to convert a recursive algorithm to an iterative one, you need to simulate the recursive call stack using an explicit stack.\nSay, you are tasked to implement Depth First Search on a binary tree. The recursive solution is pretty straightforward. It involves five lines of code. The interviewer might ask you to implement it iteratively. As suggested earlier, you can use a stack here.\n# recursive\ndef dfs(root):\nif not root:\nreturn\ndfs(root.left)\ndfs(root.right)\n# iterative\ndef dfs(root):\nstack = [root]\nwhile stack:\nnode = stack.pop()\nif node.right:\nstack.append(node.right)\nif node.left:\nstack.append(node.left)\n1# recursive\n2def dfs(root):\n3 if not root:\n4 return\n5 dfs(root.left)\n6 dfs(root.right)\n7\n8\n9# iterative\n10def dfs(root):\n11 stack = [root]\n12 while stack:\n13 node = stack.pop()\n14 if node.right:\n15 stack.append(node.right)\n16 if node.left:\n17 stack.append(node.left)\nWhen You're Asked to Find the Next Greater (or Smaller) Element in a Sequence\nThis category of problems can be solved using a monotonic stack. A monotonic stack is a stack that is either strictly increasing or decreasing. In other words, the elements in the stack are sorted in either ascending or descending order. For the next greater element, we make a monotonically decreasing stack. For the next smaller element, we make a monotonically increasing stack.\ndef next\\_greater\\_element(nums):\nresult = [-1] \\* len(nums)\nstack = []\n# iterate over the array\nfor i in range(len(nums)):\n# if the current element is greater than the\n# element at the top of the stack, pop the stack\n# the current element is the next greater element\n# for all the elements in the stack which are less\nwhile stack and nums[stack[-1]] < nums[i]:\nresult[stack.pop()] = nums[i]\nstack.append(i)\nreturn result\nprint(next\\_greater\\_element([2, 1, 2, 4, 3])) # prints: [4, 2, 4, -1, -1]\n1def next\\_greater\\_element(nums):\n2 result = [-1] \\* len(nums)\n3 stack = []\n4 # iterate over the array\n5 for i in range(len(nums)):\n6 # if the current element is greater than the\n7 # element at the top of the stack, pop the stack\n8 # the current element is the next greater element\n9 # for all the elements in the stack which are less\n10 while stack and nums[stack[-1]] < nums[i]:\n11 result[stack.pop()] = nums[i]\n12 stack.append(i)\n13 return result\n14\n15print(next\\_greater\\_element([2, 1, 2, 4, 3])) # prints: [4, 2, 4, -1, -1]\nWhen You're Asked to implement a Queue Using Stacks\nTypically a queue is implemented using a linked list. But it can also be implemented using two stacks.\nOne stack is used to enqueue elements, and the other is used to dequeue elements. When the dequeue stack is empty, we pop all the elements from the enqueue stack and push them onto the dequeue stack. This reverses the order of the elements, giving us the FIFO (First In First Out) property of a queue.\nclass Queue:\ndef \\_\\_init\\_\\_(self):\nself.enqueue\\_stack = []\nself.dequeue\\_stack = []\ndef enqueue(self, x):\n# append the new element to the enqueue stack\nself.enqueue\\_stack.append(x)\ndef dequeue(self):\n# if dequeue stack is empty pop all the elements\n# from enqueue stack and push them onto the dequeue stack\nif not self.dequeue\\_stack:\nwhile self.enqueue\\_stack:\nself.dequeue\\_stack.append(self.enqueue\\_stack.pop())\n# pop the element from the dequeue stack and return it\nreturn self.dequeue\\_stack.pop()\n1class Queue:\n2 def \\_\\_init\\_\\_(self):\n3 self.enqueue\\_stack = []\n4 self.dequeue\\_stack = []\n5\n6 def enqueue(self, x):\n7 # append the new element to the enqueue stack\n8 self.enqueue\\_stack.append(x)\n9\n10 def dequeue(self):\n11 # if dequeue stack is empty pop all the elements\n12 # from enqueue stack and push them onto the dequeue stack\n13 if not self.dequeue\\_stack:\n14 while self.enqueue\\_stack:\n15 self.dequeue\\_stack.append(self.enqueue\\_stack.pop())\n16 # pop the element from the dequeue stack and return it\n17 return self.dequeue\\_stack.pop()\nThis solution might follow a discussion on the design choices made and time complexity of this approach.\nEnqueue operations, implemented as push operations on the enqueue stack, have a time complexity of O(1)\n. Dequeue operations, however, are more intricate. In the worst case, when the dequeue stack is empty, all items are transferred from the enqueue stack, resulting in a time complexity of O(n)\n. In the best case, where the dequeue stack is not empty, the item is popped in O(1)\n. Over many operations, the time complexity averages out to an amortized O(1)\n. This is because each element undergoes at most three stack interactions. First, each element is subjected to an enqueue operation. Then, it is moved from the enqueue stack to the dequeue stack. Finally, a dequeue operation is performed on the element.\nConcurrency problems\nIn concurrent programming, data structures like stacks often play a crucial role, particularly in the classic producer-consumer problem. This problem involves two types of processes: the producer, which generates data and adds it to the stack, and the consumer, which removes and processes data from the stack.\nTo ensure smooth operation, the stack must be thread-safe, meaning multiple threads can execute push and pop operations without risking inconsistencies, known as race conditions. This thread safety is usually achieved by employing synchronization mechanisms like locks, which allow only one thread to modify the stack at any given time.\nCommon Mistakes in Interviews Featuring Stacks\nNot Knowing the Time Complexity of Stack Operations\nStack operations are O(1)\ntime because the underlying data structure is a linked list. Pushing and popping from the head of a linked list is O(1)\ntime. Now, depending on which programming language you use, there might be differences in how the stack is implemented under the hood, these differences can affect your time complexity calculations. For example, in Python, a stack is implemented using a list, which in turn, is implemented as a dynamic array. When we need to add a lot of data to the stack, the underlying dynamic array may need to resize itself, which can be an expensive operation. To mitigate this cost, we can use deque from the collections module. A deque is implemented using a doubly linked list in Python and therefore doesn't need to resize itself.\nrom collections import deque\nstack = deque()\nfor i in range(100000):\nstack.append(i)\nstack.pop()\n1rom collections import deque\n2\n3stack = deque()\n4\n5for i in range(100000):\n6 stack.append(i)\n7\n8stack.pop()\nJavaScript, Go, and Ruby employ dynamic arrays for stack implementation; JavaScript uses Array, Go utilizes a slice, and Ruby adopts Array. All these constructs potentially experience O(n)\ntime complexity during resizing due to their dynamic array nature.\nNot Considering the Space Complexity of Using the Implicit Stack for Recursive Algorithms\nRecursive algorithms use the call stack to store intermediate results. This is an implicit stack, and it's important to consider its space complexity. For example, the recursive solution to the Fibonacci sequence has a space complexity of O(n). This is because the call stack will have at most n frames. Each frame corresponds to a recursive call to the function.\ndef fib(n):\nif n <= 1:\nreturn n\n# each recursive call to fib() adds a frame to the call stack\nreturn fib(n - 1) + fib(n - 2)\n1def fib(n):\n2 if n <= 1:\n3 return n\n4 # each recursive call to fib() adds a frame to the call stack\n5 return fib(n - 1) + fib(n - 2)\nIt usually helps to draw a recursive tree to visualize the call stack. The depth of the tree is the space complexity of the algorithm.\nNot Checking for Stack Underflow\nStack underflow occurs when you try to pop an element from an empty stack. This is a common mistake. Most languages provide a version of checking whether the stack is empty before popping an element. For example, in Python, you can use the if stack\ncheck to see if the stack is empty before popping an element.\nDemonstrating Mastery Over Stacks in Interviews\nKnowing the Internal Implementation of a Stack\nStacks are commonly implemented using a linked list or a dynamic array. If this comes up during the interview, you should be able to explain the tradeoffs between the two approaches. For example, a linked list implementation is more space efficient because it doesn't need to resize itself. However, it's less cache-friendly because the elements are not stored contiguously in memory. A dynamic array implementation is less space efficient because it needs to resize itself. However, its cache behavior is friendlier because the elements are stored contiguously in memory.\nKnowing Language-Specific Nuances\nIn Java, you can use the Stack\nclass to implement a stack. However, it's recommended to use the Deque\ninterface instead because the Stack\nclass extends the Vector\nclass, which is a legacy class. In Python, you can use the list\nclass to implement a stack. However, you can also use the deque\nclass from the collections\nmodule. In a multi-threaded environment, deque\nis a better choice because it's thread-safe and memory efficient. In JavaScript, you can use the Array\nclass to implement a stack.\nDiscussing the Space and Time Complexity of Stack Operations\nAs discussed earlier, recursion uses the call stack to store intermediate results. This implicit call stack results in higher space requirements and might end up causing a stack overflow. When you offer a solution, you can discuss the time and space complexities of your solution using an implicit or an explicit stack. Having the tradeoffs in mind will help you develop a better solution.\nSuggesting an Iterative solution to a Recursive Algorithm\nMost recursive algorithms can be easily converted to an iterative solution using a stack. There are distinct advantages to using an iterative solution: space savings and no risk of stack overflow. So, it's important to know the distinction. Sometimes, the interviewer may ask you not to use iteration because the recursive solution is more elegant. In that case, you can mention the iterative solution and explain why it's better.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/stacks-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Strings Interview Questions & Tips for Senior Engineers",
      "content": "Strings Interview Questions & Tips\nWhat are Strings?\nAlong with arrays, strings are one of the simplest data structures out there and are always coming up. Strings can be thought of as a subset of arrays because, as simple as they are, strings come with their own set of intricacies and challenges. Here are three key properties that we need to remember as we start working with strings.\n- Under the hood, strings are just an array of characters. This is important because it affects the time complexities of string methods we might use – keep reading for more details on this!\n- Like arrays, strings are variable in size. This one might be obvious given the above point, but it bears repeating. In most languages, arrays are treated as a collection, whereas we think of a string as a single “thing”. However, remember that it’s still an array of characters in memory, so the space the string takes up AND it takes a linear amount of time to generate a hash of a string where N is proportional to the length of the string. When discussing time complexities the length of a string plays a factor.\n- In most languages, strings are immutable. This is the biggest difference between strings and generic arrays – you can't change them once they are constructed! If you need to update a string you have to rebuild an entirely new string with the update you want. How you avoid this waste of time & space is language dependent. In Java, a StringBuilder is used to hold a stream of characters before converting it to a final immutable string. In Python, it's common to use a list to hold individual characters and then convert it to a string at the very end. Some problems like Reversing a String are commonly solved in C++, where strings are mutable, but if you are working in a language where strings aren't mutable to follow the spirit of this question it requires you to \"fake\" string mutability by first converting your string to a list then pretending your language can mutate strings directly.\nCommon Mistakes in Interviews Featuring Strings\nViewing String Problems As \"Easy\"\nStrings, despite being one of the first data structures introduced to programmers, shouldn't be underestimated as \"easy\" in interview scenarios due to their versatility. Unlike data structures like trees or graphs that have specific algorithms like DFS/BFS or backtracking respectively, strings can incorporate a range of technical topics frequently asked in interviews. Strings are a linear data structure, and because of that all common algorithms related to linear data structures could potentially be involved in a string question. This means techniques like two pointers, sliding windows, recursion, backtracking, and dynamic programming (to name just a few) can be used in a string question. Therefore, avoiding string practice due to perceived ease could lead to challenges in handling complex string problems in interviews.\nMessing Up String Conversions\nOne of the more annoying things we can have to do, which nevertheless comes up fairly often, is various forms of string math. This includes converting characters to their index in the alphabet and converting characters to their numeric value. General familiarity with how to do these things in your interviewing language is critical. It's obscure enough to not remember on the spot, but simple enough that it looks bad if you don't know how to do it.\nMaking Assumptions About String Contents\nIt's easy to think of strings as just letters in the alphabet, but this will lead to one of the most common interview errors with string questions – making an incorrect assumption about the string contents. Useful clarifying questions to ask whenever strings are involved in a problem can be questions like.\n- Are we guaranteed that there will just be alphabetical characters? Alphanumeric?\n- Do we need to worry about punctuation?\n- Do I need to handle special characters/symbols?\n- Can the string ever be empty or null?\n- Is the string always lower/uppercase? Can we receive a mixed case string?\n- Do we need to worry about the string encoding at all? UTF-8, ASCII, etc?\n- Does the string fit into memory?\nHere's a good example of a string question where all of these questions matter in achieving the correct output to pass all tests. Don't make assumptions about what is in the string, asking these types of questions helps demonstrate your seniority and familiarity with common gotchas.\nHidden Complexity\nOne danger you should be aware of is how languages will abstract away the heavy lifting when it comes to strings. This can make us wrongly assume that \"simple\" operations are cheap. For example, we can very easily get a substring of a string in Python using the Python slicing syntax: s[1:5]. Writing it this way we may assume that this is a constant-time operation. However, in most cases, operations like this are still going to copy the substring (remember strings are immutable), meaning that it is going to take us linear time.\nOne great feature of Java is the StringBuilder class. This class provides a performant way to modify and append onto a string by using an array as the underlying data structure. StringBuilder also provides a nice toString() method that we can use to recover a string.\nC uses an array as the underlying data structure which prevents the language from masking additional complexity. With that said, we have to be careful when allocating an array in C. The size of the array is static which means all of the memory needs to be allocated up front!\n| String Operation | Description | Time | Space |\n|---|---|---|---|\n| Length | Returns the number of characters in the string. | O(1)\n| O(1)\n|\n| Index Access | Accesses a character at a specific position in the string. | O(1)\n| O(1)\n|\nConcatenation (+ )\n| Combines two strings into one. | O(n)\n| O(n)\n|\nTraversal (e.g. for loop)\n| Goes through each character in the string one by one. | O(n)\n| O(1)\n|\nNaive Search (e.g. contains , index of )\n| Searches for a specific character or substring in the string. | O(n\\*m)\n| O(1)\n|\n| Substring | Creates a new string that is a subset of the original string. | O(m)\n| O(m)\n|\nn\nrepresents the length of the stringm\nrepresents the length of the substring\nThis above table is a generalized view of string operations, but it's worth mentioning that the details will differ depending on your particular language. For example, in some Java versions, the substring operation was O(1)\nin space complexity as it shared the same character array with the original string, but this has been changed in more recent versions to avoid memory leaks, leading to O(s)\nspace complexity, with m\nas the length of the substring.\nAdvanced String Topics\nThe Multiple Pointers Technique\nSame as with arrays, it is common to use multiple pointers to traverse a string. This allows us to accomplish various interesting tasks with substrings and comparing characters. Here are some problems to consider:\nThe Sliding Window Technique\nSliding windows are common with any linear data structure. That includes things like arrays, linked lists, and, of course, strings. They are a great tool for finding the longest substring matching an arbitrary property. For practice take a look at the following.\n- Longest substring without repeating characters\n- Longest substring with at least k repeating characters\n- Find all anagrams in a string\nAdvanced String Algorithms\nThese advanced algorithms are fairly niche and only likely to be asked at FAANG companies, and even then these algorithms show up a small fraction of the time. If you want to go deep on strings, there are three advanced algorithms worth having on hand. All of these algorithms are used for searching for a substring within a string and variations of them exist in a handful of problems online. The core algorithms to learn are:\nRegular Expressions\nWhile it is unlikely that you will get a problem which can be solved directly with regular expressions, you should have a good idea of how regular expressions work. Leetcode questions with regular expression answers do exist, but are uncommon. If you're thinking of using regular expressions in your solution, you're probably over-complicating it. With that stated, it is still important to have familiarity with them. Consider playing with a site like regex101.com to develop a better sense of regular expressions. Additionally, spend some time thinking through how to document a regular expression. Demonstrating not just an understanding of regular expressions but how to make them maintainable shows a certain coding maturity.\nLanguage-Specific Advice\nUp to this point, all the advice we have given has been language agnostic but various languages handle strings very differently. In this section, we will cover features of four popular language choices: Java, C++, Python & JavaScript.\nJava Strings\nFast Facts:\n- Mutable? No\n- Primitive? No\n- Comparison:\ns1.equals(s2)\n- Access the ith character:\ns1.charAt(i)\nUseful Java String Methods:\n| Method | Description | Time | Space |\n|---|---|---|---|\ns.length()\n| Returns the length of the string | O(1)\n| O(1)\n|\ns.charAt(int i)\n| Returns the character at index i\n| O(1)\n| O(1)\n|\ns.substring(int i, int j)\n| Returns substring from i to j (inclusive of i , exclusive of j )\n| O(j-i)\n| O(j-i)\n|\ns.contains(String s)\n| Returns True if s is contained in the string\n| O(1)\n| O(1)\n|\ns.indexOf(String s)\n| Returns the starting index of the first occurrence of s\n| O(n)\n| O(1)\n|\nIn Java, there are some common points to be aware of…\n/\\* Strings are OBJECTS \\*/\n// Primitives in Java are lowercase and include data types like:\ndouble foo = 76.762121;\nchar bar = 'i';\nboolean baz = true;\n// Strings are \\*Objects\\*\nString s = \"Interviewing.io\";\n/\\* String comparison doesn't use the == operator \\*/\nString a = \"Interview\";\nString b = \"Interview\";\n// This outputs false because == compares the Object pointers not values\nSystem.out.println(a == b);\n// This outputs true because equals() compares the values of the strings\nSystem.out.println(a.equals(b));\n/\\* Comparing Object pointers uses the == operator \\*/\nString c = a;\n// This outputs true since a and b point to the same object in memory\nSystem.out.println(a == c);\n1/\\* Strings are OBJECTS \\*/\n2// Primitives in Java are lowercase and include data types like:\n3double foo = 76.762121;\n4char bar = 'i';\n5boolean baz = true;\n6\n7// Strings are \\*Objects\\*\n8String s = \"Interviewing.io\";\n9\n10\n11/\\* String comparison doesn't use the == operator \\*/\n12String a = \"Interview\";\n13String b = \"Interview\";\n14\n15// This outputs false because == compares the Object pointers not values\n16System.out.println(a == b);\n17// This outputs true because equals() compares the values of the strings\n18System.out.println(a.equals(b));\n19\n20\n21/\\* Comparing Object pointers uses the == operator \\*/\n22String c = a;\n23// This outputs true since a and b point to the same object in memory\n24System.out.println(a == c);\nC++ Strings\nFast Facts:\n- Mutable? No\n- Primitive? No\n- Comparison:\ns1.compare(s2)\n- Access the ith character:\ns1[i]\nUseful C++ String Methods:\n| Method | Description | Time | Space |\n|---|---|---|---|\ns.length()\n| Returns the length of the string s (from string::length)\n| O(1)\n| O(1)\n|\ns1.find(s2)\n| Returns the index of s1 in the string s2 (from string::find)\n| O(s1 \\* s2)\n| O(1)\n|\nstrcpy(chars, s.c\\_str())\n| Converts s1 into a character array\n| O(n)\n| O(n)\n|\ns.substr(i, j)\n| Get the substring of s from i with length j\n| O(j)\n| O(j)\n|\nThe largest difference between strings in Java and C++ is that strings are mutable in C++. See below for details!\n#include \n#include \nint main() {\n// Primitive types\ndouble foo = 76.762121;\nchar bar = 'i';\nbool baz = true;\n// Strings are not a primitive in C++. They are an object of std::string class\nstd::string a = \"Interviews\";\nstd::string b = \"Interviews\";\n// Comparing strings using compare()\n// Returns 0 since strings are equal\nif(a.compare(b) == 0){\nstd::cout << \"You will see this because both strings are identical\";\n}\n// Comparing strings using == operator\nif(a == b){\nstd::cout << \"You will see this because both strings are identical\";\n}\n// Strings are mutable in C++\nstd::string c = str1;\nc[9] = 'z'; // attempt to modify the last letter of string works!\nstd::cout << c; // will print \"Interviewz\"\nreturn 0;\n}\n1#include \n2#include \n3\n4int main() {\n5 // Primitive types\n6 double foo = 76.762121;\n7 char bar = 'i';\n8 bool baz = true;\n9\n10 // Strings are not a primitive in C++. They are an object of std::string class\n11 std::string a = \"Interviews\";\n12 std::string b = \"Interviews\";\n13\n14 // Comparing strings using compare()\n15 // Returns 0 since strings are equal\n16 if(a.compare(b) == 0){\n17 std::cout << \"You will see this because both strings are identical\";\n18 }\n19\n20 // Comparing strings using == operator\n21 if(a == b){\n22 std::cout << \"You will see this because both strings are identical\";\n23 }\n24\n25 // Strings are mutable in C++\n26 std::string c = str1;\n27\n28 c[9] = 'z'; // attempt to modify the last letter of string works!\n29 std::cout << c; // will print \"Interviewz\"\n30\n31 return 0;\n32}\nPython Strings\nFast Facts:\n- Mutable? No\n- Primitive? Yes and no, but mostly no. \"Primitive\" isn't a word in Python, all types are objects!\n- Comparison:\ns1 == s2\n- Access the ith character:\ns1[i]\nUseful Python String Methods:\n| Method | Description | Time | Space |\n|---|---|---|---|\nlen()\n| Returns the length of the string | O(1)\n| O(1)\n|\ns1 in s2\n| Is s1 a substring of s2\n| O(s1 \\* s2)\n| O(1)\n|\ns1.index(s2)\n| Returns the index of the first occurrence of s2 in the string, ValueError if not found\n| O(s1)\n| O(1)\n|\nlist(s)\n| Converts s1 into a list of characters\n| O(n)\n| O(n)\n|\ns[i:j]\n| Get the substring of s from i (inclusive) to j (exclusive)\n| O(j-i)\n| O(j-i)\n|\nIn typical Python fashion, this is probably the easiest of these four languages to handle strings. Rather than having to use a lot of function calls, much of what we might want to do is built into the language, such as getting substrings of a string. However, you should use caution when using Python, the simplicity of the language often masks underlying complexity.\n# All types in Python are objects\nfoo = 76.762121\nbar = 'i'\nbaz = True\na = \"Interviews\"\nb = \"Interviews\"\nprint(type(foo)) # \nprint(type(bar)) # \nprint(type(baz)) # \nprint(type(a)) # \n# Comparing strings in Python\nprint(a == b) # True\n# Strings are immutable in Python\na[9] = 'z' # TypeError: 'str' object does not support item assignment\n1# All types in Python are objects\n2foo = 76.762121\n3bar = 'i'\n4baz = True\n5a = \"Interviews\"\n6b = \"Interviews\"\n7print(type(foo)) # \n8print(type(bar)) # \n9print(type(baz)) # \n10print(type(a)) # \n11\n12# Comparing strings in Python\n13print(a == b) # True\n14\n15# Strings are immutable in Python\n16a[9] = 'z' # TypeError: 'str' object does not support item assignment\nJavaScript Strings\nFast Facts:\n- Mutable? No\n- Primitive? Yes\n- Comparison:\ns1 == s2\nand sometimess1 === s2\n(see below for details) - Access the ith character:\ns1[i]\nUseful JavaScript String Methods:\n| Method | Description | Time | Space |\n|---|---|---|---|\ns.length()\n| Returns the length of the string | O(1)\n| O(1)\n|\ns2.includes(s1)\n| Is s1 a substring of s2\n| O(s2)\n| O(1)\n|\ns.indexOf(searchValue)\n| Returns the index of the first occurrence of searchValue\n| O(1)\n| O(1)\n|\ns.split(separator)\n| Splits the string into an array of substrings based on the separator | O(1)\n| O(1)\n|\ns.join(separator)\n| Joins the elements of an array into a string using the separator | O(1)\n| O(1)\n|\ns.substring(i, j)\n| Get the substring of s from i (inclusive) to j (exclusive)\n| O(1)\n| O(1)\n|\nJavaScript strings share some similarities with other languages but also have their unique characteristics. In JavaScript, strings are primitive values but have access to several built-in methods that allow manipulation and retrieval of string data. It's important to note that JavaScript strings are immutable, meaning that once a string is created, it cannot be changed. Instead, operations on strings return new strings.\nWhen comparing strings in JavaScript, the strict equality operator (===)\nis used to compare both the value and the type of the string. This ensures an accurate comparison of two strings. To access individual characters within a string, the charAt()\nmethod is used.\nJavaScript provides various useful methods for working with strings, such as length\nto retrieve the length of a string, substring\nto extract a portion of a string, includes\nto check if a substring is present, indexOf\nto find the index of a substring, split\nto split a string into an array based on a separator, and join\nto concatenate array elements into a single string using a separator.\nBe sure to be particularly mindful of string immutability in JavaScript, since string update operations will compile successfully and fail silently like the below example illustrates:\nlet str = \"ab\";\n// attempting to swap 'a' and 'b'\nlet temp = str[0]\nstr[0] = str[1]; // operation does nothing and fails silently!\nstr[1] = temp; // operation does nothing and fails silently!\nconsole.log(str); // still \"ab\"!!!\n1let str = \"ab\";\n2\n3// attempting to swap 'a' and 'b'\n4let temp = str[0]\n5str[0] = str[1]; // operation does nothing and fails silently!\n6str[1] = temp; // operation does nothing and fails silently!\n7console.log(str); // still \"ab\"!!!\nOverall, JavaScript offers a range of methods and functionalities for handling strings, making it a versatile language for string manipulation tasks.\nAbout the Authors\nJared is a software engineer with nine years of development experience. Jared has worked in a variety of fields including power systems engineering and actuarial science. Jared is currently working at Dropbox in data infrastructure.\nMike Mroczka, a former senior SWE (Google, Salesforce, GE), is the primary author of Beyond Cracking the Coding Interview—the official sequel to Gayle McDowell's original CTCI. He works as a tech consultant and has a decade of experience helping engineers land their dream jobs. He’s a top-rated mentor (interviewing.io, Karat, Pathrise, Skilled.inc) and the author of viral technical content on system design and technical interview strategies featured on HackerNews, Business Insider, and Wired. He also sometimes writes technical content for interviewing.io (like this piece) and was one of the authors of interviewing.io’s A Senior Engineer's Guide to the System Design Interview.\nYou can find him online at mikemroczka.com, LinkedIn, and X.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/strings-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Topological Sort Interview Questions & Tips for Senior Engineers",
      "content": "What Is Topological Sort?\nTopological sort is an algorithm used in graph theory to sort a directed acyclic graph (DAG) based on relationships between the vertices. It arranges the vertices of a DAG in a linear order such that for each directed edge (u\n, v\n), vertex u\ncomes before vertex v\nin the ordering. This algorithm is commonly used in tasks that require a specific order of execution, such as scheduling jobs or tasks.\nIn a DAG, there are no cycles, which means that there is no way to start at a vertex and reach itself by following its edges. This property is important because it makes it possible to order the vertices in a way that respects the direction of the edges.\nTopological sort can be performed using both depth-first search (DFS) and Breadth First Search (BFS) algorithms. My preference tends to be BFS as some objects tend to be on the same level and BFS makes it easy to incorporate these while generating the sorted output on the fly. It also handles isolated vertices out of the box.\nTopological sort has many real-world applications, including task scheduling, project management, and software engineering. In the context of interviews, it is the go-to solution for problems such as course scheduling and good old Alien Dictionary. A collection of topological sort problems and solutions can be found here\nHow to Perform Topological Sort\nOften, an introduction to topological sort focuses on graph properties, which can make it a bit hard to understand. This is why most of the questions related to the topic are tagged Hard. As such, let us try and approach it like an alien who has no clue what even the word topology\nmeans!\nWhat Exactly Is 'Topology'?\nAccording to the Oxford Dictionary:\n[Noun]\nThe way in which constituent parts are interrelated or arranged.\nExample usage in a sentence: \"using distances determined in this manner ignores existing road conditions and topology that can potentially affect travel time and costs\"\nHere's a common definition from the field of mathematics.\nThe study of geometric properties and spatial relations unaffected by the continuous change of shape or size of figures.\nHmm, not particularly helpful, is it? Perhaps we can turn to Geography as that is where the term is most commonly encountered;\nGeographic\ntopology\nis a branch of geography that studies the spatial relationships between objects or features on the earth's surface. It is concerned with understanding how these objects or features are connected and how they relate to one another in space.\nMuch better. In essence, topology\nentails defining how objects in space are interconnected. The brain is in the head\n, Food is on the table\n, A car is in a parking lot\n, or Leetcode should go to hell\n. Okay, maybe not that last one, but the idea here is that we have objects that have a relationship where objects are connected through relationships such as contains\n, on top of\n, is in\n.\nGiven the relationships, there exists an innate order to the objects. You cannot access the brain without first getting through the head, food ‘on’ a plate cannot be accessed from below, and of course, you cannot master leetcode algorithmic questions without going through hell! (I'm sorry, it was too perfect not to mention!)\nIf we have multiple objects chained together, the relationships form a graph. Take this sentence:\n“Tom is in a car in a parking lot in the basement of a skyscraper with their dog in the backseat.”\nCan you see how a graph can define the relationships in this?\nIn this example, the sentence is broken down into its constituent objects which represent the vertices of the graph, The edges represent an ordered relationship in space. So the Skyscraper contains a basement which contains a Parking lot that has Tom and the Car on it. The car has a Backseat which has a Dog on it.\nWith this in mind, we can sort\nthe vertices as follows starting from the object that contains everything to the most stand-alone one:\n[Skyscraper, Basement, Parking lot, Tom, Car, Backseat, Dog]\nThe key takeaway here is that order can exist between non-numerical or alphabetical objects. In fact, you can argue that topological sort is a superset to all sort operations since numerals, as well as letters, can be thought of as objects in Euclidean\nand Alphabetical\nspace respectively thus they maintain an inherent topological ordering.\n- To generalize this discussion, most interview problems related to topological sorting entail a two-step challenge:\n- Generating the graph: See our graph article for various ways to implement graphs. Traversing the graph to generate the topological order.\nYour task as a candidate is to make it clear what the objects are and how they are related, and then to implement a traversal algorithm that outputs the vertices in order. Take the Alien Dictionary problem for example;\nThe Alien Dictionary problem involves determining whether a given order of words is valid according to an imaginary dictionary, and if so, returning a possible order for the letters used. The challenge of this problem is both in understanding how to approach the task logically, as well as in applying graph traversal algorithms to devise a solution.\nExample 1 Input:\nwords = [\"kaa\",\"akcd\",\"akca\",\"cak\",\"cad\"]\nOutput:\"kdac\"\nExample 2 Input:\nwords = [\"b\",\"a\"]\nOutput:\"ba\"\nExample 3 Input: words =\n[\"ab\",\"a\",\"b\"]\nOutput:\"\"\nOur solution article goes in-depth on the graph generation step as well as the solution. The above example ends up being represented as follows:\nWith this handy, you can leverage standard BFS to generate the final order:\n[\"k\"]→ [\"d\", \"a\"], [\"c\"]\nLeaving us with the solution:\n\"kdac\"\nWhen to Use Topological Sort in Interviews\nIn an interview, there are some simple heuristics you can follow to identify topological sort problems: If any of these ring true, topological sort would be a viable candidate solution to your problem.\n- Is the problem related to dependencies between objects?\n- Is the problem related to scheduling or ordering tasks?\n- Is the problem related to finding a linear order of elements based on certain rules or conditions?\nIf the problem involves organizing objects or tasks based on some conditions or rules, there is a good chance that topological sort can be used to solve the problem.\nCommon Mistakes in Interviews Featuring Topological Sort\nGraph Building\nThis is by far the most critical step in the algorithm and one where candidates struggle the most. While this is an opinion thus take it with a grain of salt, using an adjacency list tends to be the easiest way to implement the graph. That should address the structural representation. Our graphs article provides more alternatives that you can look into.\nKeep an eye out for Vertices without relationships, and make sure they are incorporated into the graph.\nFailing to Incorporate Isolated Vertices\nSpeaking of isolated vertices, some of the letters can sometimes have no apparent relationships. Consider the following example:\n[\"baa\", \"abcd\", \"abca\", \"cab\", \"cad\", “e”]\nThe graph representation of these would be:\n{ \"a\": [\"b\", \"d\"], \"b\": [\"c\"], \"c\": [], \"d\": [], \"e\": []}\nNote that there is an isolated node, e\n. This node does not have any edges going in or out. No words depend on it. In the Tom and Dog example, this would be the equivalent of saying:\n“Tom is in a car in a parking lot in the basement of a skyscraper with their dog in the backseat and there is a Cat at Home”\nIn this regard, the Cat and Home have nothing to do with the rest of the setting. When generating the order, they can be incorporated at the end or at the start. In our case, e would be at the end. In fact, this tends to generalize quite well. Any time you have isolated vertices, the simplest way to handle them is to inject them at the end of your output list.\nFailing to Generate All Possible Orderings\nIn an interview, make sure to clarify with your interviewer if they want one solution or all possible solutions. As you’ve seen, the same graph can be ordered in different ways. The reason why BFS is what we recommend when doing traversals is that it generates all possible orders out of the box. That said, the algorithm will usually use extra space, so clarifying the problem requirements is key. If you only need to come up with one solution, DFS would work. Be mindful of the isolated node problem in this regard.\nFailure to Identify When There is No Solution\nTo keep it simple, if a cycle is detected, there is no possible ordering. Example 3 illustrates this perfectly:\nInput:\n[“ab, “a”, “b”]\nGraph Representation:{ \"a\": \"b\", \"b\": \"a\"}\nThis is a chicken and egg problem. Which one came first if the egg comes from the chicken and the chicken from the egg? Well, obviously, the answer here is 42!\nFailing to Mark Visited Vertices\nOnce you add a node, it is key to mark it as visited in the graph to avoid visiting it more than once. This is an implementation pitfall and our DFS and BFS article go in-depth on how to handle this.\nWhat to Say in Interviews to Show Mastery Over Topological Sort\nTopological sort is one of the few medium-to-hard algorithms that are very common in interviews. Frankly speaking, if you are able to implement it and avoid the pitfalls above, that ought to be enough to showcase mastery. A couple of things to keep in mind:\nGraph Representation\nUse the simplest, viable graph structure. Do not reinvent the wheel here. Hint: Use an adjacency list if possible. It will make your life much easier! While doable, implementing the graph following a Node structure would be borderline overkill. Our graph article has an entire section dedicated to this!\nExhaustive Clarification Questions to Ask Your Interviewer\nPlease don't skip this step in your interview! Two key questions you should always ask:\n- Do we need all possible orders?\n- How do we deal with isolated nodes? (\nQuick tip on this, always propose to append them at the end as an edge case as this will work in most cases and helps separate out processing logic which can keep your implementation clean\n)\nAbout the Author\nGithire (Brian) is a backend and ML engineer with 7 YoE ranging from startups to major corporations. He has worked on tech serving a wide demographic ranging from mobile money in his homeland Kenya, embedded tech with Kakao in South Korea to MLE at Microsoft. Brian has also worked as a teacher and has a knack for writing technical articles\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/topological-sort-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Trees Interview Questions & Tips for Senior Engineers",
      "content": "Trees Interview Questions & Tips\nWhat is a Tree?\nA tree is a hierarchical data structure in computer science consisting of nodes connected by edges. Each node is an element which can store data, representing some scalar value or a key, and the edges contained in that node, representing references to other nodes.\nIn the most general sense, trees are simply directed acyclic graphs (DAGs) where each node can only have a single other node pointing to it, containing N nodes and N-1 edges. As a hierarchical structure, the topmost node in a tree is called the root node, which has no parent. Every other node in the tree has exactly one parent node and contains connections to an arbitrary number of child nodes; a node that has no children is called a leaf node.\nCompanies That Ask Tree Questions\nNode Structure\nThere is no superstructure that can randomly access any particular node in the tree. Instead, trees are inherently recursive: each child of a node is a subtree in itself. When handling trees in software engineering, we usually pass around a reference to the root, from which we can access and manipulate the tree data.\nHere's an example of tree node definition:\nclass TreeNode {\nInteger data = null;\nList children = new ArrayList();\nTreeNode(Integer value) {\ndata = value;\n}\n}\n1class TreeNode {\n2 Integer data = null;\n3 List children = new ArrayList();\n4\n5 TreeNode(Integer value) {\n6 data = value;\n7 }\n8}\nTypically, children don't have references to their parents. While this is a possible modification to make on the tree node if the need justifies the extra space, it is rarely done given that the tree is almost always traversed from the root. To learn more about graph and tree traversal algorithms, read about Depth-First Search and Breadth-First Search.\nDifferent Types of Trees\nTrees can be tall or wide and everything in between. Since the only restriction on a tree is that the edges are directed and there are no cycles, we can find really tall trees where each node only has one child, or really wide trees where each node has thousands of children.\nTrees can have rulesets that enforce the order of nodes on insertion, or they can be randomly built top-down.\nBy applying specific rulesets to trees, we can define different subtypes with their own advantages and tradeoffs. Typically, these subtypes enforce some criteria related to the height of the tree - the height of a tree is the number of edges in the longest path from the roof to a leaf - or to the order that tree nodes must be in.\nThere are many types of tree implementations, each with their own set of rules and advantages. Below are a just a few examples, with links to further discussion for the tree types we see most often in interviews:\n- Binary Trees: a tree where each node has up to two children.\n- N-ary Trees: a tree where each node can have any number of children.\n- Binary Search Trees: a binary tree where each node value follows a specific ordering property - the node is greater than all the nodes in its left subtree and smaller than all the nodes in its right subtree.\n- AVL and Red-black Trees: a height-balanced tree, such that the heights of the left and right subtrees do not differ more than a certain amount.\n- Binary Heap Trees: a complete binary tree that satisfies the heap property, used for priority queue operations.\n- Tries: an n-ary tree specifically used to store string data.\nCommon Operations on Trees\nAlthough the implementation of these operations will differ greatly based on the type of tree, let's look at the simplest case with an unbalanced N-ary tree - this is a tree without any constraints on the positions of nodes or the number of children per node.\nInsert\nIf there are no constraints on where a node needs to be in a tree, then insertion can be as simple as finding a leaf and adding it as a new child. Below we implement a version of insert where we add the new node as a child to a specific parent.\npublic static void insertNode(TreeNode root, Integer parentValue, Integer newValue) {\nif (root == null) return;\nif (root.val == parentValue) {\nTreeNode newNode = new TreeNode(newValue);\nroot.children.add(newNode);\nreturn;\n}\nfor (TreeNode child: root.children) {\ninsertNode(child, parentValue, newValue);\n}\n}\n1public static void insertNode(TreeNode root, Integer parentValue, Integer newValue) {\n2 if (root == null) return;\n3 if (root.val == parentValue) {\n4 TreeNode newNode = new TreeNode(newValue);\n5 root.children.add(newNode);\n6 return;\n7 }\n8 for (TreeNode child: root.children) {\n9 insertNode(child, parentValue, newValue);\n10 }\n11}\nBasic Search\nSearching in a tree is often explored in terms of traversal algorithms, as these will determine the path taken to search. But in its simplest form, searching in a tree is merely a recursive function - taking advantage of the recursive nature of a tree - that calls itself on each child of a node until the target node is found.\npublic static TreeNode searchNode(TreeNode root, Integer target) {\nif (root == null || root.val == target) {\nreturn root;\n}\nfor (TreeNode child : root.children) {\nTreeNode result = searchNode(child, target);\nif (result != null) {\nreturn result;\n}\n}\nreturn null;\n}\n1 public static TreeNode searchNode(TreeNode root, Integer target) {\n2 if (root == null || root.val == target) {\n3 return root;\n4 }\n5\n6 for (TreeNode child : root.children) {\n7 TreeNode result = searchNode(child, target);\n8 if (result != null) {\n9 return result;\n10 }\n11 }\n12\n13 return null;\n14 }\nDelete\nDeleting nodes from a tree is sometimes considered an advanced topic, especially when we want to preserve subtrees or adhere to constraints on the tree structure itself. We won't be diving into those here. But, if we want to delete an entire subtree, its as easy as performing the searchNode method above, and once the target is identified, removing it from the list of children from its parent.\nWhen to Use Trees In Technical Interviews\nTrees come up often in technical interview questions because they’re the right amount of difficulty to challenge candidates without taking an unreasonable amount of time for those who understand them. As a result, trees come up in both coding and system design interviews.\nUsing Trees in Coding Interviews\nThe most common tree questions involve either manipulation or traversal of trees. Manipulation can look like building a tree, converting a tree from one format to another, converting a linked list to a tree, inserting/removing nodes from a tree, and the like. These really test that you thoroughly understand how the data is structured.\nTree traversals generally involve iterating over the tree or searching for data in the tree [link to Tree and Graph traversals article]. This is where we will use tools like depth-first search (DFS) and breadth-first search (BFS) to our advantage.\nMost tree interview problems will explicitly have a tree data structure as an input. These are usually cases where we'll be asked to traverse the tree, but it's also important to be familiar with adding and deleting nodes from a tree.\nThere are some common tree questions that are derived from well-known problems in computer science that come up often in interviews. A few examples include:\n- The Lowest Common Ancestor (LCA) problem: Given two nodes in a binary tree, find their lowest common ancestor node.\n- Checking if a tree is a subtree of another tree: this requires being able to write an algorithm that traverses the tree and can identify duplicate sub-structures.\n- Maximum Path Sum: Find the maximum sum of values along any path from the root to a leaf node in a tree.\n- Find the Height of a Tree: Calculate the height of a tree (the number of edges on the longest path from the root to a leaf node).\nFinally, there are problems where the use of a tree is not so obvious. One common example is using a trie to find string prefixes. If a problem asks us to find strings by their prefix, for example when looking up a term in a dictionary or when implementing an autocomplete tool, then tries are inherently a great way to do that.\nUsing Trees in System Design Interviews\nHere are some examples of where trees are commonly used:\n- File Systems: Many file systems, such as the hierarchical file systems used in operating systems, utilize tree structures. Directories and subdirectories can be represented as nodes in a tree.\n- Search Engines: Search engines use tree-based indexing structures like tries to efficiently store and retrieve data related to keywords or phrases.\n- User Interfaces: Tree structures are used in various user interface components, such as menus, navigation bars, and organization charts. They enable hierarchical representation and navigation of elements.\n- Compilers: Control flow graphs (CFGs) and other tree-based structures are used in compiler optimizations to analyze program flow and optimize code generation. Trees can also be used to map dependencies.\n- XML/HTML Parsing: Tree structures are used in parsing and representing XML and HTML documents. The Document Object Model (DOM) represents these documents as trees, allowing for efficient manipulation and traversal.\nCommon Mistakes in Interviews Featuring Trees\n- Forgetting to handle edge cases. When implementing an algorithm involving a tree, be sure to explicitly check cases where the tree has none or only one node. This is often missed when working through solutions. Given that trees are often used in recursive algorithms, we also typically need to include base cases.\n- Mishandling leaf nodes. All trees with nodes have leaves, and it’s easy for our logic to unintentionally try to access the children of a leaf, which could lead to a null pointer exception.\n- Not using a diagram to problem-solve and communicate. Tree logic can become very complex, given its recursive nature. Make sure to visualize your algorithm with a tree diagram before you start coding, and focus on simple and readable code.\n- Not considering tradeoffs in time and space complexity. Since we can customize tree nodes to fit out use cases, be sure to discuss the space implications of your solutions with your interviewer. Often we want to optimize for time complexity, so added space can be a useful tool when looking for optimizations.\n- Misunderstanding tree terminology. Make sure to correctly understand and use terms such as root, parent, child, leaf, subtree, depth, and height. For example, interview questions often ask us to find the depth or height of a tree, or count the leaves of a tree - it's important to be familiar with these concepts.\n- Misusing BFS or DFS. Although there are cases where both traversal algorithms are applicable without any meaningful complexity tradeoff, like simply searching through an unstructured n-ary tree, a candidate needs to be confident about which situations call for a specific traversal. A common use-case for BFS, for example, is search for the shortest path between two nodes.\nClarifying Questions to Ask Your Interviewer About Trees\n- Can we prioritize time complexity over space? All data structures involve some kind of tradeoff, and trees are no different. In some cases, storing more metadata on the node can help make searching more efficient, but it will come at the cost of extra memory. A great example of this tradeoff is when working with tries - we can store prefix data on each node which will limit the distance needed to traverse, but we can imagine the memory implications are high when representing an entire dictionary with a trie!\n- How frequently will tree operations be performed? Knowing if the problem will be more read or write heavy will help inform the approach, as well as the kind of scale that your tree would have to support. For instance, we may be working with a problem or a system that demands a lot of reads but the dataset will not change often, like in the case of representing a family tree that will need to be queried often. In these cases, we can afford the extra complexity when constructing the tree in order to take advantage of more efficient search.\n- What operations need to be supported? If you'll be implementing a tree, make sure to ask your interviewer what operations to prioritize during the interview. In some cases, they can allow you to skip the implementation of some less-important operations. For example, if the problem merely asks us to build a tree, we can potentially skip implementing the delete operation and instead focus all our time on making an efficient insert implementation. Mention that in production we would want our data structures to support all CRUD operations (create, read, update, delete), but in the interest of time you would prefer to focus on what is essential for the problem.\n- What are the characteristics of the input tree? Be sure to determine if there are any constraints that the input tree adheres to, such as balancing or sorting. If so, this would be a clue as to what kind of tree data structure you should focus on during the interview. For instance, if the input tree is a BST, we will be expected to take advantage of this structure for efficient search. Alternatively, if the input tree is not already sorted and is not balanced, it is likely not efficient to sort and balance the tree, and instead we might be expected to introduce additional data structures like a hashmap to arrive at an optimal solution.\n- Is the input tree an n-ary tree, a binary tree or or a binary search tree? Be sure to ask your interviewer if the input tree is a specific type of tree. Not only does it never hurt to ask, but interviewers may sometimes intentionally omit details to see if you will ask follow-up questions. Don't ever assume the type of input tree!\nAbout the Author\nKenny is a software engineer and technical leader with four years of professional experience spanning Amazon, Wayfair, and U.S. Digital Response. He has taught courses on Data Structures and Algorithms at Galvanize, helping over 30 students land new software engineering roles across the industry, and has personally received offers from Google, Square, and TikTok.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/trees-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Tries Interview Questions & Tips for Senior Engineers",
      "content": "Tries Interview Questions & Tips\nWhat Is a Trie?\nA trie, also known as prefix tree, is a particular application of an n-ary tree - recall that an n-ary tree is just a generic tree with no restrictions - where each node represents a character in a string.\nMost commonly, tries are used to store string data in an efficient manner, where each node is a character in the string starting at the root. The root node itself is merely an access node, and its children are all the first letters of the strings stored in the trie. Here's a simple trie storing the strings \"ape\", \"ban\", and \"dad\".\nWhy a Trie?\nThe trie's strength really becomes apparent when it comes to storing strings with overlapping prefixes. Trees are directional and acyclic, meaning all the edges starting from the root will never move backward, and all the paths will end at a leaf. As such, when we store strings in a trie, the sequence of characters are represented by all the possible unique paths that can be traversed through the tree. This feature allows a tree to merge the prefixes that are common across multiple strings.\nLet's imagine we want to store the following strings in a trie: \"apple\", \"ape\", \"ban\". In the corresponding trie, we can see that although there are three strings being stored, the root only has two children, since both \"apple\" and \"ape\" can share the \"A\" node. Further, both these strings can also share the \"P\" node, since they share the prefix \"ap\". At massive scale, a trie can greatly reduce the space needed to store strings with overlapping prefixes, which is particularly useful when storing something like a large dictionary.\nFurthermore, we get efficiency gains when searching for a prefix in the trie. When searching for a string, we traverse down the tree from the root, checking if the next letter in our target string exists as a child on our current node. With every move down the tree, we reduce our search space to the remaining subtree. We'll take a closer look at the search implementation below.\nTrie Implementation\nSince a trie is merely a particular application of an n-ary tree, there are many variations on how it can be implemented. Let's take a look at the common implementation using a hash map, and discuss some of the tradeoffs we can make with node storage.\nTrie Node\nTries can be implemented differently depending on the requirements of the problem, but the most common is with the use of hashmap. In loosely-typed languages, like JavaScript, we can even get away with not defining a Node class at all and instead simply using object literals throughout.\nHere's a simple trie node class definition. Note that the node's children are stored in a hashmap, where the value of the child node is the key, which points to the actual TrieNode being referenced.\nclass TrieNode:\ndef \\_\\_init\\_\\_(self):\nself.\\_children = {}\nself.\\_data = None\n1class TrieNode:\n2 def \\_\\_init\\_\\_(self):\n3 self.\\_children = {}\n4 self.\\_data = None\nLike with many data structure implementations, there is an opportunity to pre-process certain data to be stored directly on the node, at the expense of additional space. Let's take a look at a common problem involving tries - auto-complete - to help illustrate some of the variations on trie node implementation.\nThe auto-complete problem usually gives us a list of strings as a dictionary, an input prefix from the user, and the task of finding how many full strings can be composed with the given prefix.\nDictionary\nSince we're dealing with a dictionary, we already know that a trie is a preferred way to store and model the string data at scale, as well as search for a given prefix. One common implementation for storing words is to use a boolean to indicate if a node is at the end of a word. This way, when we are traversing the trie in search for a string, if the last letter of the target string falls on a node that is the end of a word, then the target exists.\nHere's an example TrieNode:\nclass TrieNode:\ndef \\_\\_init\\_\\_(self):\n# Assuming lowercase English letters\nself.\\_children = [None]\\*26\nself.\\_is\\_end\\_of\\_word = False\n1class TrieNode:\n2 def \\_\\_init\\_\\_(self):\n3 # Assuming lowercase English letters\n4 self.\\_children = [None]\\*26\n5 self.\\_is\\_end\\_of\\_word = False\n6\nAuto-Complete\nNow that we have a trie that allows us to find words, let's implement our auto-complete feature.\nAfter building the trie, we could then implement a function on the TrieNode that traverses the trie from this node and tracks the paths to each leaf as well as nodes with the isEndOfWord\nboolean set to true\n. This list of paths would represent the words that can be formed using the input prefix.\nAlternatively, we could pre-process this information whenever a node is added and cache this data on each node. When a string is inserted into the Trie, we perform the above traversal to get a list of all the possible words that can be formed using the input prefix - we then store this list directly on the node. As a result, when we find a prefix, we can get the auto-complete suggestions in constant time.\nclass TrieNode:\ndef \\_\\_init\\_\\_(self):\n# Assuming lowercase English letters\nself.\\_children = [None]\\*26\nself.\\_is\\_end\\_of\\_word = False\nself.\\_words = []\n1class TrieNode:\n2 def \\_\\_init\\_\\_(self):\n3 # Assuming lowercase English letters\n4 self.\\_children = [None]\\*26\n5 self.\\_is\\_end\\_of\\_word = False\n6 self.\\_words = []\n7\nAs you can imagine, these design decisions have time and space tradeoffs. Performing the necessary pre-processing to get the list of possible words is time intensive on insert, but can improve efficiency for read-heavy use-cases.\nFrequency Count, Prefixes, and Other Metadata\nThere are other pieces of metadata that are commonly pre-processed and stored on trie nodes:\n- Frequency count: how many times a given string or prefix occurs in the trie. This can be useful for auto-pruning the trie.\n- Prefixes: if you want to know the path that was taken to get to a given node in the trie, you can store the path prefix as the node value.\nLike with implementing the dictionary and auto-complete, these trie nodes are updated upon insertion of a string: we store the path traversed so far on each step of the traversal and we increment the frequency count on the node we end on.\nLet's take a closer look at some common trie operations in the next section!\nSearch\nSearching through a trie involves traversal following a specific path laid out by a target string. We can treat the input string as a desired path through the trie, starting at the children of the root node. Imagining this as a mere depth-first traversal through the tree, we recurse on each subsequent character in the target word, so long as it exists. If we run out of characters, we check if the current node is labeled as being the end of a word.\nclass Trie:\ndef \\_\\_init\\_\\_(self):\nself.root = TrieNode()\ndef search(self, word):\ncurr = self.root\nfor c in word:\nindex = ord(c) - ord('a')\nif curr.\\_children[index] is None:\nreturn False\ncurr = curr.\\_children[index]\nreturn curr is not None and curr.\\_is\\_end\\_of\\_word\n1class Trie:\n2 def \\_\\_init\\_\\_(self):\n3 self.root = TrieNode()\n4\n5 def search(self, word):\n6 curr = self.root\n7\n8 for c in word:\n9 index = ord(c) - ord('a')\n10\n11 if curr.\\_children[index] is None:\n12 return False\n13\n14 curr = curr.\\_children[index]\n15\n16 return curr is not None and curr.\\_is\\_end\\_of\\_word\n17\nTime and Space Complexity\nTime complexity: O(n)\n, where n\nis the length of the word.\nSpace complexity: O(m\\*k)\n, where m\nis the number of words with an average length of k\n. This is because each character in each word would need a separate node in the trie. However, if there are common prefixes among the words, the space complexity can be significantly reduced.\nInsert\nInsert is also a traversal where we're searching for the right place to put a string. Once there is no longer a \"correct\" place, we just create new nodes and set them as children.\nclass Trie:\ndef \\_\\_init\\_\\_(self):\nself.root = TrieNode()\ndef search(self, word):\ncurr = self.root\nfor c in word:\nindex = ord(c) - ord('a')\nif curr.\\_children[index] is None:\nreturn False\ncurr = curr.\\_children[index]\nreturn curr is not None and curr.\\_is\\_end\\_of\\_word\n1class Trie:\n2 def \\_\\_init\\_\\_(self):\n3 self.root = TrieNode()\n4\n5 def search(self, word):\n6 curr = self.root\n7\n8 for c in word:\n9 index = ord(c) - ord('a')\n10\n11 if curr.\\_children[index] is None:\n12 return False\n13\n14 curr = curr.\\_children[index]\n15\n16 return curr is not None and curr.\\_is\\_end\\_of\\_word\n17\nLet's imagine we're adding the word \"application\" to this tree from before:\nIn this case, we would not add any nodes until we reached the \"L\" that ends the prefix \"appl\". At this point, since there's no \"I\" neighbor on the current node, we create a new trie node with this new value. This process continues for the remaining characters in the input string.\nTime and Space Complexity\nTime complexity: O(n)\n, where n\nis the length of the word.\nSpace complexity: O(n)\n, where n\nis the length of the word.\nWhen to Use a Trie in Technical Interviews\nTries are popular topics in interviews because they do a great job of testing that you understand trees beyond the most basic level. Knowing when to use a trie requires a strong understanding of the real life use-cases for tries.\nWhenever a problem involves overlapping prefixes of data that need to be efficiently accessed, think trie. Tries are ideal for problems involving dictionaries or string prefixes, as we can use the structure to efficiently search if a given word is in the dictionary as well as count its frequency. These types of problems include:\n- Autocomplete: Tries are particularly well-suited for implementing autocomplete functionality or generating word suggestions based on partial input. Each node is a letter in a possible word, so when we traverse the trie by following the characters of our search string, we are eliminating significant portions of the search space with each decision. By storing a dictionary of words in a trie, you can efficiently find all words that match a given prefix or partial input.\n- Spell Checking: In a similar fashion, tries can be utilized for spell-checking algorithms. If you store the dictionary words in a trie, you can easily check if a given word is spelled correctly or suggest alternative words based on the prefix by traversing.\n- Word Frequency Counting: Tries can also be used for counting the frequency of words in a text or document. By incrementing a counter on each node that a prefix ends on, we can then efficiently keep track of and query the frequency of the words.\nAnother common case where prefixes are used to structure data - networking.\n- IP Routing: Tries are commonly used in network routing algorithms, where they can efficiently store and search for network prefixes such as IP addresses. Tries are especially useful for tiered data sets where many strings contain common prefixes, since we don't need to store duplicate prefixes.\n- Longest Prefix Matching: Tries can be used in scenarios where you need to find the longest matching prefix. This is commonly employed in network protocols, such as IP routing or IP address subnet matching. Once again, we're using the efficient searching capabilities in tries, thanks to the way that strings are implemented as traversal paths in the trie. Tries are popular topics in interviews because they do a great job of testing that you understand trees beyond the most basic level. Knowing when to use a trie requires a strong understanding of the real life use-cases for tries.\nWhenever a problem involves overlapping prefixes of data that need to be efficiently accessed, think trie. Tries are ideal for problems involving dictionaries or string prefixes, as we can use the structure to efficiently search if a given word is in the dictionary as well as count its frequency. These types of problems include:\nCommon Mistakes in Interviews Featuring Tries\n- Neglecting to discuss the performance tradeoffs with node structure: Don't assume the interviewer is prioritizing time complexity. Although a problem might be efficiently solved for time complexity with a trie, be sure to mention the tradeoff in space complexity.\n- Misunderstanding time and space complexity: Candidates often fail to properly analyze trie complexity, given the many variations in implementations. Preprocessing, while it does add some time expense on insertion, does not impact the worst cast time complexity. For space complexity, it can have an impact if we are storing strings with variable lengths, in which case we might imagine\nO(m\\*n)\nspace complexity, where m is the average length of the words in the trie. - Not knowing how to construct a trie: The most common way is to make a single class with a dictionary of dictionaries representing nodes and children, but it can also be implemented with an actual Node class.\n- Neglecting case-sensitivity and character normalization: When handling strings, we need to always consider if we need to implement some character normalization, as this will address invalid characters as well as case sensitivity issues.\n- Lack of frequency counter: When constructing a trie to store a list of strings, a common issue that arises is how to handle duplicates. In some cases, an interviewer (or the problem itself) will allow you to de-duplicate the original list, such that you don't need to worry about representing duplicates. But a likely follow-up will be to implement a solution that can track duplicates - this is a great opportunity to use frequency counters on the trie nodes, which specifically tracks the number of strings that end at a given node.\nAbout the Authors\nMike Mroczka, a former senior SWE (Google, Salesforce, GE), is the primary author of Beyond Cracking the Coding Interview—the official sequel to Gayle McDowell's original CTCI. He works as a tech consultant and has a decade of experience helping engineers land their dream jobs. He’s a top-rated mentor (interviewing.io, Karat, Pathrise, Skilled.inc) and the author of viral technical content on system design and technical interview strategies featured on HackerNews, Business Insider, and Wired. He also sometimes writes technical content for interviewing.io (like this piece) and was one of the authors of interviewing.io’s A Senior Engineer's Guide to the System Design Interview.\nYou can find him online at mikemroczka.com, LinkedIn, and X.\nKenny is a software engineer and technical leader with four years of professional experience spanning Amazon, Wayfair, and U.S. Digital Response. He has taught courses on Data Structures and Algorithms at Galvanize, helping over 30 students land new software engineering roles across the industry, and has personally received offers from Google, Square, and TikTok.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/tries-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Two Pointers Interview Questions & Tips for Senior Engineers",
      "content": "What Is the Two Pointer Technique?\nThe two-pointer technique is a pattern where two pointers iterate over the data structure in tandem or separately until they satisfy a certain condition. This pattern is extremely useful when dealing with linear data structures such as arrays, linked lists, or strings.\nTwo pointer problems are among the most common types you will encounter during coding interviews. This technique involves using two pointers which move through the array or list in a synchronized or independent manner to solve a problem. The two pointer technique is a flexible and versatile strategy that can be applied to various scenarios, such as finding pairs in a sorted array, checking for a palindrome, or finding a cycle in a linked list. Two-pointer algorithms generally rely on pointer manipulation (in this context a “pointer” is just an index in an array or similar linear data structure and does not refer to memory addresses of objects like pointers in C-based contexts do).\nTwo Pointer Types\nPolynomial Pointers (for brute force combinations)\nThis pointer variety is generally considered the least beneficial, as it often necessitates the use of nested loops. Each pointer, in this setup, travels independently across each index of the input. As a result, this pattern typically results in a polynomial (commonly quadratic – O(N^2)\n) time complexity due to the fact that it computes all potential combinations of two pointers within a single linear input. The bubble sort algorithm exemplifies this kind of pointer usage.\nGenerate Subarrays: Generate all subarrays of the given array input\nPointer Chasing (\"Slow and Fast\" or \"Tortoise and Hare\") for Cycle Detection\nThis variant of the two-pointer technique is notably applied in identifying cycles in linked lists and graphs, as demonstrated in Floyd's algorithm. In this setup, both pointers initiate their journey from the beginning of the input (typically index 0) but progress at varied speeds. Generally, the \"tortoise\" pointer advances by just one index in each step, whereas the \"hare\" pointer leaps forward by two indices at a time.\nFloyd's Cycle Detection: Given the head of a Linked List, determine if a cycle exists in the Linked List\nRivaling Pointers\nIn this variant of the two-pointer technique, one pointer commences at the start of the input, while the other initiates from the input's end. These pointers subsequently shift inwardly (toward each other) alternately, adhering to a predefined logic. The binary search algorithm or Palindrome problem both serve as textbook examples of this type of problem.\nBinary Search: Given a sorted array and a target, determine if the element exists in the array\nMultiple Pointers\nWhile traditionally two-pointer problems involve exactly two pointers, it's not uncommon to encounter problems where more than two pointers can be beneficial. The \"Multiple Pointers\" technique typically involves more than two pointers that move independently or in a correlated manner based on specific logic.\nThis type of problem often shows up in more complex array or string problems, where the interaction between multiple elements at different positions needs to be considered. For instance, a problem might require you to sort an array of zeros, ones, and twos as in the Dutch Flag problem. A polynomial pointer approach can solve the problem in quadratic time. However, by cleverly segregating the array with three pointers, you can reduce the time complexity to linear time.\nDutch Flag: Multiple pointer approach to sorting 0's, 1's, and 2's.\nDouble Input Pointers\nThis pointer type is interesting since it involves two linear inputs with a single pointer on each, rather than a single input with two pointers. A common example of this would be the “merge” part of the Merge Sort algorithm in which we merge two sorted lists into a single list by carefully comparing and updating pointers in each list based on their relative values.\nMerging Two Sorted Lists: Algorithm merges two sorted lists together in linear time\nSliding Windows\nSo much can be said about this two pointer problem subtype that we have a whole separate guide on it! Predominantly observed in array and string questions, this variety of two-pointer problem aids in locating subarrays or substrings within an input. It is crucial to acknowledge that subarrays and substrings represent continuous segments of a linear input. This distinction is significant since we exploit the contiguous characteristic of a substring to bypass redundant computations from previous steps and avoid the typical polynomial pointers (brute force) approach.\nFixed Window Pattern: Given an array of 0's and 1's and a number k, find the subarray of length k with the most 1's (k = 5 in the example above)\nWhen to Use Two Pointers in Interviews\nTwo pointer problems usually surface when dealing with ordered data or when there is a need to eliminate redundant computations. Similar to the above, here are a few scenarios when this technique can be particularly handy:\n- Searching pairs in a sorted array: The pointers can start at both ends of the array and move inward until they meet, eliminating possible pairs along the way. This method is faster than using a nested loop to check all pairs.\n- Finding a cycle in a linked list: One pointer can move faster (2 steps at a time), and the other slower (1 step at a time). If there is a cycle, the faster pointer will eventually meet the slower one.\n- Checking for palindromes: The pointers can start at both ends and move inward, checking if the mirrored characters are the same.\n- Applying a sliding window: One pointer marks the start of the window, the other the end. The window can then be 'slid' through the array to check for conditions.\nValid Palindrome Example\nProblem Statement\nGiven a string s, determine if it is a palindrome, considering only\nalphanumeric characters and ignoring cases.\nIntuition\nThe two-pointer technique is highly effective for this problem. We can initiate two pointers, one at the start and one at the end of the string. We then move the pointers towards the center of the string. At each step, we check if the characters at the two pointers are the same. If not, the string is not a palindrome. We can ignore non-alphanumeric characters by advancing the corresponding pointer(s) until we reach an alphanumeric character. We also need to ensure our comparison is case-insensitive.\nCode\ndef isPalindrome(s):\nl, r = 0, len(s) - 1\nwhile l < r:\nif not s[l].isalnum():\nl += 1\nelif not s[r].isalnum():\nr -= 1\nelif s[l].lower() == s[r].lower():\nl += 1\nr -= 1\nelse:\nreturn False\nreturn True\n1def isPalindrome(s):\n2 l, r = 0, len(s) - 1\n3 while l < r:\n4 if not s[l].isalnum():\n5 l += 1\n6 elif not s[r].isalnum():\n7 r -= 1\n8 elif s[l].lower() == s[r].lower():\n9 l += 1\n10 r -= 1\n11 else:\n12 return False\n13 return True\n14\nTwo Sum II Example\nProblem Statement\nGiven a 1-indexed array of integers numbers that is already sorted in non-decreasing order,\nfind two numbers such that they add up to a specific target number. Let these two numbers\nbe numbers[i] and numbers[j] where 1 <= i < j <= numbers.length.\nIntuition\nThe two-pointer technique works well here because we can start with a pointer at each end of the sorted array. Since the array is sorted, if the sum of the two numbers pointed by the two pointers is less than the target, we can move the left pointer to the right to make the sum larger. Conversely, if the sum is larger than the target, we can move the right pointer to the left to make the sum smaller. This way, we can find the two numbers that add up to the target in linear time.\nCode\ndef twoSum(nums, target):\nl, r = 0, len(nums) - 1\nwhile l < r:\ncurrent\\_sum = nums[l] + nums[r]\nif current\\_sum == target:\nreturn [l + 1, r + 1]\nelif current\\_sum < target:\nl += 1\nelse:\nr -= 1\n1def twoSum(nums, target):\n2 l, r = 0, len(nums) - 1\n3 while l < r:\n4 current\\_sum = nums[l] + nums[r]\n5 if current\\_sum == target:\n6 return [l + 1, r + 1]\n7 elif current\\_sum < target:\n8 l += 1\n9 else:\n10 r -= 1\n11\nThe above problem and solution illustrate how the two-pointer technique helps solve problems efficiently. This strategy is a useful tool to have in your programming arsenal, especially for interview preparation. Understanding the fundamental concepts behind this technique and practicing it on problems like those above can give you a solid foundation for tackling similar problems.\nCommon Mistakes in Interviews Featuring Two Pointers\nHere are common mistakes to avoid when tackling two pointer problems in interviews, note that almost all of these involve Index Out Of Bounds errors if not planned for:\n- Not initializing pointers correctly: The initialization of pointers greatly depends on the problem at hand. Ensure you understand the problem statement thoroughly before deciding where to place the pointers initially.\n- Not moving pointers correctly: Again, the movement of the pointers depends on the problem. In some problems, both pointers move together, while in others, they may move independently.\n- Not handling edge cases: Be careful with edge cases. For instance, what if the array is empty? Or what if the array has only one element? Make sure your solution handles these scenarios gracefully.\n- Forgetting to update pointers or conditions: This can lead to an infinite loop, especially when dealing with while-loops. Always double-check your code to ensure pointers are updated correctly inside the loop.\nWhat to Say in Interviews to Show Mastery Over Two Pointers\nTwo pointer questions are an odd question type since they tend to be simple to explain, but deceptively complex to implement bug-free. Here are a few suggested phrases that demonstrate your understanding of the two-pointer technique:\n- Recognize inputs that help you: \"Given the sorted nature of the input, we can use a two-pointer technique to eliminate pairs and potentially reduce the time complexity from\nO(N^2)\ntoO(N)\n.\" - Understand the sliding window technique: \"We can employ the two-pointer technique here to create a sliding window, which can help us maintain a running total within the window size, and update it as the window slides through the array.\"\n- Show awareness of cycle detection algorithms: \"We can use the two-pointer technique to traverse this linked list. One pointer will go two steps at a time while the other moves one step at a time. If there's a cycle, the fast pointer will eventually catch up with the slow pointer.\"\nClarifying Questions to Ask Your Interviewer With Two Pointer Problems\nBefore jumping into solving two-pointer problems, it's a good idea to ask the following questions to get a better understanding of the problem:\n- Clarify the target complexity: \"Are there any constraints on the space complexity of the solution? Can we use additional data structures?\"\n- Clarify potentially unexpected input examples: \"Can the input array or list contain duplicates?\"\n- Clarify what to do if no answer is possible: \"What should the function return if no solution is found?\"\n- Make no assumptions: \"I see the input is sorted in this example, but can we always assume the input data sorted? If it's possible we get unsorted data, are we allowed to mutate it with an in-place sort?\"\nTwo Pointer Frequently Asked Questions (FAQ)\nHere are some frequently asked questions and their answers regarding the two-pointer technique:\nCan We Use More Than Two Pointers in a Problem?\nYes, it's possible to use more than two pointers. The 'two-pointer' term is more of a general idea than a strict rule. Depending on the complexity of the problem, we may need more pointers.\nHow Is Binary Search a Two-Pointer Type?\nIn a binary search, two pointers (usually referred to as 'left and 'right') are used to keep track of the remaining search space. After each step, the search space is halved by moving either the 'left' or 'right' pointer, hence the name 'binary'.\nHow Is the Sliding Window a Two-Pointer Type?\nIn sliding window problems, we maintain a 'window' of elements in an array or list using two pointers, where one pointer represents the start of the window and the other the end of the window. As we move through the array, we 'slide' this window by moving both pointers.\nAbout the Author\nMike Mroczka, a former senior SWE (Google, Salesforce, GE), is the primary author of Beyond Cracking the Coding Interview—the official sequel to Gayle McDowell's original CTCI. He works as a tech consultant and has a decade of experience helping engineers land their dream jobs. He’s a top-rated mentor (interviewing.io, Karat, Pathrise, Skilled.inc) and the author of viral technical content on system design and technical interview strategies featured on HackerNews, Business Insider, and Wired. He also sometimes writes technical content for interviewing.io (like this piece) and was one of the authors of interviewing.io’s A Senior Engineer's Guide to the System Design Interview.\nYou can find him online at mikemroczka.com, LinkedIn, and X.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/two-pointers-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Union Find Interview Questions & Tips for Senior Engineers",
      "content": "MEDIUM\nData Structures and Algorithms\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/union-find-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Google Systems Design (Mock Interview)",
      "content": "Interview Transcript\nIntergalactic Avenger: Hello?\nSpace Pheonix: Hi.\nIntergalactic Avenger: Hey, how's it going?\nSpace Pheonix: Good, how are you?\nIntergalactic Avenger: Good, good, doing good. Alright, so if it's okay, I'll just jump right in with a technical question.\nSpace Pheonix: Yes, sure.\nIntergalactic Avenger: Yeah, so I think we'll do some not necessarily coding but more system design question today, just to keep it... I'm sure you've answered enough questions about hash tables for for one day, so let's start with a distributed systems question. So the idea is that you've got a database that you're keeping in MySQL, some some standard off-the-shelf database system like a SQL database and we could even say for this purpose, for simplicity there's just one one table and it's just... You're getting more and more rows in that table and eventually you found there's more rows than can fit in one machine. So you have access to multiple machines and they're all networked together somehow. So can you think of a way to to organize the database just given that you just have access to SQL, you don't have anything like... you know, any automated tools for distributing and... So just kind of generally describe what this is going to look like.\nSpace Pheonix: Okay sure, so the idea is you just have an access to SQL database from multiple machines where I can store the data. Right now it's going to the one machine and it cannot scale for the data that we are getting. I'm just making sure that I understood correct. And somehow we need to partition this database in a way to query in future, so distributed in multiple machines. So let me first ask a couple of questions, like before splitting the data, is it... so there are a few ways. One is like usually like some geographically like if you have some countries related to the database, for example if you have a country code, we could potentially have our country, our region code, like we can split the universe in like a multiple regions, like one is like North America, South America, or Africa and Asia Pacific, kind of probably like a three regions we can split into three different machines to go like at any that are related to the three specific regions, go into specific machine. Probably one layer, one machine where it load balances these things. Somewhere we need to have a component where the data and then decide which machine to go store this data.\nIntergalactic Avenger: So the idea that... so yeah that makes sense that there's going to be a lot of... if you have so much data, it might be coming in from different sources, so would the idea be that country code is just something that's in the database or is that also relative to who's asking for that data? Like do the European users talk to the European data and the North American users talk to the North American data?\nSpace Pheonix: Okay, well...\nIntergalactic Avenger: That kind of brings up the question of, is that is that how you were thinking about it?\nSpace Pheonix: That was probably my next question was, so how the database will be coded in future, whether like a different regions will ask for different region or they will just look for their own region data when they worry, so that's debatable or a clarification question if it's going to be like Asia Pacific people asking for data from Europe, then you're pulling the data from two different machines and then merging and then responding is going to be complicated so we have to think a different way of partitioning this, probably like anything like an old data we can keep it in like in a backup database, like one transaction database where you have only current months data. If anything older, you go to different machine, pull it from there. So depending upon the query pattern, whether always you get quite often you get for last week's, last month, or last six months data that being coded, that can be kept in the main machine where we do the transactional and the rest all can go into like jobs analytics that are... this kind of model I would think of.\nIntergalactic Avenger: Okay, let me just yeah... there's a couple questions back in there so with respect to the geographical regions, so that's definitely a very good way to start. So if this was the kind of system where there were country specific data that was being read from and written to just with respect to that country and that was... and people in that region were the only ones doing it then that's an excellent way to start. But let's say for the purposes of this exercise that that's not the case. Let's say that all the data is stored centrally in one data warehouse that's located in one geographic area, so that's just to cover the first one. So then that was an interesting point with respect to the the recency, so can you just sort of sketch out for me an algorithm of how that would work. So for example, let's say that you know if I'm reading from... as I'm understanding it, there's going to be one machine in the front that is going to take in the query and it's going to look at the time range that you are looking at and based on the time range it will farm that off to different machines. So how then does that work with respect to... so is there going to be... are you going to... so let's say that you are going to have that split into day or I guess you said month, so by month. So is the idea that every month, you would add a new machine for that month so that there's a machine for 2015 December and then for next month you'll need to make a new machine that is going to host the new data or do you migrate the old data backwards?\nSpace Pheonix: Yeah so migration is what I was thinking. I wasn't proposing to add the new machine every month. Yeah since being the transaction database that is the bottleneck where everyone insert an SQL query for the same month that is going to be one machine and the rest all like... a machine can probably can accommodate more than a month data. So requests will go to probably one machine or two machine depending upon the size, whether it can hold in this one machine, then it could be just one machine. Or it could be like more than one machine, depending upon the size of the database. That was what I was thinking.\nIntergalactic Avenger: Okay, I like that idea. So this is the interesting point. So okay, so you have one machine that's kind of the the current ones and then you have maybe multiple machines that are holding the older data. So how do you... how do you split that up? So let's say that you right now maybe you have one machine for December and then one machine for all past data. Then, you're looking at this in the future and you say oh whoops, the machine that right now has all the past data in it is about to be full. So now how do we split up that data?\nSpace Pheonix: Yes, so in that case... not in that case. So we have to design to accommodate this... definitely is going to be full is the one machine for all past that's not going to just hold everything for next 10 years or 20 years so definitely does miss this for adding more machines as and when needed in the design to go get the backup database from multiple machines. So in a way I would rather say probably like to go for like a five years, ten years kind of a database. So these are all like a kind of a parallel partition right? There is completely a new concept for virtual partitioning a table can be like... so I I'm not technically like completely aware how the whole thing works like a for example the big data thing, how do they completely vertically partition the table first off of like probably 20 columns, first ten columns would be stored in one and the remaining ten columns will be stored in different machine. But I don't have the technical depth of knowledge for explaining how that is completely implemented or how the whole thing works, the vertical partitioning.\nIntergalactic Avenger: Let's not worry too much about vertical partitioning. I mean that's certainly one way you could do it, but let's just assume that there's a relatively small number of columns. It's just that there's more and more and more and more and more rows.\nSpace Pheonix: Yeah okay okay so yeah so considering there are a number of backup databases, I would probably suggest like going back like completely like up to five years one machine and complete the past like for more than five years running on more than one machine kind of approaches what I would think of.\nIntergalactic Avenger: So let me see if I have this correct, if I understand the scheme correctly. So you've got some... or I guess the one piece that's unclear for me is how does the data then sort of move and get migrated from how it is now into the past? Like once you've decided that some row is old by some definition of old, maybe it's one month or one year whatever, how do you decide where it goes? And how does the migration sort of work? So my question is when you do that migration, do you go over all the data like in the entire history as you redistribute it or when you redistribute it are you going... you just take the current data and then push it sort of somewhere?\nSpace Pheonix: Right so... yeah so what I would do... let's say this is what my addition, like in the component which decides to go find where to find the data, so that knows which server I need to go find the data. Depending how it knows, the strategy is let's say I have the current machine which does the transactions and everything for the last just one month. That's all I'm going to keep in a different machine.\nIntergalactic Avenger: Just so you know, if you want it, there's a little whiteboard if you want to draw on a little whiteboard and there's also like just the text if you want to draw little boxes in the text, so if that helps you to explain it or to think about it, you have those options open to you.\nSpace Pheonix: Yeah sure, let me try that. This is my second interview, just trying this one.\nIntergalactic Avenger: Yeah there's a little button that has like a pen on it, and that's a little whiteboard so you can you can draw stuff.\nSpace Pheonix: Oh yeah, so yeah. So this is let's call it OLTP this one, like a transaction database. So this is the current data. So even before this, let's say we have a component called the load balancer or whatever, which decides where the data, this should be queries. So all the queries coming in here. The load balancer decides where to go, so this OLTP queries the transactions in the last month, so less than one month old here. And the query here, let's say we get for old data here, so greater than one month old data is going to be stored in this backup server. So in a point where this is going to be filled completely, there should be a way like I said, this is going to be filled up, for example we have for now 10 years of data here. So right now we filled it up and then there is no space in here. At this point, I want to completely split this thing, I think my suggestion would be to just add up one more server where the new data, whatever we backup from this server will get into this machine, like I have one month old here, now I'm in the second month, so just one month old database is that I will fit into this new server. Now I need to find a way where to query from these two machines and then written back somehow that has to be, that has to happen based upon the query in the load balancer. Depending upon the query, I have to find whether just I need to go to backup server or also backup server 1 and backup server two backup server three. Depending upon the quarry I would just add this up, so that probably is what I was thinking out. I wasn't thinking... so there is one other way like I have the backup complete backup of ten years of data. I wasn't thinking of splitting this into like I have four machines now, splitting into all four machines, I wasn't thinking of that.\nIntergalactic Avenger: Yeah that's fine. So let me see if I understand the path here. I guess I'm a little bit confused... so the load balancer at the beginning looks to see if it's within a month or greater than a month and so then it can choose one or the other, but what is this other piece in in the middle, this this one right here? I guess I'm confused as to okay what its role is in the... because it seems like if the data is either split into less than one month or greater than one month... I guess I don't understand what...\nSpace Pheonix: Yeah, yeah so let me clarify that... So this one, let's say for example I am in 2015 now, my first date observer is filled out, so anything older than 2015... anything older than 2015, we get into this machine.\nIntergalactic Avenger: I can help erase the old stuff if we want to erase it.\nSpace Pheonix: Yeah sure. Is there a way?\nIntergalactic Avenger: Yeah, you just have to make the eraser a little bit bigger. It's fine yeah okay.\nSpace Pheonix: Okay so this one contains less than 2015 data. And then anything so now we learn this database is filled... filled up and then we we are adding a new machine and this will contain anything greater than 2015 like greater than or equal to 2016 for example. So going forward from the OLTP machine, I'll just start backing up things every month to get into this database machine two, that's kind of the backup service that we will write it which will run in offline mode. So this load balancer itself could understand the machine 1 and machine 2 and depending upon the query, we can pass... we have to split the query depending upon... let's say someone else, since it is like a pretty recent and if someone asks like a two month of 2015 and one month of 2016, then definitely this load balances really have to pass the query and send to the two machines. So that way we get both the roles and then join and then it sends it back. So that's kind of the load balances job and it can be considerable, we can say ok year 2015 machine one and all that probably you can put it in some xml configuration of something where this strategy kind of easily changeable and stuff so we can add more machines going forward. When we add machine three, we can just say 2017 and beyond, so that can be configured just like that in the configuration file here. So this will be written by program or something like that.\nIntergalactic Avenger: Okay, now that makes sense. Okay so it seems like... so we started off with the idea of it being geographically partitioned and that's good, that will work with some some things. Snd this is partitioned by time, so in what type of scenario is this going to be ideal? Like what kind of query patterns of people querying the database are you going to see that this is optimal for?\nSpace Pheonix: So this is completely for like a transaction database where like it's a Amazon order service, where you get plenty of orders every minute and every day, so probably that's kind of amount of data where later you get it from same country and and you would get a lot of orders that's probably one scenario, where you get like a tons of records every day.\nIntergalactic Avenger: Well, let me put it this way. So for example, let's say we're talking about an Amazon like database. And the things you're storing are things like orders, like who ordered what right? And I could imagine that in this type of situation, people are looking up recent orders more often than they're looking up past orders. They're probably looking up something they just ordered this past week to see its status, but they're probably not looking up very often their old orders. It kinda feels like you're going to get a lot of traffic going to this one machine. Then all of the backup machines are going to be less utilized. So can you think of a way... so let's even just keep going with the this sort of Amazon style database and let's just say that you know after putting this into place you notice that this one machine here gets kind of most of the action and becomes the bottleneck and these older ones, people aren't really querying for it that often and so they are less utilized. Can you think of some way that will sort of better distribute the workload between all of these different machines so that you don't have this one as the bottleneck?\nSpace Pheonix: Yeah, sure definitely. So I think, so the other way to distribute would be probably like going by... since country wasn't a thing because every order is coming from same country let's say for example it was from North America, in that case I would say just go with a last name. Usually like every go by last name, people query by... so the user identification, user ID of course it's not the thing we can do. Probably I would go with last name starting from A to like your let's say P to machine 1, from Q to Z to machine 2 and depending upon number of machines I have, I can split evenly to all the machines. But this scenario I'm thinking about is just the orders, like it can vary the condition that we are trying to... the approach we are trying to split the data between the machines depending upon the data we are getting. For example, right now we are thinking everything is orders, everything is placed by some first name A and last name B. That's the scenario I'm completely talking about. So that way any user come to query something, they go to just one machine. They will never get into multiple machines and there is no question of joining queries and merging the data from two different machines and then solving the users. So that's probably one approach I would go with.\nIntergalactic Avenger: Okay, no that's essentially... because that's definitely going to spread it out so that all of the machines are getting you know the current orders and the past orders so all the machines are kind of spreading them out. Another challenge for you here... so if you split it up by letter, some letters are going to be more popular than others, so there's many more last names that start with the letter T than start with the letter W.\nSpace Pheonix: So I have a strategy coming to it. So I was thinking of see the pattern of orders coming from... we really have to study the pattern last like a few months and see where the number of orders really coming and then that's how we have to decide the number of letters to go on to some machine X and machine Y. There is no way we can really distribute just 4 letters to sorry... like 13 letters to one machine and remaining 13 letters to the other machine. Definitely we have to see the pattern and how the last couple of months went through and depending upon that we have to say it okay probably like five letters, first 5 just to machine 1, remaining 21 letters to machine 2, probably something like that. And one more problem with this again for example since you are storing order and everything here splitted into multiple machines, in the case of like where the same order data database will be accessed by some people like who's fulfilling the orders. In that case, we have to really query, we cannot really query by name or anything, they have to see all orders today and then definitely we run into issues of pulling the data from two different machines and then merging and then assigning everything and then returning all the data, so there is no way we can get around like you're always hitting one machine, that's not high likely... like it is just one side we are solving the problem but the other side we still have the problem of solving coding from multiple machines and unwinding, so yeah.\nIntergalactic Avenger: That's a very good point, it's a good point. So just going back to that last issue like if you said that you wanted to find all the orders... so let's say we're going into the way you said before with all the last names and so that's now distributing the data a little bit better, but now the dates are are not distributed very essentially centrally. So now you want to issue a query that says you know, show me all of the orders today. Where is the bottleneck going to be in that case?\nSpace Pheonix: It's all going to be the load balancer, where... so the load balancer is the one that will get all the requests. Now it has to decide where to go pick the data. Now machine one, machine two, machine three if for example if you want everything from today, it has to go to all the machines and you got all the data from all the machines, you have the job of joining everything, and then you like union all the results and then returning to the client so the load balancer kind of becoming a bottleneck yeah.\nIntergalactic Avenger: So that's certainly true if you're doing some aggregation of all the data. So let's say that you wanted to sort all of today's orders, then certainly you're right that the the load balancer becomes the bottleneck because it would have to aggregate all of them and then sort them. But what happens if they just ask \"give me all of today's purchases in any order, I'm not concerned about the order.\"\nSpace Pheonix: Okay, so in that case, so there could be one more possibility where you get the client requests and I know the load balancer knows where all the data is and we could potentially return the results directly from machine 1, machine 2, machine 3 to the client possibly. The way is you get only if the load balancer is probably act like a probably like a velocity server where the client will get the data, the information where to go pick actual data. So I will return back machine 1, machine 2, machine 3 to the client and then client will query on more like a three parallel queries or whatever kind of the way, it can just go query directly from those machines so the balance that the load completely is between all the machines.\nIntergalactic Avenger: That's an idea, I like that. Okay, so last one. So we're... these are all excellent ideas... so let's just dig a little bit deeper into the last name issue. So you're right, I really like that idea of looking over some past data like usage patterns to sort of see who are the types of users that use it more often and that kind of thing and that's certainly something you do dynamically, but let's try to think of something that you can do more statically without looking at the usage patterns to try to clear up this issue of you know more people have last names with the letter T than have the last names letter W. So is there some way that you can distribute the records so that so that even if... so let's just say for example that you have you know 100 machines and hypothetically this would mean you would put four letters on each machine because there's basically 25 letters in the alphabet but...\nSpace Pheonix: You mean each letter in four different machines.\nIntergalactic Avenger: Yeah so you would put like the first the first quarter of the letter A would go in one machine and the order of A gets in the second machine set. So that's the sort of one way to do it but it turns out that if you put like you could fit all of the complete letter Z in one machine and actually all of letter Y too, because there's not very many people with last name Y. So two people can actually fit in Y but the letter T needs ten machines. So I mean one way you could do it is you could just sort of keep a table of each individual row with... So I mean one sort of simple way of doing it would be to create a table with each individual row in which machine is going on or you could create like a range you could say well this person to that person is on this one machine but there's kind of a lot of bookkeeping to do there. Can you think sort of a simpler way so that when a query comes into this load balancer, it knows exactly where to go very quickly and easily for which machine is holding that person's data and you don't need to keep any type of like bookkeeping around. So the bookkeeping is fine except that you know let's say you wanted to add someone to the database or you want to add an order, well you would kind of be constantly shifting around how they're all migrated if you wanted to optimize it. So can you think of a way that is going to distribute all of these people in a way that each machine is not overloaded, that all of the machines have roughly the same number of records and that you don't need to do any type of like heavy duty bookkeeping or shifting around data as say more people come online or the orders are made.\nSpace Pheonix: Okay so I was just quickly thinking of just putting the machine and mapping the machine with the user table where each record will say okay this user always goes to this machine blah, but that's easy in a way to just to return the machine or whatever the detail we want to store the data, but in a way it becomes complicated, let's say what happens if I have to bring one machine down? I have to really go back, find all the users assigned to that machine and then update with some new machine. Those are the things we have to really think about but let me think about a little more... so what I was thinking was giving some weightage, but again that sounded like a heavy duty bookkeeping kind where I say starting letter A gives some weightage 1, so a T with a lot of who orders with a weightage 10, something like... so giving weightage for the letter again I think kind of a high bookkeeping, I wouldn't suggest.\nIntergalactic Avenger: How would you pick the weight? It's the idea that the weight is the number of users with that letter, so like the wait for the letter P is how many users last names start with the letter P? That kind of thing? Well there's something to that, that's an interesting one, I hadn't thought of that one before, but that makes some sense. So then what would you do with that weight?\nSpace Pheonix: Yeah so the weight tells you... let's say you have 100 machines, it will just split up with... that weight will tell you how many machines, what is the percentage of machines that you need for each letter, so you just sum up and then find the weighted percentage for each letter and then depending upon number of machines you can just have those many machines for that specific letter, but that's again another bookkeeping. The other approach I was thinking was since we evenly need to distribute every order comes in... so let's say we want to like a very highly distributed model where you get order one go machine one, order two machine two, order three machine three, and an order n go to machine n, and order n plus 1 goes to mention one again.\nIntergalactic Avenger: I like that idea.\nSpace Pheonix: Yeah but how we really achieve that is what really becomes more of questionable where let's say if I have order one, order two, order three, I get from one user, let's say if I go to machine one and I say okay machine one order one from user 1 is always machine one I could assign the user one from then on go to always machine one and the next order goes from user 2, goes to machine 2. I will assign that users for the machine two. But again that becomes static afterwards, that's not more of dynamic anymore, so there should be a better way of distributing always all the machines used is like equally that's what I'm what...\nIntergalactic Avenger: Actually let's explore this latest idea that you had, which I actually think is quite elegant because of its simplicity that you'll have the load balancer as you're writing new things will just have a counter that will roll over, super simple to to figure out where it's going to go. And so then the only question is how do you retrieve it?\nSpace Pheonix: Yeah, so the reporting again becomes complicated there...\nIntergalactic Avenger: Um well maybe not. I mean so if you think about it so let's say that you say well give me all the orders from today for some certain user? That's what you want to query right? What can the load balancer do to find that information, given that it is totally forgotten where it put that person. Because maybe it saw that person a million transactions ago and it didn't keep track of where it put that person. So how do you get at the, you know, so how do you get that the answer to that query of you know how many purchases did that person make today right?\nSpace Pheonix: So one... these are all reporting afterwards we could potentially... I'm just thinking of these sources. There are two things right? One is OLTP and the other one is the analytics server, which is just for used to file a reporting server. Quite possibly that we can have all these machines data and the transaction data gets duplicated or are pushed to some reporting servers where this load balancer always can go query the data from... so that's... let me think, so let's say we have 100 machines here. The main reason we are distributing is because users are being online and we need to serve them quicker and faster, that's the main reason that we are distributing all these transactions during the insertion. But the reporting usually can like a couple of seconds can take, can take couple of seconds more. We could potentially have the reporting servers separate where all the data gets synced to the reporting servers, always it is the load balancer notice. If any query falls for just coding the data always pointing to the reporting servers, that is one possibility, but let's think of if there is any other way that we can always pull this data from the same machines therein. So I don't see because we lost the pattern as you said the load balancer forgot where the data is and there is no way that load balancer is keeping this mapping between the machines and the pattern of queries. Let me think a bit more.\nIntergalactic Avenger: So one thing that you're optimizing for, which is which is generally a good thing, is that you're trying not to ask more machines than necessary. So for example with this first you know description that you have here where it's charted by time, you have the less than one month and then 2016, 2015, you have the the load balancers up at the front that decides I'm going to ask only one of these machines and that saves CPU cycles obviously because you're only asking the one proper machine where it is, but that's not necessarily a restriction. You could asked more than one machine.\nSpace Pheonix: Yeah definitely, so in case of let's say we have hundred machines, we store the data like evenly from the load balancer, now the query is to select something. I could go ask more machines, but whether... but my worry is that would slow down things when someone wants the report of today's orders or last weeks orders or whatever, querying more machines will slow down things if it is just from the load balancer.\nIntergalactic Avenger: Well, actually if you think about it, so if you are the reporting server and you are trying to get the all the days orders, you still have to ask every single machine because you know, somebody with the last of the name with the letter P is going to have an order and someone with the last name of the letter Q is going to have an order, so you have to still ask all the machines when you're reporting, so that's I think that's actually not a big problem. I don't think it slows down the reporting aspect of it.\nSpace Pheonix: Okay um yeah, so could be so that's again that load balancer probably let's say if it is just a select query, then we could have and so probably we need to distribute the load balancer now. The problem is all the insertion going through the load balancer on single servers balancing everything and if it find something select query or the report query, it should just give it back to the client, go find the other load balancer or something on that machine and the other load balancer is just mainly for the reporting load balancer and this is probably just the transaction load balancer. So the second load balancer where all the reporting code will go in and that would probably easily to query from all machines and then respond, serve the user. So that way we could just split the load between the load balancers potentially. But I would not really suggest just this machine coding all the machines for the reporting purpose and as well as the same load balancer doing all the insertions to all different machines. That will really become a bottleneck I think.\nIntergalactic Avenger: So other question is I wonder starting this iteration, there's going to be multiple load balancers and each one of them is going to query all of the machines or is going to query some subset of machines? I guess I don't understand the multiple levels of load balancing. And then the other question is why can't the original load balancer just ask all of the machines in parallel what all the results are?\nSpace Pheonix: It can, it can. I'm just worried whether it will become a bottleneck for responding the queries because it's doing all the insertion as we are thinking about, we are talking all the data like Amazon sites, like this all the orders coming through this load balancer and as soon as you are doing the reporting through the same load balancer which is querying all different machines, I am really worried that will become really a bottleneck and slow down things. So what I was proposing was if whenever this load balancer gets a reporting query, I know ok this is just a report, go back to the client saying okay this is just reporting. Go to the other load balancer, so now the client hits this load balancer too, this knows okay I deal with just the reporting part of it, that will still query all the machine, but not the same load balancer. So this load balancer one will just do the insertions and stuff like that, all reporting will go through the load balancer two, which will finally query from all the machines and then serve the user. Does it make sense?\nIntergalactic Avenger: Okay yeah, so I mean if I'm understanding that, so the... it would sort of be introducing like a priority or a tier for the different load balancers and depending on what they were doing, they would sort of have a higher/lower priority to use up the resources, that's very smart yeah because you're right, that the usage of the database is not going to be the same so the... you know a user who's just logging into the site, is going to want to see a small number of records very quickly whereas the reporting server is looking at a very large number of records, but can see them more slowly. So that's great, that make sense. Yeah that's kind of all I had. I know it's a very open-ended question, but I was just curious, wanted to just talk with you about that. I don't know if you've ever done any thinking about this, it seems like you must have thought about this some because yeah you have all this ideas about load balancing and OLTPs and usages and charting, it sounds like you know all of the concepts very well, so do you do this in your in your work already? I know that I normally don't see people that have this much background in this and all the varying context.\nSpace Pheonix: Sure, I did some amount of this work in the past, so I was working really the same kind of ordering platform enough, with like a million users kind of database I was dealing with, so we ran into similar kinds of issues when we were trying to do like multiple computing things like this and exploring it was all again learning and settling down things. There is no just one best solution for everything. So that's why I was trying understand these patterns a little bit and then making sure we balance things like evenly, is really important. But did you have any other better ideas, just in case?\nIntergalactic Avenger: So I do like the one idea of the just having a round robin where you'd put each record, just over that kind of thing. The other way to do it by the way is with respect to the names. If you wanted to do it based on names, what you could do is instead of it being based on the first letter, you could just take a hash of the entire name or the entire user ID or something like that, so then what that hash will do is say you know take some space of you know a hundred thousand, a million, two million users and break it down into a number between you know one and however many machines you have, so just design your hash function so that it takes whatever your identifier is, be it their name or their ID or something like that, and remap it into a space that is exactly how many machines you have, so that way you avoid the problem of querying too many machines and and there's sort of a lot of network traffic that's excessive, but what you could do is you could do is just hash the persons identifier and then you know that that identifier will go exactly to that one machine, and that way as you add more and more users, they just get a randomly assigned according to that hash function. As you said, there's no one right answer. You know, the the practical nature of your data will will pick whatever the right one is and I thought you had a lot of really good ideas, so that's great.\nSpace Pheonix: Alright, yeah. That's good thinking of doing the hash function, that's yeah. That's something new I learned today.\nIntergalactic Avenger: Good, great. Alright, so you have a good day.\nSpace Pheonix: Thank you so much, you too. Bye-bye.\nIntergalactic Avenger: Take care, bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/google-system-design-distributed-databases",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Java Mock Interview (Google Engineer)",
      "content": "Interview Transcript\nIntergalactic Avenger: Hello?\nSupersonic Taco: Hi!\nIntergalactic Avenger: How's it going?\nSupersonic Taco: Good, how are you?\nIntergalactic Avenger: Doing good, doing good. Yeah sorry, couldn't hear you for a second so I just wrote this on the screen there. Have you ever used the platform before?\nSupersonic Taco: Yes, a couple times.\nIntergalactic Avenger: Okay so then I guess you're familiar with how it all works, so I'm just going to jump straight into a coding question.\nSupersonic Taco: Alright.\nIntergalactic Avenger: So the first question is: are you familiar with the concept of order statistics. Have you heard that term before?\nSupersonic Taco: No\nIntergalactic Avenger: It's actually a very simple thing with an overly complicated name. So, given an unordered set of numbers like what I've written here: 1, 6, 3, 9, 8, 5, the order statistics are like the nth element in the list if it were sorted. So, the first smallest number in this list would be 1, and the second smallest number is 2, and basically the nth order statistic is then the nth smallest. That make sense?\nSupersonic Taco: Yeah\nIntergalactic Avenger: Alright so we're just going to have some algorithmic questions about finding some of these nth order statistics. Just to get started as sort of a warm-up problem: how about you write a function that, given a list of numbers that are out of order, you just find the smallest. So basically the first order statistic.\nSupersonic Taco: Okay sounds good.\nSupersonic Taco\nSupersonic Taco: So I'll just declare it here: public static int is the return and I'll just call it min, and this takes an int I'll call it n.\nIntergalactic Avenger: So this should be like an array.\nSupersonic Taco: Yeah, sorry. So then I'll loop through the array, and the for each of those iterations I'll compare it against a min that I've already set up. So I'll set the min to be arr[0], and so what should I return if the array is null, or if there's no value?\nIntergalactic Avenger: Don't worry about that case. We'll just assume it'll always have some values in it.\nSupersonic Taco: Okay, sounds good. So then we'll set the min to the first one. So then moving through the array, if the element at the index of i is less than min then we make that the new min. And at the very end of the for loop you return. So just to test it to make sure, I'll write a litte test here: int[] input = {2, 3, 0, 6} should give us 0.\nIntergalactic Avenger: Yup, sounds good.\nSupersonic Taco: And let's try that then. Alright there we go: it returned 0.\nIntergalactic Avenger: Perfect, and what's the runtime of this algorithm?\nSupersonic Taco: O(n)\nIntergalactic Avenger: And is there any faster way for you to do it?\nSupersonic Taco: For an unsorted array that I know of, no.\nIntergalactic Avenger: Correct. Okay, so now you get the idea, let's make this a little harder, a little trickier. How about you give me the second smallest number?\nSupersonic Taco\nSupersonic Taco: Okay, so for the second smallest number, then I think what we would need to do is maintain two variables and check accross both of them to see...like a larger min and a smaller min so we can check if there's a number that's smaller than both of them then we would put it into the smaller min, and if it's only smaller than the larger one then we can put it into the larger min. So once again are we assuming that the array's length is two or greater?\nIntergalactic Avenger: Yep\nSupersonic Taco: Okay, then I'll just call this min2 and we'll put this at the second element of the arr[], and if the arr[] is greater than the min then it's the very smallest one so the min becomes arr[1]. min2 should be set to min and min is set to the new minimum. And then otherwise, if arr[i] is less than min2 whereas it's still greater than min then this means min2 becomes the arr[i] and instead min becomes min2.\nIntergalactic Avenger: min2 becomes arr[i], but what happened to min then?\nSupersonic Taco: Oh sorry yeah, this is maintained the same I think, because if it's less than min2 then min is still the smallest so it should stay the same, but min2 gets updated\nIntergalactic Avenger: Okay, let's run this.\nSupersonic Taco: I have to return min2 this time. Okay this should give me 2. There, it gave me 2.\nIntergalactic Avenger: Perfect. Okay, I'm trying to think if there is a corner case here. What if these were the numbers here: {3, 2, 5, 6}. It should actually be 3, because 3 is the second smallest.\nSupersonic Taco: Yeah, it returns 3.\nIntergalactic Avenger: What if...Oh because you start back at 0 again, then you flip it all around, I got it. Alright, yeah perfect. And what's the runtime of this one?\nSupersonic Taco: This one is still O(n).\nIntergalactic Avenger: Okay, so we're going to want to move this and turn it into n. So we're going to want to add another parameter here that says I want to find the nth smallest. One way you could do it is you could just expand on this idea and you could just create a list of all of the mins up to n.\nSupersonic Taco: Right.\nIntergalactic Avenger: Now, what would the runtime of that algorithm be?\nSupersonic Taco: Well if we're storing them all, then we need to check across each of them each time which would become O(n^2) because we're running through all of the previous values every time we look through the array.\nIntergalactic Avenger: Yep, so to get the 1st, it just took O(n). To get 2 it took O(n). But now if you expand this in that same sort of pattern it actually becomes O(n^2). So is there a way you can improve on that O(n^2) time?\nSupersonic Taco: Alright let's see. One way to improve would just be to sort the array and that would make it O(nlogn) immediately and then all we have to do is find the nth index in the sorted array.\nIntergalactic Avenger: Okay perfect. Now here's the real challenge. Can we do better than O(nlogn) for any arbitrary m we're trying to find? So we saw that when m is 1, we can do it in O(n) time. When m is 2, we can still do it in O(n) time. You think there's a way that you could extrapolate on that sort of patter and say: oh, I can always do it in O(n) time, no matter which of these I'm trying to find.\nSupersonic Taco: Right. So the reason that we could do it in O(n) time for this m = 1 is because we could just go through and compare them all and see which one is smallest. For m = 2, we had to compare it with each of them and also the previous minimum. Without having to compare it to all the previous minimums I'm trying to think if there's a way to figure out the nth smallest.\nSupersonic Taco: Maybe if we delete for an object but then that wouldn't help either because if we go through…\nIntergalactic Avenger: But if you delete? So certainly it's tricky. If you get stuck, I have some hints for you.\nSupersonic Taco: Yes, I'd appreciate a hint.\nIntergalactic Avenger: Okay so, you mentioned the O(nlogn) case of sorting and then picking the mth item in the list. So in that sense, once we sort this input, you have: [2, 3, 5, 6]. And then let's say m = 3, you go straight for the 5, and you know that 5 is in the correct place, that everything of the left is below it and everything to the right is above it, and it's in position number 3. So that means it is necessarily correct. If we expand this out a little bit more [2, 3, 5, 6, 10, 15, 21], what you can see is that number 5 is in the correct position, but also every single other number is in the correct position. So you've also done work to make sure the 3 is the 2nd position and the 2 is in the 1st position and the 10 is in the 5th position and you've put them all in the right places even though at the end of the all you really cared about is that the 5 is in the right place. Because whatever order any of these other ones are in, it doesn't really matter, you don't really care because you're only really interested in this one.\nSupersonic Taco: Right, okay. So basically we're looking for a way to ensure that a certain value is in a certain spot but all the other values don't have to be sorted.\nIntergalactic Avenger: Correct.\nSupersonic Taco: And the one we want to be in the right place is at the m index.\nIntergalactic Avenger: Right.\nSupersonic Taco: So if we did this for the first minimum then basically we would have to go through each of the elements and then put all the ones that are larger than a certain minimum to the right of it if so that is would be at the beginning. So basically we would have to go through and figure out how many numbers are lower than that number and how many numbers are larger than that number.\nIntergalactic Avenger: Right.\nSupersonic Taco: So what if we do that then. So say we want m to be 2 like in this case where the index is 2 that means we want two numbers to be less than the one at m, and four numbers to be to the right. Somehow there should be a way that we can go through and figure out and make it balanced so that it's like equal on both sides even though those aren't sorted. But we would need to know what the number 5 already is in order to go through and actually put that in the right spot. So there needs to be a way where we can figure that out without already knowing 5.\nIntergalactic Avenger: Right.\nSupersonic Taco: Yeah and if we just chose a random number or when one by one like we did here then it wouldn't work because then we would still go back to being O(n^2). We just still have to go through all the numbers to see which one was right.\nIntergalactic Avenger: But let's take a look at example. You could have described this process where you take this input array, you take the first number you found, and you made sure it went in the right spot. So you described a process of saying: take this number 3, and put it (just that one number) where it goes. So everything to the left is less than it, and everything to the right is greater than it.\nSupersonic Taco: A binary search tree?\nIntergalactic Avenger: Yeah. That's kind of a part of it. So describe how you might do that. You don't really much information about this array coming into it, because it's unsorted, in any order. So you might as well just start with the first number you find and say: I'm just going to put the first one where it belongs and I'll tackle the rest of the problem after that. For example, you can think of what it would look like afterwards: [2, 3, 5, 6, 10, 21, 15]. If you can imagine that this might be what the array would look like after you found the first place. So 3 goes in this spot and everything to the left is less than 3 and everything to the right is greater than 3, and you don't really know what's going on on either side and you haven't really sorted it altogether, but you do know that 3 is in the right spot.\nIntergalactic Avenger: So does this then give you some additional information in terms of how you would proceed from here? So keep in mind we're still looking for the third largest number and you just figured out that the number 3 goes in position number 1.\nSupersonic Taco: So then I know that the number 3 is the second largest number and at this point I would have enough information to find the third largest number using the technique that I just did before where I find the previous minimum then I just have to run through the array one more time to find the next minimum.\nIntergalactic Avenger: Right, that's true. And which part of that array would you run that algorithm on? The whole thing, or a part of it?\nSupersonic Taco: The right, because the right is unsorted.\nIntergalactic Avenger: Well, in a sense the left is also unsorted kind of. Because we don't really have any guarantees about what's going on to the left. In this case you do because there's only one element so there's not really much sorting to do. But what else is an interesting property? So now that you have this 3 in the right spot, in term of what you're looking for are you interested in anything on the left, or are you interested in anything on the right, or are you interested in anything on both sides?\nSupersonic Taco: Well, right now looking at this array, I would be interested in the right because the 3 is only at index 1 and we're looking for index 3. But the 2 could be the 5 too, like what if there was a 5 here instead of the 2.\nIntergalactic Avenger: It couldn't be. It couldn't be because you've split this array up. Let me start by rearranging this more: {10, 2, 5, 6, 11, 3, 15}.So you start with this 10 and you first make sure that everything on your left is less than 10 and everything on your right is greater than 10. So this might look like this: [2, 5, 6, 3, 10, 15, 11]. So you've shifted things around but you've shifted them around in a way so that everything on the left is less than 10 and everything on the right is greater than 10. So it's not just that you've found the one right place for it, but you've done a little bit extra to make sure that you split the array in two pieces.\nSupersonic Taco: Yeah, so then this is actually pretty helpful. If the 10 is over here and this is in the 4th index and m has to be to the left of it, so we don't really need to worry to the right any more because those are greater than 10 anyways.\nIntergalactic Avenger: Exactly. So then when you repeat this and you go for another iteration of it, you're only going to be looking at the left side, right?\nSupersonic Taco: Yeah.\nIntergalactic Avenger: Okay so, does that give you some ideas about how this algorithm might work?\nSupersonic Taco: Yeah it does. Because then in the first time around I'd be iterating through all the numbers to find where it belongs and the second time around I'm only iterating through the left side. So this kind of reminds me a little bit of binary search so the runtime might get a little better than O(n^2) when we do it this way.\nIntergalactic Avenger: Okay\nSupersonic Taco: Alright so, should I start implementing it then?\nIntergalactic Avenger: Yeah let's see what happens.\nSupersonic Taco\nSupersonic Taco: Alright so we're outputting just the number, and this is NthSmallest(). I'm just going to write the code for the first time and we can probably iterate through and make that repeat. So the first time around I'll have to go through the entire array. So if I look at the first one, I'll have to put it in the right spot so then I'll take int index = 0 before this loop. We're going through them and if we say: if(arr[index] > arr[i]) then we need to move it to the right, or swap it. Yeah so if the arr[] at index is greater than the arr[] at i then we need to do some swapping here. So should I just abbreviate it and just write swap here, or do you want me to write the whole swap?\nIntergalactic Avenger: You can just write swap.\nSupersonic Taco: Okay. Well actually I'm going to need to test it later so I might as well just do it now. So then we'll write int temp = arr[i] and then arr[i] = arr[index] and arr[index] = temp. So this switches them around if its greater than, but if it's less than, then essentially we need to keep moving so we don't need to do anything there. But if they're equal to each other then we stop. So we start with index = 0, oh there's a problem here because if it's starting with first one then it'll just stop immediately because it's the same one. So then we'll start at the first one, then index = 0 and the first element is 10, and then it checks to see arr[1] which is 2 and 10 > 2 so then it swaps and now it's 2 and then 10 and then it compares it again, 5: 10 > 5 so it swaps, 6: 6 > 5 so it swaps and it looks at 11. This breaks now because it'll stop since it's greater than, but it needs to continue and look for that 3.\nIntergalactic Avenger: Wait, if those numbers don't equal each other…\nSupersonic Taco: Yeah it wouldn't stop but it still needs to...yeah it would stay there and then it would go through and check against 3 and now that it's less than 3 it'll swap with that one instead and 10 will be where the 3 was and then it'll check against 15, which is greater than so it'll stay there.\nIntergalactic Avenger: So that would actually work for this specific input but think about what would happen if the input was something like this: [10, 2, 5, 6, 11, 3, 0]. First you swap the 10 with the 2 so that's right, and then you swap the 10 with the 5 which is totally right then you swap the 10 with the 6 then you leave that. Then you swap the 3 with the 10, so that's cool, and then you swap the 0 with the 10.\nSupersonic Taco: Yeah that's not right.\nIntergalactic Avenger: Not quite right because when you skipped over the 11 now you have something on the left that is bigger than it should be.\nSupersonic Taco: So then I think maybe we have to move the 11 along with the 10 every time, so maybe we can swap the 11 with whatever's next to it so it keeps moving away.\nIntergalactic Avenger: So you had this point with the 10 and the 0 like this, then what were you going to do? Move up the 0 and the 11?\nSupersonic Taco: No it was like the 10 was here: [2, 5, 6, 10, 11, 3, 0] and then you would check the 10 and the 11, and since the 11 is greater you could swap it away. Yeah you could actually just swap it with the end of the array so this becomes 0 and this becomes 11. And then here we check against the 0 is greater than and it swaps, and then it checks the 10 and the 3 is greater so it swaps.\nIntergalactic Avenger: Okay.\nSupersonic Taco: And that would put it in the right place.\nIntergalactic Avenger: So then presumably if there was another number that was greater than 10 you would swap it so like...we had it here that was like: [2, 5, 6, 10, 11, 3, 15].\nSupersonic Taco: So then it would first compare the 10 and the 11. Okay, now I see what you're saying: if it swaps there it would skip over and it wouldn't work.\nIntergalactic Avenger: But you're definitely on the right track. This is definitely the kind of manipulating that you're going to want to be doing in this kind of array. And you're definitely on the right track with respect to looking at each one of these numbers as you're going up and as long as it's less than then you're keeping it to the left and as long as its greater than you're keeping it to the right. So that's kind of how you're kind of scanning this list of numbers. So you're getting into this one sort of problematic case that when you start to have multiple numbers that are bigger it gets kind of tough with how do you deal with the bookkeeping of where does it go and who can you swap it with.\nSupersonic Taco: Yeah I can think of one way to solve that which would be to create another array and then if it's less than whatever we want we put it into the beginning of the array and hold two counters for where the beginning of the array is and then where the end of the array is and if the number is larger we add it to the end until there's only one spot left and then that's where the 10 has to go.\nIntergalactic Avenger: That's a good way to do it.\nSupersonic Taco: Alright so then I'll try to implement that instead.\nSupersonic Taco\nSupersonic Taco: Okay so then we have now two counters int start = 0 and int end = arr.length and then we loop through and so we know the number that we're looking for I'll put that in as index again and that'll start at 0 this time. So basically if the number that we're looking at right now which is arr[i] is less than the arr[index] then we put it to the right. So then we have this new array that we have to create that's the same length. And then if the arr[i] < arr[index] then it should go in the beginning so we do newArray[start] = arr[index] and start++ to show that we've added an element.\nIntergalactic Avenger: So in this line here you set newArray[start] = arr[index] is it arr[index] or arr[i]?\nSupersonic Taco: Oh sorry, yeah that's completely different thing. And are there going to be duplicates in this array or no?\nIntergalactic Avenger: Let's just say no for now.\nSupersonic Taco: Okay so if there's no duplicates then any other element we look at cannot be the one we're searching for so then we can just do an else here and this basically says that the arr[i] is greater than what we're looking for so it needs to go to the right. So it goes to newArray[end] = arr[i]. And then do end-- and this loop has to end whenever start and end are one apart from each other, because then that means we've found our index. So if end - start == 1 we return start+1. Alright so I think this should work just for the first one to place it in the right spot. So let's try it.\nIntergalactic Avenger: So I see you're returning the number right away but I'm wondering...so this is going to return not the nth smallest, but some smallest that the...you're returning which condition the first element will have gone to.\nSupersonic Taco: Yes, yes. I just wanted to break down the problem\nIntergalactic Avenger: Got it. Okay.\nSupersonic Taco: Okay, in this specific array...Oh I'm missing a return statement.\nIntergalactic Avenger: Here's an interesting question: so when will end - start == 1? When will this be true?\nSupersonic Taco: end - start will be 1 when we've gone through all the elements in the array and now we're looking at that one empty space where the element should go.\nIntergalactic Avenger: Okay, so if that's goign to happen once you're already completed with this array will this ever be see?\nSupersonic Taco: Yeah you're right. We can just recognize those and return start+1.\nIntergalactic Avenger: IndexOfOfBounds?\nSupersonic Taco: Oh end has to be arr.length-1.\nIntergalactic Avenger: Okay. I think actually because you incremented start right here, you don't need to increment start there. I think that's what's going on.\nSupersonic Taco: Alright and let me try it with another m just to make sure. If we deleted one of these, it should become 3 I believe.\nIntergalactic Avenger: Yep.\nSupersonic Taco: Okay, alright.\nIntergalactic Avenger: So now I have the functionality for figuring out the spot where one specific element should go but I have to repeat until I find wherever the element at the mth index is. So essentially this whole start...if start is m then we know that we've found our element.\nSupersonic Taco: Right.\nIntergalactic Avenger: But the thing is this index has to change every time. So I'm thinking maybe we could do this like a binary search where we choose the middle number in each half and we try to put that where it belongs, and if m is greater than the index there then we run it on the right half and if m is less than then we run it on the left half.\nSupersonic Taco: Okay so then we'll start with, instead of 0, index = start + end/2 and then looking at the end….\nIntergalactic Avenger: The index is representative of the index of the number you're comparing everything with. In that sense index represented this number 10 here. Does it get you anything to pick the number in the middle? This number here is the number in the middle, does it really matter that you take index = 0 or index=start+end/2? It's going to be 50-50 right? It's not going to be exactly in the middle there. There's kind of no way to tell how well this number you're picking at random is going to split this array in tWo. I mean you can do that, but I think that starting at index=0 is an totally reasonable way to go because at this point it's just a random array, there's no order. You might as well pick anything and then go from there.\nSupersonic Taco: Yeah, I think that's fine, we can use 0 then. We can actually make this recursive to do a little less work where once we find where the spot that index should go, we'll determine if m is in the right or left and then we will again do it. But actually that might be….yeah I think that might be one way of implementing because we can always keep index at 0 because the array that we're looking at is now a subarray so the index will always be 0. Or a way we could do this is just have index at start and then move through and then kind of keep doing it with a new start and end and that would be another way of doing it. Or we could just make new parameters here for start and end and implement it as recursive.\nIntergalactic Avenger: So I like your recursive idea because it's definitely going to make the code a little simpler. Do you actually need to add more parameters here if you do is as a recursive algorithm?\nSupersonic Taco: No, I don't have to. If I change the array then I don't have to. I was just wondering like that would still take up more memory because technically I would have to somehow cut off the array...We'll just keep it like this for now and turn it into a subarray.\nSupersonic Taco: Okay so then we're using index = 0 and we're returning start which ends up being the index of whatever element is at 0. So what we need to do is determine if m is greater than or less than start. If m is greater than start, we need to redo this on the right side of the array, so we should perform NthSmallest() on...I actually forgot the method for sub-arrays in Java.\nIntergalactic Avenger: I think there's a thing called range? Subset? Fill? I mean, you could just use copy of range if you wanted to.\nSupersonic Taco: I think I got it, there's a code completion on here and it says that it's a method so I'll just use that then. So then the original would be arr[] and I'm assuming the from is inclusive so we'd use start+1 because start we've already looked at and that's the one we've already found and the end would just still be end. And here it would just be the other way around so if we have NthSmallest() then it would be arr[] and instead of start+1 this would be 0 and this would be just start. And else that means that m = start which means we've found the element at the index we want so we just return start.\nIntergalactic Avenger: Okay, so NthSmallest() actually takes two parameters.\nSupersonic Taco: Oh right, so m minus needs to be add in.\nIntergalactic Avenger: Is it m? Because that's relative to the entire…\nSupersonic Taco: Right so if the m that we're looking for is greater than start then it would need to be m-start and if the element that we're looking for is....so if m < start then now we're looking for still m.\nIntergalactic Avenger: Right.\nSupersonic Taco: I'm going to test this now to see if there's any issues. Let's just see if we get 0 as m then we should still get back 10.\nIntergalactic Avenger: We should get 3. So 3 is the smallest one.\nSupersonic Taco: Oh yeah yeah. So it should give back 3.\nIntergalactic Avenger: We need to import ArrayLists? Or is it Arrays. Oh it's a lowercase c\nSupersonic Taco: Oh okay, let's see what happens now? I'm missing a return statement?\nIntergalactic Avenger: You don't have return in these ones. Wait which ones are they looking at?\nIntergalactic Avenger: So 52 and 54, you're calculating it without returning it.\nSupersonic Taco: Got it, alright. Now it's giving me 0, which that's not even in the input array. Oh I returned the index, I never returned the element.\nSupersonic Taco: Oh that's still not right. Alright, let's see.\nIntergalactic Avenger: So definitely the logic looks right, I'm guessing there must be some off by 1 bug. So we already figured out that with this list when you go the first time, start equals...oh wait start was 3 before, so it should have put it in the...So maybe there's some need to do some debugging with some print statements to see...because yeah the logic here is definitely looking solid.\nSupersonic Taco: Maybe here I'll just print out newArray[]. Okay.\nIntergalactic Avenger: Interesting that you have the 10 in there. So in that sense you want your newArray[] to be one element smaller. So if you see what's happening here is you started with index 0, and you're also checking index 0 again. The size is going to be 1 less because you're kind of taking one out then sort of partitioning it after you've taken that one out. So then now that you've reduced the size by a little bit you have to make up for that when you make this copy.\nSupersonic Taco: Well that wouldn't be affected by the newArray[] would it?\nIntergalactic Avenger: Well now the end actually has to be an array of length-2. Because the end is actually the end of newArray[].length-1.\nSupersonic Taco: Right. Well it's the initial array minus one so it's like the ending, but in the newArray[] it's not…\nIntergalactic Avenger: In the new array, you're copying these values over into the newArray[] so the newArray[] has to…\nSupersonic Taco: Yeah, all I had to do was arr[].length here because the end is not actually the end.\nIntergalactic Avenger: I'm looking at line 38 here.\nSupersonic Taco: Oh yeah.\nIntergalactic Avenger: So that end is actually the end of newArray[].length-1, which is the original arr[].length-2.\nSupersonic Taco: Oh okay.\nIntergalactic Avenger: And then in this one, you're not actually copying the original arr[], you want to copy the newArray[] because the original array is totally out of order and the newArray[] is the one...and you'd need the newArray[].length.\nSupersonic Taco: Okay, I get it and newArray[] has to be smaller. Yeah it should be 1 smaller....\nIntergalactic Avenger: Right, so in this one, you just want to copy to newArray[].length.\nSupersonic Taco: Well newArray[].length would include the values above it wouldnt it?\nIntergalactic Avenger: Well newArray[].length is the end of the new array, and you're trying to copy from your position all the way to the end.\nSupersonic Taco: And here there's still something wrong with the size of newArray[].\nIntergalactic Avenger: Wait can you try running again? What's wrong with the size of newArray[]? Line 46. Oh this one here: line 38, you had just changed this.\nSupersonic Taco: So this should be at minus 2?\nIntergalactic Avenger: Or you could just send end underneath the newArray[] or you could move this one up and just say end = newArray[].length-1. Either way it's the same number.\nSupersonic Taco: Oh okay, and this is still arr[].length-1. Okay now 3, okay now that's actually right.\nIntergalactic Avenger: There it is, not bad.\nSupersonic Taco: Now let's try it for some other other numbers too. So if we tried like 1, then that should give us 5. No..\nIntergalactic Avenger: Close. All right yeah, I think there must be some...I'm guessing there's an off by one in either in this m-start or this m here or the zero to start or what. I'm guessing there's a tiny little off by one bug here. So not a big deal, just because we're running a little short on time. So you did all this work and now you're inspecting smaller and smaller pieces of the array as you recurse into it, what is the runtime of this algorithm? So the question is that you did all this work, or there's all this extra code to be careful not to do any more work than you need to so the question is has this actually sped it up or is it still O(nlogn) or is it even greater than O(nlogn).\nSupersonic Taco: Well I think it depends on the case. Say for example this array was sorted in backwards order. Then the first one we'd look at would be the end and then the next one would be the end again. Say our m was 0 then we'd have to keep going through that array over and over and so we'd basically be looking at the entire array...which in the end still comes out to O(n^2). So I think the worst case our algorithm is still O(n^2).\nIntergalactic Avenger: Okay. But what about the average case. What if you randomized...That's sort of a common thing people do with these sort of divide and conquer algorithms is that if there is kind of a poisonous input then you just kind of randomize it to make sure that it's just in this big old jumbled order. So what can we expect sort of on the average case? You're totally right that there is a worst case input that makes it O(n^2), but what can we generally expect this to be in the average case.\nSupersonic Taco: I think this is still O(nlogn) then. Wait actually, in the average case it would be like we're looking at half the array since then it wouldn't be too much or too little. Wait no we're only looking at half, we'd look at 6 then 3 then 1 which is like O(nlogn).\nIntergalactic Avenger: Close. Can you see me typing up above the NthSmallest()? So the first time you run through this in the first iteration you have n elements that you're going over. Then like you said, you break it down by half and the nex time you just go over the n/2 and the next time is n/4 and n/8 et cetera. So what is that going to add up to?\nSupersonic Taco: O(logn)?\nIntergalactic Avenger: Is it?\nSupersonic Taco: Oh no it's just O(n).\nIntergalactic Avenger: Right, exactly.\nSupersonic Taco: Yeah it just becomes O(n)\nIntergalactic Avenger: Yep! So you did it. You got it down from O(nlogn) to O(n). And the trick is when you do the sort you have this halving you do each tie but you keep doing more and more work. Yeah so when you do a sort, you split it in half and then you do both sides, and so even though it's getting smaller and smaller you have more and more of them that you have to deal with, and so the length of this is logn. So like the number of iterations is logn so that's why it becomes O(nlogn). But in your case you don't have this ever increasing coefficient in front of it, so it just adds up to 2n and it's bounded.\nIntergalactic Avenger: So you got it! Very good.\nSupersonic Taco: Alright, thank you. This is a very interesting problem.\nIntergalactic Avenger: I'm glad you liked it. So I'll leave some comments on the platform but just before we go if you have any questions for me about interviewing or anything else I'd be happy to answer them.\nSupersonic Taco: I think I'm all set.\nIntergalactic Avenger: Okay awesome, then you have a good night and good luck with all your future practice rounds.\nSupersonic Taco: Thank you. Have a good night.\nIntergalactic Avenger: Okay. Bye bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/google-java-order-statistic-of-an-unsorted-array",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Java Interview with a LinkedIn Engineer (Reverse Word in String)",
      "content": "Interview Transcript\nIce Gyro: Yeah can you hear me?\nSpace Dragon: Yeah I can hear you now, thank you.\nIce Gyro: Yeah I can hear you. Thanks for the skype invitation.\nSpace Dragon: Let's jump in the question right away. Just one quick question: are you actively interviewing right now? How much are you prepared?\nIce Gyro: I'm not very prepared. I'm not actively interviewing right now. I work as a programer. I'd like to get better. This is my first every time doing interviewing.io\nSpace Dragon: Okay cool. What programming language are you most comfortable with?\nIce Gyro: Java.\nSpace Dragon: Okay cool, I'll just write the question on top here. So you basically have an array and it has something like this….So here is the array: [ 'p', 'e', 'r', 'f', 'e', 'c', 't', ' ', 'm', 'a', 'k', 'e', 's', ' ', 'p', 'r', 'a', 'c', 't', 'i', 'c', 'e' ] If you notice there is a space character and another space character later on as well. We want to convert this array into “practice makes perfect.”\nIce Gyro: So it's moving the letters around is what you want to do.\nSpace Dragon: Yeah, but what's important is that we have an array of characters and spaces in between. This whole list basically has words in reverse order, you know? So this array is basically: “perfect makes practice” and you convert it to “practice makes perfect.”\nIce Gyro: Yeah I think I understand.\nSpace Dragon: And the only thing that is given is that there can be one or more space characters between two words. So you have to make such a string into this, but it has to be in-place, you cannot use any extra anything.\nIce Gyro: Oh, in-place. I was thinking to make a brand new array.\nSpace Dragon: Do it in-place. Maybe before even writing the code we can discuss how you plan to do it?\nIce Gyro: Yeah so. If it was not in-place. I would allocate a brand new array, find where the spaces are and read them with indexOf() and copy the words into the spot. But since I don't have an extra array to work with that makes it a bit more tricky especially because I'm assuming the length of the words are not going to be the same. I'm not counting but the last word of the list might be shorter or longer than the first word in the list.\nSpace Dragon: Exactly. That is true.\nIce Gyro: And when you say swap it in place I'm thinking that I can't use any kind of temporary array. The most I could use is a single character array. So I need to basically move the first letter of the first word and swap it with the first letter of the last word and then the second letter of the first word with the second letter of the last word and so on. And when I do that one of the problems I think might happen is: suppose the first word is quite a bit longer than the last word, then I'm going to have all these blanks and in order to make everything fit, I wonder if I'm going end up sliding over the letters and stuff. So the requirement that it be done in-place seems to make the problem more difficult.\nSpace Dragon: Yeah exactly.\nIce Gyro: Yeah I don't mind, I'm here to get better. And if this first word is very very short. Like if this first word is just “g o,” then I would have to move things over quite a bit before I was able to put in this eight letter word. I would have to swap the first two letters, then go “golly I'm out of space,” and move things over a little bit. One of the things I'm not good at yet is recursive solutions and I kind of think this is perhaps is a thing that a recursive solution would be really good for, but even though I can kind of smell the recursion, I don't think I could do that in the half an hour we have.\nSpace Dragon: Maybe think about this. This is a relatively easier question once you know how to do it. There's something over there if you could think about that. Just think what strategies are there to make the last word in the beginning.\nIce Gyro: So just start with the last word in the beginning, is that it?\nSpace Dragon: So basically you can do some interplay of words here. I mean you can just look at the list and….There's one small thing that will make the whole question solved in that aspect, so a hint would be giving you an answer, but if you just look at the structure of the array, then you can think about how you could iteratively think about how you can get the last word in the beginning and the second last word in the second place and so one.\nIce Gyro: By pasting it down here and reformatting it a little bit I'm hoping I'll see the thing that will help. Not very familiar with the editor but in eclipse this is the trick for telling it not to format. So I wonder if I can take advantage of the letter being the same like: the first letters are both “p”s I don't have to move it, then I swap the e and the r then I swap the r and then swap the f and the c the e and the t the c and the i the c and the t and the space and the e. And then there actually I don't want to swap a space with anything. If I get a space then I just put a space here so we can have multiple spaces around things. So I could try that, but I still don't think that's the answer because if this were a very short word up front….\nSpace Dragon: Let me put it like this: what if the input array was something like this: ['a', ' ', 'b', ' ', 'c']. How would we approach this sort of input?\nIce Gyro: Right so, here I would want to swap a and c. I wonder if what I should do is have something like front is where the a....\nSpace Dragon: Try to build the algorithm first. If you know this sort of input the output would have been like: ['c', ' ', 'b', ' ', 'a'].\nIce Gyro: Right, that's correct.\nSpace Dragon: So for this input we have the reverse of output. This is the reverse of input.\nIce Gyro: So you don't have to be aware of where the words are at, you can just swap things sometimes.\nSpace Dragon: Yeah, if word is just one character, you could simply reverse the whole array. What if word is more than a character? What would happen then?\nIce Gyro: Then instead of reversing the whole thing you would want to treat the sequence of characters as one unit.\nSpace Dragon: Exactly, exactly. One is to do that even if you don't do that, what will happen is something like this: if you had a and say, b together and then we had space c and space d together ['a', 'b', ' ', 'c', ' ', 'd'] this would return something like ['d', ' ', 'c', ' ', 'b', 'a'] right?\nIce Gyro: Yeah, yes yes.\nSpace Dragon: But this is not something you're looking for. d is fine, c is fine, but this word is reversed right?\nIce Gyro: Yeah that should be “'a', 'b'”\nSpace Dragon: Yeah, so how can you fix that then.\nIce Gyro: I could go through and find the individual words and then just reverse them in place. I think I see it now: you reverse the entire string, then you reverse each word in place.\nSpace Dragon: Or: you reverse each word in place, and then reverse the entire string. That is also fine.\nIce Gyro: Very nice, thank you! That's an absolutely delightful problem, I like it very much.\nSpace Dragon: Yeah that's the problem with this: if you start helping the person it's very easy that you just tell the whole solution. Anyways let's start the coding.\nIce Gyro\nIce Gyro: Sure sure sure. So, code it up?\nSpace Dragon: Yeah. Let's do it.\nIce Gyro: Alright, good.\nIce Gyro\nIce Gyro: Alright, so it seems to me that there might be two cases: one where it's an odd number and one where it's an even number but I'm not sure about that. So I'm just going to have front and tail and…\nSpace Dragon: Can you use the function reverseTheWords() in the reverseWholeString()? Oh sorry my bad my bad.\nIce Gyro: Oh no worries, I appreciate your suggestions. You're a very good teaching interviewer, it's very nice.\nSpace Dragon: Okay so that looks okay to me and if I were at my desk in my old friend Eclipse I'd do this inside of some unit tests and have some asserts, but that's not the style of interviews just yet. So that's okay. current is going to just start there, and we're going to say while current spot in the array, word front is equal to the current and word tail is equal to....So if it was a string it would have an indexOf() but since it's a character array it doesn't have an indexOf(). And we're going to look for space, so we find the first space and now we know where the word is, so it's time to reverse the string there. I think I can reuse this reverse the string business by passing in the front and the tail. This version's going to take a start and stop and this one's just going to call the version with start and stop being set to 0 and the length.\nIce Gyro: Yeah.\nSpace Dragon: And then here this front and tail are really the badly named variables, but in the interest of time I'm not going to change their names. Alright so, reverseWholeString(), and once that's done then we need to move current up to the tail plus one and that looks reasonable to me. Then we're going to have this indexOf() guy, and it's going to go and look for a particular character.\nIce Gyro: Maybe one more thing you want to put in indexOf(): from where to start looking for.\nSpace Dragon: Oh that's a great idea, thanks.\nIce Gyro: Okay so, makes lots of sense. Off the top of my head, it looks pretty good. What I would do if I was just doing this for fun to learn is I'd do it as J in it, but since I don't think I have that, I'm just going to output the input array. Is it okay if I run it?\nIce Gyro\nSpace Dragon: Okay yeah we have some errors that you can address. One more thing that you did is while reversing the string….Here is main, from here we go to reverseTheWords(), reverseTheWords() calls reverseWholeString() then reverseTheWords(). Your small string is basically just reverseWholeString() with this input and reverseTheWords() I would create from current is less than this thing. w start is correct your t is the end….So basically on line sixty when you pass reverseWholeString(), maybe you're looking to pass wt minus one.\nIce Gyro: On line 60? Yes yes, you're absolutely correct.\nSpace Dragon: And then the current word increment by plus one and next you enter the loop, here are just wf and wt and in reverseWholeString() while f is less than t, we get the f element out, you're not implementing f here, in this while loop. While loop at 47.\nIce Gyro: Yes, that is a big problem.\nSpace Dragon: And I like the thing you did at line 60 where you wrote -1 before wt. Oh so this is a problem: so if current is length then it breaks right? Here you just need t--? No no, you set temp as the element at f, you put inputArray[f] as inputArray[t], and inputArray[t] is temp now. So at 51, f should go up and t should come down right?\nIce Gyro: Okay, yeah that makes sense.\nSpace Dragon: Yeah exactly. It's fine to me now.\nIce Gyro: Let's just try it.\nSpace Dragon: On line 43, reverseWholeString()….Yeah you also need to pass in the initial word. You have to pass in the array as well.\nIce Gyro: Okay let's try that.\nSpace Dragon: At line 61 there's another error. It cannot find inputArray? inputArray is misspelled here.\nIce Gyro: Okay, I'll fix that.\nSpace Dragon: Yeah I guess it's fine can you run it again?\nIce Gyro: Yeah let's try it. Okay one more: on line 61. And do you think twenty two is the value? Oh I don't think that IndexOutOfBoundsException give you the value.\nSpace Dragon: Probably we are looping something wrong. We are sending f in?\nIce Gyro: Yeah.\nSpace Dragon: So what is f?\nIce Gyro: So little off, way to high. So line 43 is calling it. Ah here we go: like that.\nSpace Dragon: Yeah so the last one is wrong here: “perfect.” So we never entered the loop for the last one right? So we can address that very easily.\nIce Gyro: So here's where we're reversing the individual words in place.\nSpace Dragon: The last word didn't.\nIce Gyro: Oh right here, what if we just say...and instead of wt we're just going to do the length of the inputArray.\nSpace Dragon: Yeah.\nIce Gyro: That was really fun, what a good time.\nSpace Dragon: Yeah someone asked me and never gave me any clue and took me like thirty minutes to think how to do it. Yeah you did good, you created a function and used those functions and that's very nice because that isn't something that comes to mind intuitively. So yeah, it was great work here.\nIce Gyro\nSpace Dragon: And can you tell me the asymptotic bounds on it? What would be the runtime of this?\nIce Gyro: So we loop through the entire array and we do that a couple of times so I think if the size of the input is the length of the character array I think this is a linear time complexity: O(n). And in space complexity I think it's O(1), actually it's really fuzzy in space complexity because you're going to need that input array. So space complexity is either constant O(1), or O(n).\nSpace Dragon: It isn't O(n). It's always constant right because we're not building any extra space anywhere so it will always remain constant, apart from the array that was given to us. That's why it's in-place right. And as the runtime is concerned you inverted a string once, O(n) and plus you invert each word again and that at most is O(n). So O(n) plus O(n) is O(n).\nIce Gyro: Yeah yeah I agree and you're saying in space complexity it's constant O(1).\nSpace Dragon: Yeah because we aren't creating any extra anything at all. Yeah that question you solve in 35 minutes yeah, less than that maybe.\nIce Gyro: Well thanks, thank you very much. This was really fun I'd like to do this again. It was really nice practice.\nSpace Dragon: Which languages do you general program in?\nIce Gyro: I just Java day to day. There's JavaScript in my shop as well. I'd like to learn JavaScript and start interviewing in JavaScript. There's some Scala in my shop, and so I'm taking the Coursera Scala class right now. And I like Ruby on Rails even though I'm working on my first Ruby on Rails project for fun and so I'd like to do Ruby as well. I think Go is very interested but one thing at a time. I think my highest priority is the JavaScript.\nSpace Dragon: And how many years have you been programming?\nIce Gyro: I've been programming for….I think I got my first programming job in 1988.\nSpace Dragon: Oh okay, okay. Your experience is my age.\nIce Gyro: That's alright. I'm used to that kind of thing. I have a lot of co-workers in their twenties and thirties.\nSpace Dragon: So where are you based. Are you based in Bay Area or are you based somewhere else?\nIce Gyro: Well, I kind of like the anonymity so I'll just say I'm based somewhere else is that alright?\nSpace Dragon: Yeah that's fine. I'm just asking because in Bay Area usually don't see people with this much experience, mostly younger people. Yeah I'm surprised. Yeah it was nice working with you.\nIce Gyro: Yeah you too, you too. So my understanding of how this works is we each fill out some feedback and since this is my very first interview I probably won't see your feedback until I interview several more times….\nSpace Dragon: No no, so you will see my feedback when you give me feedback and I give you feedback, then we can see each other's feedback.\nIce Gyro: Oh good. Well I plan to do that and I'd really like to do an interview once a week or something, cause I really do want to get better, and I think gone are the days of just talking to someone for forty minutes and getting a job. I think you have to do the interviews like this.\nSpace Dragon: Yeah yeah.\nIce Gyro: I really like your interviewing style I think you did a great job, and I'll write up the feedback in the next few minutes and maybe we'll talk to each other again sometime.\nSpace Dragon: Great, thank you. See you man, see you. Good luck.\nIce Gyro: Thanks, bye bye.\nSpace Dragon: Yeah, definitely\nIce Gyro: Have a great day! Bye!\nSpace Dragon: Bye!",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/linked-in-java-reverse-word-in-string",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Python Mock Interview",
      "content": "Interview Transcript\nThe Legendary Artichoke: Hello?\nMammoth Avenger: Hello?\nThe Legendary Artichoke: Hey can you hear me?\nMammoth Avenger: Yeah I can hear you pretty well.\nThe Legendary Artichoke: Okay perfect, so why don't you go ahead and pick whatever language you want to work in?\nMammoth Avenger: Okay it's going to be python.\nThe Legendary Artichoke: Okay cool. Alright so let's start with a quick little warm-up. So why don't you write me a function that reverses a string?\nMammoth Avenger: Okay, this is my first time doing interviewing.io so...So like the cheeky python answer is that you can just return a reversed() string for the input.\nThe Legendary Artichoke: Yeah, you could do that...although I'd prefer if you did the reversing yourself.\nMammoth Avenger: I expected. I just changed the variable name there because input is actually a built-in python function. So we could do...start with an empty string. For character in our input we would just prepend it to our output. And I think you can just add characters to a string like that. Should I go ahead and run it?\nThe Legendary Artichoke: Yeah go ahead and run it, let's see if it works.\nMammoth Avenger: Yep that seems to work.\nThe Legendary Artichoke: Yeah that looks like it works.\nMammoth Avenger: I was going to take a look at some edge cases usually as well make sure it handles non-string input like NaN stuff like that which it wouldn't do so great right now.\nThe Legendary Artichoke: I wouldn't worry about non-string inputs, we can assume that if it's not a string that numPy isn't blowing up. So what would be the time and space complexity here of your reverse() function?\nMammoth Avenger: Time is going to be O(n), basically looking at every character once which I don't think you could do better than...you could do it in half the passes if you did it in place and swapped characters but you're still going to be O(n). And space complexity: we're adding another variable output here of the same size, so we could reduce that to O(1) by doing it in-place in the same string. So actually you cannot do that because strings are not mutable.\nThe Legendary Artichoke: Correct, so there's no way to do this in O(1) space in python because you cannot mutate a string. So you are correct on that O(n) is the best you can do on space. But you're actually not correct about the time complexity.\nMammoth Avenger: Okay so...interesting. So I would have thought we looked at every character once.\nThe Legendary Artichoke: So you're correct: you look at every character once, but it's not the only thing you're doing.\nMammoth Avenger: Right, of course, yeah. So this isn't actually O(n) I think correctly that we cannot get better than O(n), so the concatenation right here is probably another O(n) actually because it's adding the whole string that we've created character by character to create a new copy of output.\nThe Legendary Artichoke: Correct: again because strings are immutable.\nMammoth Avenger: So one opportunity we could...yeah python is weird for string based interview questions but we could treat it as a array and swap each character in the correct index as we work our way either forwards or backwards. And we can get the length of the string in O(n) so then we can do it in O(n) that way? Do you want me to code it up?\nThe Legendary Artichoke: Yeah, why don't you go ahead an code that up?\nMammoth Avenger: Okay so treating it as a character array makes sense to you?\nThe Legendary Artichoke: Yeah I think that's probably a better approach.\nMammoth Avenger: So basically as we look at each character we're going to put it into the string starting from the back. So output\\_index = len(x) -1 and then output[output\\_index] = c and output\\_index -= 1. That should do it, I'll just run it see what that does. Okay off by one errors are usually the things that sneak in here so in the case length of x is 4, output\\_index is starting at 3. Right, I think we...yeah so we need to initiate this to make it like an empty array. Let's see if that works. Then we just want to join this back to a string at the end. Okay so I think that should do it, we have O(n) for the length and similar for creating the new output array and we're just doing a single character assignment per loop so I think this whole thing should be O(n) now.\nThe Legendary Artichoke: And what would happen if you just had an empty string?\nMammoth Avenger: I think empty string would return here.\nThe Legendary Artichoke: Okay cool.\nMammoth Avenger: Still this works. Yeah the whole array complication thing is a little not straightforward.\nThe Legendary Artichoke: Okay yeah, that was good. Let me go ahead and give you the meatier problem that we're going to work on. So I want you to write a function and you're function is going to be called find\\_missing() and it's going to take two arguments: the first argument is going to be an array that has some elements in it [4, 12, 9, 5, 6]. You can assume they're all unique to make the problem simpler. And it's going to take a second array that's going to contain the elements in the first array but with one element missing. And what I want this function to return is the missing element which in this case is 5.\nMammoth Avenger: And you said that we can assume they're all unique.\nThe Legendary Artichoke: Yes you can assume they're all unique.\nMammoth Avenger: So my first instinct here is to go to hash tables although we could also use sets in python I believe. So let's see...So I think if we, there's probably a very easy python way to do this where we could actually just make a set of the first array and then I think it's just like subtraction. We can just try that and we can also do it manually as well. Yeah so I'm going to say that's the super easy version which is…missing\\_items = set(full\\_set) - set(partial\\_set). And we assert(len(missing\\_items) == 1) and we return missing\\_items[0].\nThe Legendary Artichoke: I don't think you can index into a set? I take it python has a weird api for sets?\nMammoth Avenger: There's probably a way to pop things out of there but casting to a list is probably the easiest thing for now. So that will work pretty like just putting the work in python. So I can also do it with a hash table?\nThe Legendary Artichoke: No I mean this solution is good. So what would be the time and space complexities of this solution here?\nMammoth Avenger: So converting to a set assume it's going to take linear time because you're basically just populating a hash table I assume it's similar to how python implements it. So if you have m and n as the sizes of the two arrays, so they're both going to be linear and finding the difference should also be a linear operation.\nThe Legendary Artichoke: Why do you say that?\nMammoth Avenger: So at least to do this specific problem if we were doing it ourselves we would basically just be walking through the second array and removing things from the first when they match and because it's a hash table it's constant operation finding and removing them. So I don't know for sure what the full python set difference would take because you might have to walk through both of them but I think it would be linear.\nThe Legendary Artichoke: Yeah I mean let's give python the benefit of the doubt and that it's not doing this in a totally stupid way for set subtraction. So I think you can say pretty safely that this is going to be linear. Cool, and how much space would this take?\nMammoth Avenger: Right so we're going to be creating another full copy of m and n and basically just a hash table version but on that order of size and then the missing\\_items is just going to be one extra thing assuming that our input matches our criteria. So it would on the order of O(m + n) or it might be O(m) + O(n) I don't remember what the specific different between those two are.\nThe Legendary Artichoke: Well there'd be no difference between those two but what is m in this case?\nMammoth Avenger: I guess m and n are only one off so they're basically the same so we're talking linear on the size of either set really.\nThe Legendary Artichoke: Yeah, exactly. Yeah that sounds correct, you are correct. So is there any way you think I could do better than linear time here?\nMammoth Avenger: Let's see....so the only way to do better than linear time would be to not look at every item and the case where that could happen is if we...well missing item is by definition a number in the first set but not in the second. I'm trying to figure out if there's a way we can short circuit the check from looking in either array. So in the case the 5 is missing, so we're looking at the second array we don't know until the very end until we've looked at all the items we don't know for sure that there's no 5 in there. Actually that's not true we could sort it.\nThe Legendary Artichoke: If we sort it, how long would it take to sort?\nMammoth Avenger: Oh but that's O(nlogn), that's longer. So that doesn't work. So if it's not sorted then we can't know for sure until we get to the very last element that there isn't a 5 in the second one and if we go through the first one we can't know looking at any item that it's not in the second set until we've gone through so I'd say you can't do better than linear.\nThe Legendary Artichoke: Yep, you are correct and your argument is sound. There's no way to do better than linear time, because if there's at least one element we haven't looked at, that could be the missing element if we don't have any guarantee on order which we don't. Okay so linear time is the best we can do here, but let's say we want to trade off time for space. I'm very space constrained and I don't have enough memory to create a whole copy of my dataset. How would you lower the amount of space that this solution takes?\nMammoth Avenger: So if we don't care about time at all, one option is we sort both arrays and then you can just walk through them one by one you sort them in place so it takes the same amount of space, walk through them index by index and as soon as you find a difference in two elements you've found the missing item.\nThe Legendary Artichoke: Yeah, and what sorting algorithm would you use for that?\nMammoth Avenger: Just, we don't have any expectation given on the the specific kind of data that we're working with so probably just go with Quicksort or general data sanity, I think that's what python uses by default to sort data or it might be some slightly modified version of Quicksort.\nThe Legendary Artichoke: Yeah I'm pretty sure it uses a modified Quicksort and what would the be the space complexity if we used Quicksort?\nMammoth Avenger: My sorting algorithms are a little bit rusty but I did forget that it can add extra space complexity as well so that might be an issue. But I think that Quicksort is a variant of Mergesort I believe which picks a pivot and is just swapping items around. Oh but it's recursive, so it's probably bad for the space complexity. So if we really didn't care about the time complexity we could just do a Bubble sort or something that doesn't take any extra space but I think there are also better sorts that don't take any extra space.\nThe Legendary Artichoke: Yeah, you are correct. In particular there are a number of sorts that are O(nlogn) time while O(1) space such as Heapsort which you may vaguely remember.\nMammoth Avenger: Yep, okay.\nThe Legendary Artichoke: So if you use a sort like Heapsort, you could get it in O(1) space. Quicksort would be O(logn) for the reason you just mentioned which is because its recursive we need stack writes. But yeah okay you could go look up a sort that's O(1) space and if you needed to bite that bullet you could get O(nlogn) time and O(1) space. So that's good it gives us different ways to approach this problem. Let's say we need O(n) time, like O(nlogn) is not the trade off I'm willing to make. Do you think there's a way we can improve the space from O(n) to being less than O(n)?\nMammoth Avenger: This require the constraints to be fairly specific but if we're guaranteed that they're integers and they're all unique then we can just sum up the first list and subtract the sum of the second list and that should give us the missing item? And that's a very simply algorithm and that would be linear time and constant space.\nThe Legendary Artichoke: That would work. Why would you say it's constant space?\nMammoth Avenger: Because we're just doing two sums and then a subtraction?\nThe Legendary Artichoke: That's true but that doesn't guarantee that it's constant space. Do you know why?\nMammoth Avenger: I guess because we don't know how big the sum is going to be?\nThe Legendary Artichoke: Correct.\nMammoth Avenger: Gotcha, so if we're dealing with very large integers.\nThe Legendary Artichoke: Right if we're dealing with very large integers or just sufficiently many integers then clearly the size of the sum we're going to store is, in some way, going to scale with the size of the input right?\nMammoth Avenger: Yeah, is this one of the things where you could use an XOR?\nThe Legendary Artichoke: How would you use an XOR? How would you do that?\nMammoth Avenger: I think if you just XOR a series of integers and then….how does this work? I'm just going to..is it okay if I just look up what the python XOR function is and just play with it in the console for a bit?\nThe Legendary Artichoke: Yeah it's the ^, I'm fairly certain.\nMammoth Avenger: So we do 4 ^ 12, then I think it's like if you XOR with the same number again it gets you back to….basically if you have any number and you XOR it with an integer and you XOR with that integer again it undoes the effect. Yeah which is like topological because it's just flipping the bit. So I believe we would just XOR all of the integers in both lists. It feels kind of strange because you're treating the two lists differently but I believe the end result should end up with 5, and that one is actually constant space because it's only an integer at any point.\nThe Legendary Artichoke: Yeah, that sounds perfect, why don't you go ahead and write that up real quick?\nMammoth Avenger: Alright. I don't know what you would call this but XOR\\_sum seems close enough. That's it.\nThe Legendary Artichoke: Yeah let's give that a quick run and make sure that works.\nMammoth Avenger: That looks good. Don't know if that would handle negative numbers. Interesting…\nThe Legendary Artichoke: No it does because negative numbers, because the XOR is going to respect the negative bit.\nMammoth Avenger: You could use this on any binary datatype like find a missing object from a list of binary objects.\nThe Legendary Artichoke: Yeah as long as you only have one of the them right? Otherwise you would just get the XOR as the two objects. But yeah you pretty much got it, it was perfect. I don't have anything else for you so: well done.\nMammoth Avenger: Thank you. How does this work from here? Do you have a feedback form afterwards, or do we just chat about it for a bit?\nThe Legendary Artichoke: It's up to you we can chat about it if you want. We both get feedback forms and we send them to each other and then we can mutually read the feedback. If you have any questions I'm happy to answer them.\nMammoth Avenger: Yeah I'm just back on the job scene after a couple years of running my own startup so it's been a long time since I've done technical interviews any constructive criticism or things that I could do better or work on would be appreciated.\nThe Legendary Artichoke: Yeah my feedback is honestly you pretty much knocked this one out of the park and you're probably the fastest person I've seen solve this and get to the optimal solution. And you're coding is clearly strong. You're familiar with python you're pretty comfortable I can tell. The only thing that was a slight irk was calling variables x like that's just a peeve of mine, but different interviewers aren't going to care so that's totally and idiosyncrasy that doesn't matter in the long run.\nMammoth Avenger: I always struggle with variable naming in interview questions, I always seem to be vary ambiguous quantities. Any suggestions on what to call a variable for like a string input for like the reverse() function for example?\nThe Legendary Artichoke: Usually I just call it str for string. As long as there's nothing descriptive of it other than its datatype then I would just name it by its datatype. But again this is not nearly egregious enough for me to mark you down for it. Like I've done interviews where people are writing a fairly complicated function and they're calling things x and y and g and things like that or they call a function f() you know, that sort of thing. So honestly calling the input to a reverse function x is not enough of a violation that I care.\nMammoth Avenger: Cool\nThe Legendary Artichoke: Overall I'd say you solved this strongly.\nMammoth Avenger: Alright, thank you very much.\nThe Legendary Artichoke: Cool yeah, no problem take care.\nMammoth Avenger: You too, bye.\nThe Legendary Artichoke: Bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/airbnb-python-missing-item-list-difference",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Golang Mock Interview (Microsoft Engineer)",
      "content": "Interview Transcript\nIndelible Raven: Can you hear me?\nMassively Parallel Llama: Hi I can hear you, I'm on the phone.\nIndelible Raven: Awesome, yeah it's been having problems all day, for a while. So have you done this before?\nMassively Parallel Llama: I have done one before, yes.\nIndelible Raven: On here?\nMassively Parallel Llama: On here, yeah.\nIndelible Raven: Awesome, I do it just a little bit different. I do the same interview, like 35 minutes. But also at the end I can give you some feedback verbally as well. I do that with most people. So if you want to hear it just let me know. Other than that, let's see where you're at in your career.\nMassively Parallel Llama: In my career I'm about 2 or 3 years in experience.\nIndelible Raven: Alright, so I used to work at Google, but I don't know Go, and I feel bad for that.\nMassively Parallel Llama: That's okay, it's a language you'll be able to understand.\nIndelible Raven: No it's just like: if you work at Google, you really should know Go. It's like their language. Awesome well I'll just start you out with something, and ideally we'll get into a second part of the same question, so just keep that in mind.\nMassively Parallel Llama\nIndelible Raven: I'm going to give you a bunch of points on a 2 dimensional graph. It can either give its own class or do a pair. So it would just be [x,y]. It would be a list. Point[] of points, where it's something like [[1,2], [3,-1], [2,1], [2,3]], right? And then I'll give you a point, the vertex, so in this case it's not going to be [0,0], it's going to be [2,2] or anything I give. And I'm going to give you int k = 2. So what I want you to do is take the list of points on the graph and find the closest ones that are around the vertex and I want you to return the k closest.\nMassively Parallel Llama: Okay so let me just reiterate the problem so I have an understanding of it. You're going to give me a list of [x,y] coordinates and you'll give me a vertex, some ideal [x,y] coordinate and you need me to return the k closest [x,y] coordinate in the original point[].\nIndelible Raven: Yes, to the vertex\nMassively Parallel Llama: Okay, what would you define as the closet?\nIndelible Raven: Distance wise, so kind of the general Euclidean distance.\nMassively Parallel Llama: Cool. And these points, they're not in any sorted order are they?\nIndelible Raven: No.\nMassively Parallel Llama: No. Okay. So, my first intuition to this problem is to go over the [x,y] coordinates and for every single [x,y] coordinate compute the distance to the vertex and store that in some sort of...via min heap. And then once we have all of the elements stored in the min heap, we can pop out the top k from the heap and that will be the answer.\nIndelible Raven: Okay.\nMassively Parallel Llama: Does that make sense?\nIndelible Raven: Yeah that sounds reasonable.\nMassively Parallel Llama\nMassively Parallel Llama: So let me try to code this up. At the same time, before I start, maybe we can just discuss time complexity. Before I start coding maybe I'll think of something better? So the first step is to compute all distances to the vertex and that is going to take O(n) because we have to visit every single element and once we computed, we're pushing it onto the heap. Now when you insert something into a heap, we need to make sure that the heap....so inserting into a heap is actually constant, we don't need to worry about that yet. And then we need to perform k pops from the heap, and when you do a pop from the heap we need to figure out the next minimum element from the heap, so that's going to be O(k), because we need to pop k times and the bubble up operation can be performed in O(klog(n)) because heap has n elements. Yeah so that's one solution so if we just look at the worst case it's still O(n), that's out dominant time complexity right there. And of course we'll have to use space, our space is going to be our heap which is also O(n). Yeah so we could have another solution if we didn't have access to space, we just had to do it without using any extra memory, you could just sort of do a O(n)....that would be O(n^2) solution or….I can't think of a way where….\nIndelible Raven: So you're worried about space right?\nMassively Parallel Llama: Yes.\nIndelible Raven: How much space are you using?\nMassively Parallel Llama: O(n)\nIndelible Raven: Right, so how many points do I want to return?\nMassively Parallel Llama: Oh yes, so it could just be k. We need to only keep a heap of size k, everything else larger than k we can just throw out.\nIndelible Raven: Yeah, so how does that change the complexity overall?\nMassively Parallel Llama: Space complexity goes to O(k). And time complexity becomes O(klog(k)) for the pop.\nIndelible Raven: I'm not entirely sure your complexity is right. It is for pop, but not the push. Every time you insert it needs to keep track of something which means it re-heapifies, that's O(log(n)) so it should be O(nlog(k)).\nMassively Parallel Llama: Right, so if you already have a heap and you're pushing onto a heap you have to figure out what the next minimum element is so you would have to heapify. So yes this would also be O(klog(k)). Every time you're inserting or removing from the heap you have to find the next minimum so it would both be O(klog(k)).\nIndelible Raven: No it's actually O(log(k)) but's it's n times that.\nMassively Parallel Llama: Right, so for the push right, the push will be...we're going to do that n times and it's O(log(k)) right. But for pop we don't actually need to do anything here because we already have the k minimum elements and we can just return so this just goes away. So if that's the case our dominant time complexity will be the push.\nIndelible Raven: Try it out\nMassively Parallel Llama\nMassively Parallel Llama: Sure let's try it out. Okay so let's call this...for the points I'm just going to define a structure...it's going to have 2 elements and our input is going to be Points and we're also going to be given…\nIndelible Raven: Wait really, it works right to left in this case? That's weird\nMassively Parallel Llama: Yeah, it takes a while. And let's say we're going to return a list of a []points of of k closest points. So I guess while I was checking this another obvious way of doing this was compute all distances and just sort and once you sort you have your k closest element sorted already. I guess another clarification: would you like the original point or do you just want the distance?\nIndelible Raven: I don't want the vertex in the output but if there is a point on the vertex then that could be returned. So if that []point had [2,2] in it then yes.\nMassively Parallel Llama: Okay so just a special case if it's exactly the vertex then you want to return the point otherwise the distances is fine?\nIndelible Raven: No I want all the points.\nMassively Parallel Llama: Oh okay, you want all the points.\nIndelible Raven: Obviously a point on the vertex would be 0 distance so it would be the closest.\nMassively Parallel Llama: No I was wondering if the return should just be list of distances or the actual points.\nIndelible Raven: No, points.\nMassively Parallel Llama: Okay. So if that's the case I'm just going to add an extra element to our point struct and this could definitely be an option element that just has the distance.\nIndelible Raven: Actually I want you to leave the point class alone.\nMassively Parallel Llama: Okay let's just figure it out as we move forward then. How we can figure out which point to return after we have our heap. Alright let's just figure out how to compute the distances first, we're going to go through all the points. And for each point we're going to want to calculate the distance. So let's just assume we have a function that can do that for us. Once we have the distance we want to push it on to some sort of heap. We need some sort of heap, in Go, if you want to use a heap you have to use a priority queue and you have to write out the interface for it, so is it okay if I assume that I have a heap?\nIndelible Raven: No, I want to see the priority queue. It's that way in most languages.\nMassively Parallel Llama: You have to implement all of the interfaces for it.\nIndelible Raven: What do you mean?\nMassively Parallel Llama: The priority queue is offered as an interface and you have to implement the pop and the push based on the struct and how you want to compare each element on the heap.\nIndelible Raven: That's interesting. Then assume you can, but come up with...I don't know if Go has something like a comparative function, like a lambda function for it.\nMassively Parallel Llama: We don't really need a priority queue for this, a priority queue is more involved than a heap. We could write one.\nIndelible Raven: Just assume you have it.\nMassively Parallel Llama: So we have to initialize it somehow, and once we have that we can actually give it a size. We only want k elements in the heap and over here we can just do heap.push()\nIndelible Raven: No, I want you to handle the k yourself.\nMassively Parallel Llama: You want me to handle the k myself?\nIndelible Raven: Like I don't want it to limit the k, I want you to do that.\nMassively Parallel Llama: Okay. So if that's the case we need to figure out what the size of the heap is, assuming we can get the size of the heap by looking at the length of it. If this is the case then we need to find the element that's the largest in the heap.\nIndelible Raven: So is there a data structure that will let you find it in O(1)?\nMassively Parallel Llama: That will let you find the largest?\nIndelible Raven: Data structure or algorithm.\nMassively Parallel Llama: So let's assume our heap is represented as an array. If it is, we can actually keep track of each index in a map.\nIndelible Raven: I don't want to do it that way. Assume your heap works with push and pop and stuff, think about what the heap really is. What kind of heap is this?\nMassively Parallel Llama: It's a min heap? Actually it doesn't have to be a min heap, since we're only storing the k element that we're going to return, it could actually be a max heap and if it's a max heap we can just find the largest element.\nIndelible Raven: There you go.\nMassively Parallel Llama: Yeah so if our heap is a size k, then what we need to do is a heap.pop() and that will get rid the largest element and then we can just push()….even if it is full and we turn directly to a pop(). So let's assume we have some sort of peek() function so we can see what the largest element is and if its larger than our current distance, then only we need to do a heap.pop() and we need to push() our new element. So that's sort of our special case and if it's not then we don't have to worry about the dist, we can just continue and we just need to have an else here to take care of the case when our heap isn't full yet to go ahead and just push.\nIndelible Raven: So your heap is just distances, right?\nMassively Parallel Llama: Right now yes, it's just the distances.\nIndelible Raven: So how are you going to get the k closest out of that?\nMassively Parallel Llama: Right so I think it's best to define the new object or struct heapNode, and in this heapNode we can actually have a Dist and we can have a Point and for our comparative function for our heap, we don't care about the point we're just worried about the distance when we do the pop() and push(). Which means we just directly insert the distance and we should put it in this struct here. Okay so now that we have our heap, we should have k elements and I guess how you kind of write a while loop in Go, there's no while loops so you just write a for instead. So while our length of heap is not equal to 0, we keep pop() to our ans, and storing the point and returning it. And you mentioned a little bit earlier in the conversation that you want the vertex to be the first element in our answer?\nIndelible Raven: No, I literally just want the k closest.\nMassively Parallel Llama: Cool so we just append this to our list, and we don't care about the distances anymore we just want the point?\nIndelible Raven: Just the point.\nMassively Parallel Llama: And after this is done we'll have the k element and we can return our answer.\nIndelible Raven: Okay, there's more to this but I want to stop here and I want to take this to a different approach. This obviously works for k if I give you a list of points. What if my list is roughly a petabyte worth of points?\nMassively Parallel Llama: So our list of points is huge? If that's the case can we assume that the list of points coming in to program or function is element by element and not just as a giant list?\nIndelible Raven: You could. That would work.\nMassively Parallel Llama: That's a big assumption right. But this function would potentially work.\nIndelible Raven: I mean it generally would work, but it's a petabyte of points. I know Go is suppose to be fast but how long would that take?\nMassively Parallel Llama: So if its a petabyte of points just computing of every distance in our list is going to take some time. So if our point array is too big, we can just throw more resources at it and divide up the point[] to a more manageable chunks and send it to multiple machines I guess. And after they've all figured out their k lowest, we can do a merge operation to find out the k lowest afterwards.\nIndelible Raven: Sorry could you repeat that?\nMassively Parallel Llama: Yeah so my first thought is if it's too many points we divide up the points to manageable chunks and we divide up the work to multiple machines that hey here's a set of points, find the k closest and once every machine has done its work we have a merge operation to find what the actual k closest is at the end. That's my initial thought process if the points[] is too big.\nIndelible Raven: I mean that makes sense but what is that?\nMassively Parallel Llama: What is that? Like just a term for it? It kind of reminds of MapReduce a little bit?\nIndelible Raven: There you go, MapReduce.\nMassively Parallel Llama: Yeah you have a bunch of workers that are parsing various chunks and combining it afterwards once their done.\nIndelible Raven: So that's kind of what I'm looking for and how you would set up the MapReduce and stuff like that.\nMassively Parallel Llama\nIndelible Raven: Let's stop here that way I can give you your feedback if you want.\nMassively Parallel Llama: Sure sure.\nIndelible Raven: Usually I evaluate people's ability to code, especially when it comes to style guide. But truth be told I still don't really know how Go works or what style guide would look like. But based on general style guide it looks good. Still confusing but….\nMassively Parallel Llama: Just to touch on Go a bit. Go actually forces you to follow style. If you look at every codebase it'll look identical no sort of tabs versus spaces. So for example if I had line 48 on line 49 this actually won't compile. So it has to look like this, Go sort of forces the same sort of standards on everybody.\nIndelible Raven: I really wish you got those semicolons, drives me nuts that there aren't semicolons.\nMassively Parallel Llama: I think in Go they are optional, you can use them if you want.\nIndelible Raven: I really wish you had your edge cases. Say hey, what happens when k is less than 0 or if k is greater than the number of points. And actually wrote out test cases and error checking in the code. That's something I look for. Your algorithm design is pretty good, you're able to come up with a semi-optimal solution and I gave you a very very subtle hint and you were able to come up with a much more optimal solution as a result. I would have liked to see you go faster, time is not your solution in an interview. Ideally when we come up with these questions we plan for us to solve it in 15 minutes and since we know these questions it's going to take longer for the person but I still would have liked to see if go a little bit faster that way we could spend a little more time talking about MapReduce and what the Map would look like and how you would Reduce it. So I used to work at Google and I work at Microsoft. There's a different mentally when you work with an excessive amount of data. You don't think about how it works in one program you don't think about how it works linearly. Your brain automatically switches to: how do I spread this out to thousands of machines. I wish you went there first, instead of saying: hey we're just going to use a datastream and it'll work perfectly fine. When I switch to that, when I come up with something new the obvious answer is not the right answer. It may use some of the same code but it's not going to use the exact same code, so your first thought should not have been that. I kind of wish you started talking about MapReduce instead of the general concept of one. It kind of gives me the impression that you never really use one right?\nMassively Parallel Llama: I honestly haven't.\nIndelible Raven: The reason I bring this up is, at the two companies I worked for, it's big there. If you're interviewing for me there, I kind of expect that. If you're not interviewing there then that feedback is kind of pointless but take it as your want. Overall I think you did well, I would have liked to see you go faster and talk a little more but I think you did well. Took you a little while to figure out to use a max heap for sure. It's really all I have, you did pretty good. Do you have any questions?\nMassively Parallel Llama: In terms of coding fluency, I need to just solve more problems and get faster before I actually go into the real interviews.\nIndelible Raven: Not even faster the speed at which you're coding is fine. You need to come up with a way to make it fluid, make one step into the next into next to the end. I know that doesn't make sense in real life coding, but it has to be a very fluid operation and if it is, you're going to go fast. You don't need to speed up how you're coding, you just need to speed up your fluidity.\nMassively Parallel Llama: Yeah that definitely makes sense.\nIndelible Raven: Yeah so you talked a little about the scale. Do you think, when we started off with the problem, maybe I should have asked you how big the points array could be?\nMassively Parallel Llama: I would have told you it would have fit in an array. I wanted this answer first because this teaches me how well you code. MapReduce and this are two different things. So you would have still ended up with this but then I would have shifted to MapReduce. What I wanted to see was your mindset shift once you knew what the data was. It's always good to ask how much data there is, but I would have not told you a petabyte at the beginning.\nIndelible Raven: Yeah I don't think I have anything. This was great. This was a great experience looking back.\nMassively Parallel Llama: Thanks for interviewing with me. I think you did well. I would have definitely moved you on-site, I might have even said yes to a hire. So I have feedback, some is negative but that's just other stuff you can improve on.\nIndelible Raven: I'm going to jump off, write your feedback. It's probably not going to be much because you did well. Just going to hit on the speed part. That's all I have so I wish you the best in the future and good luck!\nMassively Parallel Llama: Yeah thanks man, thanks a lot. Bye\nIndelible Raven: Bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/microsoft-go-vertex-distance-order-statistic",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to Reverse a String [Interview Question + Solution]",
      "content": "How to Reverse a String (With Solutions in Python, Java & JavaScript)\nHow to Reverse a String: Problem Overview\nHow to Reverse a String: Problem Overview\nThe Reverse String problem involves taking a given string of characters and reversing the order of the characters. This problem, despite its simplicity, invites many advanced approaches, such iteration, recursion, or multiple pointers, each presenting a unique time and space complexity tradeoff.\nAn Example of the Reverse String Problem\nAn Example of the Reverse String Problem\nWrite a program to reverse the given string. The program's output would be a string with all characters in reverse order.\nInput: \"hello world\" Output: \"dlrow olleh\"\nInput: \"aba\" Output: \"aba\"\nInput: \"ab\" Output: \"ba\"\nInput: \"\" Output: \"\"\nConstraints\nThe number of characters in the string would be in the range [0, 100000].\nHow to Reverse a String : 4 Approaches in Python, Java & JavaScript\nHow to Reverse a String : 4 Approaches in Python, Java & JavaScript\nThe most straightforward answer is to use an inbuilt library-provided function that is usually available in most languages. But the interviewer is probably not interested in our knowledge of library functions. This means the ideal solution would be similar to how a library would implement a reverse\nfunction (i.e., Python, JavaScript, Ruby). There are several approaches, and we'll discuss some of them here.\nApproach 1: Build String Iteratively (Brute Force)\nThe original string's first character turns into the reverse string's last character. The second character of the original string becomes the second last character of the reversed string. And so on.\nWe can loop through each character of the original string and build the reversed string iteratively. We start with an empty string and append the characters to it as we loop across the original string. Please note that we are appending the characters to the beginning of the string. By doing so, we ensure that the characters appearing later in the original string appear earlier in the reversed string.\nAlgorithm\n- Initialize an empty string\nreversed\\_string\n. - Loop through each character of the original string.\n- Append the character at the beginning of\nreversed\\_string\n. - Return the\nreversed\\_string\n.\nReverse String JavaScript, Python and Java Solutions - Brute Force\nfunction reverseString(string) {\nlet reversedString = \"\";\nfor (char of string) {\nreversedString = char + reversedString;\n}\nreturn reversedString;\n}\n1function reverseString(string) {\n2 let reversedString = \"\";\n3 for (char of string) {\n4 reversedString = char + reversedString;\n5 }\n6 return reversedString;\n7}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n²)\n. A common mistake is to think of the time complexity of this approach asO(n)\n, but this is not the case. The time complexity isO(n²)\nbecause each time we append a character to the end of the string, we end up creating a new string. This new string then gets assigned to the variablereversed\\_string\n. This is anO(n)\noperation, and we are doing this for each character in the string. So the total time complexity isO(n \\* n) = O(n²)\n.If we are coding in a language that support string mutability, then appending a character would be a constant time operation. So the time complexity would be\nO(n)\n. -\nSpace Complexity:\nO(n)\n. We are creating a new string of lengthn\n, which is the only memory space we use.\nApproach 2: Build String Iteratively (Linear Time)\nIn the previous approach, we noted that it was not the optimal solution because we were creating a new string each time we added a character to the end of the string, which is an O(n)\noperation. Can we find a way to bring this operation down to O(1)\n?\nInstead of creating a new string every time we need to find a data structure that we can append individual characters to in constant time, and to this we can use a stack. A stack is a data structure that follows the LIFO principle. In this approach, we push all the characters of the original string onto the stack and then pop them one by one in order to build the reversed string.\nAdditionally, while building the reversed string, we use a dynamic array to store the characters. By using a dynamic array, we avoid creating a new string every time we append a character to the end of the string, making the operation O(1)\ninstead of O(n)\n.\nAlgorithm\n- Initialize an empty stack\nstack\n. - Loop through each character of the original string.\n- Push the character to the stack.\n- Initialize an empty dynamic array\nreversed\\_string\n. - Loop until the stack is empty.\n- Pop the top character from the stack. Append it to the end of\nreversed\\_string\n. - Create a string from the dynamic array\nreversed\\_string\nand return it.\nReverse String Javascript, Python and Java Solutions - Using a Stack\nfunction reverseString(string) {\nlet stack = [];\nfor (char of string) {\nstack.push(char);\n}\nlet reversedString = [];\nwhile (stack.length > 0) {\nreversedString.push(stack.pop());\n}\nreturn reversedString.join(\"\");\n}\n1function reverseString(string) {\n2 let stack = [];\n3 for (char of string) {\n4 stack.push(char);\n5 }\n6 let reversedString = [];\n7 while (stack.length > 0) {\n8 reversedString.push(stack.pop());\n9 }\n10 return reversedString.join(\"\");\n11}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n)\n. We are looping through the original string once and pushing the characters to the stack. Then we loop across the string again and pop all the characters from the stack. Finally, we join all the characters of reversed\\_string, so the total time complexity isO(n + n + n) = O(3n) = O(n)\nPlease note that an algorithm that takes3n\ntime is classified withO(n)\ntime complexity. Big-O notation is a measure of how an algorithm scales as the size of the input grows. As the size ofn\nincreases, the constant factor3\nbecomes insignificant. -\nSpace Complexity:\nO(n)\n, as we use a stack that storesn\ncharacters.\nApproach 3: In Place Reversal (Two Pointers)\nWhen a string is reversed, the last character becomes the first character, and the first character becomes the last character. Similarly, the second last character becomes the second character, and the second character becomes the second last character. And so on. In other words, characters at the same position relative to the start and the end of the string are swapped.\nWe iterated from one end of the string to the other in the previous approaches. It is also possible to iterate from both ends of the string simultaneously. Let's have two pointers, one pointing at the start of the string and the other at the end of the string. We can swap the characters at these two pointers. Then we can move the pointers toward the middle of the string. We can keep doing this until the two pointers meet each other.\nIn most languages, a string is immutable. This means that we cannot change the characters of the string. We can only create a new string. So we need to convert the string to a character array. Then we can swap the characters at the two pointers. After swapping all the characters, we can transform the character array back to a string.\nIf the language supports mutable strings (e.g., Ruby, PHP, Swift), we can directly swap the characters at the two pointers. Some languages don't support mutability directly, but might have a class or a standard library that provides a mutable string. For example, there is StringBuilder in Java.\nAlgorithm\n- Convert the string to a character array\nchar\\_array\n. - Initialize two pointers,\nstart\nandend\n, to point at the start and the end of the string, respectively. - Loop until\nstart\nis less thanend\n. - Swap the characters at\nstart\nandend\n. - Increment\nstart\nand decrementend\n. - Convert the character array back to a string and return it.\nReverse String Javascript, Python and Java Solutions - Using In Place Reversal\nfunction reverseString(string) {\nlet charArray = string.split(\"\");\nlet start = 0;\nlet end = charArray.length - 1;\nwhile (start < end) {\nswap(charArray, start, end);\nstart += 1;\nend -= 1;\n}\nreturn charArray.join(\"\");\n}\nfunction swap(charArray, start, end) {\n// using destructuring assignment to swap the characters\n[charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n}\n1function reverseString(string) {\n2 let charArray = string.split(\"\");\n3 let start = 0;\n4 let end = charArray.length - 1;\n5 while (start < end) {\n6 swap(charArray, start, end);\n7 start += 1;\n8 end -= 1;\n9 }\n10 return charArray.join(\"\");\n11}\n12\n13function swap(charArray, start, end) {\n14 // using destructuring assignment to swap the characters\n15 [charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n16}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n)\n. Both pointers traverse the string from opposite ends until they merge. So every character is processed once in this process. Swapping two characters takes constant amount of time. So the overall time complexity isO(n)\n. -\nSpace Complexity:\nO(n)\n. We are using a character array to store the characters of the string. So the space complexity isO(n)\n. If the input to the function is a character array itself or the language supports string mutability, then the space complexity would beO(1)\n, because the algorithm does an in-place reversal of the character array / string.\nApproach 4: In Place Reversal (Recursion)\nNote: While recursion will work for this problem, it overcomplicates the problem without added benefit and as such many interviewers will prefer one of the non-recursive approaches above. We have included the recursive solution here for completeness.\nIn the previous approach, we iterated two pointers toward the middle of the string and used them to swap the characters at the index of each pointer. While this method works well, we want to present a similar approach that uses recursion.\nWe define a recursive function that receives the character array and pointers for start and end as input. The function swaps the characters at the start and end pointers. Then it calls itself with the start pointer incremented by 1 and the end pointer decremented by 1. This way, the function keeps swapping the characters at the start and end pointers until the start pointer is greater than the end pointer. The function returns when the start pointer is greater than the end pointer. This way, we can reverse the string in place.\nIn the end, we convert the character array to a string and return it.\nAlgorithm\n- Convert the string to a character array\nchar\\_array\n. - Call the recursive function\nreverseStringHelper\nwithchar\\_array\n,0\nandchar\\_array.length - 1\nas input. - Convert the character array back to a string and return it.\nRecursive function reverseStringHelper\n:\n- Base case: If\nstart\nis greater thanend\n, return. - Swap the characters at\nstart\nandend\n. - Call the recursive function\nreverseStringHelper\nwithchar\\_array\n,start + 1\nandend - 1\nas input.\nReverse String Javascript, Python and Java Solutions - Using In Place Reversal with Recursion\nfunction reverseString(string) {\nlet charArray = string.split(\"\");\nreverseStringHelper(charArray, 0, charArray.length - 1);\nreturn charArray.join(\"\");\n}\nfunction reverseStringHelper(charArray, start, end) {\nif (start > end) {\nreturn;\n}\nswap(charArray, start, end);\nreverseStringHelper(charArray, start + 1, end - 1);\n}\nfunction swap(charArray, start, end) {\n// using destructuring assignment to swap the characters\n[charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n}\n1function reverseString(string) {\n2 let charArray = string.split(\"\");\n3 reverseStringHelper(charArray, 0, charArray.length - 1);\n4 return charArray.join(\"\");\n5}\n6\n7function reverseStringHelper(charArray, start, end) {\n8 if (start > end) {\n9 return;\n10 }\n11 swap(charArray, start, end);\n12 reverseStringHelper(charArray, start + 1, end - 1);\n13}\n14\n15function swap(charArray, start, end) {\n16 // using destructuring assignment to swap the characters\n17 [charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n18}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n)\n. Both pointers traverse the string from opposite ends until they merge. We swap two characters in the main body of recursion, which is a constant time operation. So the overall time complexity isO(n)\n. -\nSpace Complexity:\nO(n)\n. We are using a character array to store the characters of the string. On top of that, we are using the call stack to store the function calls. We maken/2\nfunction calls, which isO(n)\n. So, the space complexity isO(n)\n.\nPractice the Reverse String Problem With Our AI Interviewer\nPractice the Reverse String Problem With Our AI Interviewer\nReverse String Frequently Asked Questions (FAQ)\nReverse String Frequently Asked Questions (FAQ)\nWhy can’t you just use reverse() when reversing a string?\nIn real life, you probably would. However, in an interview, you’ll want to demonstrate to your interviewer that you understand what programming languages do under the hood when they call a function like reverse(). That’s why it’s important to be able to implement it from scratch. It’s also an opportunity to demonstrate to your interviewer that you know if strings are mutable or immutable in your language of choice.\nHow do you reverse a string in place?\nTo reverse a string in place means to modify the original string directly without using any additional memory. There are two ways to do this: the first is iterative, and the second uses recursion. Note that the recursive approach isn’t as efficient and overcomplicates the problem needlessly.\nWith the iterative approach, you’d use two pointers to swap characters symmetrically from both ends of the string: the first with the last, the 2nd with the 2nd to last, and so on. We’d repeat this approach until the two pointers met each other. Depending on whether strings are mutable or not in your programming language of choice, you might have to convert the string to a character array before doing the swaps.\nWith the recursive approach, we convert our string to a character array, and then pass it into the recursive function, along with pointers for the start and end. The function swaps the characters at the start and end pointers. Then it calls itself with the start pointer incremented by 1 and the end pointer decremented by 1. The function returns when the start pointer is greater than the end pointer.\nWhat’s the difference between reversing a string and reversing an array of integers?\nHow different these are depends on whether strings are mutable or not in your language of choice.\nWhen reversing a string, you are dealing with a sequence of characters. Strings are typically treated as immutable in many programming languages, including Python, which means you cannot modify them directly. To reverse a string in place, you need to convert it into a mutable data structure (like an array) first, perform the reversal, and then convert it back to a string.\nOn the other hand, when reversing an array of integers, you are working with a collection of numeric values. Arrays of integers are mutable data structures in most programming languages, allowing direct modification. You can reverse the order of elements in an array by swapping elements at symmetric positions, without needing to convert the array into a different data type.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/reverse-string",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Longest Substring Without Repeating Characters (Solved)",
      "content": "How to Solve Longest Substring Without Repeating Characters\nWhat is the Longest Substring Without Repeating Characters Problem?\nWhat is the Longest Substring Without Repeating Characters Problem?\nThe Longest Substring Without Repeating Characters problem involves searching through a given string and identifying the longest sequence of non-repeating characters. This problem can be solved with a brute force search approach, or with a more advanced and efficient sliding window technique.\nLongest Non-repeating Substring Example Inputs and Outputs\nLongest Non-repeating Substring Example Inputs and Outputs\nGiven a string s\n, find the length of the longest substring without repeating characters.\nExample 1\nInput: \"abcabcbb\"\nOutput: 3\nThe longest substrings without repeating characters are abc\n, bca\n, and cab\n, all with length 3.\nExample 2\nInput: \"bbbbb\"\nOutput: 1\nThe longest substring without repeating characters is b\n, with length 1.\nExample 3\nInput: = \"pwwkew\"\nOutput: 3\nThe longest substring without repeating characters is wke\n, with length 3.\nConstraints\n- 0 <= s.length <= 1000000\n- The character set for\ns\nis ASCII.\nSolution to the Longest Substring Without Repeating Characters Interview Question\nSolution to the Longest Substring Without Repeating Characters Interview Question\nThere are three ways to approach the longest substring problem. Before we talk about them in detail, note that when asked to explore a \"subsection\" of an array or string, you should always confirm your understanding of the search space. Remember that a substring is a contiguous slice of characters taken from a string (similar to a subarray), as opposed to a subsequence which can skip characters, or a permutation which can be out of order. With this knowledge, we can rule out any need for backtracking, and instead start to think more greedy.\nAnother important thing to confirm with your interviewer when handling strings is the character set, as this will help us define the space complexity of the problem. A safe assumption is that our solution will implement ASCII (128 characters) or Extended ASCII (256 characters).\nNow, here are the three approaches you can take.\n1. Brute Force\nWith the search space defined, a naïve approach becomes fairly straightforward: generate each substring from the input string, check if there are any repeating characters for each, and use a standard-library function (such as math.max()\nin Java) to record the max length found for valid substrings.\nWe can separate this work into two subproblems. First, we need a helper function to determine if a given string has any repeating characters - this can be done by scanning a given range and counting character occurrences with a hash map.\nNext, to generate each substring from the input string s\n, we can enumerate all substrings with two nested loops. Given i\nand j\nas all possible start and end indices for a substring of s\n, we have 0 <= i <= j <= n\n, where n\nis the length of the input string.\nLongest Substring Without Repeating Characters Python and JavaScript Solutions - Brute Force\nclass Solution:\ndef is\\_unique\\_within\\_range(start: int, end: int) -> bool:\nchars = set()\nfor i in range(start, end + 1):\nchar = s[i]\nif char in chars:\nreturn False\nchars.add(char)\nreturn True\ndef length\\_of\\_longest\\_substring(s: str) -> int:\nresult = 0\nfor i in range(len(s)):\nfor j in range(i, len(s)):\nif (self.is\\_unique\\_within\\_range(i, j)):\nresult = max(result, j - i + 1)\nreturn result\n1class Solution:\n2 def is\\_unique\\_within\\_range(start: int, end: int) -> bool:\n3 chars = set()\n4 for i in range(start, end + 1):\n5 char = s[i]\n6 if char in chars:\n7 return False\n8 chars.add(char)\n9 return True\n10 def length\\_of\\_longest\\_substring(s: str) -> int:\n11 result = 0\n12 for i in range(len(s)):\n13 for j in range(i, len(s)):\n14 if (self.is\\_unique\\_within\\_range(i, j)):\n15 result = max(result, j - i + 1)\n16 return result\nTime/Space Complexity Analysis\n- Time Complexity: O(n³). Two nested loops is O(n²), and the helper function makes an additional nested loop.\n- Space Complexity: O(min(n, m)), where\nn\nis the length of the strings\nandm\nis the size of the character set.\n2. Sliding Window\nTo optimize the naïve approach, let's see where duplicate work is being performed.\nConsider this example: if the string \"abc\" has no repeating characters, and we append a new character \"d\" at the end to make the string \"abcd\", do we need to re-check if \"abc\" has repeating characters? Our two nested loops are doing just that - repeatedly checking sections of the string that have already been evaluated - and our helper function is re-checking for repeat characters without using information from overlapping checks.\nInstead of naively enumerating each substring, how can we intelligently skip substrings that we already know to be invalid? Let's use the string “kadbakf” as an example.\nkadb\nis a valid candidate for longest substring since it has no repeating characters.\nIf j\nmoves to index 4 though, the new substring kadba\nwould be invalid. So, we can deduce that with i\nat position 0, all subsequent iterations of j\nwill be invalid, since they will contain this invalid substring. We can confidently stop iterating j\nat this point.\nSo, let's iterate i\nand begin considering new candidate substrings, since we've already seen the longest possible substring with i\nat index 0. But adba\nis also invalid, so any iteration on j\nwill remain invalid.\nLet's increment i\nuntil the substring in the range i\nto j\nis valid again. Here, once i\nis at index 2, there is only one a\ncharacter in the substring, so we can again try to increase the length by iterating j\nanew.\nThis technique is known as a sliding window, and it is approach applicable to a wide variety of leetcode / algorithms problems. The window represents a candidate substring bounded by a start and an end pointer, which expands and contracts based on what we're looking for. Sliding windows are commonly used when searching for an optimal range in an iterable data structure like a string or an array. This is because the algorithm will first search for a possible answer before then expanding (or contracting, whichever is the priority) to try to optimize. For example, if we were searching for the shortest substring that contains the letters a\nand b\n, we would only contract our window if those letters existed in the current substring (valid condition), otherwise we're adding characters until the condition is met.\nConversely, when looking for the maximum possible length, as in the problem at hand, we can only expand the window when the current substring is valid (otherwise, we must first arrive at a valid state by removing characters from the left). Looking back at the example above, j\nonly iterates forward while the condition is satisfied - in this case, all characters between i\nand j\nare unique - and i\nonly iterates forward while the condition is not satisfied.\nHaving made this insight on our substring enumeration, we can further improve the way we check for substrings with unique characters. Remember that a sliding window allows us to take advantage of overlapping subproblems - so, instead of re-checking each window for distinct characters, let's track the current character count of the window and evaluate the new state when a single character is added or removed.\nMore formally, if we know that a substring in the range i\nto j\nhas no repeating characters, then when adding the next character at j+1\n, we simply need to check if that character already exists in the previous range. And because we established the character set at the beginning of our solution, this can be determined in constant time using an array of length 128 to represent character occurrence in a substring.\nNote that, although there are still two nested loops in our code, the time complexity of the iteration is now linear, as i\nand j\nwill only iterate over each character once. Unlike our naïve implementation, the two pointers are not dependent on one another, and instead iterate based on the state of the range between them, which can be determined in constant time and space.\nLongest Substring Without Repeating Characters Python and JavaScript Solutions - Sliding Window\nclass Solution:\ndef length\\_of\\_longest\\_substr(s: str) -> int:\n# List representing ASCII characters to track occurences\nchars = [0] \\* 128\nresult = 0\ni = 0\nj = 0\nwhile j < len(s):\nright\\_char = s[j]\nchars[right\\_char] += 1\nwhile chars[right\\_char] > 1:\nleft\\_char = s[i]\nchars[left\\_char] -= 1\ni += 1\nresult = max(result, i - j + 1)\nreturn result\n1class Solution:\n2 def length\\_of\\_longest\\_substr(s: str) -> int:\n3 # List representing ASCII characters to track occurences\n4 chars = [0] \\* 128\n5 result = 0\n6 i = 0\n7 j = 0\n8 while j < len(s):\n9 right\\_char = s[j]\n10 chars[right\\_char] += 1\n11 while chars[right\\_char] > 1:\n12 left\\_char = s[i]\n13 chars[left\\_char] -= 1\n14 i += 1\n15 result = max(result, i - j + 1)\n16 return result\nTime/Space Complexity Analysis\n- Time Complexity: O(n). At worst, the two pointers both perform linear scans of the string, which would be O(2n). This can be interpreted as O(n) in Big-O notation, since constants are ignored when determining order of magnitude.\n- Space Complexity: O(1). Limited to 128 ASCII characters, space is constant.\n3. Sliding Window Optimized\nAs a marginal optimization, we can avoid two passes with our pointers by improving how we cache character occurrences and update our pointers.\nRemember what we determined in the previous approach: once a duplicate character is found in a given window, this candidate substring will remain invalid until one of the dupes is removed. Seeing that we need to arrive at a valid state before we can continue iterating our right pointer, can we improve how we iterate the left pointer? Indeed! Instead of iteratively searching for the next valid position, we can deduce where it would necessarily be: the index directly after the first occurring duplicate's index in the substring. Moving i\nto this position effectively removes the duplicate from the substring.\nTracking character counts in our hash map won't serve us anymore - instead, let's record the last index at which each character was encountered, so the left pointer can be updated in constant time. Thus when the right pointer finds a repeat, we simply update the left pointer to the position of the last occuring repeat (plus 1).\nLongest Substring Without Repeating Characters Python and JavaScript Solutions - Sliding Window Optimized\nclass Solution:\ndef length\\_of\\_longest\\_substr(s: str) -> int:\nresult = 0\nhash\\_map = {}\ni = 0\nj = 0\nwhile j < len(s):\nchar = s[j]\n# If a duplicate is found, update i to our stored next valid position\nif char in hash\\_map:\ni = max(hash\\_map[char], i)\nresult = max(result, j - i + 1)\n# Store the next index for this character, as this will be the next valid position to de-duplicate\nhash\\_map[char] = j + 1\nreturn result\n1class Solution:\n2 def length\\_of\\_longest\\_substr(s: str) -> int:\n3 result = 0\n4 hash\\_map = {}\n5 i = 0\n6 j = 0\n7 while j < len(s):\n8 char = s[j]\n9 # If a duplicate is found, update i to our stored next valid position\n10 if char in hash\\_map:\n11 i = max(hash\\_map[char], i)\n12 result = max(result, j - i + 1)\n13 # Store the next index for this character, as this will be the next valid position to de-duplicate\n14 hash\\_map[char] = j + 1\n15 return result\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(1)\nPractice the Longest Substring Without Repeating Characters Problem With Our AI Interviewer\nPractice the Longest Substring Without Repeating Characters Problem With Our AI Interviewer\nLongest Substring Without Repeating Characters Frequently Asked Questions (FAQ)\nLongest Substring Without Repeating Characters Frequently Asked Questions (FAQ)\nHow do you find the longest substring without repeating characters?\nThere are three ways to solve this problem. First, there’s the brute force approach, where you generate each substring from the input string, check if there are any repeating characters for each, and record the max length found for valid substrings. This approach runs in O(n³)\ntime. A more efficient way to do it is with a sliding window approach, where you look at substrings bounded by a start and an end pointer, which expand and contract. To start, you create a new set where you track what characters you’ve seen. If the next character is not already in the set, you add it to the set and expand your window by moving the end pointer to the right. If the next character is already in the set, you remove the character at the beginning of the window from the set and contract the window by moving the start pointer to the right. At each step, you calculate the length of the current window and compare it to the previous maximum length. This approach runs in O(n)\ntime. Finally, there’s the optimized sliding window approach, where you can avoid two passes by improving on how you cache character occurrences and update your pointers. This approach also runs in linear time.\nWhat’s the most efficient way to find the longest substring without repeating characters?\nThe most efficient solution to this problem is an optimized sliding window approach.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/longest-substring-without-repeating-characters",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Longest Common Subsequence (Problem & Solution)",
      "content": "Longest Common Subsequence (With Solutions in Python, Java & JavaScript)\nWhat is the Longest Common Subsequence Problem?\nWhat is the Longest Common Subsequence Problem?\nThe Longest Common Subsequence (LCS) problem is a common technical interview question where you're asked to find the longest sequence of characters present in two strings. Variations of this problem are commonly found in real-world applications such as bioinformatics, natural language processing, and text comparison. This problem can be solved using dynamic programming techniques, which involve breaking down the problem into smaller subproblems and then solving them iteratively.\nExamples of the Longest Common Subsequence Problem\nExamples of the Longest Common Subsequence Problem\nGiven two strings, return the longest common subsequence between the two strings. A subsequence of a string is a string that contains characters from the original string in the same order as the original, but may have characters deleted.\nExample 1\nInput: s1 = \"abccba\", s2 = \"abddba\" Output: \"abba\"\nExample 2\nInput: s1 = \"zfadeg\", s2 = \"cdfsdg\" Output: \"fdg\"\nExample 3\nInput: s1 = \"abd\", s2 = \"badc\" Output: \"ad\" (or \"bd\")\nConstraints\n-\n1 <= s1.length, s2.length <= 1000\n-\nThere may be multiple valid answers, but they'll all have the same length.\nHow to Solve the Longest Common Subsequence Problem\nHow to Solve the Longest Common Subsequence Problem\nTo solve the longest common subsequence problem (also known as longest common substring), it is helpful to first consider a couple of important properties of the lcs\nfunction. Firstly, if two strings s1, s2\nend in the same substring then their lcs\nis the lcs\nof the two strings without their common substring concatenated with said substring. For example, lcs(\"abccba\", \"abddba\") = lcs(\"abcc\", \"abdd\") + \"ba\"\n, since the length of the longest common subsequence between the two input strings is at minimum the length of the common consecutive string they share.\nSecondly, if two strings do not have a common ending substring, the lcs\nof the two strings will be the same as the lcs\nresulting from removing the ending of one of the strings. Put another way, lcs(s1, s2)\nis one of two recursive possibilities:\nlcs(s1[:-1], s2)\nlcs(s1, s2[:-1])\nwhere s1[:-1]\nis a string with the last character removed. For example, suppose s1=\"abcd\", s2=\"zdef\"\n, then lcs(s1, s2) = lcs(\"abcd\", \"zde\") = lcs(\"abcd\", \"zd\") = \"d\"\n. But note in this example that lcs(\"abcd\", \"zde\")\nis clearly not equal to lcs(\"abc\", \"zde\")\n.\nRecursive Approach\nLeveraging the above two properties, we can use a recursive solution to approach a longest common subsequence algorithm and solve this using backtracking.\nStarting at the end of the two strings:\n- If the characters at the end are the same, we can return\nlcs(s1[:-1], s2[:-1]) + s1[-1]\n. - If the characters are not the same, we must compute both\nlcs(s1[:-1], s2)\nandlcs(s1, s2[:-1])\n, and return the longer given sequence.\ndef solution(s1, s2):\nif len(s1) is 0 or len(s2) is 0:\nreturn ''\nelif s1[-1] == s2[-1]:\nreturn solution(s1[:-1], s2[:-1]) + s1[-1]\nelse:\nsub1 = solution(s1[:-1], s2)\nsub2 = solution(s1, s2[:-1])\nreturn sub1 if len(sub1) > len(sub2) else sub2\n1def solution(s1, s2):\n2 if len(s1) is 0 or len(s2) is 0:\n3 return ''\n4 elif s1[-1] == s2[-1]:\n5 return solution(s1[:-1], s2[:-1]) + s1[-1]\n6 else:\n7 sub1 = solution(s1[:-1], s2)\n8 sub2 = solution(s1, s2[:-1])\n9 return sub1 if len(sub1) > len(sub2) else sub2\nTime/Space Complexity\nLet m\nand n\nbe the length of the two strings.\n- Time Complexity:\nO(2^m \\* 2^n)\nin the worst case. This algorithm computes all possible subsequences for both strings, resulting in time complexity of2^(len(s))\nfor a string, but it also computes all possible subsequences per subsequence of the other string, hence the product. - Space Complexity:\nO(max(m,n))\n. The space complexity is due to the height of the recursion call stack being the maximum length between the two strings.\nRecursive Solution With Memoization\nWhen implementing a recursive algorithm, one optimization to always look out for is to address repeated work. For example, if we employ the above algorithm on a string that includes the substring \"abc\" in three different locations we will effectively be calling lcs(abc)\nthree different times within the recursion tree. How can we avoid this and improve the time complexity? By storing the lcs\ncomputations in a lookup table, otherwise known as memoization.\ndef solution(s1, s2):\nreturn solution\\_recur(s1, s2, {})\ndef solution\\_recur(s1, s2, solutions):\n# use a frozenset here because (1) frozenset is hashable, so can be\n# used for a key, and (2) order of the inputs does not matter for this function.\ninputs = frozenset([s1, s2])\nsolved = solutions.get(inputs, None)\nif solved is not None:\nreturn solved\nif len(s1) == 0 or len(s2) == 0:\nsolved = ''\nelif s1[-1] == s2[-1]:\nsolved = solution\\_recur(s1[:-1], s2[:-1], solutions) + s1[-1]\nelse:\nsub1 = solution\\_recur(s1[:-1], s2, solutions)\nsub2 = solution\\_recur(s1, s2[:-1], solutions)\nsolved = sub1 if len(sub1) > len(sub2) else sub2\nsolutions[inputs] = solved\nreturn solved\n1def solution(s1, s2):\n2 return solution\\_recur(s1, s2, {})\n3def solution\\_recur(s1, s2, solutions):\n4 # use a frozenset here because (1) frozenset is hashable, so can be\n5 # used for a key, and (2) order of the inputs does not matter for this function.\n6 inputs = frozenset([s1, s2])\n7 solved = solutions.get(inputs, None)\n8 if solved is not None:\n9 return solved\n10 if len(s1) == 0 or len(s2) == 0:\n11 solved = ''\n12 elif s1[-1] == s2[-1]:\n13 solved = solution\\_recur(s1[:-1], s2[:-1], solutions) + s1[-1]\n14 else:\n15 sub1 = solution\\_recur(s1[:-1], s2, solutions)\n16 sub2 = solution\\_recur(s1, s2[:-1], solutions)\n17 solved = sub1 if len(sub1) > len(sub2) else sub2\n18 solutions[inputs] = solved\n19 return solved\nTime/Space Complexity\nDue to how the recursive function is formulated, the lcs\nof (m + 1) \\* (n + 1)\ndifferent input pairs will be computed. Since this solution caches those results, it has:\n- Time Complexity:\nO(m \\* n)\n- Space Complexity:\nO(m \\* n)\nDynamic Programming Approach\nNotice that in the previous approaches, we relied on the fact that the problem being solved had very similar subproblems which were used to ultimately solve the original problem. Of course, these types of situations can be tackled using memoization as seen above. However, an even more powerful approach can be used to tackle overlapping subproblems: dynamic programming.\nTo solve this using a dynamic programming approach, this solution will construct a table of results, and then trace back through the table from the bottom up to construct the longest subsequence. Letting s1=\"abd\"\nand s2=\"badc\"\n, the initial table would look like:\nNotice that the table has been augmented with a row and column for no characters in a string. The added row and column serve as a base case upon which to fill out the rest of the table.\nThe table can be constructed row by row (or column by column). At each cell the character of the row is compared with the character of the column, and based on the result the following items are stored:\n- The length of the longest subsequence between the two substrings up to and including the characters at the current cell. The value will be one plus the \"previous\" cell's value if the characters match; otherwise it will be the \"previous\" cell's value.\n- The direction of the cell \"prior\" to the current cell which has the largest value. If the characters match, then the \"previous\" cell is up one and to the left one. Otherwise it is whichever cell has the larger value between the cell to the left and the cell above.\nContinuing with the example, to fill in the first row the following would occur:\n- 'a', 'b': unequal; above and to the left are 0; so store 0 with direction of \"both\"\n- 'a', 'a': equal; upper left is 0; so store 1 with direction of \"up-left\"\n- 'a', 'd': unequal; above is 0, but left is 1, so store 1 with direction of \"left\"\n- 'a', 'c': unequal; above is 0, but left is 1, so store 1 with direction of \"left\"\nNext we fill in the second row via:\n- 'b', 'b': equal; upper left is 0, so store 1 with direction of \"up-left\"\n- 'b', 'a': unequal; above and to the left are both 1; so store 1 with direction of \"both\"\n- 'b', 'd': unequal; above and to the left are both 1; so store 1 with direction of \"both\"\n- 'b', 'c': unequal; above and to the left are both 1; so store 1 with direction of \"both\"\nFinally, the last row:\n- 'd', 'b': unequal; above and to the left are 0, so store 0 with direction of \"both\"\n- 'd', 'a': unequal; above is 1 while to the left is 0; so store 1 with direction of \"up\"\n- 'd', 'd': equal; upper left is 1; so store 2 with direction \"up-left\"\n- 'd', 'c': unequal; above is 1, while to the left is 2; so store 2 with direction 'left'\nNow that the table is completed we can trace back through the table to construct the lcs\n. To do so, we start in the bottom right corner of the table, which will have the largest number. At each cell, check the direction. If the direction is \"up-left\", then the character at the current cell is part of the lcs\n, so prepend it to the result (since the traceback goes through the table in reverse). Whether the character is part of the lcs\nor not, follow the direction encoded in the cell to navigate the table until the value of the cell is zero.\nUsing the example above, the traceback would proceed as follows:\n- Start in the bottom right corner, where the value stored is 2. This indicates any\nlcs\nhas a length of 2. As the direction isleft\n, move to the cell(d,d)\n- In the cell\n(d,d)\n, the direction isup-left\n, so'd'\nis the last character in anlcs\n. Prepend'd'\nto the result, which is then just\"d\"\nso far, and move to the cell(b,a)\n. - In the cell\n(b,a)\n, the direction isboth\n, and the algorithm could choose to go either to theleft\norup\n(with different resulting strings). For this example, the canonical direction isup\n, so navigate to the cell(a,a)\n. - In cell\n(a,a)\n, the direction isup-left\n, so'a'\nis the penultimate character in anlcs\n. Prepend'a'\nto the result to end up with a string of\"ad\"\nso far, and move to the cell('',b)\n. - In the cell\n('',b)\n, the value stored is 0, so the algorithm stops, and thelcs\nis\"ad\"\n.\nNote 1: In step 3, had the algorithm gone to the left\ninstead of up\n, the lcs\nwould have been \"bd\"\ninstead of \"ad\"\n.\nNote 2: It is possible to store the actual subsequences inside each cell, but such a solution would need to include all subsequences that could be arrived at in each cell, which would add to the space complexity.\nclass SolutionNode:\ndef \\_\\_init\\_\\_(self, direction=\"sink\", value=0):\n# valid directions are: sink, up, left, up-left, or both\nself.direction = direction\nself.value = value\ndef solution(s1, s2):\nif len(s1) == 0 or len(s2) == 0:\nreturn ''\n# building the table with the extra row and column\nlcs = [[SolutionNode() for x in range(len(s2)+1)]\nfor y in range(len(s1)+1)]\n# skip first row; it is supposed to be all zeros anyway\nfor i, row in enumerate(lcs[1:], 1):\n# skip first row; it is supposed to be all zeros anyway\nfor j, cell in enumerate(row[1:], 1):\nif s1[i-1] == s2[j-1]:\ncell.value = lcs[i-1][j-1].value + 1\ncell.direction = 'up-left'\nelif lcs[i][j-1].value == lcs[i-1][j].value:\ncell.direction = 'both'\ncell.value = lcs[i][j-1].value\nelif lcs[i][j-1].value > lcs[i-1][j].value:\ncell.direction = 'left'\ncell.value = lcs[i][j-1].value\nelse:\ncell.direction = 'up'\ncell.value = lcs[i-1][j].value\n# The table is built; now to traceback\ni = len(s1)\nj = len(s2)\nnode = lcs[i][j]\nval = node.value\nresult = ''\nwhile val > 0:\n# Could instead go 'left' on 'both'\nif node.direction == 'up' or node.direction == 'both':\ni -= 1\nelif node.direction == 'left':\nj -= 1\nelse:\ni -= 1\nj -= 1\n# need to prepend since this constructs the lcs in reverse\nresult = s1[i] + result\nnode = lcs[i][j]\nval = node.value\nreturn result\n1class SolutionNode:\n2 def \\_\\_init\\_\\_(self, direction=\"sink\", value=0):\n3 # valid directions are: sink, up, left, up-left, or both\n4 self.direction = direction\n5 self.value = value\n6def solution(s1, s2):\n7 if len(s1) == 0 or len(s2) == 0:\n8 return ''\n9 # building the table with the extra row and column\n10 lcs = [[SolutionNode() for x in range(len(s2)+1)]\n11 for y in range(len(s1)+1)]\n12 # skip first row; it is supposed to be all zeros anyway\n13 for i, row in enumerate(lcs[1:], 1):\n14 # skip first row; it is supposed to be all zeros anyway\n15 for j, cell in enumerate(row[1:], 1):\n16 if s1[i-1] == s2[j-1]:\n17 cell.value = lcs[i-1][j-1].value + 1\n18 cell.direction = 'up-left'\n19 elif lcs[i][j-1].value == lcs[i-1][j].value:\n20 cell.direction = 'both'\n21 cell.value = lcs[i][j-1].value\n22 elif lcs[i][j-1].value > lcs[i-1][j].value:\n23 cell.direction = 'left'\n24 cell.value = lcs[i][j-1].value\n25 else:\n26 cell.direction = 'up'\n27 cell.value = lcs[i-1][j].value\n28 # The table is built; now to traceback\n29 i = len(s1)\n30 j = len(s2)\n31 node = lcs[i][j]\n32 val = node.value\n33 result = ''\n34 while val > 0:\n35 # Could instead go 'left' on 'both'\n36 if node.direction == 'up' or node.direction == 'both':\n37 i -= 1\n38 elif node.direction == 'left':\n39 j -= 1\n40 else:\n41 i -= 1\n42 j -= 1\n43 # need to prepend since this constructs the lcs in reverse\n44 result = s1[i] + result\n45 node = lcs[i][j]\n46 val = node.value\n47 return result\nTime/Space Complexity\n- Time Complexity:\nO(m \\* n)\n. - Space Complexity:\nO(m \\* n)\n.\nAdditional Reading\nThe final solution can be further improved. One such way is the Hunt-Szymanski Algorithm.\nPractice the Longest Common Subsequence Problem With Our AI Interviewer\nPractice the Longest Common Subsequence Problem With Our AI Interviewer\nLongest Common Subsequence Frequently Asked Questions (FAQ)\nLongest Common Subsequence Frequently Asked Questions (FAQ)\nWhich approach to solving longest common subsequence is the most efficient?\nThe optimal time complexity of the longest common subsequence (LCS) algorithm is O(m \\* n)\n, where m\nand n\nare the lengths of the input strings. This is typically implemented using dynamic programming, where we create a matrix of size (m+1) x (n+1) to store the prefix lengths and fill the matrix iteratively, requiring examining each cell, which takes constant time. Another way to achieve this time complexity is using recursion with memoization, where we ensure no duplicate computations are made when visiting each node in the resursive tree. As a result, the overall time complexity is determined by the number of cells in the matrix or nodes in the recursive tree.\nWhat is the brute force approach to solving the longest common sequence problem?\nThe longest common subsequence (LCS) algorithm can be solved naively with recursion - the algorithm exhaustively explores all possible combinations of characters in both strings and returns the longest length. Without cacheing, this results in a large number of redundant computations, which leads to an exponential time complexity - O(2^(m + n))\n, where m and n are the lengths of the input strings. This inefficiency makes the brute force recursive approach impractical for larger input sizes.\nCan there be more than one longest common subsequence?\nNo, by definition, there can only be one longest common subsequence (LCS) between two strings. The LCS is defined as the longest subsequence that is common to both strings, meaning it appears in both strings in the same order but not necessarily consecutively.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/longest-common-subsequence",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Container With Most Water (Interview Solution)",
      "content": "What Is The Container With Most Water Problem?\nWhat Is The Container With Most Water Problem?\nContainer With the Most Water is a coding problem that involves finding the largest possible area that can be formed by two vertical lines on a graph, bound by the height of the shorter line. This problem can be solved using a two-pointer approach, which involves traversing the array from both sides and keeping track of the maximum area found so far.\nAn Example of the Container With the Most Water Problem\nAn Example of the Container With the Most Water Problem\nGiven n\nnon-negative integers a0, a1, a2, ..., a[n-1]\n, where each represents a point at coordinate (i, a[i])\n, n\nvertical lines are drawn such that the two endpoints of the line i\nis at (i, 0)\nand (i, ai)\n. Find two lines that, together with the x-axis, form a container that can hold the most amount of water possible.\nExample\n- Input:\nheights\n= [3, 9, 4, 8, 2, 6, 1] - Output: 24\nConstraints\n- number of integers n: [2, 10,000]\n- each integer a[i]: [0, 1,000]\nTwo Ways to Solve the Container With the Most Water Problem\nTwo Ways to Solve the Container With the Most Water Problem\nThere are two ways to approach the Container With the Most Water technical interview question: brute force or two pointers.\nApproach 1: Brute Force\nIn the context of this problem, the size of the 2D container is determined by multiplying its width by its height. The brute force approach is to use nested for loops to calculate all possible containers to find the largest one.\nTo accomplish this, we can iterate over the heights with an outer loop, and form a container with every other height to its right using an inner loop. Each subarray that we generate this way is a possible container - the container's size will be the lower of the two heights, multiplied by the distance between the heights.\nWe can track the max container size as we go and return the max container size at the end of our iteration.\nContainer With the Most Water Python, Javascript and Java Solution - Brute Force\ndef max\\_water(heights: list[int]) -> int:\nln = len(heights)\nmax\\_area = 0\nfor left\\_index in range(ln):\nleft\\_height = heights[left\\_index]\nfor right\\_index in range(left\\_index + 1, ln):\nright\\_height = heights[right\\_index]\nwidth = right\\_index - left\\_index\nheight = min(left\\_height, right\\_height)\narea = width \\* height\nmax\\_area = max(area, max\\_area)\nreturn max\\_area\n1def max\\_water(heights: list[int]) -> int:\n2 ln = len(heights)\n3 max\\_area = 0\n4 for left\\_index in range(ln):\n5 left\\_height = heights[left\\_index]\n6 for right\\_index in range(left\\_index + 1, ln):\n7 right\\_height = heights[right\\_index]\n8 width = right\\_index - left\\_index\n9 height = min(left\\_height, right\\_height)\n10 area = width \\* height\n11 max\\_area = max(area, max\\_area)\n12 return max\\_area\nTime / Space Complexity\n- Time complexity:\nO(n²)\n- Space complexity:\nO(1)\n. No need for extra space, since we’re just iterating over the matrix.\nThe nested loops produce O(n²)\ntime complexity.\nApproach 2 (Optimal): Two Pointers\nAlthough the brute force approach does not repeat any calculations, it ignores useful information that can help eliminate unnecessary calculations. For example, if a container has sides a[i]\nand a[j]\nsuch that a[i] < a[j]\n, all containers with sides a[i]\nto a[i+1], ... a[j-1]\nwill have a maximum height of a[i]\nwith a smaller width than j - i\n, producing less area than the original container. Thus, these possibilities do not need to be considered when we're looking for maximum area.\nInstead of trying every combination, we start the 2 pointers at opposite ends (indexes 0\nand n-1\n) to represent the sides of the container. After computing the area using the lower height and distance between the pointers, the options are to increment the left pointer or decrement the right pointer.\nBecause we want to maximize the water contained, move the pointer with the lower height toward the other pointer. If the heights are equal, we can update either pointer because any potential increase in the next height is limited by one of the equal existing heights. The process is repeated until the pointers meet.\nContainer With the Most Water Python, JavaScript and Java Solution - Two Pointers\ndef max\\_water(heights):\nleft\\_index = 0\nright\\_index = len(heights) - 1\nmax\\_area = 0\nwhile left\\_index < right\\_index:\nwidth = right\\_index - left\\_index\nleft\\_height = heights[left\\_index]\nright\\_height = heights[right\\_index]\nmin\\_height = min(left\\_height, right\\_height)\narea = width \\* min\\_height\nmax\\_area = max(area, max\\_area)\nif left\\_height <= right\\_height:\nleft\\_index += 1\nelse:\nright\\_index -= 1\nreturn max\\_area\n1def max\\_water(heights):\n2 left\\_index = 0\n3 right\\_index = len(heights) - 1\n4 max\\_area = 0\n5 while left\\_index < right\\_index:\n6 width = right\\_index - left\\_index\n7 left\\_height = heights[left\\_index]\n8 right\\_height = heights[right\\_index]\n9 min\\_height = min(left\\_height, right\\_height)\n10 area = width \\* min\\_height\n11 max\\_area = max(area, max\\_area)\n12 if left\\_height <= right\\_height:\n13 left\\_index += 1\n14 else:\n15 right\\_index -= 1\n16 return max\\_area\n17\nTime / Space Complexity\n- Time complexity:\nO(n)\n- Space complexity:\nO(1)\nBecause the left or right pointer is moved toward the other in each iteration until they meet, the list of integers is traversed once.\nPractice the Container With the Most Water Problem With Our AI Interviewer\nPractice the Container With the Most Water Problem With Our AI Interviewer\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/container-with-most-water",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to Reverse a Linked List (Python, Java + more)",
      "content": "How to Solve Reverse a Linked List\nWhat is the Reverse Linked List Problem?\nWhat is the Reverse Linked List Problem?\nThe Reverse Linked List problem involves reversing the order of elements in a linked list, a data structure where each node is connected to the subsequent node with a pointer. The goal of this problem is to traverse the linked list while reversing the order of the pointers that link the nodes together.\nReverse Linked List Examples\nReverse Linked List Examples\nGiven the head of a linked list, reverse the list and return the new head.\nExample 1\nInput: [1,2,3,4,5]\nOutput: [5,4,3,2,1]\nExample 2\nInput: [1,2]\nOutput: [2,1]\nExample 3\nInput: [1]\nOutput: [1]\nConstraints\n- The number of nodes in the list is in the range [0, 5000].\n- -5000 <= Node.value <= 5000\nSolution to the Reverse a Linked List Interview Question\nSolution to the Reverse a Linked List Interview Question\nBefore we can reverse a linked list, let’s start our approach with a concrete understanding of how a singly linked list works. After all, this interview question is an opportunity to demonstrate your familiarity with the data structure. Unlike an array, a linked list is a recursive data structure - each node points to another node - which means we don't have random access to its members. Instead, for a singly linked list we're given a head node with a next property that points to the subsequent node in the list. For a doubly linked list, we would also have a prev\nproperty that points to the previous node on the list. Here's an example of a linked list with two listnodes:\nclass Node:\ndef \\_init\\_(self, value=None):\nself.value = value\nself.next = None\nn1 = Node(1)\nn2 = Node(2)\nn1.next = n2\nIn this original linked list, the first node (n1\n) points to the second node (n2\n) with the next\nproperty.\nIf this list were to be reversed, its clear that n2\nwould point to n1\n. But what would n1\npoint to? Recall that while n2\ndoes not have a child because it is at the end of the list, the node's next\nproperty still exists - it simply points to null\n. And while there is no node pointing to n1\n, we can imagine that its parent is null\n. So n1\nwould point to null\n.\nWe can imagine a null\nnode at the head and the tail of the list.\nAt minimum, reversing a given linked list will require updating each node's next\npointer to reference its parent. Since we'll need to visit each node at least once, our solution space is limited to a linear traversal.\nLet's explore how we can update each linked list node in-place with a linear traversal. A linked list can be traversed both recursively and iteratively - in both approaches, we maintain a reference to the current node, its parent, and its child, and re-assign the next\nreference for each node.\n1. Recursive Approach\nSince a linked list is an inherently recursive data structure, it makes sense that we can employ a recursive approach. Let’s consider a post-order recursive traversal to reverse the list. Why \"post-order\"? The key here is to recurse on each subsequent node until the last node is reached, and then update the next\npointers as each execution pops off the call stack.\nEach call to the recursive function reverse\\_list\nis passed in a reference to the current node's child, which adds a new execution frame to the call stack.\nOnce a null\nnode is reached (our base case), we begin the reassignment process. As each context is popped off the stack, we assign the current node's child's next\npointer to the current node, effectively reversing its reference. Then return the reversed list so far.\nWe also set the current node's next\npointer to null\n- this will be overwritten once the subsequent recursive call is resolved, except for the original head which is now the tail and therefore has no next\nnode.\nReverse Linked List Python and JavaScript Recursive Solutions\nclass Solution:\ndef reverse\\_list(curr\\_node: Node) -> Node:\nif not curr\\_node or not curr\\_node.next:\nreturn curr\\_node\nprev = self.reverse\\_list(curr\\_node.next)\ncurr\\_node.next.next = curr\\_node\ncurr\\_node.next = None\nreturn prev\n1class Solution:\n2 def reverse\\_list(curr\\_node: Node) -> Node:\n3 if not curr\\_node or not curr\\_node.next:\n4 return curr\\_node\n5 prev = self.reverse\\_list(curr\\_node.next)\n6 curr\\_node.next.next = curr\\_node\n7 curr\\_node.next = None\n8 return prev\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(n)\nAlthough we are not constructing a new linked list, recursion requires linear space on the call stack to maintain a reference to each execution context.\n2. Iterative Approach\nReversing a linked list with an iterative approach is more space efficient than the recursive solution, and tends to be more easy to grasp. The task of any iterative traversal is managing pointers across iterations.\nFirst, let's set up our state-of-the-world for the head (input) node.\nprev\npoints to null\n(the head has no parent), curr\npoints to the current node (the head), and, if there is indeed a current node, temp\\_next\npoints to the current node's child.\nAt each iteration, we assign the current node's next\npointer to the node at prev\n(reversing the reference). We then iterate forward by pointing prev\nto the current node and curr\nto the original next\nnode.\nWe continue this process until a null\nchild is reached - at which point we can return the most recent prev\nnode which is our new head.\nReverse Linked List Python and JavaScript Solutions - Iterative\nclass Solution:\ndef reverse\\_list(self, node: Node) -> Node:\nprev = None\ncurr = node\nwhile curr:\ntemp\\_next = curr.next\ncurr.next = prev\nprev = curr\ncurr = temp\\_next\nreturn prev\n1class Solution:\n2 def reverse\\_list(self, node: Node) -> Node:\n3 prev = None\n4 curr = node\n5 while curr:\n6 temp\\_next = curr.next\n7 curr.next = prev\n8 prev = curr\n9 curr = temp\\_next\n10 return prev\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(1)\nPractice the Reverse a Linked List Problem With Our AI Interviewer\nPractice the Reverse a Linked List Problem With Our AI Interviewer\nReverse a Linked List Frequently Asked Questions (FAQ)\nReverse a Linked List Frequently Asked Questions (FAQ)\nWhat is a linked list?\nA linked list is a data structure that consists of a sequence of nodes, each of which contains two parts: a data element and a reference to the next node in the sequence. The nodes are linked together, forming a chain. Unlike an array, a linked list is a recursive data structure - each node points to another node - which means we don't have random access to its members. Instead, we're given a head node with a next property that points to the subsequent node in the list.\nWhy do you reverse a linked list?\nSince a singly linked list is a directional data structure, the list nodes can only be accessed in a fixed, linear order. There are a few reasons why a software engineer may need to reverse a linked list.\n- Performance optimization: if performing a search operation on a sorted linked list and you're looking for a value at the end of the list.\n- User experience: when displaying a list of messages, you may want the user to be able to reverse the sort order.\n- Traversal: if we are storing something like browser or operation history in a linked list and we want to traverse backward along the same path.\nWhat is the fastest way to reverse a linked list?\nYou can reverse a linked list with either a recursive or iterative approach. Both approaches run in linear time, O(n)\n. The recursive approach requires constant space, and the iterative approach requires O(n)\nspace.\nHow do you reverse a linked list without using recursion?\nYou can use an iterative approach! Reversing a linked list iteratively is more space efficient than recursion and tends to be more easy to grasp. The task of any iterative traversal is managing pointers across iterations. To do this, you’ll need 3 pointers: prev\n, curr\n, and temp\\_next\n. prev\nstarts out pointing to null (the head has no parent), curr\npoints to the current node (the head), and, if there is indeed a current node, temp\\_next\npoints to the current node's child. At each iteration, we assign the current node's next pointer to the node at prev\n(reversing the reference). We then iterate forward by pointing prev\nto the current node and curr\nto the original next node. We continue this process until a null child is reached - at which point we can return the most recent prev\nnode which is our new head.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/reverse-linked-list",
      "author": "",
      "user_id": ""
    },
    {
      "title": "K Closest Points To Origin (Interview Question and Solution)",
      "content": "How to Solve K Closest Points To Origin\nK Closest Points To Origin Introduction\nK Closest Points To Origin Introduction\nThe K Closest Points To Origin problem involves comparing the distance of points plotted on a graph. This is a common problem in data analysis, most often found in the context of generating nearest neighbor sets. Similar to other k-selection algorithms, this problem can be solved with a variety of sorting techniques and challenges us to use a heap data structure to improve time complexity. Before viewing the problem and solution, below are some short video snippets from real mock interviews to help prepare you for some common pitfalls that interviewees stumble into.\n• Problem\n• Solution\n• Interview Analysis: Snippets from Real Interviews 🔥\n-\nCommon Mistakes: Forgetting Data Structures\nEven if you do a good job otherwise, forgetting what a certain data structure looks like could be grounds for failure. Watch this example to see what a real interviewer thinks when this happens. -\nCommon Mistakes: Syntax Errors\nInterviewees often know more than one programming language. Before you interview, you should familiarize yourself with the language you will be interviewing in, especially if it differs from the one you use at work. -\nCommon Mistakes: Variable Names and Data Types\nVariables and data types are foundational concepts, but experienced engineers still make these simple mistakes. -\nSenior Level Extension Question\nSee what separates a senior engineer from a junior/mid-level. -\nPossible Approach: Checking Distance\nFind out how a senior engineer recommends checking distance in this question. It'll surprise you. -\nOptimization: Size Efficiency\nYou've heard the phrase \"Size isn't everything, it's how you use it.\" That couldn't be more true for this question!\nK Closest Points To Origin Problem\nK Closest Points To Origin Problem\nGiven a list of tuples that represent (X, Y) coordinates on an XY plane and an integer K, return a list of the K-closest points to the origin (0, 0).\nExample Inputs and Outputs\nExample 1\nInput:\npoints = [[5, 5], [3, 3], [4, 4]], k = 2\nOutput:\n[[3, 3], [4, 4]] or [[4, 4], [3, 3]]\nExample 2\nInput:\npoints = [[-1, 4], [5, 3], [-1, -1], [8, -6], [1, 2]], k = 2\nOutput:\n[[-1, -1], [1, 2]] or [[1, 2], [-1, -1]]\nConstraints\nThe number of nodes in the list is in the range [0, 5000]\nK is >= 0 and <= the length of the input list\nK Closest Points To Origin Solutions\nK Closest Points To Origin Solutions\nReading through the problem a few ideas immediately jump out:\n- We need to calculate the distance of each point from the origin (or at a minimum convert the coordinate tuple to a numerical value)\n- Once the distance has been calculated we need to determine the K-closest points\nTo solve this problem we will need to do some basic algebra. We have a right triangle and we need to calculate the length of the hypotenuse, and we can do so using the Pythagorean theorem:\nA^2 + B^2 = C^2\nAs a quick aside, we don't actually need to calculate C\n(the hypotenuse, or distance from origin), as simply calculating A^2 + B^2\nfor each coordinate will allow us to order the points from closest to furthest from origin without actually determining the exact distance.\nNow that we know how to calculate the distances, let's explore different ways to find the k-closest points.\n1. Sorting\nGiven we need to find the K\nclosest points to origin, the naive approach should hopefully become clear relatively quickly. If we calculate the distance for each coordinate pair, we can then sort the coordinates by distance and finally slice the list from 0 to K\nin order to return the K\nclosest points to the origin.\nK Closest Points to Origin Python and JavaScript Solutions - Sorting\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n# Note: Sorting the input list mutates the input\n# -> whether the input should be mutated (as opposed to copied and then sorted)\n# -> can be decided collaboratively with the interviewer\npoints.sort(key=lambda xy\\_tuple: xy\\_tuple[0]\\*\\*2 + xy\\_tuple[1]\\*\\*2)\nreturn points[:k]\n1def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n2 # Note: Sorting the input list mutates the input\n3 # -> whether the input should be mutated (as opposed to copied and then sorted)\n4 # -> can be decided collaboratively with the interviewer\n5 points.sort(key=lambda xy\\_tuple: xy\\_tuple[0]\\*\\*2 + xy\\_tuple[1]\\*\\*2)\n6 return points[:k]\nTime/Space Complexity Analysis\n- Time Complexity:\nO(n \\* log(n))\n- Space Complexity:\nO(k)\n, as we are sorting in place and returning a new list withK\npoints\n2. Using a Heap\nGiven we have found a somewhat-obvious, naive solution that runs in O(n\\*log(n))\ntime, we should start thinking about how we can use different approaches or data structures in order to optimize the time complexity of our algorithm. In order to improve our time complexity we will need to avoid fully sorting the input, and if we aren't sorting the input we will need to repeatedly select the point with the smallest distance from the origin.\nIt is here that alarm bells should start to go off in our head. What data structure can be used to efficiently, repeatedly select the smallest (or largest) item in a collection? And the answer is... a heap!\nTo give a quick refresher, heaps are an ordered (but not fully sorted) data structure often backed by an array. They can be created in linear time and they ensure selection of the smallest or largest element at any given time, but they are not fully in order. Read more about how heaps are constructed and used here.\nBack to our problem, we can iterate over the list, calculate the distance from the origin for each coordinate and convert it to a heap in place. From there, in order to find the K\nclosest points to the origin we will need to pop\nfrom the heap K\ntimes, which is often a method exposed via heap library code in a given language.\nK Closest Points to Origin Python and JavaScript Solutions - Using a Heap\nimport heapq\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n# O(n)\ndistance\\_coordinate\\_tuples = [(x\\*x + y\\*y, [x, y]) for x, y in points]\n# O(n)\nheapq.heapify(distance\\_coordinate\\_tuples)\n# O(k\\*log(n))\nk\\_smallest = heapq.nsmallest(k, distance\\_coordinate\\_tuples)\n# O(k)\nreturn [coordinate for distance, coordinate in k\\_smallest]\n# same as above as a one-liner\ndef kClosest(self, points, k):\nreturn heapq.nsmallest(k, points, key=lambda p: p[0]\\*\\*2 + p[1]\\*\\*2)\n1import heapq\n2def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n3 # O(n)\n4 distance\\_coordinate\\_tuples = [(x\\*x + y\\*y, [x, y]) for x, y in points]\n5 # O(n)\n6 heapq.heapify(distance\\_coordinate\\_tuples)\n7 # O(k\\*log(n))\n8 k\\_smallest = heapq.nsmallest(k, distance\\_coordinate\\_tuples)\n9 # O(k)\n10 return [coordinate for distance, coordinate in k\\_smallest]\n11# same as above as a one-liner\n12def kClosest(self, points, k):\n13 return heapq.nsmallest(k, points, key=lambda p: p[0]\\*\\*2 + p[1]\\*\\*2)\nTime/Space Complexity Analysis\n- Time Complexity:\nO(n) + O(k\\*log(n))\n- Space Complexity:\nO(1)\n(orO(n)\nif you mutate the input)\nPractice the K Closest Points To Origin Problem With Our AI Interviewer\nPractice the K Closest Points To Origin Problem With Our AI Interviewer\nK Closest Points To Origin Analysis\nK Closest Points To Origin Analysis\nCommon Mistakes: Forgetting Data Structures\nOften candidates may have a great understanding of programming and problem solving skills. However if you haven't practised in a while, you may find you have forgotten what some data structures look like or how to fully implement them. In this snippet the interviewer notes that the candidate has a good understanding of algorithms and data structures but struggles with mapping those concepts onto the STL libraries. Noting the fact that the candidate had to look up what a priority queue looked like. In a real interview, this can definitely hinder your chances of passing even though you certainly have the knowledge and capabilities. Practise makes perfect, so ensure you brush up before you interview!\nCommon Mistakes: Syntax Errors\nProspective candidates will often be knowledgeable in more than one programming language. During mock technical interviews, it is important to practise and familiarize yourself with the language you will be interviewing in, especially if it differs from the native language you code in at your current job. In this snippet the the candidate notes that they more comfortable with C++ even though they mainly work with Java on the job. The interviewer points out some syntax errors in the candidate's code, specifically with creating a vector, and suggests a simpler solution. The interviewer speculates that the candidate may be trying to apply Java syntax to their C++ code.\nCommon Mistakes: Variable Names and Data Types\nWhen calculating distance in this question, it is important to use the double data type as opposed to int. This snippet shows the importance of looking out for small mistakes in variable data types and names that can lead to errors when running code.\nSenior Level Extension Question\nMany solutions to the K closest points question do not take into account what would happen if given a large data set of points or a near infinite stream of points. A MapReduce is one solution to this problem. At a mid to senior level there is an expectation that candidates understand how to use a MapReduce. In this example after much deliberation and guidance, the candidate suggests using a MapReduce, but was unsure of the specifics and unable to implement one. The interviewer noted that the candidate's lack of experience with MapReduce could be a concern for a mid-level position, emphasizing the importance of distributed systems in handling large amounts of data. This scenario highlights the practical challenges of scaling algorithms to real-world data and the need for senior-level expertise in handling such issues.\nPossible Approach: Checking Distance\nIn this snippet the interviewer suggests checking if it's the first k instead of checking if the distance is less than the minimum. This is a key tip when tackling similar problems - Often candidates rush into creating a loop and forget to add code to check if you have K.\nOptimization: Size Efficiency\nIn this snippet the candidate suggests optimizing the comparator function by using a map to store distance-to-pair values, rather than recalculating distances each time. The interviewer discuss the potential challenges of working with larger data sets and to explore ways to keep the data size efficient, such as storing only the distance and index of the original point.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/k-closest-points-to-origin",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Kth Smallest Element (Interview Solution)",
      "content": "How to Solve Kth Smallest Element\nWhat is the Kth Smallest Element Problem?\nWhat is the Kth Smallest Element Problem?\nThe Kth Smallest Element in an Array problem that involves searching through an array of integers and finding the k'th smallest element. Although on the surface this task is trivial, the challenge is in applying advanced sorting algorithms and data structures, such as a heap, recursion, and quickselect, and communicating tradeoffs in time complexity.\nKth Smallest Element in an Unsorted Array Examples\nKth Smallest Element in an Unsorted Array Examples\nGiven an integer array nums\nand an integer k\n, return the kth\nsmallest element in the array.\nExample 1\nInput: nums = [1,5,7,6,4,3,2], k = 3 Output: 3\nExample 2\nInput: nums = [1,1,1,2,2,3], k = 3 Output: 1\nExample 3\nInput: nums = [1], k = 1 Output: 1\nConstraints\n- 1 <= nums.length <= 100000\n- -10000 <= nums[i] <= 10000\nSolution to the Kth Smallest Element Interview Question\nSolution to the Kth Smallest Element Interview Question\nThere are three strategies you can use to solve the kth smallest element in an unsorted array problem — Brute Force, Heap, and Quickselect.\n1. Brute Force\nThe naïve approach to solving the problem would be to:\n- sort the array in increasing order and then,\n- pick the kth element of the array\nHowever, sorting the array would take O(n log(n))\nworst-case time complexity here, where n\nis the size of the array.\nDuring the interview, try not to spend more than 5 minutes discussing the brute force solution. The interviewer will be more interested in the optimal solution(s).\nTime/Space Complexity\n- Time Complexity:\nO(n log(n))\n, wheren\nis the number of elements in nums. - Space Complexity:\nO(1)\n, no additional data structure used.\n2. Heap Approach\nBy using the brute force sorting technique, we are unnecessarily sorting the entire array of n\nelements. Since we are interested only in the kth\nelement in sorted order, we could possibly restrict the sorting/re-arrangement to k\nelements, which would limit the sorted array to a length of k\n. The heap data structure helps us to achieve this optimization.\nHeap Approach Steps\n- Create a max heap of size\nk\n. - Insert each element into the heap - with each insert, we “heapify”, which means we re-sort the elements to satisfy the heap property.\n- If the size of the heap exceeds\nk\n, pop the top element of the heap. - After traversing all the elements of the array, return the top element of the heap.\nNote that if we were looking for the kth largest element, we would perform the same above steps with a min-heap.\nReplacing the top element of the heap of size k\ntakes logk\ntime. So in the worst case, it would be done n\ntimes and effectively, the time taken would be O(nlogk)\n.\nKth Smallest Element Python and Java Solutions - Heap\nimport heapq\nclass Solution:\ndef findKthSmallest(self, nums: List[int], k: int) -> int:\n# 1: Create max heap (simulated by negative values)\nmax\\_heap = []\nfor element in nums:\n# 2: Insert each element to the heap\nheappush(max\\_heap, -element)\n# 3: If the size of the heap exceeds k, pop the element at the top\nif len(max\\_heap) > k:\nheappop(max\\_heap)\n# 4: return top element of max heap\nreturn -heappop(max\\_heap)\n1import heapq\n2class Solution:\n3 def findKthSmallest(self, nums: List[int], k: int) -> int:\n4 # 1: Create max heap (simulated by negative values)\n5 max\\_heap = []\n6\n7 for element in nums:\n8\n9 # 2: Insert each element to the heap\n10 heappush(max\\_heap, -element)\n11 # 3: If the size of the heap exceeds k, pop the element at the top\n12 if len(max\\_heap) > k:\n13 heappop(max\\_heap)\n14\n15 # 4: return top element of max heap\n16 return -heappop(max\\_heap)\nTime/Space Complexity\n- Time Complexity:\nO(n log(k))\n, wheren\nis the number of elements in nums andk\nis the heap size. - Space Complexity:\nO(k)\n, for the heap.\n3. Quickselect Approach\nQuickselect algorithm is an algorithm quite similar to quicksort algorithm where you repeatedly partition a given array based on a pivot element, repeating the process until you have a subarray of length of one. Elements less than the pivot are moved to the left, and elements greater than the pivot are moved to the right. After each partition step, the pivot element is at the correct position in the ordered list. Since we are interested in the kth\nelement, we would have derived that when the pivot element index in the array becomes k-1\n. If the pivot index is greater than target index k-1\n, continue partitioning on the left side; if the pivot index is smaller than target index k-1\n, then partition on the right side. In a particular iteration, if the pivot element index becomes k-1\n, we can return the pivot element itself.\nThe average case time complexity of quickselect algorithm is O(n)\n. However, in the worst case, the time complexity is O(n²)\n— this could be the case when you have lot of repeated elements. Make sure to discuss this with the interviewer before moving on to coding!\nKth Smallest Element Python and Java Solutions - Quickselect\nclass Solution:\ndef partition(self, left: int, right: int, nums: list[int]):\n# get random pivot index\npivot\\_index = random.randint(left, right)\npivot\\_value = nums[pivot\\_index]\n# move pivot element to the end\nnums[pivot\\_index], nums[right] = nums[right], nums[pivot\\_index]\n# when we find an element less than pivot\\_value, move it left of pivot\\_index and increment the swap position\ni = left\nfor j in range(left, right):\nif nums[j] < pivot\\_value:\nnums[i], nums[j] = nums[j], nums[i]\ni += 1\n# move pivot to its final place\nnums[right], nums[i] = nums[i], nums[right]\nreturn i\ndef quickselect(self, left: int, right: int, k\\_target\\_index: int, nums: list[int]):\nif left == right:\nreturn nums[left]\n# find the pivot's correct position\npivot\\_index = self.partition(left, right, nums)\n# if the pivot index is equal to our target, we're done\nif k\\_target\\_index == pivot\\_index:\nreturn nums[pivot\\_index]\nelif k\\_target\\_index < pivot\\_index:\nreturn self.quickselect(left, pivot\\_index - 1, k\\_target\\_index, nums)\nelse:\nreturn self.quickselect(pivot\\_index + 1, right, k\\_target\\_index, nums)\ndef findKthSmallest(self, nums: List[int], k: int) -> int:\nn = len(nums)\nreturn self.quickselect(0, n - 1, k - 1, nums)\n1class Solution:\n2 def partition(self, left: int, right: int, nums: list[int]):\n3 # get random pivot index\n4 pivot\\_index = random.randint(left, right)\n5 pivot\\_value = nums[pivot\\_index]\n6 # move pivot element to the end\n7 nums[pivot\\_index], nums[right] = nums[right], nums[pivot\\_index]\n8 # when we find an element less than pivot\\_value, move it left of pivot\\_index and increment the swap position\n9 i = left\n10 for j in range(left, right):\n11 if nums[j] < pivot\\_value:\n12 nums[i], nums[j] = nums[j], nums[i]\n13 i += 1\n14 # move pivot to its final place\n15 nums[right], nums[i] = nums[i], nums[right]\n16 return i\n17\n18 def quickselect(self, left: int, right: int, k\\_target\\_index: int, nums: list[int]):\n19 if left == right:\n20 return nums[left]\n21 # find the pivot's correct position\n22 pivot\\_index = self.partition(left, right, nums)\n23 # if the pivot index is equal to our target, we're done\n24 if k\\_target\\_index == pivot\\_index:\n25 return nums[pivot\\_index]\n26 elif k\\_target\\_index < pivot\\_index:\n27 return self.quickselect(left, pivot\\_index - 1, k\\_target\\_index, nums)\n28 else:\n29 return self.quickselect(pivot\\_index + 1, right, k\\_target\\_index, nums)\n30\n31 def findKthSmallest(self, nums: List[int], k: int) -> int:\n32 n = len(nums)\n33 return self.quickselect(0, n - 1, k - 1, nums)\nTime/Space Complexity\n- Time Complexity:\nO(n)\nin average,O(n²)\nin worst-case. - Space Complexity:\nO(1)\nPractice the Kth Smallest Element Problem With Our AI Interviewer\nPractice the Kth Smallest Element Problem With Our AI Interviewer\nKth Smallest Element Frequently Asked Questions (FAQ)\nKth Smallest Element Frequently Asked Questions (FAQ)\nHow do you find the kth smallest element in an array?\nThere are 3 ways to solve this problem: brute force, using a heap, and using quickselect. The brute force approach would be to sort the array, and then pick the kth element in the array. This approach runs in O(n log(n))\ntime because you have to sort. A more efficient approach is to use a heap. To do this, you would create a max heap of size k and insert each element into the heap. If the size of the heap exceeds k, pop the top element of the heap. Finally, after traversing all the elements of the array, return the top element of the heap. This approach runs in O(nlogk)\ntime. Finally, you could use quickselect. The idea behind quickselect is similar to quicksort, but instead of sorting the entire array, quickselect only focuses on the elements that are needed to find the kth smallest element. The average case time complexity of the quickselect algorithm is O(n)\n, but in the worst case the time complexity is O(n²)\n- this could be the case when you have a lot of repeated elements.\nWhat's the most efficient way to find the kth smallest element in an array?\nIt depends. Using a heap will run in O(nlogk)\ntime, and using quickselect will run in O(n)\non average but could go up to O(n²)\nin the worst case.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/kth-smallest-element",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Reverse Words in a String (Python)",
      "content": "What is the Reverse Words in a String Problem?\nWhat is the Reverse Words in a String Problem?\nReverse Words in a String is a programming problem that requires you to take a string of words and return a new string with the order of the words reversed. This problem invites us to use native string and array methods, by looping over the input string in reverse and building a new string to return, and can even be done in-place using languages that permit string mutation.\nAn Example of the Reverse Words in a String Problem\nAn Example of the Reverse Words in a String Problem\nGiven an input string s\n, reverse the order of the words without reversing the words themselves.\nNote that the input string s\nmay contain multiple spaces between any given two words, as well as leading or trailing spaces; however, the return sentence should only have a single space between all words and should not have any leading or trailing space.\nExample 1 Input: s = “This sentence is forwards” Output: “forwards is sentence This”\nInput: s = “ a blue whale rhino Boston arepa heaven “ Output: s = “heaven arepa Boston rhino whale blue a“\nConstraints\n- The string will only contain upper-case and lower-case letters (no punctuation)\n1 <= s.length <= 10,000\nSolutions to the Reverse Words in a String Interview Question\nSolutions to the Reverse Words in a String Interview Question\nThere are two methods for reversing words in a string. One method is splitting on spaces, reversing the list and joining. Alternatively, you can reverse the string in place.\nApproach 1: Split on Spaces, Reverse the List and Join\nThis specific problem can be tackled in a manner similar to how we'd approach it if we were solving manually (remember, in an interview setting you always want to communicate your strategy, especially for multi-step solutions like this):\nIdentify all the individual words at the beginning and end of the string, and then trim/eliminate the unneeded space. Reverse the order of the words and build the string back up to form the result.\nDiving into the code, most modern programming languages provide a standard library method to split a string on a given character, in this case ” “\n.\nReverse Words in a String Python and Ruby Solutions - Split on Spaces, Reverse the List and Join\ns = “ this is a string “\nwords = s.split(“ “)\nprint(words) # ['', 'this', 'is', '', 'a', 'string', '', '']\n1s = “ this is a string “\n2words = s.split(“ “)\n3print(words) # ['', 'this', 'is', '', 'a', 'string', '', '']\nWhen we use this method, note how both trailing and leading spaces end up in the words list as empty strings. We can then filter\nthe words list in order to remove the empty strings:\nwords = s.split(“ “)\nfiltered\\_words = [s for s in words if s != '']\nprint(filtered\\_words) # ['this', 'is', 'a', 'string']\n1words = s.split(“ “)\n2filtered\\_words = [s for s in words if s != '']\n3print(filtered\\_words) # ['this', 'is', 'a', 'string']\n4\nAll we have left to do now is reverse the list and join the words with a space between them, and in the end we have a fairly straightforward algorithm.\nclass Solution:\ndef reverseWords(self, s: str) -> str:\nwords = s.split(' ')\nfiltered\\_words = [s for s in words if s != '']\nreturn ' '.join(filtered\\_words[::-1])\n1class Solution:\n2 def reverseWords(self, s: str) -> str:\n3 words = s.split(' ')\n4 filtered\\_words = [s for s in words if s != '']\n5 return ' '.join(filtered\\_words[::-1])\n6\nTime/Space Complexity\n- Time complexity:\nO(n)\n, as the interpreter iterates over the input string once and the list of words twice. - Space complexity:\nO(n)\n, to store the list of words after splitting by spaces.\nApproach 2: In-place\nLet’s pretend that you find yourself in an interview and your interviewer has asked a follow up question: “Is it possible to solve this problem and be more efficient from a space complexity standpoint?”\nWe already know our first solution is O(n)\n, leaving O(log(n))\nand O(1)\nas the two most common ways to improve. A log(n)\nalgorithm is most often related to dividing and conquering or binary search, and neither of those concepts apply here. So how can we make our solution constant space? We aren’t allowed extra memory, so the only way to do so is by mutating the string in place.\nDepending on the coding language being used, strings are either mutable or immutable. If a given language has immutable strings this means that the string can't be edited in-place without creating a new string in memory (which is a O(n)\noperation, with n\nbeing the length of the string). Conversely, if a given language has mutable strings that means the string can be edited in-place, similar to an array/list.\nFor example, in Ruby:\ns = ‘0123456789’ # note this is a string\ns[1..8] = s[1..8].reverse\n# the ruby version of print() or console.log()\nputs s # ‘0876543219’, as ‘12345678’ has been reversed in-place\n1s = ‘0123456789’ # note this is a string\n2s[1..8] = s[1..8].reverse\n3\n4# the ruby version of print() or console.log()\n5puts s # ‘0876543219’, as ‘12345678’ has been reversed in-place\n6\nTo read more about mutable vs immutable strings, check out this article on the topic by MIT.\nIf coding in a language with immutable strings (Python, Javascript, Java, etc.) mutating the string will not work, however there may be classes or libraries (such as Stringbuilder in Java) that would allow you to employ a similar approach - an interviewer may let you just assume you have one of these imported.\nTo mutate the string in place the algorithm can again be broken down into multiple steps:\n- Identify the distinct words by iterating over the string looking for spaces\n- Reverse the words in place one word at a time, trimming/skipping extra spaces while iterating\n- Trim any unneeded space from the end of the string\nReverse Words in a String Ruby Solution - In-place String Mutation\ndef reverse\\_words(s)\ns.reverse!\nl = 0\nr = 0\ni = 0\nn = s.length\nwhile i < n\n# find the next space\nwhile i < n and s[i] != ' '\ns[r] = s[i]\nr += 1\ni += 1\nend\nif l < r\n# reverse the current word\ns[l..r-1] = s[l..r-1].reverse\ns[r] = ' '\nr += 1\nl = r\nend\ni += 1\nend\n# trim end of string since we have shuffled string to the left\ns.slice!(r..s.length)\ns.strip!\nreturn s\nend\n1def reverse\\_words(s)\n2 s.reverse!\n3\n4 l = 0\n5 r = 0\n6 i = 0\n7 n = s.length\n8\n9 while i < n\n10\n11 # find the next space\n12 while i < n and s[i] != ' '\n13 s[r] = s[i]\n14 r += 1\n15 i += 1\n16 end\n17\n18 if l < r\n19 # reverse the current word\n20 s[l..r-1] = s[l..r-1].reverse\n21\n22 s[r] = ' '\n23 r += 1\n24 l = r\n25 end\n26\n27 i += 1\n28 end\n29\n30 # trim end of string since we have shuffled string to the left\n31 s.slice!(r..s.length)\n32\n33 s.strip!\n34\n35 return s\n36\n37end\n38\nTime/Space Complexity\n- Time complexity:\nO(n)\n, as we iterate over the string with multiple pointers but only do one iteration of each pointer. - Space complexity:\nO(1)\nPractice the Reverse Words in a String Problem With Our AI Interviewer\nPractice the Reverse Words in a String Problem With Our AI Interviewer\nReverse Words in a String Frequently Asked Questions (FAQ)\nReverse Words in a String Frequently Asked Questions (FAQ)\nHow do you reverse each word in a string?\nThere are two approaches you can take. The first is to split the string on spaces, reverse each word individually (see our in-depth solution to “reverse a string”), and then join them back. This approach runs in O(n)\ntime and requires O(n)\nspace.\nA more space-efficient solution is to reverse the entire sentence in place. Note that this approach only works in languages where strings are mutable. To mutate the string in place, you would identify words by iterating over the string looking for spaces. Then you’d reverse the words in place one word at a time. Finally you’d trim any unneeded spaces from the end of the string.\nThis solution still runs in linear time but requires only constant space.\nWhy can’t I just use the reverse() function to solve this problem?\nYou can… if you’re implementing sentence reversal in the real world. In an interview, however, you need to show your interviewer that you know how built-in functions work under the hood – that’s part of why interviewers ask questions like this.\nHow do you reverse each word in a string in Python?\nBecause strings are immutable in Python, you wouldn’t be able to reverse the string in place. As such, you can use the approach where you split the string on spaces, reverse each word, and then join them back, like so:\ndef reverseWords(self, s: str) -> str:\n3 words = s.split(' ')\n4 filtered\\_words = [s for s in words if s != '']\n5 return ' '.join(filtered\\_words[::-1])\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/reverse-words-in-a-string",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Amazon Leadership Principles Interview (questions + tips)",
      "content": "Before we dive into specific interview questions, it’s important to understand what the Amazon Leadership Principles are and what they mean for Amazon employees and team members.\nBelow we list the 16 Leadership Principles developed by Jeff Bezos and give a brief overview of each. We’ll also tell you how that value impacts the work environment and share some Leadership Principles questions which could probe for each LP. You’ll notice some of the questions seem irrelevant to the LP they’re listed under; that’s because some Amazonians intentionally design tricky questions. Don’t use these as a way to guess which LP a question is aimed at. For now, use them to start building a model in your head of what these interviews actually look like.\n1. Customer Obsession\nCustomer obsession is about giving the customer what they want before they know they want it. It’s a business-driver; engineers who are obsessed with delighting customers will churn out new features faster. Since Amazonians are encouraged to find ways to delight the customer before they know they’d like to be delighted, this promotes repeat business, effectiveness, and innovation.\nExample “Customer Obsession” questions:\n- Tell me about a time when you strongly disagreed with your manager or peer on something you considered very important to the business.\n- To try to meet the high expectations of our customers, we sometimes promise more than we can deliver. Tell me about a time when you overcommitted yourself or your company.\n2. Invent and Simplify\nAmazon rewards risk-taking. They push the bounds of what’s possible from cloud to e-commerce. They want big ideaters with business savvy; engineers at Amazon are encouraged to innovate as well as cut costs. As big as they grow, they still keep it simple: AWS is the biggest cloud provider in the world, yet Amazon.com strives to be their number one client. That’s an example of a simple solution to a complex problem, which is what this Leadership principle is all about.\nExample “Invent and Simplify” questions:\n- Tell me about a time when you didn’t meet customer’s needs.\n- Give me an example of a complex problem you solved with a simple solution.\n3. Learn and Be Curious\nVirtually every tech company’s marketing about their culture will include something like this. Curiosity drives learning. Amazon wants smart people who are never satisfied; they want you to always be learning. They promote taking big swings even if you end up missing. You can’t learn from your mistakes without curiosity.\nExample “Learn and Be Curious” questions:\n- Give me an example of a mission or goal you didn’t think was achievable. We all have things about ourselves we'd like to improve on at work. Give me an example of something that you've worked on to improve your overall work effectiveness.\n4. Insist on the Highest Standards\nOver the years, Jeff Bezos has repeated the mantra “Every day is day one.” He wants employees who approach every day as if they haven’t accomplished anything yet. That is a very high standard. Another reflection of Amazon’s high standards is how challenging and rewarding it is to become one of their most trusted interviewers, which is called a “Bar Raiser”. A good portion of those who apply don’t make the cut and if you make it your promotion packet gets a big boost. A Bar Raiser can veto the votes of all other interviewers in an onsite round. Those are high standards.\nExample “Insist on the Highest Standards” questions:\n- Tell me about a time when you had to work with a difficult customer or user.\n- Tell me about a time when you used external trends to improve your own company's products or services.\n5. Deliver Results\nAmazon aims for market domination. This is a company which values the “what” over the “why” and the “how”; they don’t care about how you get there or why you get there as much as they care about you getting there. You get there. In their interviews, they expect candidates to move quickly and without any hints, and they have coding questions on the easier side because they want to get to the optimal outcome as soon as possible.\nExample “Deliver Results” questions:\n- Could you tell me about a time where you were working on a project where you were working with another person. Over time, that person lessened their involvement in the project and you had to take on more responsibility.\n- Tell me about a strategic decision you had to make without clear data or benchmarks.\n6. Strive to be the Earth’s Best Employer\nIf you’re a software engineer, you won’t get asked about this.\n7. Dive Deep\nLike most tech companies, Amazon wants decisions to be made based on data; to implement an idea, you’ll need to show data. Where Amazon is different is this gritty mentality of “get the fricking job done”. Diving deep is essentially pulling yourself up by the bootstraps and making it happen. It’s also about developing a cultural attitude of people who are willing to get their hands dirty in order to win.\nExample “Dive Deep” questions:\n- Tell me about a time when you had to communicate a change in direction that you anticipated people would have concerns with.\n- Tell me about a time where you were thrown into a project where you had no experience in.\n8. Have Backbone; Disagree and Commit\nThis is the most misunderstood Leadership Principle. What it doesn’t mean is “I’ll stand up for myself. Then do it my way regardless of what you say.” What it actually means is “I verbalize the things I disagree on. Then I commit to taking action. Whether it was the action you or I proposed doesn’t matter: I’ll commit to following through on something.” This is also probably the most infamous LP, and it seems to be part of the reason for Amazonian interviewers' higher than normal level of intensity.\nExample “Have Backbone; Disagree and Commit” questions:\n- Often, we must make decisions as a group. Give me an example of a time you committed to a group decision even though you disagreed.\n- Tell me about a time where you disagreed with a coworker or PM or manager because you believed the decision they wanted to make was wrong for the customer.\n9. Success and Scale Bring Broad Responsibility\nUsually only eng managers get asked about this one, so we’ll skip it.\n10. Ownership\nTake accountability. Do all of, if not more than, what the job requires. The intention is to stimulate taking risks, having pride, and sacrificing for the business. Amazon wants folks who take big bets, hold themself to high expectations, and put in the hard work. This is one of the reasons they place a higher value on focusing on their individual contribution when answering Leadership Principles questions.\nExample “Ownership” questions:\n- Describe a time when you took on work outside of your comfort area.\n- Describe a situation where you made an important business decision without consulting your manager.\n11. Are Right, A Lot\nThis is another value that adds to the energy of a Leadership Principles interview: this is about competition. You have to know your stuff if you’re right, a lot. You also have to be willing to assert your point and back it up with all that data you dove deep for. This LP doesn’t mean Amazonians can’t mess up. They openly encourage candidates to describe times they were wrong, especially when they were wrong on a big gamble. Their ethical decision tree would look something like: Step 1: Dominate. Step 2: Did you dominate? If yes, proceed to success. If not, you better have risked enough to learn if and how domination is possible.\nExample “Are Right, A Lot” questions:\n- Tell me about a time when you did not effectively manage your projects and something did not get completed on time.\n- Tell me about a time you wouldn’t compromise on achieving a great outcome when others felt something was good enough.\n12. Hire and Develop the Best\nDomination requires finding great players and weeding out the subpar players. They’re the only FAANG company that has a formal title for their “best” interviewers: Bar Raisers. Not only does Amazon compete against other tech companies to find the “best” talent but\nthey also compete with themselves. You can interview with multiple teams simultaneously; it’s a dog-eat-dog world at Amazon and that includes dogs in the same pack.\nExample “Hire and Develop the Best” questions:\n- Tell me about a time when you received negative feedback.\n- Describe a time when you improved morale and productivity on your team.\n13. Think Big\nAmazon has a proven track record with huge ambition, large bets, and rapid expansion to new markets. Going to the moon, for one. Knowing your destination is one thing. It’s another level for your destination to be in the clouds (not an AWS joke, we swear). It’s about having a grand vision of the future so they can achieve those high standards.\nExample “Think Big” questions:\n- Give an example of a creative idea you had that proved really difficult to implement.\n- Tell me about a time when you encouraged a team member or organization to take a big risk.\n14. Bias for Action\nYou can’t take over the world if you don’t act. You might have the best idea to refactor the codebase in your head, but if it never moves towards implementation, it’s worthless. A straightforward way to make employees more productive is to openly encourage them to produce. Amazon’s bias against inaction affects their interview style: they’re looking for candidates who move fast without hints, who seek market domination, and who deliver results.\nExample “Bias for Action” questions:\n- Give me an example of a calculated risk that you have taken where speed was critical.\n- Tell me about a time where you were the first one to take action on something.\n15. Frugality\nAmazon is one of the rare companies who openly flaunts being frugal. Since when is “cutting costs” sexy? When it’s said by a group of the terminators who want to dominate the world, that’s when. Amazon wants you to not only figure out how to go to the moon, they want you to cut costs while you do it. One way to impress Amazon in the interview is to talk about the decisions you made in the past which saved the company money. You can learn how to do that in a later section of this guide called “\nHow to practice for Leadership Principles.”\nExample “Frugality” questions:\n- Tell me about a time you pushed back on a deadline.\n- Give me an example of how you have helped save costs or eliminate waste within your role or organization.\n16. Earn Trust\nThis is one of the rare Leadership Principles which is not about competition. It’s about cooperation. If you want to demonstrate cooperation, focus on how you understood the other person’s perspective. A difference of opinion is natural and healthy. This LP is about showing you know how to repair: either reactively after or proactively before a difference of opinion.\nExample “Earn Trust” questions:\n- Tell me about a time when you had a disagreement with a colleague or manager.\n- Describe a time when you needed to influence a peer who had a differing opinion about a shared goal.\nYou can read more about how Amazon defines these LPs\nhere.\nAmazon's interview process involves a)\nbehavioral interview rounds and b)\ntechnical interview rounds with a few behavioral questions thrown in. The behavioral questions will all focus on your work history. Importantly,\nAmazon will decide whether or not to hire you and how much responsibility to give you based partly on how well you demonstrate their Leadership Principles when you discuss your work history.\nWhat Amazon assesses is consistent between interviewers. Each interviewer will be assigned 1-3 LPs to look for when interviewing you. They're searching for signals on whether you: meet the bar, raise the bar, or are below the bar (for their assigned LPs).\nBut\nhow Amazon conducts the behavioral round varies widely. Our research has shown that if you were to observe sessions of 10 different LP interviewers, you would discover that each interviewer has their own way of determining a candidate's fit. One interviewer might ask more questions on fewer topics, while another interviewer may do the opposite. Complicating matters, upon observing the same behavior, different interviewers will likely perceive different signals. Notably,\nthere is no consensus on what makes a good answer good.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/amazon-leadership-principles",
      "author": "",
      "user_id": ""
    },
    {
      "title": "System Design Interview Guide for Senior Engineers",
      "content": "You may be reading this guide because you recently failed a system design interview. Or you watched a YouTube video that made system design seem like an overwhelming topic you’ll never fully grasp. Or perhaps you have years of experience working in the field, yet you struggle to demonstrate your technical prowess in the brief span of a system design interview.\nProfessional experience with distributed systems isn’t needed to pass system design interviews. And even if you do have that experience, keep in mind that many talented distributed systems engineers still struggle with the system design interview format. How you perform in an interview is not a measure of your worth as a software engineer—it is a measure of your ability to do system design interviews. The two are related but not equal; being a good programmer has a surprisingly small role in passing interviews.\nOne of our experts was asked: “As an experienced engineer without any scalable systems experience, how can I go into something like a FAANG system design interview when I have never designed those systems before?” Here’s the expert’s reply:\n\"I worked at Facebook for five and a half years. I learned more about system design from reading the internal interviewing wiki than I ever got from working at Facebook. They've got all kinds of distributed systems knowledge there, and it’s concentrated in a handful of infrastructure teams who build really great libraries and really great backend systems. That means that the rest of us never have to think about distributed systems. We get to say, 'I'm gonna make a new data type, and if I dump a billion records in it tomorrow, it doesn't matter. The systems folks have my back.' I worked at Facebook for a really long time, but I learned almost nothing about designing systems from experience.\"\nYou can pass system design interviews even if you’ve never designed distributed systems before. If you have copied files between machines with drag-and-drop, you are halfway there. If you implemented clients or servers or have opened network connections, you’ve got this. This guide will teach you the most important 20% of information that will appear 80% of the time in system design interviews. By the end of this guide you won’t be an expert, but you’ll be well on your way to being a better engineer and a much better interview candidate.\nWant to know exactly what a FAANG System Design interviewer looks for? Get detailed feedback on your system design skills from our professional interviewers.\nSee available timesIn this excerpt taken from Design Your Life, written by two Stanford professors and engineers, you’ll get a better understanding of how different problems require different approaches. We bolded to emphasize the parts that are most important to note.\n“There’s a difference between design problems and engineering problems... Engineering is a good approach to solving a problem when you can get a great deal of data and you’re sure there is one best solution. Bill [one of the authors] worked on the problem of engineering the hinges on Apple’s first laptops, and the solution he and his team came up with made those laptops some of the most reliable on the market. The solution required many prototypes and lots and lots of testing, similar to the design process, but the goal of creating hinges that would last five years (or opening and closing ten thousand times) was fixed, and his team tested many different mechanical solutions until they met their goal. Once this goal was met, the solution could be reproduced millions of times. It was a good engineering problem.\n“Compare this with the problem of designing the first laptop that had a ‘built in mouse’. Because Apple’s computers relied on the mouse to do almost everything, building a laptop that required you to be wired up to a regular mouse was unacceptable. This was a design problem. There was no precedent to design toward, there was no fixed or predetermined outcome; there were plenty of ideas floating around the lab, and a number of different designs were tested, but nothing was working. Then along came an engineer named Jon Krakower. Jon had been tinkering around with miniaturized trackballs, and had the crazy idea to push the keyboard to the back of the unit, leaving just enough room to squeeze in this tiny pointing device. This turned out to be the big breakthrough everyone had been looking for, and has been part of the signature look of Apple laptops ever since.\n“When you have a desired outcome (a truly portable laptop computer) but no clear solution in sight, that’s when you brainstorm, try crazy stuff, improvise, and keep ‘building your way forward’ until you come up with something that works. You know it when you see it. A great design comes together in a way that can’t be solved with equations and spreadsheets and data analysis. It has a look and feel all of its own - a beautiful aesthetic that speaks to you.”\nThis is one reason engineers new to system design can bomb their first couple of system design interviews spectacularly: They approach a design problem as if it’s an engineering problem. There is not a single “best” solution to a system design problem. There are no predetermined outcomes. The less code you write in a system design interview, the better.\nTo succeed in a system design interview, you want to collaborate with your interviewer, try crazy stuff, and try more crazy stuff until the design “feels right.”\nThe difference between coding and system design is the difference between retrieving and creating.\nInstead of finding (or “retrieving”) a solution, you are creating a solution. In this way, coding is akin to a science, while system design is more like an art.\nHere’s another way to think about it. You aren’t solving a problem—you’re creating a map to help someone else find the solution. Instead of coloring inside some lines, you’ll need to draw the lines for someone else to color in. In a system design interview, there are no correct answers—though there are certainly incorrect ones—so there is nothing to solve. Instead, you’ll ask questions, make stuff, and explain how and why the stuff you made was reasonable.\nDuring the interview, you’ll spend an hour playing the role of a Tech Lead, so just pretend that the interviewer is a junior engineer who will be implementing your design. Juniors will have lots of questions, and since you’re the Tech Lead, you want to welcome these questions.\n“Pretend it’s 1999, so a lot of the stuff we have access to today simply doesn’t exist. You and a group of your schoolmates are in your garage, hoping to make something. You're the most senior one there. You will design it and your friends will code it up, and the thing is: the Minimum Viable Product has to be completed by tomorrow. So, there’s no time to prep and no need to worry about the intricacies of system architecture that you don’t know. Just answer this: How would you design this system so your friends could code it up today, right now? It doesn’t have to be pretty. It doesn’t have to be complicated. It doesn’t have to impress anyone. It just has to get done.”\nThe value of communication in coding interviews is controversial (source). But without communication in a system design interview, nothing happens. By necessity, it’s more conversational in nature than a coding interview and will have more back and forth between interviewer and candidate.\nWith that said, sometimes you’ll have an interviewer who is cold or not very collaborative. Dealing with these interviewers requires practice. The more senior you become, the more important it is to learn how to adjust your communication style to match your audience. We recommend completing mock interviews with a variety of interviewers to help you become a seasoned, fearless veteran of system design interviews.\nThere’s no “right” way to design a system. If two experts designed the same system, you would see two different designs, beautiful and aesthetic in their own way and both as “correct” as the other (and with the accompanying justifications to support them).\nIn part 2, two experts will show you how they would each design the same system, providing you with a practical lesson on this topic.\n“If you want to be a great interview candidate you’ve gotta know… It’s your responsibility to leave breadcrumbs for the interviewer to go where you want them to go. That way you have them walk you down the road where you are at your best. And then the Jedi mind trick is to get them to think it was their idea to get you there.”\nWhat if your measurement of success in an interview isn’t what you say, but instead it’s what you get the interviewer to say? Imagine you say something that engages the interviewer’s curiosity so much that they have no choice but to follow up with a “tell me more about that.” If the areas you get them to dig into the deepest, are things you’re good at: congratulations you are doing the Jedi mind trick.\nA candidate doing a system design interview will usually experience confusion. The interview format is so open-ended, you cannot know about everything they'll ask you. However, there will be opportunities to strut your stuff. There will be moments when they ask you about something you know very well, and when this happens put your shoulders back and flex your muscles on this topic.\nWhen beginning an interview, try to imagine what the interviewer is looking for. What are their goals for the session? How can you help them achieve those goals in a way that persuades them that you’ll be a strong hire?\nPut simply, the interviewer's goal is to find enough data to hire you. Given the limited time available to them, an interviewer has to try to get enough positive signal about your ability so they can justify giving you a “hire” rating. In one hour you have to show your interviewer that you understand the fundamentals of a system (end to end). You also should be able to name and explain (at least at a high level) each part of the system, describe the tradeoffs you make, and find a solution.\nThe best way to accomplish this is to imagine that you’re explaining a design doc to a group of more junior engineers. They will ask you questions about your decisions and want to know what you’re trying to solve. Anticipating these questions and your responses will set you up for success in the interview.\nWant to know exactly what a FAANG System Design interviewer looks for? Get detailed feedback on your system design skills from our professional interviewers.\nSee available timesWith this basic model in mind, let's consider the main elements that system design interviewers look for, and the elements that don’t matter.\nYour interviewer will expect you to have knowledge of a wide range of basic topics, but they won't expect you to be an expert in any of them. For instance, you should understand the difference between SQL and NoSQL databases, their broad performance characteristics, and the types of applications each might be useful for (which we’ll teach you later in this guide). But you would not need to know how the internals of either type of database work at any kind of detailed level.\nIn spite of this, you still might be asked to design those internals! Keep in mind, though, that your answer doesn't need to be optimal or reflect real-world implementations. For example, if an interviewer asks you to design a database/SQL query engine, they're not trying to discern if you're familiar with the academic literature on query engines or discover how much time you've spent working on database internals.\nInstead, they want to see how you would approach the problem based on what you do know, starting from first principles and collaborating with them. Your answer will probably not be anywhere near optimal, and that's OK! The interviewer will focus on the process, not the result.\nInitial prompts to system design problems tend to be intentionally light on detail. Many candidates make a mistake by extrapolating details from the initial prompt and crafting a solution based on those assumptions.\nFor example, imagine that the interviewer instructs you to design a \"photo sharing service\" with some minimally defined capabilities. This may cause some candidates to imagine that they're rebuilding Instagram and start designing around the assumption that all images will be relatively small, not examined closely, and that extensive compression to save storage and bandwidth is acceptable.\nBut the interviewer didn’t tell you to rebuild Instagram, so you’ll need to keep in mind that there are many different types of photo sharing services. The interviewer may have had in mind something like Imgur or Photobucket, sites that cater more to basic image hosting for the web. Or they could be thinking about something like Flickr or 500px, services built for photographers to show off their work in high resolution.\nSo how do you figure out what type of service the interviewer wants you to build? Ask them! A basic prompt leaves room for you to start a conversation with your interviewer about the system you're designing—what type of users does it serve, what type of traffic can it expect, what limits will it have? Demonstrating that you can think critically about the parameters of your service is the first step in any system design interview.\nBe very careful any time you find yourself responding immediately to a prompt in a system design interview. Even aspects of your design that seem insignificant need at least cursory consideration. Let’s use IDs as an example.\nA candidate will often start a discussion of a data model with a statement like, \"I'll use auto incrementing IDs,\" or \"I'll use GUID here\" as kind of a default approach to assigning IDs to data. In many applications, however, the type of ID you assign to your data has practical consequences.\nIs this ID going to be exposed to users? If so, how long does it need to be to avoid collisions? If we auto-increment it, are we worried about the visibility that will give third parties into our traffic patterns or the possibilities of users guessing the IDs to each others' data? If it's intended to be shared, is it convenient to type? If you print it on a business card or a flier, does it contain characters that you could confuse for each other (e.g., “1” and “I”, “0” and “O”)?\nYou don't need to hold an inquiry for every minor detail, but always be sure to give some justification for the decisions you make and let your interviewer know how your decisions would change in different circumstances. System design problems don't have a single definitive answer, so interviewers just want to see that you can justify your answers.\nCoding problems usually have an expected path. Typically you'll begin with an obvious but inefficient solution, and then the interviewer will prompt you for a series of improvements. Those improvements lead you to increasingly efficient solutions until you finally arrive at the optimal implementation.\nSystem design problems, on the other hand, resemble a Choose Your Own Adventure book rather than a linear novel. A complex system contains a multitude of sub-components, each one of which could serve as a design problem on its own. After you've sketched the overall layout of your system, an interviewer may decide to keep your focus on the big picture or dive into a deeper examination of one particular component.\nThe path your interview takes will be steered by your interviewer, but they're likely to take cues from the sub-problems in which you display interest or aptitude. In some cases they may explicitly ask you which part of the problem you'd prefer to focus on.\nEven if you're not choosing directly, you can still influence an interview's direction. As you talk your way through a solution, it’s OK to specifically note the parts that you have experience in and explain when you're making educated guesses. Your interviewer won't expect you to know everything, but giving them a better idea of what you do know will help them steer the interview in ways that reveal your strengths and problem-solving ability.\nWhen faced with a choice in a design interview, it's easy to focus on the technical details, but remember that computer systems serve human users, so you’ll want to anchor your technical decisions to the user experience they enable.\nSuppose, for instance, that the image sharing service you're designing will require users to log in before uploading an image. In technical terms, you might want to avoid login to keep the database schema simpler, or you could introduce login to gather better metrics. An anonymous experience may be best for a public image-hosting site intended for quick turnaround and low interaction, while a logged-in experience offers the possibility of community features like commenting and sharing, personalized metrics, and the ability to restrict an upload to authorized viewers. You may want to take either approach or even both, allowing a limited anonymous experience with extra features for logged-in users.\nThe important thing is to discuss the possible approaches and their consequences for the user experience with your interviewer before making a decision. You can never go wrong by making the end user the driving force in your design.\nThink of red and green flags as signposts you can use to orient yourself in the interview. Green flags indicate that things are going well, that you're engaging with the interviewer and making a positive impression. Red flags warn you that you may be going astray and should try to get the interview back on track.\nFollowing this quote’s advice has steered many interviewees in the wrong direction. There is no game, and talking for the sake of talking is one way to hang yourself with the rope the interviewer gives you. Also, if the goal is to not explode, well, you’re wasting your and your interviewer’s time.\nAs we mentioned earlier, this guide will teach you the basic information that you’ll be asked about in 80% of system design interviews. Although these are great odds, you still may encounter a scenario that’s beyond your level of understanding. If this happens to you, don’t worry! Just engage in an honest dialogue with your interviewer, explaining when you lack certain knowledge or have gaps in your understanding. When you do have a sense of how to proceed, but you’re uncertain, you should communicate from first principles. Later in this guide, we will explain how to overcome that uncertainty and still score points with your interviewer.\nKeep in mind that your interviewers use the same problems over and over again, and they frequently see candidates make the same mistakes. If they try to divert you from a course of action, it's likely because they've seen others flounder when using the same approach. You may be the one candidate in a hundred who finds a unique and better solution—we've had this happen before!—but carefully consider the odds before proceeding with a solution against the interviewer's advice.\nWith that said, there is an art to pushing back against your interviewer when the situation calls for it, and later in this guide we’ll teach you how and when to employ this strategy .\nWhen the interviewer offers feedback, you integrate it into your design. You ask probing questions and receive useful answers about the system you're designing, its users, and its traffic. Try to establish a tone as if you were working through a problem with a coworker rather than proving yourself to an interviewer. In the real world, when you’re assigned a project, you’ll have to ask a variety of people several questions to ensure that you fully understand the problem before making decisions. That’s what interviewers want to see.\nIt's OK to not know things—no one will have every answer—but it's better to admit that to your interviewer than to avoid the questions altogether. Your interviewer may be able to offer you a hint or help you reason about alternatives if they know you're struggling, but if you skip right ahead you'll miss the opportunity to provide them with any positive signal from that portion.\nIf you’re looking for a mid-level position or below, your interviewer should determine the direction and speed of the interview. Given an initial overview of your design, they may ask you for clarification on some aspects of it. They may ask you to produce a more detailed design for one or more components. And they may also change the requirements and ask how you could adapt your solution to accommodate this new view of the world. Wherever they take the interview, follow along and focus on the areas they direct you to.\nIf you’re applying for a senior role (or above), it’s a good sign if you direct more of the interview. In junior system design interviews, the interviewer expects to drive the interview, but as you reach senior levels the expectation shifts to the interviewee.\nBeing overly confident and talking too much might count against a mid-level candidate. Some interviewers (especially off-script ones) love giving candidates more rope to hang themselves with, and then they ask specific questions that focus on what the candidate struggles with.\nIf your goal is to maximize a mid-level offer, not improve your \"average passing rate\" (i.e., if you are comfortable sacrificing some senior-plus chances to increase your mid-level chances), then you might be better off consciously \"giving control away\" to your interviewer.\nSimply put, at the above-senior level an awkward pause will be held against you—that’s basically guaranteed. But at mid-level, most of your attempts to fill in an awkward pause may hurt you more than keeping silent.\nAnother way to think of it: when you are not leading the conversation, you signal that you’re not really far above mid-level. (But if you are comfortable at mid-level, this is not a downside!)\nThe saying, ‘Better to remain silent and be thought a fool than to speak out and remove all doubt’ can be true for mid-level interviews but not for seniors or above-senior.”\nIf you're struggling to provide an answer, give yourself a little bit of time to come up with something. If you're truly stuck, however, you should ask your interviewer for help. They can't tell that you're at an impasse unless you tell them, and you may waste valuable interview time while they debate whether it's been long enough to interrupt you.\nAn interview doesn't need to be a continuous stream of consciousness, and it never hurts to sanity check your ideas before verbalizing them.\nIn Part 4 of this guide, we’ll teach you how to get unstuck and exactly what to say when you’re stuck.\nOften, candidates will say things like: “we could use this type of DB, or this other, or that other, and these are some pros and cons…” and then they move on to another component. It’s a good practice to talk about benefits and tradeoffs, but then you have to make a decision. In the real world you have to make decisions—the same thing applies to the interview. If the interviewer challenges you with some questions, it’s totally fine to change your mind and alter the component (if you think there are better choices).\nWe could use this type of DB, or this other, or that other, and these are some pros and cons…\n\"We could use this type of DB, or this other, or that other, and these are some pros and cons… And based on all these tradeoffs, I’ll use THAT type of DB.\"\nDon’t say things because you think you’re supposed to say them. This often occurs when candidates name specific brands of technologies (e.g., “Kafka” or “Cassandra”). Not being familiar with specific databases or other components is fine. Be smart and don’t say brand names just for the sake of saying them.\nI’m going to use Cassandra...” unless you are VERY familiar with that, because the next question will be: “Why Cassandra and not some\\_other\\_db?\nI’m going to use a NoSQL db because of [insert brief rationale].\nI will use Kafka…” unless you’re prepared to explain how Kafka works. Don’t say “I will use Kafka” unless you are prepared to talk about other types of queues, because they may ask you: “Oh, Kafka, interesting choice. Why that instead of [some other queue]?\nI will use a queue because of [insert brief rationale].\nSay the generic name of the component, not the brand name unless you are very familiar with it. Don’t say Kafka. Instead, say “a queue.\nYou finished Part 1! We hope you gained a basic understanding of the system design interview and learned some tips and tricks you can use to excel in it. As you continue reading Parts 2-4, these “glimmers” of understanding will become more and more the default system of your interviewing skills.\nIn Part 2 we’ll teach you the 15 fundamental system design concepts. You’ll also get to watch our long form video of two system design experts designing the same system. They’re tasked with designing interviewing.io, which in this challenge is actually three systems in one: “Design google docs, a remote compiler, and a recording service… in 30 minutes or less.”\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/system-design-interview",
      "author": "",
      "user_id": ""
    },
    {
      "title": "A Senior Engineer’s Guide to FAANG Interviews",
      "content": "There are lots of guides out there to FAANG interview processes. This one is the most thorough and the most detailed because it’s the only one made by interviewers for candidates – we spent hundreds of hours talking to dozens of current and former FAANG interviewers about their processes. Throughout this guide, you’ll see a bunch of direct quotes from these interviewers, where they describe the idiosyncrasies of each company’s process and bar in their own words. We’re fortunate to have them in the interviewing.io community, and we’re lucky that we can collaborate with them on this type of content. As you can imagine, they all requested to stay anonymous, but we want to thank them here, first and foremost.\nFAANG interviews are a gauntlet, but you can pass them even if you doubt yourself – interviewing is easier once you learn a company’s operating metaphor. George Lakoff (neuroscience and artificial Intelligence researcher) says that every human organization has a metaphor they operate as. If you ask an employee at a FAANG company about their metaphor, you’ll probably receive a blank stare in return. But if you look at the interviewing data of that same FAANG company, the metaphors jump out of the data set like bread out of a toaster.\nThis guide will walk you through all the FAANGs’ metaphors and the unwritten codes of those metaphors: what they reward, what they punish, and what they’re blind to. To show them you’re obviously a part of their tribe, model their metaphors and unwritten codes.\nMetaphors aside, this guide will also walk you through the unglamorous logistics of every FAANG’s interview process so that you know how many steps there are, what those steps entail, and what kinds of questions they ask. Our goal is to have you walk in and be completely unfazed by the proceedings because you’re expecting them.\nOf course, even with all the insider info in the world, if you’re not prepared for technical interviews, you will fail, so we’d be remiss if we didn’t share some useful insights about practice to help you on your journey.\nThere are 3 steps to getting a strong offer at FAANG.\nSteps 1 and 3 are out of scope for this post, which is solely focused on Step 2.\nMoreover, this guide is written for experienced, back-end leaning engineers – interview processes are usually different for juniors, but we won’t be getting into those differences. Finally, we won’t be getting into the differences in process for front-end engineers, SREs, etc. That said, if you’re targeting those roles, you’ll still get value out of this guide.\nIn Part 1 of this guide, we’ll highlight key similarities and differences between the FAANG companies, namely:\nIn Part 2, we’ll go through each company one by one and tell you how each of their processes work and how to prepare for each one.\nIf you’re planning on interviewing with multiple FAANGS, we recommend reading Part 1 first. If you'd prefer to skip straight to a company’s individual guide then just click on it in the table of contents to the left! Individual guides include more detailed information on company-specific coding interviews, behavioral interviews, and anecdotes from actual interview experiences.\nAll of these big tech companies share grueling interview processes, strong initial compensation packages, and above average benefits. They compete with each other for the same engineers. If tech has a food chain, they’re at the top. Most other tech companies copy or are influenced by what FAANG does.\nThere are also a number of myths about FAANG interview processes. Two big ones are that Amazon has the lowest bar, and Google has the highest bar. That’s not true; we have the data. The reality is that all of their bars are different. It’s not a linear comparison. It’s a multidimensional comparison. Because of that, it’s impossible to say something like, “The entire process at Google is harder than the entire process at Amazon.” They’re simply different processes.\n“My friend interviewed at Google and Facebook, and he passed both loops. At Google, he was offered L6. At Facebook, he was offered L4. Speaking about luck: this is the same person with the same experience. And the level of difference– at two of the most trusted names in tech–was two levels of seniority.\nAnd one common idea in big tech is that Google’s process is easier than Facebook’s. But you can see here: it really depends. After all, this person accepted the L4 role at Facebook because the compensation package was bigger than the role at Google for L6.”\nLong story short: it’s complicated. That’s exactly why we wrote this guide: to demystify the differences, to decouple the 6-headed monster, and to demonstrate how to attack each head, one at a time.\nThis is the ultimate insider’s guide to tech interviews at FAANG. However, even with all the insider info in the world, if you’re not prepared for technical interviews, you will fail, so we’d be remiss if we didn’t share some useful insights about practice to help you on your journey. Yes, we know we’re a practice platform, and, look, you don’t have to practice with us. But you should practice! Here’s why.\nThree different startups with robust data sets on software engineering interviews found eerily similar data points about what happens after you do five technical interviews. I worked at all three companies and saw this data myself.\nMind you, these datasets were quite different: Triplebyte skewed towards folks with nontraditional backgrounds, interviewing.io inclined towards senior backend engineers, and Pathrise was mainly junior engineers. Despite that, the number five emerged across these data sets, and it’s clear that something happens after you complete five technical interviews. We can’t explain what yet. But the data is screaming in all caps: there is a there there. One more anecdotal point: these five interviews should ideally mimic the real thing as much as possible. For instance, if you want a FAANG job, but your five interviews are with startups that don’t ask algorithmic questions, you won’t get as much value. The more your practice can simulate the real game, the better.\nIf you’re unprepared for a FAANG interview, ask to reschedule. Not rescheduling is the number one mistake we see our users make! Getting an interview tomorrow (as opposed to 1-3 months from tomorrow) is, in most cases, no different to the company… but very different to you – if you fail, you might get frozen out for months. In the rare cases where rescheduling could hurt your chances because it’s a specific role for a specific team, your recruiter will tell you that. Either way, there’s no harm in asking.\nRecruiter calls don’t differ much from FAANG company to FAANG company, so we decided to put everything about what to expect in a recruiter call in one place. If a recruiter call ever meaningfully deviates from this format, we’ll mention it. Otherwise, expect that it doesn’t.\nA recruiter call is the first step of almost every process. In this call, a recruiter will ask you about your past experience, your salary expectations, and why you’re interested in that particular company. They will also ask you about your timeline (how soon you expect to accept an offer), how far along you are with other companies, whether you have outstanding offers, and so on.\nIn this call, it’s important to be able to succinctly talk about your past few positions, your major contributions at those positions (what did you do individually versus what did your team do) and their impact on the business. Remember that most recruiters don’t have a technical background and they’re not software developers, so it’s important to be able to describe your technical contributions in clear layman’s terms.\nIt’s also really important, at this stage, not to reveal your salary expectations, your salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number. Just don’t do it – when you give out information this early in the process, you’re painting future you into a corner.\nThis section will give you a feel for how these companies’ processes differ. For now, don’t worry about how that translates into interview prep – we’ll cover that later when we describe how to prepare for each company.\nTake a look at the chart below. In it, we rank the FAANGs on their “Chaos Score”. The more points a company has, the more chaotic they are.\nIn this context, we define “chaos” as the level of uncertainty and unpredictability that candidates can expect from the interview process and its outcomes. If a company consistently follows the same process, asks the same questions, and thoroughly trains their interviewers, they are not chaotic. If their process is completely non-standard, non-deterministic and subjective, they are chaotic.\n| Company Name | Chaos Score |\n|---|---|\n| Apple | 20 |\n| Netflix | 20 |\n| Microsoft | 18 |\n| Amazon | 12 |\n| 10 | |\n| Meta | 3 |\nAs you can see, Apple and Netflix win the award for the most chaotic interview processes in FAANG. Microsoft gets 2nd place. Amazon gets 3rd, Google 4th, and Facebook 5th.\nChaos can be pain or pleasure depending on your tolerance for uncertainty. Chaos can also either impose a terrible detriment or prove a huge advantage in interviews specifically. For instance, candidates who have spent a long time grinding on LeetCode might prefer less chaotic companies. More chaotic companies can work for candidates for a few reasons: a) niche skill sets can be an easier match for niche interview processes, b) practical interviews are more likely, and c) the interview process shows them how the team they’d be joining actually operates.\nTo calculate each company’s Chaos Score, we picked four categories and graded each company on a 0 to 5 point scale in each category, where 5 means most chaotic and 0 means least.\nWe added up the points for each company, with a maximum possible Chaos Score of 20.\n| North star | Team dependent process? | Level of training for interviewers? | Level of standardization? | |\n|---|---|---|---|---|\n| Apple | Why (5) | Yes (5) | None (5) | None (5) |\n| Netflix | Why (5) | Yes (5) | None (5) | None (5) |\n| Microsoft | How (3) | Yes (5) | None (5) | None (5) |\n| Amazon | What (1) | Yes (5) | High (2) | Low (4) |\n| How (3) | No (0) | Medium (3) | Low (4) | |\n| What (1) | No (0) | Highest (1) | Highest (1) |\nBy “North star”, we mean what a given company values most. As such, we grouped companies into 3 buckets: companies who primarily care about \"Why\", \"How\", and \"What\".\n“Why” is the most chaotic because judging motivations is the most subjective approach. “How” is the second most chaotic because judging thought processes is the second most subjective. “What” is the least chaotic because judging end results is the least subjective method.\n“Why” companies can’t agree on what a good “why” looks like because it’s a “gut feel / friend test”. Whom you consider to be a friend and who gives you a good gut feeling isn’t quantifiable. It’s completely subjective. “Why” companies are the most prone to bias. If you speak their language and model the behaviors they encourage, you’ll seem like a friend and give them a good gut feel. If you don’t, then you won’t.\nIf chaos is hell, then “Why” companies are raising hell for candidates and themselves.\n“How” companies mainly care about your thought process: Okay, you didn’t get to the optimal solution, but what was the journey like? Google and Microsoft repeat this mantra again and again – they want to know how you think. You might get asked a really hard or specific question, but they don’t necessarily require an optimal answer to pass. They put far more weight on your ability to demonstrate a solid thought process.\n“What” companies mainly care about your results, such as: Did you get to the optimal solution? Facebook and Amazon want you to get there, and fast. “What” is the most straightforward for candidates: simply get results as quickly as possible.\nA Google or Facebook interview doesn’t change depending on the team you’re interviewing for. Both companies have one big, centralized interview process that’s completely divorced from which team you might end up on. If you do well in the team-agnostic process, there will be a team matching component after the onsite. You will NOT, however, be interviewing with your future coworkers.\n(Note: Google is rumored to be changing to a team-dependent process, but we’ll leave that where it is for now.)\nAt Microsoft, Netflix, Apple, and Amazon, the process is team-dependent. You’ll not only be interviewing with the people that you’ll be working with, but there’s more chaos. Each team defines how they do things: the types of questions asked, the types of interview rounds, and even how they make hiring decisions.\nTeam-dependent processes are more challenging in the sense that you're more likely to get blind-sided; because each team has a different process, candidates are more likely to prep for X and get (a significantly different) Y.\nYet, team-independent processes are more challenging because of the machinery. Your interviewers are so far removed from you. That detachment affects how they treat, judge, and talk about you.\nThink of it like this: At Netflix, Apple, Amazon, and Microsoft you’re interviewing with humans. At Google and Facebook, you’re interviewing with a machine.\nFacebook is the least chaotic company in this category because they have the most in-depth interviewer training in FAANG. Their process is rigorous and selective. Though most would-be interviewers pass within 6 months, some people who try never pass the bar to become an interviewer. Facebook is the only FAANG where this is true.\nFacebook and Amazon put interviewer candidates through roughly the same things, but Facebook is more rigorous. For example, both will have similar modules interviewers go through in training. A module at Amazon is more likely to be a box to check: if you do it, you pass. At Facebook, you don’t pass simply for doing it: you pass by meeting a predetermined bar. Also, Facebook modules are more likely to have a rubric.\nGoogle used to have a more in-depth interviewer training process than what they have now. For whatever reason, they began to skimp on their interviewer training roughly sometime in the 2010s. Now, Googlers can get a bit of training, but usually not as much as folks at Facebook or Amazon.\nNetflix, Microsoft, and Apple do not train their interviewers; certain teams may be exceptions but there’s no company-wide required interview training. The day you start, you can start interviewing. That makes them the most chaotic in this category.\nWhat this means for candidates is that the less training they put their interviewers through, the more likely you’ll have a bad interviewer. As the old saying goes: “Prepare for the worst, pray for the best.”\nCompanies that standardize their interview questions give interviewers less free reign; groups with no standardization have more free reign. At all companies, there will be interviewers who go rogue and deviate from the norm. Yet, each company has a norm.\nFacebook wins again for being the least chaotic/most predictable. In behavioral rounds, interviewers at Facebook can ask whatever behavioral questions they want. However, in technical rounds, they can only ask pre-approved coding questions. They can also modify pre-approved coding challenges. That’s it.\nGoogle is tied for the second least chaotic here; their interviewers have free reign in technical rounds. They have a large technical question bank, yet interviewers routinely make up their own ambiguous one-of-a-kind questions. In behavioral rounds, they can only ask or modify pre-approved questions.\nAmazon is tied for second least chaotic, but for a different reason. Technically, there’s no standardization for any round (technical or behavioral). They do, however, tend to repeat questions from their internal question bank (which is not required for interviewers to use.)\nMicrosoft, Apple, and Netflix are the most chaotic companies. Each team decides what to ask. Questions tend to be customized to the hiring manager’s preferences, a senior individual contributor’s diligence, what this team works on day-to-day, or the specific domain this team is in.\nWhether you get one shot or unlimited shots to land an offer changes how you prepare. Here’s the breakdown of which companies let you interview with multiple teams concurrently.\n| Company Name | Can interview with different teams concurrently? |\n|---|---|\n| Apple | Yes |\n| Netflix | Yes |\n| Microsoft | Yes |\n| Amazon | Yes |\n| No | |\n| Meta | No |\nIf you can interview with multiple teams concurrently, then they don’t have a cool down period. So, after you fail, you don’t need to wait at all to reinterview. Two of the biggest players only give you one shot to win, and at the remaining four your chances are unlimited.\nBecause their interview process is centralized, Google and Facebook are the only ones well-organized enough to not let candidates “double dip”.\nIf you really want a job at Netflix, Apple, Amazon, or Microsoft: stack the odds of landing your dream job in your favor and interview with multiple teams. There’s no cool-down period, so if you get rejected from Team A, you can interview with Team B tomorrow.\nIn Part 2, we’ll give you a deeper feel for each company, and we’ll tell you what to do about it. Each company has its own section, and each section is organized into five subsections:\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Gift Interviews",
      "content": "We helped write the sequel to \"Cracking the Coding Interview\".\nRead 9 chapters for free\n→\ninterviewing.io\nOpen menu\nInterview resources\nFor employers\nGift mock interviews\nBlog\nFAQ\nLog in\nGive it a try\nHelp someone get awesome at technical interviews\nGift to\nTheir name\nTheir email\nGift from\nYour name\nYour email\nNumber of interviews\nTotal (15% off for 4 interviews or more)\n$225\nPayment method\nOptional gift message\nPay & send gift\nQuestions? Email\nsupport@interviewing.io\nWe know exactly what to do and say to get the company, title, and salary you want.\nInterview prep and job hunting are chaos and pain. We can help. Really.\nGet started for free",
      "content_type": "blog",
      "source_url": "https://interviewing.io/gift-practice-interviews",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Amazon Leadership Principles Interview (questions + tips)",
      "content": "Before we dive into specific interview questions, it’s important to understand what the Amazon Leadership Principles are and what they mean for Amazon employees and team members.\nBelow we list the 16 Leadership Principles developed by Jeff Bezos and give a brief overview of each. We’ll also tell you how that value impacts the work environment and share some Leadership Principles questions which could probe for each LP. You’ll notice some of the questions seem irrelevant to the LP they’re listed under; that’s because some Amazonians intentionally design tricky questions. Don’t use these as a way to guess which LP a question is aimed at. For now, use them to start building a model in your head of what these interviews actually look like.\n1. Customer Obsession\nCustomer obsession is about giving the customer what they want before they know they want it. It’s a business-driver; engineers who are obsessed with delighting customers will churn out new features faster. Since Amazonians are encouraged to find ways to delight the customer before they know they’d like to be delighted, this promotes repeat business, effectiveness, and innovation.\nExample “Customer Obsession” questions:\n- Tell me about a time when you strongly disagreed with your manager or peer on something you considered very important to the business.\n- To try to meet the high expectations of our customers, we sometimes promise more than we can deliver. Tell me about a time when you overcommitted yourself or your company.\n2. Invent and Simplify\nAmazon rewards risk-taking. They push the bounds of what’s possible from cloud to e-commerce. They want big ideaters with business savvy; engineers at Amazon are encouraged to innovate as well as cut costs. As big as they grow, they still keep it simple: AWS is the biggest cloud provider in the world, yet Amazon.com strives to be their number one client. That’s an example of a simple solution to a complex problem, which is what this Leadership principle is all about.\nExample “Invent and Simplify” questions:\n- Tell me about a time when you didn’t meet customer’s needs.\n- Give me an example of a complex problem you solved with a simple solution.\n3. Learn and Be Curious\nVirtually every tech company’s marketing about their culture will include something like this. Curiosity drives learning. Amazon wants smart people who are never satisfied; they want you to always be learning. They promote taking big swings even if you end up missing. You can’t learn from your mistakes without curiosity.\nExample “Learn and Be Curious” questions:\n- Give me an example of a mission or goal you didn’t think was achievable. We all have things about ourselves we'd like to improve on at work. Give me an example of something that you've worked on to improve your overall work effectiveness.\n4. Insist on the Highest Standards\nOver the years, Jeff Bezos has repeated the mantra “Every day is day one.” He wants employees who approach every day as if they haven’t accomplished anything yet. That is a very high standard. Another reflection of Amazon’s high standards is how challenging and rewarding it is to become one of their most trusted interviewers, which is called a “Bar Raiser”. A good portion of those who apply don’t make the cut and if you make it your promotion packet gets a big boost. A Bar Raiser can veto the votes of all other interviewers in an onsite round. Those are high standards.\nExample “Insist on the Highest Standards” questions:\n- Tell me about a time when you had to work with a difficult customer or user.\n- Tell me about a time when you used external trends to improve your own company's products or services.\n5. Deliver Results\nAmazon aims for market domination. This is a company which values the “what” over the “why” and the “how”; they don’t care about how you get there or why you get there as much as they care about you getting there. You get there. In their interviews, they expect candidates to move quickly and without any hints, and they have coding questions on the easier side because they want to get to the optimal outcome as soon as possible.\nExample “Deliver Results” questions:\n- Could you tell me about a time where you were working on a project where you were working with another person. Over time, that person lessened their involvement in the project and you had to take on more responsibility.\n- Tell me about a strategic decision you had to make without clear data or benchmarks.\n6. Strive to be the Earth’s Best Employer\nIf you’re a software engineer, you won’t get asked about this.\n7. Dive Deep\nLike most tech companies, Amazon wants decisions to be made based on data; to implement an idea, you’ll need to show data. Where Amazon is different is this gritty mentality of “get the fricking job done”. Diving deep is essentially pulling yourself up by the bootstraps and making it happen. It’s also about developing a cultural attitude of people who are willing to get their hands dirty in order to win.\nExample “Dive Deep” questions:\n- Tell me about a time when you had to communicate a change in direction that you anticipated people would have concerns with.\n- Tell me about a time where you were thrown into a project where you had no experience in.\n8. Have Backbone; Disagree and Commit\nThis is the most misunderstood Leadership Principle. What it doesn’t mean is “I’ll stand up for myself. Then do it my way regardless of what you say.” What it actually means is “I verbalize the things I disagree on. Then I commit to taking action. Whether it was the action you or I proposed doesn’t matter: I’ll commit to following through on something.” This is also probably the most infamous LP, and it seems to be part of the reason for Amazonian interviewers' higher than normal level of intensity.\nExample “Have Backbone; Disagree and Commit” questions:\n- Often, we must make decisions as a group. Give me an example of a time you committed to a group decision even though you disagreed.\n- Tell me about a time where you disagreed with a coworker or PM or manager because you believed the decision they wanted to make was wrong for the customer.\n9. Success and Scale Bring Broad Responsibility\nUsually only eng managers get asked about this one, so we’ll skip it.\n10. Ownership\nTake accountability. Do all of, if not more than, what the job requires. The intention is to stimulate taking risks, having pride, and sacrificing for the business. Amazon wants folks who take big bets, hold themself to high expectations, and put in the hard work. This is one of the reasons they place a higher value on focusing on their individual contribution when answering Leadership Principles questions.\nExample “Ownership” questions:\n- Describe a time when you took on work outside of your comfort area.\n- Describe a situation where you made an important business decision without consulting your manager.\n11. Are Right, A Lot\nThis is another value that adds to the energy of a Leadership Principles interview: this is about competition. You have to know your stuff if you’re right, a lot. You also have to be willing to assert your point and back it up with all that data you dove deep for. This LP doesn’t mean Amazonians can’t mess up. They openly encourage candidates to describe times they were wrong, especially when they were wrong on a big gamble. Their ethical decision tree would look something like: Step 1: Dominate. Step 2: Did you dominate? If yes, proceed to success. If not, you better have risked enough to learn if and how domination is possible.\nExample “Are Right, A Lot” questions:\n- Tell me about a time when you did not effectively manage your projects and something did not get completed on time.\n- Tell me about a time you wouldn’t compromise on achieving a great outcome when others felt something was good enough.\n12. Hire and Develop the Best\nDomination requires finding great players and weeding out the subpar players. They’re the only FAANG company that has a formal title for their “best” interviewers: Bar Raisers. Not only does Amazon compete against other tech companies to find the “best” talent but\nthey also compete with themselves. You can interview with multiple teams simultaneously; it’s a dog-eat-dog world at Amazon and that includes dogs in the same pack.\nExample “Hire and Develop the Best” questions:\n- Tell me about a time when you received negative feedback.\n- Describe a time when you improved morale and productivity on your team.\n13. Think Big\nAmazon has a proven track record with huge ambition, large bets, and rapid expansion to new markets. Going to the moon, for one. Knowing your destination is one thing. It’s another level for your destination to be in the clouds (not an AWS joke, we swear). It’s about having a grand vision of the future so they can achieve those high standards.\nExample “Think Big” questions:\n- Give an example of a creative idea you had that proved really difficult to implement.\n- Tell me about a time when you encouraged a team member or organization to take a big risk.\n14. Bias for Action\nYou can’t take over the world if you don’t act. You might have the best idea to refactor the codebase in your head, but if it never moves towards implementation, it’s worthless. A straightforward way to make employees more productive is to openly encourage them to produce. Amazon’s bias against inaction affects their interview style: they’re looking for candidates who move fast without hints, who seek market domination, and who deliver results.\nExample “Bias for Action” questions:\n- Give me an example of a calculated risk that you have taken where speed was critical.\n- Tell me about a time where you were the first one to take action on something.\n15. Frugality\nAmazon is one of the rare companies who openly flaunts being frugal. Since when is “cutting costs” sexy? When it’s said by a group of the terminators who want to dominate the world, that’s when. Amazon wants you to not only figure out how to go to the moon, they want you to cut costs while you do it. One way to impress Amazon in the interview is to talk about the decisions you made in the past which saved the company money. You can learn how to do that in a later section of this guide called “\nHow to practice for Leadership Principles.”\nExample “Frugality” questions:\n- Tell me about a time you pushed back on a deadline.\n- Give me an example of how you have helped save costs or eliminate waste within your role or organization.\n16. Earn Trust\nThis is one of the rare Leadership Principles which is not about competition. It’s about cooperation. If you want to demonstrate cooperation, focus on how you understood the other person’s perspective. A difference of opinion is natural and healthy. This LP is about showing you know how to repair: either reactively after or proactively before a difference of opinion.\nExample “Earn Trust” questions:\n- Tell me about a time when you had a disagreement with a colleague or manager.\n- Describe a time when you needed to influence a peer who had a differing opinion about a shared goal.\nYou can read more about how Amazon defines these LPs\nhere.\nAmazon's interview process involves a)\nbehavioral interview rounds and b)\ntechnical interview rounds with a few behavioral questions thrown in. The behavioral questions will all focus on your work history. Importantly,\nAmazon will decide whether or not to hire you and how much responsibility to give you based partly on how well you demonstrate their Leadership Principles when you discuss your work history.\nWhat Amazon assesses is consistent between interviewers. Each interviewer will be assigned 1-3 LPs to look for when interviewing you. They're searching for signals on whether you: meet the bar, raise the bar, or are below the bar (for their assigned LPs).\nBut\nhow Amazon conducts the behavioral round varies widely. Our research has shown that if you were to observe sessions of 10 different LP interviewers, you would discover that each interviewer has their own way of determining a candidate's fit. One interviewer might ask more questions on fewer topics, while another interviewer may do the opposite. Complicating matters, upon observing the same behavior, different interviewers will likely perceive different signals. Notably,\nthere is no consensus on what makes a good answer good.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/amazon-leadership-principles",
      "author": "",
      "user_id": ""
    },
    {
      "title": "System Design Interview Guide for Senior Engineers",
      "content": "You may be reading this guide because you recently failed a system design interview. Or you watched a YouTube video that made system design seem like an overwhelming topic you’ll never fully grasp. Or perhaps you have years of experience working in the field, yet you struggle to demonstrate your technical prowess in the brief span of a system design interview.\nProfessional experience with distributed systems isn’t needed to pass system design interviews. And even if you do have that experience, keep in mind that many talented distributed systems engineers still struggle with the system design interview format. How you perform in an interview is not a measure of your worth as a software engineer—it is a measure of your ability to do system design interviews. The two are related but not equal; being a good programmer has a surprisingly small role in passing interviews.\nOne of our experts was asked: “As an experienced engineer without any scalable systems experience, how can I go into something like a FAANG system design interview when I have never designed those systems before?” Here’s the expert’s reply:\n\"I worked at Facebook for five and a half years. I learned more about system design from reading the internal interviewing wiki than I ever got from working at Facebook. They've got all kinds of distributed systems knowledge there, and it’s concentrated in a handful of infrastructure teams who build really great libraries and really great backend systems. That means that the rest of us never have to think about distributed systems. We get to say, 'I'm gonna make a new data type, and if I dump a billion records in it tomorrow, it doesn't matter. The systems folks have my back.' I worked at Facebook for a really long time, but I learned almost nothing about designing systems from experience.\"\nYou can pass system design interviews even if you’ve never designed distributed systems before. If you have copied files between machines with drag-and-drop, you are halfway there. If you implemented clients or servers or have opened network connections, you’ve got this. This guide will teach you the most important 20% of information that will appear 80% of the time in system design interviews. By the end of this guide you won’t be an expert, but you’ll be well on your way to being a better engineer and a much better interview candidate.\nWant to know exactly what a FAANG System Design interviewer looks for? Get detailed feedback on your system design skills from our professional interviewers.\nSee available timesIn this excerpt taken from Design Your Life, written by two Stanford professors and engineers, you’ll get a better understanding of how different problems require different approaches. We bolded to emphasize the parts that are most important to note.\n“There’s a difference between design problems and engineering problems... Engineering is a good approach to solving a problem when you can get a great deal of data and you’re sure there is one best solution. Bill [one of the authors] worked on the problem of engineering the hinges on Apple’s first laptops, and the solution he and his team came up with made those laptops some of the most reliable on the market. The solution required many prototypes and lots and lots of testing, similar to the design process, but the goal of creating hinges that would last five years (or opening and closing ten thousand times) was fixed, and his team tested many different mechanical solutions until they met their goal. Once this goal was met, the solution could be reproduced millions of times. It was a good engineering problem.\n“Compare this with the problem of designing the first laptop that had a ‘built in mouse’. Because Apple’s computers relied on the mouse to do almost everything, building a laptop that required you to be wired up to a regular mouse was unacceptable. This was a design problem. There was no precedent to design toward, there was no fixed or predetermined outcome; there were plenty of ideas floating around the lab, and a number of different designs were tested, but nothing was working. Then along came an engineer named Jon Krakower. Jon had been tinkering around with miniaturized trackballs, and had the crazy idea to push the keyboard to the back of the unit, leaving just enough room to squeeze in this tiny pointing device. This turned out to be the big breakthrough everyone had been looking for, and has been part of the signature look of Apple laptops ever since.\n“When you have a desired outcome (a truly portable laptop computer) but no clear solution in sight, that’s when you brainstorm, try crazy stuff, improvise, and keep ‘building your way forward’ until you come up with something that works. You know it when you see it. A great design comes together in a way that can’t be solved with equations and spreadsheets and data analysis. It has a look and feel all of its own - a beautiful aesthetic that speaks to you.”\nThis is one reason engineers new to system design can bomb their first couple of system design interviews spectacularly: They approach a design problem as if it’s an engineering problem. There is not a single “best” solution to a system design problem. There are no predetermined outcomes. The less code you write in a system design interview, the better.\nTo succeed in a system design interview, you want to collaborate with your interviewer, try crazy stuff, and try more crazy stuff until the design “feels right.”\nThe difference between coding and system design is the difference between retrieving and creating.\nInstead of finding (or “retrieving”) a solution, you are creating a solution. In this way, coding is akin to a science, while system design is more like an art.\nHere’s another way to think about it. You aren’t solving a problem—you’re creating a map to help someone else find the solution. Instead of coloring inside some lines, you’ll need to draw the lines for someone else to color in. In a system design interview, there are no correct answers—though there are certainly incorrect ones—so there is nothing to solve. Instead, you’ll ask questions, make stuff, and explain how and why the stuff you made was reasonable.\nDuring the interview, you’ll spend an hour playing the role of a Tech Lead, so just pretend that the interviewer is a junior engineer who will be implementing your design. Juniors will have lots of questions, and since you’re the Tech Lead, you want to welcome these questions.\n“Pretend it’s 1999, so a lot of the stuff we have access to today simply doesn’t exist. You and a group of your schoolmates are in your garage, hoping to make something. You're the most senior one there. You will design it and your friends will code it up, and the thing is: the Minimum Viable Product has to be completed by tomorrow. So, there’s no time to prep and no need to worry about the intricacies of system architecture that you don’t know. Just answer this: How would you design this system so your friends could code it up today, right now? It doesn’t have to be pretty. It doesn’t have to be complicated. It doesn’t have to impress anyone. It just has to get done.”\nThe value of communication in coding interviews is controversial (source). But without communication in a system design interview, nothing happens. By necessity, it’s more conversational in nature than a coding interview and will have more back and forth between interviewer and candidate.\nWith that said, sometimes you’ll have an interviewer who is cold or not very collaborative. Dealing with these interviewers requires practice. The more senior you become, the more important it is to learn how to adjust your communication style to match your audience. We recommend completing mock interviews with a variety of interviewers to help you become a seasoned, fearless veteran of system design interviews.\nThere’s no “right” way to design a system. If two experts designed the same system, you would see two different designs, beautiful and aesthetic in their own way and both as “correct” as the other (and with the accompanying justifications to support them).\nIn part 2, two experts will show you how they would each design the same system, providing you with a practical lesson on this topic.\n“If you want to be a great interview candidate you’ve gotta know… It’s your responsibility to leave breadcrumbs for the interviewer to go where you want them to go. That way you have them walk you down the road where you are at your best. And then the Jedi mind trick is to get them to think it was their idea to get you there.”\nWhat if your measurement of success in an interview isn’t what you say, but instead it’s what you get the interviewer to say? Imagine you say something that engages the interviewer’s curiosity so much that they have no choice but to follow up with a “tell me more about that.” If the areas you get them to dig into the deepest, are things you’re good at: congratulations you are doing the Jedi mind trick.\nA candidate doing a system design interview will usually experience confusion. The interview format is so open-ended, you cannot know about everything they'll ask you. However, there will be opportunities to strut your stuff. There will be moments when they ask you about something you know very well, and when this happens put your shoulders back and flex your muscles on this topic.\nWhen beginning an interview, try to imagine what the interviewer is looking for. What are their goals for the session? How can you help them achieve those goals in a way that persuades them that you’ll be a strong hire?\nPut simply, the interviewer's goal is to find enough data to hire you. Given the limited time available to them, an interviewer has to try to get enough positive signal about your ability so they can justify giving you a “hire” rating. In one hour you have to show your interviewer that you understand the fundamentals of a system (end to end). You also should be able to name and explain (at least at a high level) each part of the system, describe the tradeoffs you make, and find a solution.\nThe best way to accomplish this is to imagine that you’re explaining a design doc to a group of more junior engineers. They will ask you questions about your decisions and want to know what you’re trying to solve. Anticipating these questions and your responses will set you up for success in the interview.\nWant to know exactly what a FAANG System Design interviewer looks for? Get detailed feedback on your system design skills from our professional interviewers.\nSee available timesWith this basic model in mind, let's consider the main elements that system design interviewers look for, and the elements that don’t matter.\nYour interviewer will expect you to have knowledge of a wide range of basic topics, but they won't expect you to be an expert in any of them. For instance, you should understand the difference between SQL and NoSQL databases, their broad performance characteristics, and the types of applications each might be useful for (which we’ll teach you later in this guide). But you would not need to know how the internals of either type of database work at any kind of detailed level.\nIn spite of this, you still might be asked to design those internals! Keep in mind, though, that your answer doesn't need to be optimal or reflect real-world implementations. For example, if an interviewer asks you to design a database/SQL query engine, they're not trying to discern if you're familiar with the academic literature on query engines or discover how much time you've spent working on database internals.\nInstead, they want to see how you would approach the problem based on what you do know, starting from first principles and collaborating with them. Your answer will probably not be anywhere near optimal, and that's OK! The interviewer will focus on the process, not the result.\nInitial prompts to system design problems tend to be intentionally light on detail. Many candidates make a mistake by extrapolating details from the initial prompt and crafting a solution based on those assumptions.\nFor example, imagine that the interviewer instructs you to design a \"photo sharing service\" with some minimally defined capabilities. This may cause some candidates to imagine that they're rebuilding Instagram and start designing around the assumption that all images will be relatively small, not examined closely, and that extensive compression to save storage and bandwidth is acceptable.\nBut the interviewer didn’t tell you to rebuild Instagram, so you’ll need to keep in mind that there are many different types of photo sharing services. The interviewer may have had in mind something like Imgur or Photobucket, sites that cater more to basic image hosting for the web. Or they could be thinking about something like Flickr or 500px, services built for photographers to show off their work in high resolution.\nSo how do you figure out what type of service the interviewer wants you to build? Ask them! A basic prompt leaves room for you to start a conversation with your interviewer about the system you're designing—what type of users does it serve, what type of traffic can it expect, what limits will it have? Demonstrating that you can think critically about the parameters of your service is the first step in any system design interview.\nBe very careful any time you find yourself responding immediately to a prompt in a system design interview. Even aspects of your design that seem insignificant need at least cursory consideration. Let’s use IDs as an example.\nA candidate will often start a discussion of a data model with a statement like, \"I'll use auto incrementing IDs,\" or \"I'll use GUID here\" as kind of a default approach to assigning IDs to data. In many applications, however, the type of ID you assign to your data has practical consequences.\nIs this ID going to be exposed to users? If so, how long does it need to be to avoid collisions? If we auto-increment it, are we worried about the visibility that will give third parties into our traffic patterns or the possibilities of users guessing the IDs to each others' data? If it's intended to be shared, is it convenient to type? If you print it on a business card or a flier, does it contain characters that you could confuse for each other (e.g., “1” and “I”, “0” and “O”)?\nYou don't need to hold an inquiry for every minor detail, but always be sure to give some justification for the decisions you make and let your interviewer know how your decisions would change in different circumstances. System design problems don't have a single definitive answer, so interviewers just want to see that you can justify your answers.\nCoding problems usually have an expected path. Typically you'll begin with an obvious but inefficient solution, and then the interviewer will prompt you for a series of improvements. Those improvements lead you to increasingly efficient solutions until you finally arrive at the optimal implementation.\nSystem design problems, on the other hand, resemble a Choose Your Own Adventure book rather than a linear novel. A complex system contains a multitude of sub-components, each one of which could serve as a design problem on its own. After you've sketched the overall layout of your system, an interviewer may decide to keep your focus on the big picture or dive into a deeper examination of one particular component.\nThe path your interview takes will be steered by your interviewer, but they're likely to take cues from the sub-problems in which you display interest or aptitude. In some cases they may explicitly ask you which part of the problem you'd prefer to focus on.\nEven if you're not choosing directly, you can still influence an interview's direction. As you talk your way through a solution, it’s OK to specifically note the parts that you have experience in and explain when you're making educated guesses. Your interviewer won't expect you to know everything, but giving them a better idea of what you do know will help them steer the interview in ways that reveal your strengths and problem-solving ability.\nWhen faced with a choice in a design interview, it's easy to focus on the technical details, but remember that computer systems serve human users, so you’ll want to anchor your technical decisions to the user experience they enable.\nSuppose, for instance, that the image sharing service you're designing will require users to log in before uploading an image. In technical terms, you might want to avoid login to keep the database schema simpler, or you could introduce login to gather better metrics. An anonymous experience may be best for a public image-hosting site intended for quick turnaround and low interaction, while a logged-in experience offers the possibility of community features like commenting and sharing, personalized metrics, and the ability to restrict an upload to authorized viewers. You may want to take either approach or even both, allowing a limited anonymous experience with extra features for logged-in users.\nThe important thing is to discuss the possible approaches and their consequences for the user experience with your interviewer before making a decision. You can never go wrong by making the end user the driving force in your design.\nThink of red and green flags as signposts you can use to orient yourself in the interview. Green flags indicate that things are going well, that you're engaging with the interviewer and making a positive impression. Red flags warn you that you may be going astray and should try to get the interview back on track.\nFollowing this quote’s advice has steered many interviewees in the wrong direction. There is no game, and talking for the sake of talking is one way to hang yourself with the rope the interviewer gives you. Also, if the goal is to not explode, well, you’re wasting your and your interviewer’s time.\nAs we mentioned earlier, this guide will teach you the basic information that you’ll be asked about in 80% of system design interviews. Although these are great odds, you still may encounter a scenario that’s beyond your level of understanding. If this happens to you, don’t worry! Just engage in an honest dialogue with your interviewer, explaining when you lack certain knowledge or have gaps in your understanding. When you do have a sense of how to proceed, but you’re uncertain, you should communicate from first principles. Later in this guide, we will explain how to overcome that uncertainty and still score points with your interviewer.\nKeep in mind that your interviewers use the same problems over and over again, and they frequently see candidates make the same mistakes. If they try to divert you from a course of action, it's likely because they've seen others flounder when using the same approach. You may be the one candidate in a hundred who finds a unique and better solution—we've had this happen before!—but carefully consider the odds before proceeding with a solution against the interviewer's advice.\nWith that said, there is an art to pushing back against your interviewer when the situation calls for it, and later in this guide we’ll teach you how and when to employ this strategy .\nWhen the interviewer offers feedback, you integrate it into your design. You ask probing questions and receive useful answers about the system you're designing, its users, and its traffic. Try to establish a tone as if you were working through a problem with a coworker rather than proving yourself to an interviewer. In the real world, when you’re assigned a project, you’ll have to ask a variety of people several questions to ensure that you fully understand the problem before making decisions. That’s what interviewers want to see.\nIt's OK to not know things—no one will have every answer—but it's better to admit that to your interviewer than to avoid the questions altogether. Your interviewer may be able to offer you a hint or help you reason about alternatives if they know you're struggling, but if you skip right ahead you'll miss the opportunity to provide them with any positive signal from that portion.\nIf you’re looking for a mid-level position or below, your interviewer should determine the direction and speed of the interview. Given an initial overview of your design, they may ask you for clarification on some aspects of it. They may ask you to produce a more detailed design for one or more components. And they may also change the requirements and ask how you could adapt your solution to accommodate this new view of the world. Wherever they take the interview, follow along and focus on the areas they direct you to.\nIf you’re applying for a senior role (or above), it’s a good sign if you direct more of the interview. In junior system design interviews, the interviewer expects to drive the interview, but as you reach senior levels the expectation shifts to the interviewee.\nBeing overly confident and talking too much might count against a mid-level candidate. Some interviewers (especially off-script ones) love giving candidates more rope to hang themselves with, and then they ask specific questions that focus on what the candidate struggles with.\nIf your goal is to maximize a mid-level offer, not improve your \"average passing rate\" (i.e., if you are comfortable sacrificing some senior-plus chances to increase your mid-level chances), then you might be better off consciously \"giving control away\" to your interviewer.\nSimply put, at the above-senior level an awkward pause will be held against you—that’s basically guaranteed. But at mid-level, most of your attempts to fill in an awkward pause may hurt you more than keeping silent.\nAnother way to think of it: when you are not leading the conversation, you signal that you’re not really far above mid-level. (But if you are comfortable at mid-level, this is not a downside!)\nThe saying, ‘Better to remain silent and be thought a fool than to speak out and remove all doubt’ can be true for mid-level interviews but not for seniors or above-senior.”\nIf you're struggling to provide an answer, give yourself a little bit of time to come up with something. If you're truly stuck, however, you should ask your interviewer for help. They can't tell that you're at an impasse unless you tell them, and you may waste valuable interview time while they debate whether it's been long enough to interrupt you.\nAn interview doesn't need to be a continuous stream of consciousness, and it never hurts to sanity check your ideas before verbalizing them.\nIn Part 4 of this guide, we’ll teach you how to get unstuck and exactly what to say when you’re stuck.\nOften, candidates will say things like: “we could use this type of DB, or this other, or that other, and these are some pros and cons…” and then they move on to another component. It’s a good practice to talk about benefits and tradeoffs, but then you have to make a decision. In the real world you have to make decisions—the same thing applies to the interview. If the interviewer challenges you with some questions, it’s totally fine to change your mind and alter the component (if you think there are better choices).\nWe could use this type of DB, or this other, or that other, and these are some pros and cons…\n\"We could use this type of DB, or this other, or that other, and these are some pros and cons… And based on all these tradeoffs, I’ll use THAT type of DB.\"\nDon’t say things because you think you’re supposed to say them. This often occurs when candidates name specific brands of technologies (e.g., “Kafka” or “Cassandra”). Not being familiar with specific databases or other components is fine. Be smart and don’t say brand names just for the sake of saying them.\nI’m going to use Cassandra...” unless you are VERY familiar with that, because the next question will be: “Why Cassandra and not some\\_other\\_db?\nI’m going to use a NoSQL db because of [insert brief rationale].\nI will use Kafka…” unless you’re prepared to explain how Kafka works. Don’t say “I will use Kafka” unless you are prepared to talk about other types of queues, because they may ask you: “Oh, Kafka, interesting choice. Why that instead of [some other queue]?\nI will use a queue because of [insert brief rationale].\nSay the generic name of the component, not the brand name unless you are very familiar with it. Don’t say Kafka. Instead, say “a queue.\nYou finished Part 1! We hope you gained a basic understanding of the system design interview and learned some tips and tricks you can use to excel in it. As you continue reading Parts 2-4, these “glimmers” of understanding will become more and more the default system of your interviewing skills.\nIn Part 2 we’ll teach you the 15 fundamental system design concepts. You’ll also get to watch our long form video of two system design experts designing the same system. They’re tasked with designing interviewing.io, which in this challenge is actually three systems in one: “Design google docs, a remote compiler, and a recording service… in 30 minutes or less.”\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/system-design-interview",
      "author": "",
      "user_id": ""
    },
    {
      "title": "A Senior Engineer’s Guide to FAANG Interviews",
      "content": "There are lots of guides out there to FAANG interview processes. This one is the most thorough and the most detailed because it’s the only one made by interviewers for candidates – we spent hundreds of hours talking to dozens of current and former FAANG interviewers about their processes. Throughout this guide, you’ll see a bunch of direct quotes from these interviewers, where they describe the idiosyncrasies of each company’s process and bar in their own words. We’re fortunate to have them in the interviewing.io community, and we’re lucky that we can collaborate with them on this type of content. As you can imagine, they all requested to stay anonymous, but we want to thank them here, first and foremost.\nFAANG interviews are a gauntlet, but you can pass them even if you doubt yourself – interviewing is easier once you learn a company’s operating metaphor. George Lakoff (neuroscience and artificial Intelligence researcher) says that every human organization has a metaphor they operate as. If you ask an employee at a FAANG company about their metaphor, you’ll probably receive a blank stare in return. But if you look at the interviewing data of that same FAANG company, the metaphors jump out of the data set like bread out of a toaster.\nThis guide will walk you through all the FAANGs’ metaphors and the unwritten codes of those metaphors: what they reward, what they punish, and what they’re blind to. To show them you’re obviously a part of their tribe, model their metaphors and unwritten codes.\nMetaphors aside, this guide will also walk you through the unglamorous logistics of every FAANG’s interview process so that you know how many steps there are, what those steps entail, and what kinds of questions they ask. Our goal is to have you walk in and be completely unfazed by the proceedings because you’re expecting them.\nOf course, even with all the insider info in the world, if you’re not prepared for technical interviews, you will fail, so we’d be remiss if we didn’t share some useful insights about practice to help you on your journey.\nThere are 3 steps to getting a strong offer at FAANG.\nSteps 1 and 3 are out of scope for this post, which is solely focused on Step 2.\nMoreover, this guide is written for experienced, back-end leaning engineers – interview processes are usually different for juniors, but we won’t be getting into those differences. Finally, we won’t be getting into the differences in process for front-end engineers, SREs, etc. That said, if you’re targeting those roles, you’ll still get value out of this guide.\nIn Part 1 of this guide, we’ll highlight key similarities and differences between the FAANG companies, namely:\nIn Part 2, we’ll go through each company one by one and tell you how each of their processes work and how to prepare for each one.\nIf you’re planning on interviewing with multiple FAANGS, we recommend reading Part 1 first. If you'd prefer to skip straight to a company’s individual guide then just click on it in the table of contents to the left! Individual guides include more detailed information on company-specific coding interviews, behavioral interviews, and anecdotes from actual interview experiences.\nAll of these big tech companies share grueling interview processes, strong initial compensation packages, and above average benefits. They compete with each other for the same engineers. If tech has a food chain, they’re at the top. Most other tech companies copy or are influenced by what FAANG does.\nThere are also a number of myths about FAANG interview processes. Two big ones are that Amazon has the lowest bar, and Google has the highest bar. That’s not true; we have the data. The reality is that all of their bars are different. It’s not a linear comparison. It’s a multidimensional comparison. Because of that, it’s impossible to say something like, “The entire process at Google is harder than the entire process at Amazon.” They’re simply different processes.\n“My friend interviewed at Google and Facebook, and he passed both loops. At Google, he was offered L6. At Facebook, he was offered L4. Speaking about luck: this is the same person with the same experience. And the level of difference– at two of the most trusted names in tech–was two levels of seniority.\nAnd one common idea in big tech is that Google’s process is easier than Facebook’s. But you can see here: it really depends. After all, this person accepted the L4 role at Facebook because the compensation package was bigger than the role at Google for L6.”\nLong story short: it’s complicated. That’s exactly why we wrote this guide: to demystify the differences, to decouple the 6-headed monster, and to demonstrate how to attack each head, one at a time.\nThis is the ultimate insider’s guide to tech interviews at FAANG. However, even with all the insider info in the world, if you’re not prepared for technical interviews, you will fail, so we’d be remiss if we didn’t share some useful insights about practice to help you on your journey. Yes, we know we’re a practice platform, and, look, you don’t have to practice with us. But you should practice! Here’s why.\nThree different startups with robust data sets on software engineering interviews found eerily similar data points about what happens after you do five technical interviews. I worked at all three companies and saw this data myself.\nMind you, these datasets were quite different: Triplebyte skewed towards folks with nontraditional backgrounds, interviewing.io inclined towards senior backend engineers, and Pathrise was mainly junior engineers. Despite that, the number five emerged across these data sets, and it’s clear that something happens after you complete five technical interviews. We can’t explain what yet. But the data is screaming in all caps: there is a there there. One more anecdotal point: these five interviews should ideally mimic the real thing as much as possible. For instance, if you want a FAANG job, but your five interviews are with startups that don’t ask algorithmic questions, you won’t get as much value. The more your practice can simulate the real game, the better.\nIf you’re unprepared for a FAANG interview, ask to reschedule. Not rescheduling is the number one mistake we see our users make! Getting an interview tomorrow (as opposed to 1-3 months from tomorrow) is, in most cases, no different to the company… but very different to you – if you fail, you might get frozen out for months. In the rare cases where rescheduling could hurt your chances because it’s a specific role for a specific team, your recruiter will tell you that. Either way, there’s no harm in asking.\nRecruiter calls don’t differ much from FAANG company to FAANG company, so we decided to put everything about what to expect in a recruiter call in one place. If a recruiter call ever meaningfully deviates from this format, we’ll mention it. Otherwise, expect that it doesn’t.\nA recruiter call is the first step of almost every process. In this call, a recruiter will ask you about your past experience, your salary expectations, and why you’re interested in that particular company. They will also ask you about your timeline (how soon you expect to accept an offer), how far along you are with other companies, whether you have outstanding offers, and so on.\nIn this call, it’s important to be able to succinctly talk about your past few positions, your major contributions at those positions (what did you do individually versus what did your team do) and their impact on the business. Remember that most recruiters don’t have a technical background and they’re not software developers, so it’s important to be able to describe your technical contributions in clear layman’s terms.\nIt’s also really important, at this stage, not to reveal your salary expectations, your salary history, or where you are in the process with other companies. We wrote a detailed post about salary negotiation that lays out exactly what to say when recruiters pressure you to name the first number. Just don’t do it – when you give out information this early in the process, you’re painting future you into a corner.\nThis section will give you a feel for how these companies’ processes differ. For now, don’t worry about how that translates into interview prep – we’ll cover that later when we describe how to prepare for each company.\nTake a look at the chart below. In it, we rank the FAANGs on their “Chaos Score”. The more points a company has, the more chaotic they are.\nIn this context, we define “chaos” as the level of uncertainty and unpredictability that candidates can expect from the interview process and its outcomes. If a company consistently follows the same process, asks the same questions, and thoroughly trains their interviewers, they are not chaotic. If their process is completely non-standard, non-deterministic and subjective, they are chaotic.\n| Company Name | Chaos Score |\n|---|---|\n| Apple | 20 |\n| Netflix | 20 |\n| Microsoft | 18 |\n| Amazon | 12 |\n| 10 | |\n| Meta | 3 |\nAs you can see, Apple and Netflix win the award for the most chaotic interview processes in FAANG. Microsoft gets 2nd place. Amazon gets 3rd, Google 4th, and Facebook 5th.\nChaos can be pain or pleasure depending on your tolerance for uncertainty. Chaos can also either impose a terrible detriment or prove a huge advantage in interviews specifically. For instance, candidates who have spent a long time grinding on LeetCode might prefer less chaotic companies. More chaotic companies can work for candidates for a few reasons: a) niche skill sets can be an easier match for niche interview processes, b) practical interviews are more likely, and c) the interview process shows them how the team they’d be joining actually operates.\nTo calculate each company’s Chaos Score, we picked four categories and graded each company on a 0 to 5 point scale in each category, where 5 means most chaotic and 0 means least.\nWe added up the points for each company, with a maximum possible Chaos Score of 20.\n| North star | Team dependent process? | Level of training for interviewers? | Level of standardization? | |\n|---|---|---|---|---|\n| Apple | Why (5) | Yes (5) | None (5) | None (5) |\n| Netflix | Why (5) | Yes (5) | None (5) | None (5) |\n| Microsoft | How (3) | Yes (5) | None (5) | None (5) |\n| Amazon | What (1) | Yes (5) | High (2) | Low (4) |\n| How (3) | No (0) | Medium (3) | Low (4) | |\n| What (1) | No (0) | Highest (1) | Highest (1) |\nBy “North star”, we mean what a given company values most. As such, we grouped companies into 3 buckets: companies who primarily care about \"Why\", \"How\", and \"What\".\n“Why” is the most chaotic because judging motivations is the most subjective approach. “How” is the second most chaotic because judging thought processes is the second most subjective. “What” is the least chaotic because judging end results is the least subjective method.\n“Why” companies can’t agree on what a good “why” looks like because it’s a “gut feel / friend test”. Whom you consider to be a friend and who gives you a good gut feeling isn’t quantifiable. It’s completely subjective. “Why” companies are the most prone to bias. If you speak their language and model the behaviors they encourage, you’ll seem like a friend and give them a good gut feel. If you don’t, then you won’t.\nIf chaos is hell, then “Why” companies are raising hell for candidates and themselves.\n“How” companies mainly care about your thought process: Okay, you didn’t get to the optimal solution, but what was the journey like? Google and Microsoft repeat this mantra again and again – they want to know how you think. You might get asked a really hard or specific question, but they don’t necessarily require an optimal answer to pass. They put far more weight on your ability to demonstrate a solid thought process.\n“What” companies mainly care about your results, such as: Did you get to the optimal solution? Facebook and Amazon want you to get there, and fast. “What” is the most straightforward for candidates: simply get results as quickly as possible.\nA Google or Facebook interview doesn’t change depending on the team you’re interviewing for. Both companies have one big, centralized interview process that’s completely divorced from which team you might end up on. If you do well in the team-agnostic process, there will be a team matching component after the onsite. You will NOT, however, be interviewing with your future coworkers.\n(Note: Google is rumored to be changing to a team-dependent process, but we’ll leave that where it is for now.)\nAt Microsoft, Netflix, Apple, and Amazon, the process is team-dependent. You’ll not only be interviewing with the people that you’ll be working with, but there’s more chaos. Each team defines how they do things: the types of questions asked, the types of interview rounds, and even how they make hiring decisions.\nTeam-dependent processes are more challenging in the sense that you're more likely to get blind-sided; because each team has a different process, candidates are more likely to prep for X and get (a significantly different) Y.\nYet, team-independent processes are more challenging because of the machinery. Your interviewers are so far removed from you. That detachment affects how they treat, judge, and talk about you.\nThink of it like this: At Netflix, Apple, Amazon, and Microsoft you’re interviewing with humans. At Google and Facebook, you’re interviewing with a machine.\nFacebook is the least chaotic company in this category because they have the most in-depth interviewer training in FAANG. Their process is rigorous and selective. Though most would-be interviewers pass within 6 months, some people who try never pass the bar to become an interviewer. Facebook is the only FAANG where this is true.\nFacebook and Amazon put interviewer candidates through roughly the same things, but Facebook is more rigorous. For example, both will have similar modules interviewers go through in training. A module at Amazon is more likely to be a box to check: if you do it, you pass. At Facebook, you don’t pass simply for doing it: you pass by meeting a predetermined bar. Also, Facebook modules are more likely to have a rubric.\nGoogle used to have a more in-depth interviewer training process than what they have now. For whatever reason, they began to skimp on their interviewer training roughly sometime in the 2010s. Now, Googlers can get a bit of training, but usually not as much as folks at Facebook or Amazon.\nNetflix, Microsoft, and Apple do not train their interviewers; certain teams may be exceptions but there’s no company-wide required interview training. The day you start, you can start interviewing. That makes them the most chaotic in this category.\nWhat this means for candidates is that the less training they put their interviewers through, the more likely you’ll have a bad interviewer. As the old saying goes: “Prepare for the worst, pray for the best.”\nCompanies that standardize their interview questions give interviewers less free reign; groups with no standardization have more free reign. At all companies, there will be interviewers who go rogue and deviate from the norm. Yet, each company has a norm.\nFacebook wins again for being the least chaotic/most predictable. In behavioral rounds, interviewers at Facebook can ask whatever behavioral questions they want. However, in technical rounds, they can only ask pre-approved coding questions. They can also modify pre-approved coding challenges. That’s it.\nGoogle is tied for the second least chaotic here; their interviewers have free reign in technical rounds. They have a large technical question bank, yet interviewers routinely make up their own ambiguous one-of-a-kind questions. In behavioral rounds, they can only ask or modify pre-approved questions.\nAmazon is tied for second least chaotic, but for a different reason. Technically, there’s no standardization for any round (technical or behavioral). They do, however, tend to repeat questions from their internal question bank (which is not required for interviewers to use.)\nMicrosoft, Apple, and Netflix are the most chaotic companies. Each team decides what to ask. Questions tend to be customized to the hiring manager’s preferences, a senior individual contributor’s diligence, what this team works on day-to-day, or the specific domain this team is in.\nWhether you get one shot or unlimited shots to land an offer changes how you prepare. Here’s the breakdown of which companies let you interview with multiple teams concurrently.\n| Company Name | Can interview with different teams concurrently? |\n|---|---|\n| Apple | Yes |\n| Netflix | Yes |\n| Microsoft | Yes |\n| Amazon | Yes |\n| No | |\n| Meta | No |\nIf you can interview with multiple teams concurrently, then they don’t have a cool down period. So, after you fail, you don’t need to wait at all to reinterview. Two of the biggest players only give you one shot to win, and at the remaining four your chances are unlimited.\nBecause their interview process is centralized, Google and Facebook are the only ones well-organized enough to not let candidates “double dip”.\nIf you really want a job at Netflix, Apple, Amazon, or Microsoft: stack the odds of landing your dream job in your favor and interview with multiple teams. There’s no cool-down period, so if you get rejected from Team A, you can interview with Team B tomorrow.\nIn Part 2, we’ll give you a deeper feel for each company, and we’ll tell you what to do about it. Each company has its own section, and each section is organized into five subsections:\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Google Interviews + Questions",
      "content": "Google’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Google? Do anonymous mock interviews with real Google interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Google’s job interview process, evaluation criteria, and interviewers.\nAll human organizations behave like a metaphor; Google isn’t a sports team, or a family, or an army. It’s a cool grad school. Larry and Sergey set up their offices based on the model of a Stanford campus on purpose. They wanted to create an environment and company culture where people can feel chill enough to talk about anything. In general, Google interviewers tend to be more collaborative than other FAANG interviewers. At Google, the slower you go, the faster you get there.\nGoogle has one big, centralized interview process that’s completely divorced from which team you might end up on, which means that you will NOT, however, be interviewing with your future team members – Google has a horde of interchangeable technical interviewers who have all been trained on the same process. If you do well, there will be a team matching component at the end.\nAt Google, because the process is centralized, you cannot interview with multiple teams concurrently, which means you don’t get multiple shots on goal. Not only that, but Google has a limit for how many chances they’ll give you before you’re blocked from interviewing again.\n“You can interview three times in 5 years. If you fail all three times then you can’t interview at Google again: you’re blocked.”\nNote that recently, there have been rumblings of Google changing their process to something more decentralized, where a hiring manager chooses you for a team before you interview, nullifying the need for post-onsite team matching. As far as we know, this new model is being tried out right now, but the change hasn’t been adopted company-wide.\nGoogle also has rules for candidates who pass their interviews:\n“If you pass Google’s onsite, and end up not taking the offer, your “passing of the onsite '' is good for about a year. And if you choose to re-engage in that time, the process varies widely. Usually you can skip the phone interview. Most times you have to do the full or partial onsite. If you choose to re-engage, tell their recruiters ‘I already passed the onsite’ and push to get as many steps skipped as you can.”\nGoogle is not results-oriented. They’re process oriented. In other words, they care more about the “How” than the “What”. You’ve heard it before, and it’s true – they don’t need you to get to the optimal solution, but they do need to be impressed by your thought process. Because of this, Google is more attracted to comfort with ambiguity than speed.\nOddly, in spite of using a centralized interview process, Google doesn’t have in-depth training for its interviewers; it may surprise some candidates that there’s a larger-than-expected number of bad interviewers at Google.\n“There is one thing that always bothered me about the Google interview process. And it's something that a lot of candidates don’t realize. There are a lot of bad interviewers at Google. Mostly because there are a lot of highly talented people who think they know everything.\nI was the interviewer for the third interview round at in-person onsite. And I saw the candidate was there by himself; the second interviewer wasn’t there. The candidate was alone because the second interviewer got frustrated – they thought the candidate wasn’t worth the time for an onsite, so they left early.”\n“Google is more likely than Facebook to design questions on purpose to be tricky. At Google, sometimes this is intentionally disguising technical questions to look like X but they’re really Y. And other times at Google, it’s designing a technical question such that if a candidate doesn’t ask a particular question they likely won’t get the answer.”\nPlease see the section above called “A note about recruiter calls”\nGoogle’s technical phone screen is a coding interview that focuses exclusively on data structures and algorithms questions. Your interviewer will ask you to write code to solve a specific problem.\nOne idiosyncratic aspect of Google’s process is their insistence on using Google docs for writing code (versus other companies which tend to use tools like CoderPad). This can be a bit jarring for those of us who are used to writing code in an IDE that does things like auto-indentation, auto-complete, syntax highlighting, adding missing parentheses or brackets etc. Despite not using an IDE, your interviewer will expect you to produce syntactically correct code. This is really hard.\nBefore your Google interview, you should practice in Google docs so you don’t forget to close parentheses or indent your code.\nThat said, more recently, Google has started interviewing using an internal tool with syntax highlighting, indentation and brackets completion. Whether you get to use it or not depends on your geography.\nThe second phone screen happens only if the first one did not produce enough signal to move forward. Perhaps you didn’t communicate your thought process well enough, your code wasn’t of good enough quality, or you weren’t fast enough – but it’ll be only one of these – if you struggled with two or all three, most likely you aren’t moving forward.\nIf you do get scheduled for a second phone screen, push your recruiter to give you detailed feedback so you can do better the second time – nothing beats knowing exactly where you need to improve. You probably won’t get a response, but if you do it’s a large boost to your prep.\nIf you get a second phone screen it will be very similar to the first in terms of structure and content.\nThe Google onsite usually includes 4-6 rounds. Recently, there have been some internal experiments with the format, but generally the rounds are primarily coding, and secondarily system design. Some candidates get a single behavioral round, and others get to skip it.\nThe more experience you have, the higher proportion of system design and domain-specific questions you can expect to be asked.\nAs we mentioned above, Google is process-oriented rather than results-oriented. As such, communication during coding and system design rounds is more important at Google than the end result.\nThe most important rounds at Google are coding. In fact, Google is the only FAANG company that considers coding to be more important than system design. Google’s coding rounds are about complexity more than speed. Their interviewers are allowed to ask anything they want, so it's more likely you might get a question you’ve never practiced before.\nGoogle interviewers are more likely than any other FAANG company to purposefully design a question so it tricks candidates. For example, they’ll disguise a question to look like it’s Three Sum, but that’s a red herring – it’s not a Three Sum problem. It just looks like one.\nA lot of what you’ll see in the onsite coding mirrors what you saw in the technical phone screen. During the onsite, you may see your interviewer layer more complexity on top of questions – they’ll design a question where they plan for you to get to the solution, then when you do they’ll move the goalposts and say something like: “Remember that assumption we made earlier about [X thing]? Let’s remove that. How would that change your approach?”\n“At Google, I’ve passed more people that arrive at the optimal solution without coding it than I do people who arrive at the optimal solution and code it. The actual code you write is less important than the thought process.”\n“Google is highly unstructured. Everyone can ask whatever they want.”\nEven though they can ask whatever they want, Google interviewers have a question bank too, but the bank is much much bigger than Facebook’s bank and, like Facebook’s bank, it’s community maintained. Some interviewers never deviate from the bank, and others don’t touch it, preferring instead to formulate their own unique questions..\nThis speaks to Google rewarding the “how” (aka “how a candidate got there”) or their thought processes. It also speaks to Google rewarding comfort with ambiguity. Other FAANGs have specific niche topics they love hearing and talking about (such as “performance” at Amazon), but Google is more abstract. Google might love speaking about and asking about ambiguity more than any other FAANG.\nFinally, Google’s coding questions are never practical. They are always theoretical. They will never ask you to pull up your own environment and write a program. They will also never ask you to take a solution to a coding problem and apply it to a real world scenario. When prepping for Google, only practice theoretical questions.\nFor everything you need to prepare for Google’s coding interview, check out the section called \"Google coding interview preparation resources\" below.\nThe second most important onsite interview type at Google is system design. Again, they are allowed to ask anything they want, so don’t be scared off if you get a question you’ve never practiced before.\nHigh-level and low-level system design questions are both likely. Some examples include:\nGoogle system design interviewers also tend to design problems that include linchpin questions. These are questions where if you don’t ask about a specific aspect of the problem, you can’t really solve it. For example, an older system design question at Google asked you to set up a service in some foreign country, and in the prompt, the interviewer mentioned that you have a dependency on some third party service.\nThe linchpin question to ask: “What’s the service level agreement for that 3rd party service?” If you didn’t ask that (or something like it), then you wouldn’t be able to effectively reason about availability, which you’d need to do in order to do well on the question.\nTo avoid getting tricked, ask even more questions in Google system design rounds than you normally would.\nThe least important round at Google is the behavioral round. They have the easiest behavioral screen in FAANG. Plus, you might complete an onsite at Google without a behavioral round because they’re optional. It’s not clear which candidates get them and which don’t. This is another reason to not prep too hard for their behavioral round.\nIf you do get some behavioral questions, they might be one of the following:\nGoogle is also more likely to ask you reflective questions. Most other FAANGs stick to situational questions such as, “Tell me of a time when…”. Those situational questions ask you to describe a past circumstance or scenario you’ve actually experienced and are fairly straightforward to answer. Reflective questions, on the other hand, can be tricky because they’re asking you to reflect on, or speak to, something less concrete, e.g., “What do you think about setting goals?”\nThe smart way to answer a reflective question is to re-formulate it, and then answer as if it’s a situational question. So, “What do you think about setting goals” instead becomes,”Talk about a time you used goal-setting as a time management strategy”, which you can now more-easily answer by describing a real experience and outcome, “The last time I set goals…etc”, as opposed to wading into theories about personal agency. “I think goals are cool and important…” might not get high marks.\n“To be honest, there was some cultural backlash at Google when they announced that we had to do these behavioral interviews. What that means is you may get an interviewer who has very little interest in conducting this type of interview. Which could go very good or very bad. I have some peers who think this should not be a part of the interview process. So they give everyone the highest marks, pretty much just to eliminate this category from the interview. Google is primarily engineers, and most of the engineers think that this is a bunch of HR BS. So they either just won’t accept any calendar invites they get or they'll just check the boxes.”\nMost of the time, the post-interview feedback process at Google is completely asynchronous, and interviewers don’t meet live to discuss hiring decisions. That’s one reason why interviewing at Google isn’t like interviewing with humans: it’s more akin to interviewing with a machine.\nEach interviewer rates candidates on the following seven-point scale: Strong No-Hire, No Hire, Leaning No-Hire, On The Fence, Leaning Hire, Hire, and Strong Hire.\nHow this affects candidates is simple: a Strong Hire can get you an offer, but it can also buy you a second chance. If you don’t get an offer, but you get a Strong Hire from one of your interviewers, you might be offered one bonus interview round to decide whether you get an offer or not.\nThat said, you don’t need to get a “Strong Hire” to get a second chance. Overall, if you showed enough signal to not-fail but not enough to pass, sometimes they will ask you to do an additional round.\nIf you get lucky enough to get a round where you are really excelling, don’t quit while you’re ahead. Keep going. In that round, don’t just strive to win; strive for total domination.\nA “Strong No-Hire” bars you from interviewing at Google for some time. Reports vary here, but one of our Google interviewers told us that if you get a Strong No-Hire, you might be frozen out for several years.\nIf you passed overall then you will move on to the hiring committee phase.\nGoogle’s hiring committee consists of four to five engineers and engineering managers who have not interviewed you, with the intent of making hiring decisions as objective as possible.\nGoing into the hiring committee review, your recruiter will prepare a packet that consists of your resume, any notes from the person who referred you (if you were referred), your recruiter’s notes from their call with you, and all the feedback from your interviewers, from the technical phone screen to the onsite.\nIf you’re told you’ve passed the onsite, ask if you can submit a more recent copy of your resume. Some Google recruiters will let your new resume be the only resume the Hiring Committee sees. Your resume you submitted for the online application probably wasn’t customized for Google, but what you submit to the hiring committee can be.\nWhen the committee meets, they evaluate all the data on you holistically, and they need a consensus in order to decide to make a hire.\nOther than hire/no-hire decisions, the hiring committee will also decide on leveling. Ever since COVID and the rise of remote interviewing, we’ve gotten more and more reports from users that they’re being down-leveled at Google. Apparently the rationale is that Google doesn’t feel like they get as much signal from remote interviews as they did from in-person ones, and as such, when they don’t get enough of a signal for a hire but too much good signal for a rejection: they downlevel – when you want to reduce the probability of a false positives for L5… offer L4!\nEngineers who are downleveled at Google accept the lower level offer a lot of the time, especially in the current climate. In some extreme cases, we’ve seen engineering managers with 10+ YoE accept an L3 (basically a new grad) offer.\nOnce you get past the hiring committee, you will move on to team matching. The team matching process is a bit like speed dating. In the ideal case, your recruiter will propose a few teams that are actively looking for someone with your skills, and then you’ll meet with the hiring manager from each team to gauge cultural fit and chemistry. In order to move forward, both of you have to opt in.\nThat said, there are rare instances where a candidate will get past the hiring committee but then not find a team that they gel with.\n“Getting five scores of ‘Leaning Hire’ is most likely to result in a ‘No Hire’ decision. I have seen many cases where the candidates got five scores of ‘Leaning Hire’, and the recruiter gave them positive feedback too, but the candidate got rejected. In these cases, every person the candidate dealt with directly (the interviewers) were positive, yet the hiring committee (the only people in the process who dealt with the candidate indirectly) rejected the candidate.”\nHere are some tips for preparing for your Google coding interview:\nIn addition, we’ve aggregated a bunch of useful Google content for you! We have replays of candidates doing mock interviews with Google interviewers, long-form solutions to common Google questions, and deep dives into technical topics that tend to come up in Google interviews.\nBelow are a series of mock interview replays, conducted by Google interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Google ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Google interviews, we did two things. First, we spoke to a bunch of Google interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Google. Based on all of the above, here are the technical topics you’re likely to encounter:\nWant to know if you’re ready to interview at Google? Do anonymous mock interviews with real Google interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/google",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Meta Interviews + Questions",
      "content": "Before you interview with Meta, read our guide on negotiating with them. They’ve gotten very aggressive, and if you don’t know the rules, you will fail.\nMeta’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Meta? Do anonymous mock interviews with real Meta interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Meta’s hiring process, evaluation criteria, and interviewers.\nMeta interviewers are guided by the company’s current motto: move fast. All human groups have a metaphor they operate from. Meta isn’t a family or an army. They’re a well-structured Formula 1 team; they spend a lot of effort to put safeguards in place, and then they go pedal to the metal. At Meta, speed wins.\nAt Meta, because the process is centralized, you cannot interview with multiple teams concurrently like you can at some other tech companies. You get one shot on goal every ~3 to 6 months, depending on performance.\n“If you pass Meta’s onsite, but don’t take the offer your status of ‘passed onsite’ is valid for a year. If you don’t take their offer and then choose to re-engage within that year, tell their recruiter ‘I already passed the onsite’ and push to get steps skipped because you usually can.”\nWhen interviewing at Meta, listen closely to the subtle clues and hints your interviewer gives you. Meta is the only FAANG where you can’t become an interviewer unless you give good hints.\nPlease see the previous section called “A note about recruiter calls”. Also read our guide to negotiating with Meta. It starts at the recruiter call.\nMeta's technical phone screen is a 45-minute coding interview that focuses on data structures and algorithms.\nAt the beginning of the interview, your interviewer will ask you a question or two about your resume and recent work that you've done. This portion will take 5 minutes, and how you answer these questions doesn't meaningfully factor into the interview's outcome - they are just meant to break the ice and get you talking. The part that matters is the technical portion.\nAfter the intro portion, your interviewer will ask you two coding questions, and they expect you to get through both in 35 minutes. These questions will be LeetCode easy or medium difficulty.\nMeta’s technical phone screens are conducted in CoderPad. If you've never used it, you may want to play around in their sandbox and get familiar with their environment before your real interview. One specific thing about Meta's way of using CoderPad is that during the interview, they'll have code execution turned off - if you've used it before and are accustomed to testing your code during the interview by running it, you'll need to practice not being able to.\nThe typical Meta onsite will consist of the following:\nThe process for E6 engineers, as outlined in the diagram above, is slightly different. There will be a Leadership Assessment interview after the Technical Screen. In this interview, the following topics might be covered:\nThe onsite for E6 engineers will also be different. You should only get one coding round, one architecture round, one design round and then a behavioral round.\nThere are four main types of interviews you’re going to encounter when you apply for an engineering job at Meta – coding interviews, behavioral interviews, and either a system design or product design interview. Here’s what to expect during each of these rounds of interviews.\nMeta's process is highly standardized, so coding interview questions and themes tend to repeat. Coding questions are pre-approved, but that doesn’t mean the interviewers have no freedom.\n“Meta gives you the questions to ask or modify. But they don't tell you the answers in their interviewing wiki. And they let you design the path of the question: you get to ask your own twists and turns.”\n“There’s some variance with the interviewer, but usually there are 20 mins per question, and the questions are simple. They want you to get the algorithm fast, and implement the basic solution. The kind of bugs that can be acceptable are empty input, and out of scope inputs like empty array/null. But an incomplete algorithm at Meta usually doesn’t cut it. They want you to get to it and get to it quickly, and you can sacrifice making a little bit of a mess along the way.”\n“I think there is a rule that during the programming interview, interviewers have to ask two questions. And the questions have to be balanced. The first is more like a juicy question testing problem solving skills and you as the interviewer can permit some bugs in the implementation. The second will be easy from the algorithmic point of view but the goal is to assess how much the candidate can write debugless code and test this code perfectly. And if a candidate fails to solve both problems, even if they somewhat shine during one problem: it will be ‘No Hire’.”\nIt's not that bugs are encouraged, it’s that they're the only company that's top-down directive is: sometimes, in certain rounds, bugs are okay. No other company does that. Meta relaxes the need for bug-free code so that candidates can code faster.\nFinally, Meta doesn’t ask dynamic programming questions and, in fact, those questions are banned.\nFor everything you need to prepare for Meta’s coding interview, check out the section called \"Meta coding interview preparation resources\" below.\nMeta hires two types (on paper) of backend engineers: System Generalists and Product Generalists. System generalists get a system design interview, and product generalists get the confusingly named product design interview (in most other contexts, product design refers to UI/UX).\nWhich of these interviews you get is determined by your recruiter, based on your experience. If you have worked on a lot of product features, then you get a product design interview. If you have worked on high-scale distributed systems, then you get system design.\nThe product design interview at Meta is similar to the system design interview but with some key differences:\nTake a look at this video, by Meta, about the difference between these two interview types:\n“Product design is less databases, more data flow, more time spent on details of the API (e.g. parameters that will pass). System design is more databases, less API details, and more about scaling.”\n“Many people think Meta only asks high level system design questions like ‘Design Twitter’ or ‘Design Meta Feed.’ But that’s not the case. They also ask low level questions. In E6 or above interviews, you will most likely be asked ‘Design Redis’, or ‘Design Kafka’, or ‘Design Memcached.’ I’d even seen rare occasions where E5 candidates would be asked low-level system design questions; low-level questions are less common in rounds for E5 and below.”\n“You have to ask about back of the envelope estimations. A lot of senior engineers hate to do that. I hate to do that as well. It’s a waste of time. When I do the ‘There is a rule that I have to do this. But there is no point in doing this. Let’s spend 5 minutes talking about real system design. Let’s assume we have to scale our system from 0 to Google level and therefore estimations are just a waste of time.’”\nAsk your interviewer: “Do you want to spend a few minutes on estimations? I’m okay with skipping it, but if you need to see it, then let’s do it. If we skipped it, one thing that might be a more interesting conversation would be spending a few minutes on how to scale this system.’”\nIf you don’t know what to talk about in a E5 Meta system design round, talk about user experience. Go on about two choices you could make, then explain in depth the one preferred because it’d be a better user experience.\nIt’s also common for Meta interviewers to ask you to walk them through a system you’ve worked on in the past, which is known as a reverse system design interview.\nUnlike technical questions, behavioral questions at Meta are not standardized: interviewers can ask you whatever they want. Behavioral rounds are of medium/low importance at Meta; they’re less important than technical interview rounds, but they do carry some weight. For the best summary of what to expect in a Meta behavioral interview, read this blog post by a former Meta engineering manager – in it he describes exactly how behavioral interviews at Meta are evaluated and also includes a bunch of sample questions.\nHere is a list of questions to get you started. Read the post to get examples of good answers (split out by the candidate’s seniority level!)\nFinally, if you are applying for E5 and above make sure to have a couple of projects that lasted longer than one quarter – if all your examples are of smaller initiatives, your interviewer may walk away with the impression that you can’t handle complex projects. Also, remember to quantify the impact that you made by sharing specific metrics.\nMeta’s candidate review and feedback process is usually completely asynchronous. Sometimes, they’ll do a live debrief but it’s rare. This means there’s a low likelihood for an interviewer to “fight” for a candidate. Socially influencing interviewers won’t go very far here.\nMeta is also the only FAANG that asks interviewers for a confidence score when filling out post-onsite feedback forms. As a result, the process at Meta can be more forgiving on failed rounds because a lower confidence score means a failed round carries less weight. Also, Meta is the only FAANG that directly asks interviewers about downleveling.\n“Coding is used to decide ‘Should we hire this person?’ System and product design is used to decide ‘How should we level this person?’\nFor coding interviews, the interviewer says a binary score first: ‘Hire’ or ‘No Hire’. Then in the comments, they say how confident they are in that binary score. The ‘Hire’ or ‘No Hire’ is an official metric, but the confidence score is not.\nFor system/product design, the interviewer gives the ‘Hire’ or ‘No Hire’ first. Then they say if the candidate should be considered for another level.\nSo the final decision could be like: ‘No Hire’ for E5 with low confidence. ‘Hire’ for E4 with high confidence.\"\nIn cases where the hiring panel is hung, it’s possible they may request one more follow-up interview to help them get more signal.\n“Interview feedback is discussed primarily by the system design and behavioral interviewers, and those are the interviewers who have the most say regarding both the hire decision and a candidate’s level. If interviewers don’t feel like they got enough signal and the candidate ends up being on the fence, the recruiter will push for an additional round. Indicative hint: If you have an additional follow-up interview, your interviewers were probably split.\"\n“At Staff level and above, it’s a mandate that candidates can’t get hired if they don’t pass both system design rounds.”\n“For E6 and above candidates, if you fail one system design round but do well in the other rounds, you can get a mulligan. They can let you retake one system design round. But the same isn’t true for behavioral: if you fail there’s no mulligan. If you fail the behavioral round, it will be ‘No Hire.’”\nMeta made some changes to their process in 2023. Before, unlike at other FAANGs, you'd generally accept an offer before knowing with which team you'd end up on. Then you'd do a 6 week “Bootcamp”, where you'd be trained on Meta's engineering infrastructure and systems. After the bootcamp, there would be a 2 week team-matching period.\nNow, after you finish the onsite, you jump straight to the team matching process. Team matching now happens BEFORE you get an offer, and offers are contingent on team matching completely successfully.\nYou'll talk with hiring managers from a number of teams to gauge fit and chemistry: we've heard that sometimes it's a handful, and sometimes it's over 10.\nAfter your team matching conversations, your recruiter will ask you to choose a team. In order to move forward, both you and the hiring manager have to opt in.\nOnce you make your choice, your recruiter will officially make an offer, and you'll usually have just a few days to make your decision. We hope this will change in the future, but recently Meta has been very aggressive with both offer timelines and with negotiations - they will not negotiate unless you can share competitive offer details from another top-tier company.\nOne other key difference between Meta's new process and the old one is what happens during Bootcamp. Historically, Bootcamp took 6 weeks, and in addition to training new hires on Meta's engineering infrastructure and systems, there'd be a multi-week “speed dating”-esque team matching component.\nBootcamp still exists, but now it's much shorter - 2-4 weeks, and the focus is getting new engineers ramped up on generic tools. After that, new engineers will continue to ramp up on their specific teams.\nThe team matching process is a bit like speed dating. You meet with hiring managers to gauge fit and chemistry. In order to move forward, both of you have to opt in.\n“When the market is good, you can talk to 20 different teams at the same time.”\nThere are exceptions – some people with niche skills may get hired for a specific team before they start Bootcamp, but they still have to do the bootcamp period, just not the team-matching part afterwards.\nWe’ve aggregated a bunch of useful Meta content for you! We have replays of candidates doing mock interviews with Meta interviewers, long-form solutions to common Meta questions, and deep dives into technical topics that tend to come up in Meta interviews.\nBelow are a series of mock interview replays, conducted by Meta interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Meta ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics might come up in your Meta interviews, we did a few things. First, we spoke to a bunch of Meta interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data, the LeetCode question list above, AND our own data-set of mock interviews in the style of Meta. Based on all of the above, here are the technical topics you’re likely to encounter.\nThe following interview guides and resources can help you better understand Meta’s recruitment process and support your interview prep so you impress the hiring committee.\nWant to know if you’re ready to interview at Meta? Do anonymous mock interviews with real Meta interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/meta-facebook",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Amazon Interviews + Questions",
      "content": "All human organizations operate as a metaphor. Amazon isn’t a sports team or a family; they’re a motley crew of Terminators. They’re a different breed with notoriously high standards. They reward aggression. And they want to take over the market (or the earth, depending on who you ask)...\nAmazon’s process is not centralized, and you can interview with multiple teams concurrently. To up your odds, interview with as many teams as you have the appetite for.\nAmazon really loves their Leadership Principles (LPs). Amazon interviewers may sandwich LP questions anywhere and everywhere throughout your interview rounds: coding rounds, system design rounds, all rounds. In short, at an Amazon interview, be prepared for Leadership Principles questions anywhere, anytime.\nFinally, Amazon has one of the more-structured interviewing cultures. They’re the only FAANG where interviewers exist in a formal hierarchy, and Amazon openly encourages and rewards interviewers who reach the top rung in that hierarchy.\nIn this guide we’ve compiled a comprehensive Amazon job interview prep guide based on in-depth discussions with Amazon interviewers and interviewees. Our guide includes a detailed walkthrough of the interview process, common questions and solutions, interview tips, video replays of mock Amazon interviews, and more.\nWant to know if you’re ready to interview at Amazon? Do anonymous mock interviews with real Amazon interviewers, and see exactly where you stack up.\nSee available timesAmazon’s interview process consists of the following steps:\nWe walk through each of these steps in detail below.\nWhether you start with an online assessment or an Amazon recruiter call depends on a few factors:\nIf you answered yes to any of these questions, then you will likely not have to do an online assessment, and your first step will be a recruiter call. That said, we’ve gotten some conflicting reports from Amazonians, and it may be that Amazon has more recently started using online assessments to test the competencies of more senior engineers as well.\nIf you do the online assessment, here’s how it works. It’s a timed, asynchronous test consisting of several coding problems, conducted via HackerRank. These are usually data structures and algorithm problems of easy to medium-level difficulty, as well as some multiple choice system design questions where you have to select the design option that’s ideal in a given situation. If you do well in the online assessment, you can skip the second step, which is the technical phone screen.\nIf you end up skipping the online assessment, the first step in your process will be a recruiter call. Please see the section above called “A note about recruiter calls.”\nAmazon’s technical phone interview is a coding interview that tends to focus exclusively on data structures and algorithms. Despite the focus on speed, Amazon interview questions may require a lot of code, and the time allowed is usually 30-40 minutes, which means you’ll usually get one question, as opposed to Facebook, where you might get multiple questions.\nFor these screens, Amazon uses an internal tool called Livecode, which has syntax highlighting for popular languages but does NOT have the ability to run the code. In fact, no code is ever compiled or run in Amazon technical interviews.\nFinally, there’s a 50% chance that your interviewer will throw in 1 or 2 Leadership Principles questions into the phone screen. They’re not guaranteed, but they’ll definitely come up during the onsite.\nThere’s some variance, but the typical Amazon onsite, or in-person interview, for technical roles, will consist of:\nAmazon has a special type of interviewer that they include in onsite loops: the Bar Raiser. These are typically senior-level Amazon employees at the top of the formal interviewer hierarchy, and they’re the toughest and most-trained interviewers at Amazon. They serve as an independent and objective evaluator, asking follow-up questions, and ensuring that hiring decisions are not influenced solely by the candidate's immediate team or department.\n“Being a Bar Raiser makes an impact on your promotion packet. Every L5 nearing promotion at Amazon, is encouraged to do the Bar Raiser training. It’s a big input to get to L6 or L7. Part of the promotion packet is: how are you demonstrating some of the Leadership Principles. And “Hire and Develop the Best” is one of the LPs. There’s a lot of work to do in hiring to become a Bar Raiser: you have to do a lot of training and a ton of interviews. Being a Bar Raiser carries a lot of weight at Amazon if you want to get promoted.”\nAt Amazon, Bar Raisers and hiring managers are the only interviewers who have the formal authority to veto a hiring decision. You can recognize them because they are the only interviewer in your onsite loop who has nothing to do with the team you’re interviewing for. Bar Raiser rounds can be super intense, but don’t shrink when you feel a Bar Raiser throw flames your way; embrace the fire.\nThere are three main types of interviews you’ll face as a software engineer interviewing at Amazon. These are coding, behavioral, and system design interviews.\nYou will have to do coding interviews in the phone screen and in the onsite. Coding rounds at the onsite are very similar to technical phone screen rounds, except that in the technical phone screen you might get Leadership Principles questions, whereas in the onsite coding portion, you definitely will.\nAmazon asks mostly medium-difficulty LeetCode-style coding questions and avoids hard questions. The idea is to let candidates demonstrate how quickly they get to the optimal result, all in the service of hiring engineers who can churn out new features quickly.\nDespite the focus on speed, Amazon questions may be a complex problem that requires a lot of code, and the time allowed is usually 30-40 minutes, which means you’ll usually get one question, as opposed to Facebook, where you might get multiple questions.\nAmazon’s coding rounds test the following technical skills:\nAlthough your performance in technical interviews matters (if you fail the technical, you usually will not move forward), it’s not as important as the outcome of the behavioral interview, and coding interviews during the onsite at Amazon actually feature Leadership Principles questions.\n“Because no code is ever run on an editor, the approach, speed, and testing are most important. Code syntax, typos, variable naming, and edge cases are less important.”\nGraph questions are among the most popular types of questions asked at Amazon, as well as tree questions that require BFS or DFS. Classic questions like LRU cache, meeting rooms, word break, word search, word ladder, and so on may also come up.\nWe’ve heard from Amazon interviewers that all of the data structures and algorithms questions in Amazon’s official question bank are actually on LeetCode. That said, Amazon interviewers are allowed to ask whatever they want in coding rounds, and some will deviate from the question bank to ask more practical questions such as, “Implement a function with some behavior with the help of these two APIs…””\nFinally, like Facebook, Amazon shies away from dynamic programming questions (though they’re not banned outright).\nFor everything you need to prepare for Amazon’s coding interview, check out the section called \"Amazon coding interview preparation resources\" below.\nThe behavioral interview is one of, along with coding interviews at the onsite, the most important in terms of leading to an offer.\n“I’ve done over a hundred interviews at Amazon. The behavioral interview is most likely to get someone pushed over the line if they were borderline in their technical interviews. The opposite is not true: if they don’t meet the behavioral bar, we don’t care how they did in technicals, we aren’t hiring them.”\nBehavioral is an extremely important part of the Amazon interview process – Amazon is more likely to downlevel or reject you solely based on behavioral – and their behavioral round might be the most well-thought-out interview in all of big tech. It also might be the easiest to fail if you don’t specifically prepare for it. There’s no flavor like the flavor of an Amazonian behavioral interviewer; if you’ve never encountered it before and don’t expect it, it can be jarring.\nOne of the most common mistakes our users make is not taking this interview seriously because at most other companies, behavioral interviews tend to be more lip service than a meaningful part of the process. The bottom line is, if you want an Amazon job at a senior level or above, you have to seriously prepare for the behavioral interview questions.\nNot all Leadership Principles are created equal. Customer Obsession is the 👑one Leadership Principle to rule them all. When in doubt, demonstrate Customer Obsession. If you get a curveball, give an answer that shows you’re deeply committed to making things customers love.\n“If you have a bad LP round, or if LPs are problematic in the debrief, it’s almost always a ‘no hire.’ But if you have great LPs then there is a conversation where we try to see if the candidate can be hired even if the technical rounds weren't at the bar. But not the other way around. But if there’s anything ‘at the bar’ or ‘below the bar’ for LP, then you fail.”\n“If a candidate does not do that well on the technical round but they do well on LPs, there is always a possibility of recycling the candidate because they’re a good fit for Amazon but not good for the team. So sometimes we’ll help them interview with other teams, and they don’t have to do a full onsite: they just need to do 1-2 more rounds as a follow up. But if they’re below the bar for LPs, then they’re not a fit for Amazon so Amazon wouldn’t help set them up to other teams with shortened onsites.”\nIn this round, expect questions from all 5 of these categories:\nHonestly, the best place to find a detailed question list for Amazon’s behavioral interview, as well as a bunch of other interview preparation resources, is our Senior Engineer's Guide to the Amazon Leadership Principles Interview.\nSystem design and coding aren’t the be-all and end-all at Amazon – of course, you still have to pass them, but if your performance is borderline, doing well on behavioral Leadership Principles questions will take you over the finish line. In fact, interviewers will likely ask you 1-2 Leadership Principles questions in your system design interviews. Try to be efficient when answering LP questions in system design rounds. LPs come first. Finish them early so that you have more time for the technical question.\n“In many debriefs, I hear the hiring manager say that we can extend the L5 offer with the understanding that system design is not their strength, but it's coachable. At the L6 level, the system design bar is comparable to Facebook or Google.”\nIf you’re in a system design round at Amazon, and you don’t know what to talk about, talk about performance. They want Amazon to be the number one customer of AWS. And they love to find engineers who understand and are passionate about fine tuning performance in the cloud.\nAmazon is more likely to ask you practical system design questions. For example, if you’re interviewing with a team who controls Amazon’s inventory management, they might ask you to design a piece of an inventory management system.\nOther common system design questions include:\nThe design questions are most likely about designing well-known features, as opposed to a complete system from scratch like Design Facebook or Twitter.\nAmazon interviewers are allowed to ask whatever they want in system design, but a lot of interviewers fall back on reusing questions from Amazon’s question bank.\nFor tooling in system design interviews, candidates can usually choose any type of drawing tool. Excalidraw is most popular, followed by Miro.\nAmazon has one of the more well-structured decision-making processes in tech: teams typically do a pre-brief (live meeting before the onsite), submit asynchronous feedback, and also do a debrief (live meeting after the onsite). They rely heavily on live discussion to make decisions. Notably, though some interviewers might be able to tell an outlier story of a time a regular interviewer out-argued a Bar Raiser, most of the time the interviewers go along with what the Bar Raiser says.\nAmazon interviewer’s grade on a 5-point scale: Strongly Inclined, Inclined, Neutral, Not Inclined, Strongly Not Inclined.\nThe two most important interviewers at the onsite are the Bar Raiser and the hiring manager. At Amazon, all of the other team members involved in the interview could vote to hire, but if the Bar Raiser or the hiring manager aren’t on board, that candidate is likely getting rejected.\nAt Amazon, identify the Bar Raiser (the only person whose work has nothing to do with the team for which you’re interviewing) and the hiring manager (if you don’t know who it is, ask the recruiter before the onsite or an interviewer if during the onsite). Most of your energy should go towards impressing these two people – since Amazon relies so heavily on live discussions to make hiring decisions, impression management is more impactful here.\nWe’ve aggregated a bunch of useful Amazon content for you! We have replays of candidates doing mock interviews with Amazon interviewers, long-form solutions to common Amazon questions, and deep dives into technical topics that tend to come up in Amazon interviews.\nBelow are a series of mock interview replays, conducted by Amazon interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Amazon ask on our platform as well as sample answers. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Amazon interviews, we did two things. First, we spoke to a bunch of Amazon interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Amazon. Based on all of the above, here are the technical topics you’re likely to encounter:\nWant to know if you’re ready to interview at Amazon? Do anonymous mock interviews with real Amazon interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/amazon",
      "author": "",
      "user_id": ""
    },
    {
      "title": "JavaScript Interview Questions & Tips for Senior Engineers",
      "content": "How is JavaScript Used in Technical Interviews?\nJavaScript Interview Stats\nThe selection of a programming language can often be a decisive factor in the arena of technical interviews. Based on the data collected from over 100k interviews on our platform, JavaScript emerged as the third most popular language of choice, being used in 12% of all technical interviews. JavaScript ranks just below popular programming languages like Python and Java, yet, when chosen, JavaScript delivers a pass rate of 42% in the interviews, showcasing its significance and effectiveness.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews by language.\nOne of the reasons for JavaScript's popularity is its versatility. It works on both the backend and frontend, making it a valuable tool for full-stack developers. Using a single language across multiple layers of an application can enhance productivity and improve workflow.\nOf course, it wouldn't be a discussion about JavaScript without acknowledging the love-hate relationship it enjoys with programmers. JavaScript can be likened to that old friend you may sometimes find eccentric and unpredictable, yet they always surprise you with their resourcefulness and charm. No matter how you feel about it, one thing is sure — you can't ignore JavaScript.\nWhy JavaScript is Important for Technical Interviews\nUnique Qualities of JavaScript\nJavaScript stands out due to its adaptability and prevalence in web development. It's a flexible tool that handles both object-oriented and functional programming styles, making it ideal for showcasing diverse problem-solving skills in interviews. Its role as the sole native language of web browsers puts it front and center in web development, offering a clear edge during interviews. Its use in front-end and back-end development, thanks to tools like Node.js and frameworks like React, makes it a full-stack developer's dream.\nIndustry Significance of JavaScript\nJavaScript's importance goes beyond its technical merits—it's also a leading language in the industry. The 2023 Stack Overflow Developer Survey marks it as the most commonly used language for the eleventh year in a row. GitHub's Octoverse Report 2022 also attests to the same fact, with JavaScript being the most used language on GitHub. This sustained industry demand ensures that JavaScript expertise remains highly valued in technical interviews.\nJavaScript Idioms & Idiosyncrasies\nJavaScript was developed by Brendan Eich in just ten days in the year 1995 while he was working at Netscape Communications. Over the years, JavaScript has undergone numerous changes and enhancements. ECMAScript (ES), the standardized language specification, has overseen these transformations. One of the most significant shifts came with the release of ES6 (also known as ES2015) in June 2015, which introduced new syntax and powerful features that transformed the way JavaScript code was written. Since then, new versions of the specification have been released yearly, with the latest being ES2023.\nWhile the specifications have evolved, JavaScript's core principles have remained unchanged. It's a dynamic, weakly typed, prototype-based language that supports object-oriented, imperative, and declarative programming styles. Additionally, it's a single-threaded, non-blocking, asynchronous language that uses an event loop to handle concurrency. In recent years, the emergence of TypeScript - a statically typed superset of JavaScript - highlights the evolving nature of JavaScript, offering type safety and improved tooling. In this section we'll learn about JavaScript's idioms and idiosyncrasies, that make it special.\nSingle Threaded Event Loop & Asynchronous Behavior\nJavaScript is single-threaded, meaning it can process one operation at a time in a single sequence, or thread, of operations. While this might seem limiting, especially considering that many programming languages use multi-threading, JavaScript leverages this single-threaded nature using an event loop mechanism to handle asynchronous operations efficiently.\nJavaScript's single-threaded nature helps it avoid the complexities of multithreading while manipulating DOM tree, making it easier to learn and use. But since it can only process one operation at a time, a long-running operation can block the thread and hang the system, causing what is known as a \"blocking\" operation.\nTo overcome this, JavaScript uses an event-driven, non-blocking I/O model. It utilizes an event loop and a callback queue. When an asynchronous operation is encountered, it's offloaded to the browser's Web APIs, freeing up the main thread to continue executing other operations. The associated callback function is pushed into a task queue when the asynchronous operation is completed. The event loop continually checks this queue and pushes any waiting callbacks back onto the main thread for execution as soon as it's free.\nThis unique design allows JavaScript to handle high I/O workloads efficiently without the complexity and potential issues of multi-threading, making it particularly well-suited for web development, where asynchronous operations like network requests, user interactions, and timers are common.\nconsole.log(\"Fetching data...\");\nsetTimeout(function() {\nconsole.log(\"Data fetch complete!\");\n}, 2000);\nconsole.log(\"Waiting for data...\");\n// Output:\n// Fetching data...\n// Waiting for data...\n// Data fetch complete!\n1console.log(\"Fetching data...\");\n2\n3setTimeout(function() {\n4 console.log(\"Data fetch complete!\");\n5}, 2000);\n6\n7console.log(\"Waiting for data...\");\n8\n9// Output:\n10// Fetching data...\n11// Waiting for data...\n12// Data fetch complete!\n13\nJavaScript Execution Environment\nThe environments in which JavaScript runs, such as web browsers (Chrome, Safari, Firefox, etc.) or servers (Node.js, Deno, Bun, etc.), each provide unique features and behaviors. Although ECMAScript defines the standard specifications for JavaScript, not all environments implement these uniformly, leading to environment-specific quirks. For instance, a feature like the Fetch API, widely supported in modern web browsers, wasn't natively supported in Node.js until version 17.5 (with experimental flag). Therefore, understanding your JavaScript execution environment and its specific features is crucial for creating robust, cross-compatible code.\nType Coercion\nAs a weakly typed language, JavaScript can automatically convert values from one type to another, a behavior known as type coercion.\nconsole.log(4 + \"2\"); // Output: \"42\"\nlet numStr = \"42\";\nlet num = +numStr; // '+' operator triggers type coercion.\nconsole.log(num); // Output: 42 (a number, not a string)\n1console.log(4 + \"2\"); // Output: \"42\"\n2\n3let numStr = \"42\";\n4let num = +numStr; // '+' operator triggers type coercion.\n5console.log(num); // Output: 42 (a number, not a string)\n6\nThis behavior of JavaScript may remind you of type casting seen in other languages. The key difference is that type casting (or type conversion) is explicitly done by the programmer, while type coercion is performed implicitly by the language. In JavaScript, it's important to understand when and how type coercion occurs to prevent unexpected outcomes.\nFunction Expressions\nJavaScript treats functions as first-class objects so that they can be assigned to variables, stored in data structures, passed as arguments to other functions, and returned from other functions.\n// function gets assigned to a variable\nlet calculateArea = function(radius) {\nreturn Math.PI \\* radius \\* radius;\n};\n1// function gets assigned to a variable\n2let calculateArea = function(radius) {\n3 return Math.PI \\* radius \\* radius;\n4};\nHoisting\nHoisting is a unique behavior of JavaScript where variable and function declarations are moved to the top of their containing scope during the compilation phase before the code has been executed.\ngreet(); // Output: Hello, Interviewing.io!\n// Function declaration\nfunction greet() {\nconsole.log('Hello, Interviewing.io!');\n}\n1greet(); // Output: Hello, Interviewing.io!\n2\n3// Function declaration\n4function greet() {\n5 console.log('Hello, Interviewing.io!');\n6}\nClosure\nA closure is a function that has access to the variables of its outer function, even after the outer function has returned. This is possible because the inner function has access to the outer function's scope, even after the outer function has finished executing. This helps create private variables and function factories.\nfunction outerFunc() {\nlet outerVar = 'I am outside!';\nfunction innerFunc() {\nconsole.log(outerVar);\n}\nreturn innerFunc;\n}\nlet inner = outerFunc();\ninner(); // Output: I am outside!\n1function outerFunc() {\n2 let outerVar = 'I am outside!';\n3 function innerFunc() {\n4 console.log(outerVar);\n5 }\n6 return innerFunc;\n7}\n8let inner = outerFunc();\n9inner(); // Output: I am outside!\nThe this\nKeyword\nIn JavaScript, this\nis a special keyword that refers to the context in which a function is called. This can vary depending on how and where the function is invoked. In a method of an object, this\nrefers to the object itself. In a simple function call, this\nrefers to the global object (in non-strict mode) or is undefined\n(in strict mode).\nconst myObj = {\nvalue: 'Hello, World!',\nprintValue: function() {\nconsole.log(this.value);\n}\n};\nmyObj.printValue(); // Output: Hello, World!\n1const myObj = {\n2 value: 'Hello, World!',\n3 printValue: function() {\n4 console.log(this.value);\n5 }\n6};\n7\n8myObj.printValue(); // Output: Hello, World!\nContrast this with Python, where the object context is passed explicitly as a parameter (self\n) to an instance method, and with Java, where this\nalways refers to the current instance of the class.\nUnderstanding the this\nkeyword, and its context-dependent nature, is crucial for writing and debugging JavaScript code. It’s also a source of frequent mistakes. We'll learn more about that in the next section.\nDestructuring\nIntroduced in ES6, destructuring allows for quickly unpacking values from arrays or properties from objects. This can help simplify code and make it more readable.\nlet candidate = {\nname: \"Alice\",\nlanguage: \"JavaScript\",\nexperience: \"3 years\",\n};\nlet { name, experience } = candidate;\nconsole.log(name, experience); // Output: Alice, 3 years\n1let candidate = {\n2 name: \"Alice\",\n3 language: \"JavaScript\",\n4 experience: \"3 years\",\n5};\n6\n7let { name, experience } = candidate;\n8console.log(name, experience); // Output: Alice, 3 years\nRest and Spread Operators\nThese operators provide convenient ways to handle collections of items and can often simplify the code written in an interview.\nSpread: While destructuring 'unpacks' elements from an array or properties from an object, the spread operator takes it further by allowing you to expand or 'spread out' these elements or properties in a new context. It's helpful when you want to combine arrays or to use an array's values as function arguments.\nlet candidate = {\nname: \"Alice\",\nbasicSkills: [\"HTML\", \"CSS\"]\n};\nlet updatedCandidate = {\n...candidate, // Using spread operator to copy properties from candidate object\nadvancedSkills: [\"JavaScript\", \"React\"]\n};\nconsole.log(updatedCandidate);\n/\\* Output:\n{\nname: \"Alice\",\nbasicSkills: [\"HTML\", \"CSS\"],\nadvancedSkills: [\"JavaScript\", \"React\"]\n}\n\\*/\n1let candidate = {\n2 name: \"Alice\",\n3 basicSkills: [\"HTML\", \"CSS\"]\n4};\n5\n6let updatedCandidate = {\n7 ...candidate, // Using spread operator to copy properties from candidate object\n8 advancedSkills: [\"JavaScript\", \"React\"]\n9};\n10\n11console.log(updatedCandidate);\n12/\\* Output:\n13{\n14 name: \"Alice\",\n15 basicSkills: [\"HTML\", \"CSS\"],\n16 advancedSkills: [\"JavaScript\", \"React\"]\n17}\n18\\*/\nRest: The Rest operator collects multiple elements and condenses them into a single array. It's used in function arguments to allow the function to accept any number of parameters.\nfunction getCandidateDetails({ name, ...skills }) {\nconsole.log(`Candidate ${name} has the following skills:`);\nconsole.log(`Basic: ${skills.basicSkills}`);\nconsole.log(`Advanced: ${skills.advancedSkills}`);\n}\ngetCandidateDetails(updatedCandidate);\n/\\* Output:\nCandidate Alice has the following skills:\nBasic: HTML,CSS\nAdvanced: JavaScript,React\n\\*/\n1function getCandidateDetails({ name, ...skills }) {\n2 console.log(`Candidate ${name} has the following skills:`);\n3 console.log(`Basic: ${skills.basicSkills}`);\n4 console.log(`Advanced: ${skills.advancedSkills}`);\n5}\n6\n7getCandidateDetails(updatedCandidate);\n8/\\* Output:\n9Candidate Alice has the following skills:\n10Basic: HTML,CSS\n11Advanced: JavaScript,React\n12\\*/\nCommon JavaScript Interview Mistakes\nIn the context of interviews, a deep understanding of JavaScript is critical. There are some common pitfalls that candidates often fall into. Recognizing these mistakes can greatly enhance your interview performance and overall coding skills.\nImproper Use of 'this' Keyword\nThe this\nkeyword in JavaScript can be tricky, as its context depends on how and where it's called. Let's consider an example where you are iterating over an array of numbers to calculate their sum:\nclass ArraySum {\nconstructor(numbers) {\nthis.numbers = numbers;\nthis.sum = 0;\n}\ncalculateSum() {\nthis.numbers.forEach(function(num) {\nthis.sum += num;\n});\n}\n}\nlet obj = new ArraySum([1, 2, 3]);\nobj.calculateSum();\nconsole.log(obj.sum); // NaN\n1class ArraySum {\n2 constructor(numbers) {\n3 this.numbers = numbers;\n4 this.sum = 0;\n5 }\n6\n7 calculateSum() {\n8 this.numbers.forEach(function(num) {\n9 this.sum += num;\n10 });\n11 }\n12}\n13\n14let obj = new ArraySum([1, 2, 3]);\n15obj.calculateSum();\n16console.log(obj.sum); // NaN\n17\nHere, this inside the forEach\ncallback doesn't refer to the ArraySum\ninstance, but to the global object (undefined\nin strict mode). This results in NaN\nbecause undefined\n+ number in JavaScript is NaN\n.\nThe issue can be fixed using an arrow function:\nclass ArraySum {\nconstructor(numbers) {\nthis.numbers = numbers;\nthis.sum = 0;\n}\ncalculateSum() {\nthis.numbers.forEach(num => {\nthis.sum += num;\n});\n}\n}\nlet obj = new ArraySum([1, 2, 3]);\nobj.calculateSum();\nconsole.log(obj.sum); // 6\n1class ArraySum {\n2 constructor(numbers) {\n3 this.numbers = numbers;\n4 this.sum = 0;\n5 }\n6\n7 calculateSum() {\n8 this.numbers.forEach(num => {\n9 this.sum += num;\n10 });\n11 }\n12}\n13\n14let obj = new ArraySum([1, 2, 3]);\n15obj.calculateSum();\n16console.log(obj.sum); // 6\nThe arrow function doesn't have its own this\ncontext, it inherits it from the surrounding code. Now this\nwithin the forEach\ncallback correctly refers to the ArraySum\ninstance, leading to the correct sum of numbers.\nUsing Array as a Queue without Time Complexity Considerations\nJavaScript has no built-in queue data structure. Using an array as a queue is common during data structure and algorithm questions. However, it can be computationally expensive. Suppose you're implementing a Breadth-First Search (BFS) on a graph in an interview; you might use an array as a queue to hold nodes:\nfunction bfs(graph, startNode) {\nlet queue = [];\n// enqueue operation\nqueue.push(startNode);\nwhile(queue.length > 0) {\n// dequeue operation, O(n)\nlet node = queue.shift();\nconsole.log(node.value);\nfor(let child of node.children) {\nqueue.push(child);\n}\n}\n}\n1function bfs(graph, startNode) {\n2 let queue = [];\n3 // enqueue operation\n4 queue.push(startNode);\n5\n6 while(queue.length > 0) {\n7 // dequeue operation, O(n)\n8 let node = queue.shift();\n9 console.log(node.value);\n10\n11 for(let child of node.children) {\n12 queue.push(child);\n13 }\n14 }\n15}\nArray.prototype.shift()\nhas a time complexity of O(n)\nbecause it re-indexes every remaining element in the array. This can be a major inefficiency for large arrays.\nYou should always let your interviewer know you know this limitation. If the interviewer insists, you should be able to implement it using a linked list. This will give you a time complexity of O(1)\nfor both enqueue and dequeue operations.\nMistakes with Type Coercion and Equality (== and ===)\nUnderstanding JavaScript's type coercion in comparison operations is crucial, especially when dealing with different data types. Let's look at a simple but confusing example:\nlet a = '0';\nlet b = 0;\nconsole.log(a == b); // true\nconsole.log(a === b); // false\n1let a = '0';\n2let b = 0;\n3\n4console.log(a == b); // true\n5console.log(a === b); // false\nIn the first log statement, JavaScript coerces the string '0' to a number due to the ==\noperator, resulting in true. In the second log statement, the ===\noperator checks both value and type, hence '0' (string) and 0 (number) are not considered equal.\nAs a best practice, it is always recommended to use the ===\noperator.\nNot Writing Idiomatic JavaScript\nIdiomatic JavaScript means writing code that aligns with the community's accepted best practices and conventions. The following table shows some common mistakes that are not idiomatic JavaScript and how to fix them:\n| Non-idiomatic JavaScript | Idiomatic JavaScript | Explanation |\n|---|---|---|\nlet x = new Array(); | let x = []; | Use literal notation to initialize arrays. |\nlet y = new Object(); | let y = {}; | Use literal notation to initialize objects. |\nfor (let i = 0; i < array.length; i++) { console.log(array[i]); } | array.forEach(element => console.log(element)); | Use forEach for array iteration. |\nif (a !== null && a !== undefined) {...} | if (a) {...} | JavaScript treats null , undefined , 0 , NaN , \"\" as falsy. Just use if (a) to check for these. |\nlet z; if (x) { z = y; } else { z = w; } | let z = x ? y : w; | Use the ternary operator for simple conditional assignment. |\narr.indexOf(el) === -1 | !arr.includes(el) | Use includes to check if an array contains a specific element. |\nfor (let i = 0; i < users.length; i++) { if (users[i].age > 21) { adults.push(users[i]); }} | let adults = users.filter(user => user.age > 21); | Use filter for creating a new array with all elements that pass a test. |\nUnintentionally Mutating Array or Objects\nJavaScript is a language where arrays and objects are mutable and are passed by reference. Therefore, any changes to the array or object inside a function will reflect outside the function as well, leading to unintentional side effects.\nLet's consider a simple array-based DFS approach where you're not properly managing mutations:\nlet graph = {\n'A': ['B', 'C'],\n'B': ['A'],\n'C': ['A', 'B', 'D', 'E'],\n'D': ['C', 'E', 'F'],\n'E': ['C', 'D'],\n'F': ['D']\n};\nlet visited = [];\nfunction dfs(node) {\nvisited.push(node);\nfor (let neighbor of graph[node]) {\nif (!visited.includes(neighbor)) {\ndfs(neighbor);\n}\n}\nreturn visited;\n}\nlet pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\nlet pathFromB = dfs('B'); // ['A', 'B', 'C', 'D', 'E', 'F']\n1let graph = {\n2 'A': ['B', 'C'],\n3 'B': ['A'],\n4 'C': ['A', 'B', 'D', 'E'],\n5 'D': ['C', 'E', 'F'],\n6 'E': ['C', 'D'],\n7 'F': ['D']\n8};\n9\n10let visited = [];\n11\n12function dfs(node) {\n13 visited.push(node);\n14 for (let neighbor of graph[node]) {\n15 if (!visited.includes(neighbor)) {\n16 dfs(neighbor);\n17 }\n18 }\n19 return visited;\n20}\n21\n22let pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\n23let pathFromB = dfs('B'); // ['A', 'B', 'C', 'D', 'E', 'F']\nIn the above code, we expect pathFromA\nand pathFromB\nto be different, but since visited\nis shared and gets mutated during each DFS\nrun, pathFromB\ndoesn't give us the expected result.\nTo fix this, we need to initialize visited\nwithin the function itself:\nfunction dfs(node, visited = []) {\nvisited.push(node);\nfor (let neighbor of graph[node]) {\nif (!visited.includes(neighbor)) {\ndfs(neighbor, visited);\n}\n}\nreturn visited;\n}\nlet pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\nlet pathFromB = dfs('B'); // ['B', 'A', 'C', 'D', 'E', 'F']\n1function dfs(node, visited = []) {\n2 visited.push(node);\n3 for (let neighbor of graph[node]) {\n4 if (!visited.includes(neighbor)) {\n5 dfs(neighbor, visited);\n6 }\n7 }\n8 return visited;\n9}\n10\n11let pathFromA = dfs('A'); // ['A', 'B', 'C', 'D', 'E', 'F']\n12let pathFromB = dfs('B'); // ['B', 'A', 'C', 'D', 'E', 'F']\nNow, pathFromA\nand pathFromB\nare different as expected. Understanding and managing mutations properly is crucial in JavaScript, particularly in tricky algorithms such as DFS.\nNot Understanding the Sort() Method\nJavaScript's built-in Array.prototype.sort()\nmethod can be a source of confusion, especially when sorting numerical arrays. If no compare function is supplied, sort()\nwill convert items to strings and sort them in lexicographic (alphabetical) order, which can lead to unexpected results when dealing with numbers.\nFor instance, let's say you're working on a coding problem where you're given an array of integers, and you need to sort them in ascending order. You might think you could simply use sort()\n:\nlet arr = [10, 21, 4, 15];\narr.sort();\nconsole.log(arr); // Outputs: [10, 15, 21, 4]\n1let arr = [10, 21, 4, 15];\n2arr.sort();\n3console.log(arr); // Outputs: [10, 15, 21, 4]\nThis output isn't what you'd expect if you wanted to sort numerically. It's because sort()\nconverts the numbers to strings, and '10' is lexicographically less than '4'.\nTo correctly sort numbers in JavaScript, you need to supply a comparator function:\nlet arr = [10, 21, 4, 15];\n// sort method is passed a comparator function\n// if comparator(a, b) returns a negative number, a comes before b\n// if comparator(a, b) returns a positive number, b comes before a\n// if comparator(a, b) returns 0, a and b are unchanged with respect to each other\narr.sort((a, b) => a - b);\nconsole.log(arr); // Outputs: [4, 10, 15, 21]\n1let arr = [10, 21, 4, 15];\n2\n3// sort method is passed a comparator function\n4// if comparator(a, b) returns a negative number, a comes before b\n5// if comparator(a, b) returns a positive number, b comes before a\n6// if comparator(a, b) returns 0, a and b are unchanged with respect to each other\n7arr.sort((a, b) => a - b);\n8\n9console.log(arr); // Outputs: [4, 10, 15, 21]\n10\nUsing 'var' instead of 'let' or 'const'\nThe use of var\nis considered outdated in modern JavaScript (ES6 and later). Instead, let\nand const\nare preferred because they provide block scoping, reducing potential bugs and making the code easier to predict and understand.\nThe general rule of thumb is:\n-\nUse\nconst\nwhen the variable should not be reassigned. This is often true for function declarations, imported modules, and configuration variables. Usingconst\ncan help you catch errors where you accidentally try to reassign a variable. -\nUse\nlet\nwhen the variable will be reassigned. This is common in loops (for instance, counters), and in some algorithm implementations.\nChoosing let\nor const\nappropriately in your code makes it more predictable and signals to other developers (and interviewers) that you understand the variable's purpose and lifecycle. This can make your code easier to read and maintain.\nIt's also important to note that const\ndoes not make the entire variable immutable, only the assignment. For instance, if you declare an object or an array with const\n, you can still modify the elements in the array or the object's properties. This can lead to unintentional behavior if not fully understood.\nconst obj = {};\nobj.property = 'value'; // This is allowed\nconst arr = [];\narr.push(1); // This is allowed\n1const obj = {};\n2obj.property = 'value'; // This is allowed\n3\n4const arr = [];\n5arr.push(1); // This is allowed\n6\nJavaScript Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in JavaScript. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose JavaScript as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/javascript-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Python Interview Questions & Tips for Senior Engineers",
      "content": "Python Interview Questions & Tips\nWhat Makes Python Unique?\nPython is an interpreted, object-oriented general-purpose programming language. It is beloved by many developers and one of the most popular languages in the world, ranking second to JavaScript in the 2022 Stack Overflow Developer survey.\nWhile few aspects of Python are unique to the language, a variety of attributes that developers love and a deep toolbox of features make it an exceptional choice for a wide range of applications and projects:\nReadability: Python is one of the most readable programming languages, frequently using English or understandable keywords (continue\n, pass\n, def\n, local\n, finally\n, etc). It also requires consistent spacing in order to run without errors and largely avoids the usage of symbols, which both improve readability.\nA robust standard library: From json\nto datetime\nto io\n, Python has a deep collection of standard library modules that enables the development of a variety of application types out of the box.\nAn even-deeper ecosystem of non-standard modules: NumPy (used for scientific computing and mathematics) and Pandas (used for data analysis and manipulation) lead an incredibly deep set of non-standard-library modules, followed by other libraries such as collections\n, Flask, Django and TensorFlow. All of these libraries contribute to Python’s versatility, a major aspect of its popularity.\nExcellent documentation: The official Python documentation, as well as many top libraries, have comprehensive and easy-to-understand documentation, which is appreciated by Python engineers of all levels.\nList comprehensions and dict comprehensions: Python also has an easy, approachable and compact syntax for iterating and mapping over lists. For example, in another language you may have to write something like this in order to iterate over a list of integers and multiply them by 3:\nnums = [2, 7, 12, 32]\nnewlist = []\nfor x in nums:\nnewlist.append(x \\* 3)\nprint(newlist) # [6, 21, 36, 96)\n1nums = [2, 7, 12, 32]\n2newlist = []\n3\n4for x in nums:\n5 newlist.append(x \\* 3)\n6\n7print(newlist) # [6, 21, 36, 96)\n8\nHowever, in Python this code can be done in one line using a list comprehension:\n```\nnums = [2, 7, 12, 32]\nnewlist = [x\\*3 for x in nums]\nprint(newlist) # [6, 21, 36, 96)\n```\n1```\n2nums = [2, 7, 12, 32]\n3newlist = [x\\*3 for x in nums]\n4print(newlist) # [6, 21, 36, 96)\n5```\n6\nYou can even nest list comprehensions and add if\nstatements, though doing so can make the code slightly more difficult to read and quickly comprehend:\ncapital\\_tuples = [['Colorado', 'Denver'], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\ncities\\_and\\_states\\_starting\\_with\\_m = [\ncity\\_or\\_state\nfor city\\_state\\_tuple in capital\\_tuples\nfor city\\_or\\_state in city\\_state\\_tuple\nif city\\_or\\_state[0] == 'M'\n]\nprint(cities\\_and\\_states\\_starting\\_with\\_m) # ['Minnesota', 'Massachusetts']\n1capital\\_tuples = [['Colorado', 'Denver'], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\n2cities\\_and\\_states\\_starting\\_with\\_m = [\n3 city\\_or\\_state\n4 for city\\_state\\_tuple in capital\\_tuples\n5 for city\\_or\\_state in city\\_state\\_tuple\n6 if city\\_or\\_state[0] == 'M'\n7]\n8print(cities\\_and\\_states\\_starting\\_with\\_m) # ['Minnesota', 'Massachusetts']\n9\nSimilarly, you can use construct dictionaries using dict comprehensions:\ncapital\\_tuples = [[\"Colorado\", \"Denver\"], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\ncapital\\_dict = {state: capital for state, capital in capital\\_tuples}\nprint(capital\\_dict) # { 'Colorado': 'Denver', 'Minnesota': 'St. Paul', 'Massachusetts': ‘Boston' }\n1capital\\_tuples = [[\"Colorado\", \"Denver\"], ['Minnesota', 'St. Paul'], ['Massachusetts', 'Boston']]\n2capital\\_dict = {state: capital for state, capital in capital\\_tuples}\n3print(capital\\_dict) # { 'Colorado': 'Denver', 'Minnesota': 'St. Paul', 'Massachusetts': ‘Boston' }\n4\nLambda expressions / lambda functions: Lambda expressions are anonymous, simple functions in Python often used within high-order functions such as filter\nor map\n. They are syntactically restricted to a single expression and semantically they are simply syntactic sugar for a normal function definition.\nnums = [2, 7, 12, 17, 23]\nodd\\_nums = list(filter(lambda x: x % 2 != 0, nums))\nprint(odd\\_nums)\nnums\\_squared = list(map(lambda x: x\\*\\*2, nums))\nprint(nums\\_squared)\n1nums = [2, 7, 12, 17, 23]\n2odd\\_nums = list(filter(lambda x: x % 2 != 0, nums))\n3print(odd\\_nums)\n4\n5nums\\_squared = list(map(lambda x: x\\*\\*2, nums))\n6print(nums\\_squared)\n7\nPython Interview Stats\nWe've hosted over 100k interviews on our platform. Python was the language of choice in those interviews 40% of the time, and engineers who interviewed in Python passed their interviews 56% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nCommon Python Interview Mistakes\nThough Python is known for being easy to understand, debug and reason about, there are a handful of quirks that may throw off newer developers or developers coming from other languages:\nSpacing matters: While strict spacing rules makes Python code more readable, it also won’t run properly without consistent spacing. For example, many languages use brackets ({\nand }\n) to denote the beginning and ending of code blocks or functions, but Python relies on indentation and colons.\nScope and closures: In many languages you can automatically reference variables in the enclosing scope (or other outer scopes), but in Python you can only reference local variables. In order to access variables in an outer scope the nonlocal\nkeyword is required, and in order to reference variables in the global scope the (you guessed it) global\nkeyword is required.\n# Global variable\nglobal\\_var = 10\ndef outer\\_function():\n# Outer function variable\nouter\\_var = 20\ndef inner\\_function():\n# Local variable\ninner\\_var = 30\nprint(\"Local variable:\", inner\\_var) # 30\nnonlocal outer\\_var\nouter\\_var = 40\nprint(\"Nonlocal variable:\", outer\\_var) # 40\nglobal global\\_var\nglobal\\_var = 50\nprint(\"Global variable:\", global\\_var) # 50\nprint(\"Outer variable:\", outer\\_var) # 20\ninner\\_function()\nouter\\_function()\n1# Global variable\n2global\\_var = 10\n3\n4def outer\\_function():\n5 # Outer function variable\n6 outer\\_var = 20\n7\n8 def inner\\_function():\n9 # Local variable\n10 inner\\_var = 30\n11\n12 print(\"Local variable:\", inner\\_var) # 30\n13 nonlocal outer\\_var\n14 outer\\_var = 40\n15 print(\"Nonlocal variable:\", outer\\_var) # 40\n16 global global\\_var\n17 global\\_var = 50\n18 print(\"Global variable:\", global\\_var) # 50\n19\n20 print(\"Outer variable:\", outer\\_var) # 20\n21 inner\\_function()\n22\n23outer\\_function()\n24\nInterpreted: Python is an interpreted language, meaning errors surface at run-time; as opposed to compiled languages such as Java, where errors surface at compile time.\nPython Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in Python. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose Python as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/python-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Java Interview Questions & Tips for Senior Engineers",
      "content": "Java Interview Questions & Tips\nJava Interview Stats\nWe've hosted over 100k interviews on our platform. Java was the language of choice in those interviews 29% of the time. Java also had the highest success rates – engineers who chose Java as their interview language passed their interviews 51% of the time.\nBelow is a distribution of programming languages and their popularity in technical interviews as well as success rates in interviews, by language.\nJava Idioms & Idiosyncrasies\nJava is a popular choice in software development for its portability, simplicity, and its robust, object-oriented capabilities. It's a high-level language that has a great emphasis on readability and simplicity.\nAs a seasoned and commonly used language, Java boasts a vast feature set and numerous libraries. It’s a language that enforces strict typing and has an extensive standard library. It’s a language and culture with a significant amount of formalism, especially regarding object-oriented programming and type systems.\nMost candidates and interviewers will be familiar with Java’s class structure, inheritance rules, and other internals. Focus on the core parts of what make Java great and express your solutions in with good Object-Oriented styles.\n- Classes and Objects: Java is a fully object-oriented language. Ensure you're comfortable with classes, objects, inheritance, polymorphism, and encapsulation.\n- Exception Handling: Java has a robust exception handling mechanism with try, catch, finally, and throw blocks. Understand the difference between checked and unchecked exceptions.\n- Java Collections Framework: Java provides a rich set of prepackaged data structures and algorithms called the Java Collections Framework. Be comfortable with common collections like List, Set, Map, Queue, etc.\n- Generics: Generics provide compile-time type safety that allows programmers to catch invalid types at compile time.\n- Concurrency: Understand the basics of multi-threading, synchronization, and the Java concurrency utilities from the java.util.concurrent package.\n- Stream API: Java 8 introduced the Stream API for functional-style operations on streams of elements. It is beneficial to understand how to use streams for operations like filtering, mapping, or collecting elements to a result container.\n- Java Memory Model: Understand how memory allocation works in Java, including the role of the garbage collector.\nCommon Java Interview Mistakes\nWhen interviewing in Java, there are a few common pitfalls to avoid.\nIgnoring Exceptions\nJava's exception handling capabilities are one of its strong points, offering developers a structured way to predict, catch, and handle errors during the execution of the program. These mechanisms consist of try, catch, and finally blocks, as well as throws clauses. Yet, despite the robustness of these features, mishandling exceptions can lead to code that is not only faulty but also difficult to debug and maintain.\nOne common mistake is ignoring or \"swallowing\" exceptions. This refers to the practice of catching an exception but not handling it appropriately, typically leaving the catch block empty. This can be problematic as it hides error symptoms that could be critical for diagnosing issues. Swallowing exceptions is especially perilous when it's done at the system's higher levels, which could result in an entire chain of operations failing silently.\nFor instance, consider the following piece of code:\ntry {\nint result = 10 / 0; // This line will throw an ArithmeticException\n} catch (ArithmeticException e) {\n// This is an example of swallowing an exception\n}\n1try {\n2 int result = 10 / 0; // This line will throw an ArithmeticException\n3} catch (ArithmeticException e) {\n4 // This is an example of swallowing an exception\n5}\nIn the above example, an ArithmeticException is thrown due to division by zero, but the exception is swallowed in the catch block, leading to a silent failure. This kind of error can be incredibly difficult to track down in a larger codebase because it leaves no trace.\nA better practice would be to at least log the exception, giving you a chance to diagnose the problem if something goes wrong. Here's how you might handle the exception more effectively:\ntry {\nint result = 10 / 0; // This line will throw an ArithmeticException\n} catch (ArithmeticException e) {\nSystem.err.println(\"An arithmetic error occurred: \" + e.getMessage());\n}\n1try {\n2 int result = 10 / 0; // This line will throw an ArithmeticException\n3} catch (ArithmeticException e) {\n4 System.err.println(\"An arithmetic error occurred: \" + e.getMessage());\n5}\nBy appropriately logging the exception, you will get a message in your error log indicating what went wrong, making it easier to debug and fix the issue. In real-world applications, you'd likely use a logging framework like Log4j or SLF4Jinstead of System.err.println, but the principle remains the same.\nRemember, ignoring exceptions may result in unpredictable behavior, while proper exception handling leads to more robust, reliable, and maintainable software.\nNeglecting Null Checks\nJava's object-oriented paradigm permits the use of null references, i.e., references that do not point to any object. While null references can be handy, they also pose a common pitfall: a NullPointerException\n(NPE). This exception is thrown when a program attempts to use an object reference that has the null value. These include calling an instance method on the object referred to by the null reference or trying to access a field of the object. Forgetting to check for null before accessing object methods or properties is a common oversight that can lead to such crashes.\nTake, for example, the following code:\nString myString = null;\nint length = myString.length(); // This will throw a NullPointerException\n1String myString = null;\n2int length = myString.length(); // This will throw a NullPointerException\nIn this scenario, myString\nis null\n, and calling length()\non it results in a NullPointerException\n. This mistake can be easy to overlook in complex codebases or when dealing with returned values from methods, or objects that have many fields in them, leading to program failure.\nA good defensive programming practice is to make null checks before accessing methods or properties of an object. Modifying the previous example, we would have:\nString myString = null;\nint length = 0;\nif (myString != null) {\nlength = myString.length(); // Safe!\n}\n1String myString = null;\n2int length = 0;\n3if (myString != null) {\n4 length = myString.length(); // Safe!\n5}\nIn this case, we only attempt to call the length()\nmethod if myString\nis not null\n, thereby avoiding the potential for a NullPointerException\n.\nMoreover, as of Java 8, the Optional\nclass was introduced to help deal with null references in a more explicit and safer manner. Using Optional\ncan help you design more robust APIs by making the potential absence of a value explicit in your method signatures and forcing the caller to consider the null case. Here's an example of that :\nOptional myOptionalString = Optional.ofNullable(null);\nint length = myOptionalString.map(String::length).orElse(0);\n1Optional myOptionalString = Optional.ofNullable(null);\n2int length = myOptionalString.map(String::length).orElse(0);\nIn this example, we wrap the potentially null string in an Optional\n. Optional.ofNullable\nis used to create an Optional\nthat will either hold a non-null value or be empty if the provided value is null. Then, we use the map function to apply the length method only if the Optional\nis not empty. If the Optional\nis empty, which means the original string was null\n, the orElse\nmethod will be used to provide a default value of 0\n.\nWhile null references cannot always be avoided, careful checks, liberal use of Optional\n, and thoughtful API design can prevent many common NullPointerExceptions\n, leading to more robust and error-resilient programs.\nImproper Usage of equals() and hashCode()\nJava's Object class, from which all other classes inherit, includes equals()\nand hashCode()\nmethods. When you create custom classes in Java, you may need to override these methods, particularly if you're going to use instances of these classes as keys in a HashMap\nor inside a Set\n. Not doing so may lead to unexpected results.\nThe equals()\nmethod checks if two objects are equal at a logical level. By default, this method checks for reference equality, meaning it returns true only if the two references being compared point to the same object in memory. In many cases, you'll want to change this behavior to check for logical equality instead.\nFor example, consider a Interviewer\nclass where equality should be determined by a interviewer's unique ID:\npublic class Interviewer {\nprivate String id;\nprivate String name;\npublic Interviewer(String id, String name) {\nthis.id = id;\nthis.name = name;\n}\n// Incorrect: uses reference equality, not logical equality\n// This equals method is inherited from the Object class\n// // public boolean equals(Object obj) {\n// return this == obj;\n// }\n// Correct: checks for logical equality using the unique ID\n@Override\npublic boolean equals(Object obj) {\nif (this == obj)\nreturn true;\nif (obj == null || getClass() != obj.getClass())\nreturn false;\nInterviewer interviewer = (Interviewer) obj;\nreturn id.equals(interviewer.id);\n}\n}\n1public class Interviewer {\n2 private String id;\n3 private String name;\n4\n5 public Interviewer(String id, String name) {\n6 this.id = id;\n7 this.name = name;\n8 }\n9\n10 // Incorrect: uses reference equality, not logical equality\n11 // This equals method is inherited from the Object class\n12 // // public boolean equals(Object obj) {\n13 // return this == obj;\n14 // }\n15\n16 // Correct: checks for logical equality using the unique ID\n17 @Override\n18 public boolean equals(Object obj) {\n19 if (this == obj)\n20 return true;\n21 if (obj == null || getClass() != obj.getClass())\n22 return false;\n23 Interviewer interviewer = (Interviewer) obj;\n24 return id.equals(interviewer.id);\n25 }\n26}\nThe hashCode()\nmethod, on the other hand, is used in collections like HashMap\nand HashSet\nfor efficient data access. It should be overridden in such a way that if two objects are equal according to the equals()\nmethod, their hashCode()\nmethod should return the same value. If it doesn't, this can lead to unexpected and incorrect behavior when using these objects in collections.\nContinuing the Interviewer class example:\n// Incorrect: does not override hashCode(), so it\n// uses the default one from Object class\n// which is not consistent with the overridden equals method\n// @Override\n// public int hashCode() {\n// return super.hashCode();\n// }\n// Correct: hashCode() is consistent with equals()\n@Override\npublic int hashCode() {\nreturn id.hashCode();\n}\n1 // Incorrect: does not override hashCode(), so it\n2 // uses the default one from Object class\n3 // which is not consistent with the overridden equals method\n4 // @Override\n5 // public int hashCode() {\n6 // return super.hashCode();\n7 // }\n8\n9 // Correct: hashCode() is consistent with equals()\n10 @Override\n11 public int hashCode() {\n12 return id.hashCode();\n13 }\nBy properly overriding equals()\nand hashCode()\n, you can ensure that your custom objects behave as expected when used in collections or when compared using equals()\n. Remember, when overriding one, you should override both. Otherwise, you might end up with hard-to-detect bugs and unexpected behavior.\nOvercomplicating Solutions\nJava offers various features, such as streams and optional. However, overuse can lead to unnecessarily complicated and hard-to-read code. In interviews, prioritize simplicity and readability over clever, complex solutions.\nFor example, a complex chain of stream operations might seem like a clever way to solve a problem in a single line. Still, it could also end up being confusing to the interviewer who's trying to follow your logic. Similarly, while we discuss the usefulness of Optional\nin the point above, excessive usage of Optional\nmight clutter your code, making it harder to understand and maintain.\nIn a coding interview, your primary goal is to convey your problem-solving skills effectively. Your solutions should be easy to understand, correct, and efficient. Prioritize simplicity and readability over using advanced language features to create clever but complicated solutions. An interviewer will be more impressed by your ability to write clean, straightforward code that solves the problem efficiently, rather than a convoluted solution that makes heavy use of advanced language features.\nTherefore, while it's beneficial to be familiar with advanced features in Java, it's crucial to use them judiciously and in a way that enhances, not obscures, your code's readability and simplicity.\nHow to Demonstrate Java Expertise in Interviews\nTo show off your Java expertise, you could delve deep into some of the core ideas behind the Java language, such as the JVM and memory management, or discuss the latest features in the recent JDK releases. Mention garbage collection where appropriate and be sure to use Java slang like describing objects as POJOs (Plain Old Java Objects).\nTalk about how Java has evolved over the years and how the introduction of new features like lambda expressions, the Stream API, and the module system have changed the way you code in Java. If you've adopted a more functional style with these features or even have dabbled with Kotlin then it could be worth mentioning.\nRemember to also follow Java best practices, such as preferring immutability, avoiding raw type usage, leveraging the enhanced for loop and try-with-resources statement, and properly overriding equals and hashCode when necessary.\nDemonstrating your understanding of Java best practices and idioms is crucial to succeed in Java interviews. Don't get lost in niche Java trivia and focus on showing that you can code and not how to solve a problem without involving a whole ton of extra bells and whistles.\nJava Interview Replays\nBelow you can find replays of mock interviews conducted on our platform in Java. The questions asked in these interviews tend to be language-agnostic (rather than asking about language-specific details and idiosyncrasies), but in these cases, the interviewee chose Java as the language they would work in.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/java-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "System Design Interview Questions & Tips for Senior Engineers",
      "content": "About System Design Interviews\nIf you’re a mid-level or senior-level software engineer, regardless of where you interview, you will get asked at least a few system design questions. Most companies will ask system design questions during the onsite, but some may include a system design component in their technical phone screen (more likely if they’re a startup rather than a FAANG).\nSystem design interview questions fall, by and large, into the following 12 categories:\n- APIs\n- Databases (SQL vs NoSQL)\n- Scaling\n- CAP theorem\n- Web authentication and basic security\n- Load balancers\n- Caching\n- Message queues\n- Indexing\n- Failovers\n- Replication\n- Consistent hashing\nThat’s a long list, and system design is a really broad topic. Rather than trying to summarize everything you need to know about these types of interviews in a few paragraphs (an impossible task), we’ve written the best guide to system design interviews out there.\nBy the way, many people believe that in order to pass a FAANG system design interview, you have to have professional experience with distributed systems. We’ll show you that that’s categorically false, and that with the right preparation, you don’t need to fall into the catch-22 of having to have worked at a FAANG in order to get a job at a FAANG.\nCheck out our in-depth guide to system design, developed by the best interviewers in the industry, directly from their experience in thousands of technical interviews:\nSystem Design Interview Replays\nSystem Design Interview Questions and Solutions\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/system-design-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Dynamic Programming Interview Questions & Tips for Senior Engineers",
      "content": "Dynamic Programming Interview Questions & Tips\nWhat is Dynamic Programming?\nDynamic programming is an optimization technique used to efficiently solve problems that are computationally complex. The key characteristic is the way dynamic programming breaks the overall problem into smaller, overlapping subproblems. Often the solutions to subproblems are stored and reused to avoid repeated work. In comparison with other approaches, this greatly improves the efficiency of the solution.\nCompanies That Ask Dynamic Programming Questions\nA Practical Example: Determining the Nth Fibonacci Number\nTo quickly refresh your memory, the Fibonacci Sequence is a sequence of numbers in which every number is the sum of the two previous numbers:\n0, 1, 1, 2, 3, 5, 8, 13, 21, …\nWe should also restate that the Fibonacci sequence is known to start with 0, 1. This represents the \"base case\" which will be covered in more detail later on.\nNow, looking from left-to-right, it is fairly easy to see that each number, along with its predecessor, is needed to determine the next in the sequence. Think of this as a “bottom-up” approach in that it begins with the first example and builds up to the desired solution.\nSaid another way, and this time looking from right-to-left, a given number in the sequence can be derived from the two previous numbers. Think of this as a \"top-down\" approach in that it begins with the desired solution and drills down toward the first example.\nRegardless of which way you look at it, the computation can be formalized as F(n) = F(n-1) + F(n-2). This is known as a recurrence relation and is another important concept that we’ll get back to later.\nLet’s now turn to some code and step through a simple top-down solution that makes use of recursion:\ndef fib(n):\nif n == 0:\nreturn 0\nif n == 1:\nreturn 1\nreturn fib(n - 1) + fib(n - 2)\n1def fib(n):\n2 if n == 0:\n3 return 0\n4 if n == 1:\n5 return 1\n6 return fib(n - 1) + fib(n - 2)\nConsider what happens when invoked as fib(5)\nto determine the fourth Fibonacci number.\nN - 1 = 4\nand N - 2 = 3\nso this function makes recursive calls to return fib(4) + fib(3)\n. Notice that the invocation of fib(4)\nwill in turn make recursive calls fib(3)\nand fib(2)\n. This highlights the overlapping subproblems and where work is being repeated. The function calls can also be represented as a tree to visualize and identify the repeated work:\nIn the end, solving for the fifth Fibonacci number ends up solving for:\n- The fourth Fibonacci number once\n- The third number twice\n- The second number three times\n- The first number five times\nThis is where dynamic programming really shines as it helps avoid repeating work and provides a far more efficient solution.\nIncorporating Memoization to Avoid Repeated Work\nIn the recursive algorithm for this problem the answer to fib(3)\n(and all other subproblems) is immediately discarded; what a waste!\nInstead, we can utilize a hashmap to store the return value of fib(3)\nand later when the same subproblem comes up, the result can be quickly retrieved, with O(1) time complexity, instead of repeating it all over. Summing two numbers a handful of times for low values of N may not seem like a big deal, but as N gets subproblem repetition increases rapidly. This technique of caching the result of a function call, in order to avoid making the same call again in future, is known as memoization.\ndef topDownFib(n):\ndp = [0] \\* (n+1)\nreturn topDownFibHelper(n, dp)\ndef topDownFibHelper(n, dp):\nif n == 0 or n == 1:\nreturn n\n# If value is not set in cache, compute it\nif dp[n] == 0:\ndp[n] = topDownFibHelper(n-1, dp) + topDownFibHelper(n-2, dp)\nreturn dp[n]\n1def topDownFib(n):\n2 dp = [0] \\* (n+1)\n3 return topDownFibHelper(n, dp)\n4\n5def topDownFibHelper(n, dp):\n6 if n == 0 or n == 1:\n7 return n\n8 # If value is not set in cache, compute it\n9 if dp[n] == 0:\n10 dp[n] = topDownFibHelper(n-1, dp) + topDownFibHelper(n-2, dp)\n11 return dp[n]\n12\nWorking Iteratively from the Bottom Up Using Tabulation\nSimilarly, this problem can be solved from the bottom up, calculating and storing each number in the sequence along the way. This style of storing and reusing results is known as “tabulation”.\ndef bottomUpFib(n):\nif n == 0:\nreturn 0\n# Initialize cache\ndp = [0] \\* (n+1)\ndp[1] = 1\n# Fill cache iteratively\nfor i in range(2, n+1):\ndp[i] = dp[i-1] + dp[i-2]\nreturn dp[n]\n1def bottomUpFib(n):\n2 if n == 0:\n3 return 0\n4 # Initialize cache\n5 dp = [0] \\* (n+1)\n6 dp[1] = 1\n7\n8 # Fill cache iteratively\n9 for i in range(2, n+1):\n10 dp[i] = dp[i-1] + dp[i-2]\n11\n12 return dp[n]\n13\nAlthough an array can be used for tabulation when solving for Fibonacci (and in fact is excessive since at most 2 previous previous results are ever needed), it demonstrates a concept that often needs to be extended as far as using multi-dimensional arrays to solve more complex problems.\nA Quick Recap on What We Learned via Fibonacci\nAfter considering Fibonacci from different perspectives and seeing two contrasting approaches, we’ve now been introduced to all the core concepts associated with dynamic programming:\n- Base cases and the sub-problems that give light to a recurrence relation\n- Top-down approaches which typically involve recursion and memoization\n- Bottom-up approaches that are usually iterative and use tabulation\nLet’s move on to look at when and how to apply Dynamic programming in interviews.\nUsing Dynamic Programming in Interviews\nBefore getting to the more formal concepts that determine whether dynamic programming can be applied, let's look at some basic heuristics to use in an interview to determine whether to even consider dynamic programming.\nHeuristics for Identifying Dynamic Programming Problems\nThe first heuristic comes from considering the problem statement. Does it ask for the min/max out of a set of possible options, the best/worst of a set of possible options, or perhaps the total number of options? This isn't confirmation that dynamic programming is suitable, or even that's the best approach, but it is a good signal that DP is worth exploring.\nAs always in a technical interview, it's good practice to discuss and work through one or two simple-ish examples. Doing so helps to clarify the interviewer's requirements and expectations, plus it provides test cases for later. While working through the examples you likely identified a brute-force approach. And in explaining how the brute force work leads to the result, did you find yourself mentioning that the more complex example \"follows on from\" or \"makes use of\" the simpler example? This is a second heuristic and it's a great indication that there are sub-problems and repeated work which means a dynamic programming approach could work well.\nDoes a programmatic solution involving recursion become apparent? Where does the recursion lead? Eventually it must \"bottom out\" and this is likely to be the base case. What are the branches or conditional paths that trigger recursive calls? They will likely form part of the recurrence relation. The availability of a recursive solution is a third heuristic you can look for.\nWith one or more of these heuristics present, you can be confident spending time and looking hard for a dynamic programming solution.\nOptimal Substructure and Overlapping Subproblems\nMore formally, in order to apply dynamic programming to a problem two conditions must be present:\n- Optimal substructure\n- Overlapping subproblems\nOptimal Substructure\nOptimal substructure requires that you can solve a problem based on the solutions of subproblems. For example, if you want to calculate the 5th Fibonacci number, it can be solved by computing fib(5) = fib(4) + fib(3). It is not necessary to know any more information other than the solutions of those two subproblems in order to determine the solution.\nA useful way to think about optimal substructure is whether a problem can be easily solved recursively. Recursive solutions inherently solve a problem by breaking it down into smaller subproblems. If you can solve a problem recursively, it most likely has an optimal substructure.\nOverlapping Subproblems\nOverlapping subproblems means that when you split your problem into subproblems, you sometimes get the same subproblem multiple times. With the Fibonacci example, if we want to compute fib(5)\n, we need to compute fib(4)\nand fib(3)\n. However, to compute fib(4)\n, we need to compute fib(3)\nagain. This is a wasted effort, since we’ve already computed the value of fib(3)\n.\nDynamic programming relies on overlapping subproblems, and it uses memory to save the values that have already been computed to avoid computing them again. The more overlap there is, the more computational time is saved.\nThe FAST Method\nFAST is an acronym that stands for Find the first solution, Analyze the solution, identify the Subproblems, and Turn around the solution.\nIt isn’t the only way to work through problems to reach a dynamic programming solution, but aims to be easy to remember and apply while being broadly applicable.\nLet’s break down each of these steps.\nFind the First Solution\nThe first step to solving any dynamic programming problem using The FAST Method is to find an initial brute force recursive solution. Solve the problem without concern for efficiency, just as a starting point. Though there are a couple of constraints on how this brute force solution should look:\n-\nRecursive functions should be self-contained. Storing results by updating global variables may make it impossible to introduce memoization later on. Craft a function that is solely dependent on its parameters and not affected by outside factors.\n-\nAvoid unnecessary recursive function arguments. Subproblem results will eventually be memoized based on the arguments; the fewer the better.\nAnalyze the First Solution\nAnalyze the initial brute force solution. This involves determining the time and space complexity and determining if there are any obvious areas for improvement.\nAs part of the analytical process, confirm that the first solution fits the rules for problems with Dynamic programming solutions:\n- Does it have an optimal substructure?\n- Are there overlapping subproblems?\nSubproblem Identification\nIf there is indeed a Dynamic programming solution, the appropriate subproblems can now be identified and coded. Apply memoization to avoid unnecessary repeated work. At this point the problem is solved with a top-down solution that likely exhibits optimal complexity and no does not repeat any work.\nTurn the Solution Around\nSince we understand the problem well, we can go further. This involves coding the alternate bottom-up approach that iteratively computes and uses tabulation to store the results of successive subproblems, until the overall solution is reached. Turning the solution to bottom-up is generally desired as it avoids pitfalls associated with recursion and the call stack.\nDeciding on Top-down/Memoization vs. Bottom-up/Tabulation\nIn an interview, the choice of top-down or bottom-up approaches should be balanced with other factors beyond performance: How easily can the bottom-up solution be coded, is it as easily reasoned about and discussed with the interviewer? Which approach are you most comfortable with? That may be the most important factor of all!\nCommon Mistakes in Interviews Featuring Dynamic Programming\n-\nJumping too quickly to conclude dynamic programming is necessary. When you have a hammer, everything starts to look like a nail. If the problem doesn’t require an optimal solution but rather any correct solution, a greedy approach will likely be simpler to identify and implement.\n-\nConversely, looking too hard for a greedy solution and failing to recognize a dynamic programming problem. A way to determine which solution is more appropriate is to know whether a sub-solution helps lead to the final solution. If a sub-solution (a solution with a part of the input) helps, then dynamic programming is probably the way to go!\n-\nFailing to identify how to break the problem into subproblems so that the recurrence relation and base case(s) become clear. When you have a strong intuition (or have been told) that a problem needs a Dynamic programming solution, this is the major challenge. Reviewing plenty of questions and gaining practice is essential.\n-\nStruggling to define and work with a suitable result matrix. Many problems (such as Longest Common Subsequence) involve two- or multi-dimensional arrays to store sub-problem results. These can be difficult to conceive and may be tricky to work with in code. Again it’s all about practice.\n- Lack of clarity in communicating your dynamic programming logic. Visualizations can help a great deal here. As we’ve seen in this article, sketching a recursive tree or a matrix table can be helpful tools to gain shared understanding with your interviewer.\nWhat to Say in Interviews to Show Mastery Over Dynamic Programming\n- Articulate why dynamic programming is applicable (overlapping subproblems and optimal substructure) for a given problem\n- Refer to the recurrence relation and base case(s). Reason about and justify that the subproblem dependencies are acyclic.\n- Discuss and ask the interviewer if they have a preference when it comes to the tradeoffs between top-down (recursive) and bottom-up approaches.\nAbout the Authors\nTom has four years of experience developing software professionally, including experience at both Amazon and Pinterest. He is experienced both as an interviewer, conducting interviews on behalf of the companies he's worked for, and interviewee, as he has landed software engineering offers from Google, Twitter, Stripe, Airtable and Doordash during previous job searches.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/dynamic-programming-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Binary Trees Interview Questions & Tips for Senior Engineers",
      "content": "Binary Trees Interview Questions & Tips\nWhat is a Binary Tree?\nA binary tree is a type of tree data structure where each node can have at most two children, typically referred to as the left child and the right child. This binary structure allows for efficient searching, insertion, and deletion operations, especially when further rules are applied to the tree to express different types of binary trees.\nHere's an example of a binary tree node implementation:\nclass BinaryTreeNode {\nInteger data = null;\nBinaryTreeNode left = null;\nBinaryTreeNode right = null;\nBinaryTreeNode(Integer value) {\ndata = value;\n}\n}\n1class BinaryTreeNode {\n2 Integer data = null;\n3 BinaryTreeNode left = null;\n4 BinaryTreeNode right = null;\n5\n6 BinaryTreeNode(Integer value) {\n7 data = value;\n8 }\n9}\nGiven that not all nodes need to have two children, binary trees can be tall or wide, and everything in between. If each node in a binary tree only has one child (except for leaves), the tree would be much taller than it is wide. On the other hand, if most or all the nodes in a binary tree have two children, then the tree would be considered balanced.\nSpecifically, we can view binary trees as being balanced or unbalanced by this measure: a binary tree is balanced when the heights of the left and right subtrees of any node differ by at most one. \\*\\*The height of a tree is determined by the number of edges in the longest path from the root to a leaf. \\*\\*\nThe main advantage of a balanced binary tree is that we can achieve optimal performance for searching, adding and deleting operations - by maintaining logarithmic height, these operations can be performed in O(log n) time complexity on average.\nExamples of balanced binary trees are AVL trees and Red-Black trees. These are considered advanced topics, sometimes found in database implementations along with other use-cases, and rarely come up in interview questions. More often, when discussing binary tree optimizations, we encounter binary search trees.\nWhat is a Binary Search Tree (BST)?\nA common implementation of a binary tree is a binary search tree. Right there in the name, the binary search tree enables efficient implementation of the binary search algorithm thanks to the way the binary tree is organized: for each node in the tree, the value of the node is greater than the value of all the nodes in its left subtree and smaller than the value of all the nodes in its right subtree.\nDue to the tree's binary search property, this structure enables a systematic and efficient search process. When searching for a target value, comparisons are made at each node to determine whether to process the left or the right subtree. This allows for the elimination of half of the remaining search space at each step, resulting in a worst-case time complexity of O(log n) for searching, where n is the number of nodes in the tree.\nThe height of a binary search tree affects the efficiency of the operations. Balanced binary search trees, such as AVL trees or Red-Black trees, maintain a balanced structure to ensure logarithmic time complexity for operations.\nImplementing a Binary Search Tree\nTo create a binary search tree, the insertNode method will enforce the binary search property. Traversing from the root, insertNode will recursively search for the correct position to add the new node by checking the binary condition: if the currentNode is larger than the new node, traverse left, if the currentNode is smaller than the new node, traverse right. Search will apply the same logic, but return if the target is found.\nInsert\nprivate BinaryTreeNode insertNode(BinaryTreeNode root, int key) {\nif (root == null) {\nreturn new BinaryTreeNode(key);\n}\nif (key < root.data) {\nroot.left = insertNode(root.left, key);\n} else if (key > root.data) {\nroot.right = insertNode(root.right, key);\n}\n// if the input key already exists, we don't do anything.\nreturn currentNode;\n}\n1private BinaryTreeNode insertNode(BinaryTreeNode root, int key) {\n2 if (root == null) {\n3 return new BinaryTreeNode(key);\n4 }\n5\n6 if (key < root.data) {\n7 root.left = insertNode(root.left, key);\n8 } else if (key > root.data) {\n9 root.right = insertNode(root.right, key);\n10 }\n11\n12 // if the input key already exists, we don't do anything.\n13 return currentNode;\n14 }\nprivate BinaryTreeNode deleteNode(BinaryTreeNode root, Integer key) {\nif (root == null) {\nreturn root;\n}\nif (key < root.data) {\nroot.left = deleteNode(root.left, key);\n} else if (data > root.data) {\nroot.right = deleteNode(root.right, key);\n} else {\n// Node to be deleted is found\n// Case 1: Node has no child or only one child\nif (root.left == null) {\nreturn root.right;\n} else if (root.right == null) {\nreturn root.left;\n}\n// Case 2: Node has two children\nroot.data = minValue(root.right);\nroot.right = deleteNode(root.right, root.data);\n}\nreturn root;\n}\nprivate Integer minValue(BinaryTreeNode root) {\nInteger minValue = root.data;\nwhile (root.left != null) {\nminValue = root.left.data;\nroot = root.left\n}\nreturn minValue;\n}\n1private BinaryTreeNode deleteNode(BinaryTreeNode root, Integer key) {\n2 if (root == null) {\n3 return root;\n4 }\n5\n6 if (key < root.data) {\n7 root.left = deleteNode(root.left, key);\n8 } else if (data > root.data) {\n9 root.right = deleteNode(root.right, key);\n10 } else {\n11 // Node to be deleted is found\n12\n13 // Case 1: Node has no child or only one child\n14 if (root.left == null) {\n15 return root.right;\n16 } else if (root.right == null) {\n17 return root.left;\n18 }\n19\n20 // Case 2: Node has two children\n21 root.data = minValue(root.right);\n22 root.right = deleteNode(root.right, root.data);\n23 }\n24\n25 return root;\n26 }\n27\n28private Integer minValue(BinaryTreeNode root) {\n29 Integer minValue = root.data;\n30 while (root.left != null) {\n31 minValue = root.left.data;\n32 root = root.left\n33 }\n34 return minValue;\n35}\nTraversal Order in a Binary Tree\nA common task with binary trees is traversing the data structure, since without random access, this is the only way to do anything with our data: search, add, delete, print, etc. In addition to selecting an appropriate traversal algorithm, we also need to determine the order in which we want to visit the nodes.\nAt a high level, there are two types of traversals: depth-first search (DFS) and breadth-first search (BFS). To explore these algorithms generally, you should read more about DFS and BFS. But in this article, we'll specifically discuss how traversal order is important for binary tree traversal.\nDFS is a search algorithm that traverses a tree data structure by prioritizing exploring deeper paths from from child node to child node until a leaf node is finally visited or some condition is met. When visiting each node in a binary tree, the DFS algorithm has three operations it needs to perform in some order: \"visit the node\", which means perform some work (eg. print the value, add to some counter, delete it, etc), traverse down the left subtree, and traverse down the right subtree. The order of these three operations has a huge impact on the ultimate traversal order, so we further subdivide DFS into preorder, inorder, and postorder traversal.\nAs an alternative to DFS, the BFS algorithm prioritizes visiting all the direct children at the same level before moving deeper into the tree. With this pattern, there is only one possible traversal order, which is called level-order traversal.\nLet's explore these traversal orders more closely.\nDepth-First Search (DFS)\nConsider an example where we are printing all the nodes of the binary search tree from before using a DFS traversal.\nInorder Traversal\nInorder traversal is a process for visiting each node in a binary tree by first visiting the left subtree, then the node itself, and then the right subtree. With inorder traversal, the path always favors the leftmost tree before traversing the rest.\nThe sequence produced with inorder traversal: 1, 3, 4, 6, 7, 8, 10, 13, 14.\nIn a binary search tree, inorder traversal results in visiting the nodes in ascending order. This is because by favoring resolving the left subtree at each node, at each node we are always moving toward the smallest value available and returning the inorder successor.\nvoid inorderTraversal(BinaryTreeNode node) {\n// base case: if node is null, do nothing\nif (node != null) {\n// recurse on left child\ninorderTraversal(node.left);\n// visit current node\nSystem.out.print(node.data + \" \");\n// recurse on right child\ninorderTraversal(node.right);\n}\n}\n1void inorderTraversal(BinaryTreeNode node) {\n2 // base case: if node is null, do nothing\n3 if (node != null) {\n4 // recurse on left child\n5 inorderTraversal(node.left);\n6\n7 // visit current node\n8 System.out.print(node.data + \" \");\n9\n10 // recurse on right child\n11 inorderTraversal(node.right);\n12 }\n13}\nPreorder Traversal\nPreorder traversal visits each node in the tree by first visiting the node itself, then traversing the left subtree, and finally traversing the right subtree. In each recursive call, the function first prints (or \"visits\") the current node, then calls the recursive function on the left subtree, and finally on the right subtree.\nThe sequence produced with preorder traversal: 8, 3, 1, 6, 4, 7, 10, 14, 13\nvoid preorderTraversal(BinaryTreeNode node) {\n// base case: if node is null, do nothing\nif (node != null) {\n// visit current node\nSystem.out.print(node.data + \" \");\n// recurse on left child\npreorderTraversal(node.left);\n// recurse on right child\npreorderTraversal(node.right);\n}\n}\n1void preorderTraversal(BinaryTreeNode node) {\n2 // base case: if node is null, do nothing\n3 if (node != null) {\n4 // visit current node\n5 System.out.print(node.data + \" \");\n6\n7 // recurse on left child\n8 preorderTraversal(node.left);\n9\n10 // recurse on right child\n11 preorderTraversal(node.right);\n12 }\n13}\nPostorder Traversal\nIn each recursive call, the function first performs DFS on the left subtree, then performs DFS on the right subtree, and finally visits the current node.\nThe sequence produced with postorder traversal: 7, 6, 4, 1, 3, 13, 14, 8\nvoid postorderTraversal(BinaryTreeNode node) {\n// base case: if node is null, do nothing\nif (node != null) {\n// recurse on left child\npostorderTraversal(node.left);\n// recurse on right child\npostorderTraversal(node.right);\n// visit current node\nSystem.out.print(node.data + \" \");\n}\n}\n1void postorderTraversal(BinaryTreeNode node) {\n2 // base case: if node is null, do nothing\n3 if (node != null) {\n4 // recurse on left child\n5 postorderTraversal(node.left);\n6\n7 // recurse on right child\n8 postorderTraversal(node.right);\n9\n10 // visit current node\n11 System.out.print(node.data + \" \");\n12 }\n13}\nPostorder traversal is often used to delete the nodes of a tree in a specific order, because we can easily reconstruct the node references. We are basically marking the exact path of the recursive calls by immediately printing each node as it is visited.\nBreadth-First Search (BFS)\nLevel Order Traversal\nAs an alternative to using DFS we can also traverse a binary tree using Breadth-First Search (BFS), where we visit each node belonging to the same level before moving deeper into the tree. BFS uses a queue data structure (instead of a stack or recursion), in order to maintain the level-order traversal.\nThe sequence produced with level order traversal: 8, 3, 10, 1, 6, 14, 4, 7, 13\nLevel order traversal in a binary tree is often applied to problems where we need to process tree nodes by level, or if we want to find the shortest distance between two nodes.\npublic static void levelOrderTraversal(TreeNode root) {\nif (root == null)\nreturn;\nQueue < TreeNode > queue = new LinkedList < > ();\nqueue.offer(root);\nwhile (!queue.isEmpty()) {\nTreeNode node = queue.poll();\nSystem.out.print(node.val + \" \");\nif (node.left != null)\nqueue.offer(node.left);\nif (node.right != null)\nqueue.offer(node.right);\n}\n}\n1public static void levelOrderTraversal(TreeNode root) {\n2 if (root == null)\n3 return;\n4\n5 Queue < TreeNode > queue = new LinkedList < > ();\n6 queue.offer(root);\n7\n8 while (!queue.isEmpty()) {\n9 TreeNode node = queue.poll();\n10 System.out.print(node.val + \" \");\n11\n12 if (node.left != null)\n13 queue.offer(node.left);\n14\n15 if (node.right != null)\n16 queue.offer(node.right);\n17 }\n18}\nTime and Space Complexity\nTime complexity: O(n)\n, where n is the number of nodes. If we're not explicitly performing binary search, we will visit every node at worst in a traversal.\nSpace complexity: O(n)\n, additional space is needed on the call stack when performing recursion.\nWhen to Use Binary Trees In Technical Interviews\nMost of the time, interview questions involving trees will be explicitly stated as such. The problem will come in the form of “Given a tree, do X”. Sometimes, the task may be challenging but not very ambiguous, for example validating a binary search tree. The most important thing when you see problems like this is to make sure that you understand what type of tree you’re dealing with. If it’s a BST, that has different implications than a binary tree that is not sorted, and could provide valuable clues for arriving at an optimal solution.\nIn other cases, we might be asked to store data efficiently - this could be an opportunity to implement a BST. A common interview task is to implement the insertion and search functions of a BST, as this is a great way to demonstrate one's understanding of the data structure, so be sure to practice these. Deleting a node from a BST can be asked as well but is often considered an advanced topic.\nFor generic binary trees, questions often involve assessing the dimensions of the tree, for example the height or diameter of the tree, or searching specific conditions between two or more nodes in the tree, like LCA or path sum. Here are some areas that come up often in interviews:\n- Height: Calculate the height of a binary tree (the number of edges on the longest path from the root to a leaf node).\n- Find Mirror Image: Determine if a binary tree is a mirror image of itself (symmetric).\n- Lowest Common Ancestor (LCA): Given two nodes in a binary tree, find their lowest common ancestor node.\n- Diameter of a Tree: Calculate the diameter of a binary tree (the length of the longest path between any two nodes).\n- Path Sum: Check if there exists a root-to-leaf path in a binary tree that adds up to a given sum. 6.Serialize and Deserialize: Serialize a binary tree into a string representation and deserialize it back to a binary tree.\nCommon Mistakes in Interviews Featuring Binary Trees\n- Mistaking a Binary Tree for a Binary Search Tree. Remember that an interviewer might intentionally leave information out of their problem description to leave room for your inquiries. The difference between a general binary tree and a BST will greatly influence the solution you propose.\n- Forgetting to consider duplicate keys when implementing a BST. Paying close attention to implementation details will help demonstrate your familiarity with the data structure.\n- Not using visual aids. Binary tree logic can become very complex, given its recursive nature. Using tree diagrams can help you work through the problem and communicate more effectively with your interviewer.\n- Misusing BFS or DFS. In some binary tree problems, where we don't have a sorted tree or we simply need to visit every node to perform some operation, both traversal algorithms are applicable without any meaningful complexity tradeoff. But a candidate needs to be confident about which situations call for a specific traversal. A common use-case for BFS, for example, is searching for the shortest path between two nodes. DFS on the other hand, is useful to perform on a binary search tree when we want to traverse the nodes in their sorted order.\n- Forgetting to set min/max bounds when validating binary search trees. An incorrect implementation just checks whether node.right.data > node.left.data and node.left.data < node.right.data\n- Not knowing how to use recursion within trees. Trees are inherently recursive data structures, so it's important to be familiar with recursive traversal. It may be obvious how to traverse from parent to child, but using recursive to traverse from child to parent (with return statement) is essential.\n- Incorrectly stating space complexity for recursive traversal. It is easy to forget that recursion doesn't use additional space since we are not introducing a new data structure. But in fact, we are taking advantage of an existing stack call the call stack, which must grow linearly with the number of nodes we are recursing on.\n- Forgetting to handle edge cases. Binary tree nodes can still have zero or one child, so be sure to explicitly check for edge cases. We also need to include base cases for recursive traversals.\nClarifying Questions to Ask Your Interviewer About Binary Trees\n- Is the input binary tree or a binary search tree? Clarifying the parameters offered by the interviewer is a great problem-solving skill to demonstrate. In some cases, interviewers will intentionally omit that the binary tree you're working with is actually sorted, so be sure to ask! This of course will have a huge impact on the approach you'll end up taking for your solution.\n- Will the input contain duplicate values? Whether you are streaming values or getting a tree as input, make sure to specify if duplicates need to be handled, as this complicates binary search tree implementation. For binary search trees, this is especially complicated, and will likely be the crux of the problem if the tree contains them. Alternatively, you might be building a BST from a stream of values, and you'll want to be sure you can omit duplicates if its appropriate in the problem.\n- How do we handle scenarios where a binary tree is empty or has null nodes? It is always encouraged to ask about how edge cases should be handled, as some interviewers will be happy enough that you communicated that you are aware of them, and will offer to let you skip implementation.\n- What operations need to be supported? If you'll be implementing a binary tree, make sure to ask your interviewer what operations to prioritize during the interview. In some cases, they can allow you to skip the implementation of some less-important operations.\n- What are the characteristics of the input tree? Be sure to determine if there are any constraints that the input binary tree adheres to, such as balancing or sorting, max height, weighted branches, etc. If so, this would be a clue as to what kind of tree data structure you should focus on during the interview.\nHow to Show Mastery of Trees in Interviews\nKnow Your BST\nOne of the most common topics in software engineering interviews is the Binary Search Tree. You want to be able to showcase your ability to implement binary trees efficiently and correctly. Make sure to practice implementing tree construction, node insertion, deletion, and traversal algorithms.\nSpeaking of traversal algorithms - many interview problems test your understanding of the traversal order, especially when working with binary search trees, since the output sequence order is not arbitrary. Be sure to understand the use-cases for preorder, inorder, postorder, and level-order traversals.\nBe Familiar with Recursive and Iterative Implementations of DFS\nAlthough trees are inherently recursive, and thus lend themselves to recursive traversal implementations, a candidate should be comfortable with the iterative implementation as well. This helps demonstrate your strong understanding of recursion as well, since we can mimic the recursive mechanism we get from the call stack with a stack we implement ourselves. The above traversals are all recursive - here's an example of an iterative DFS:\nIterative DFS\npublic static void iterativeDFS(BinaryTreeNode root) {\nif (root == null)\nreturn;\nStack < BinaryTreeNode > stack = new Stack < > ();\nstack.push(root);\nwhile (!stack.isEmpty()) {\nBinaryTreeNode node = stack.pop();\nSystem.out.print(node.val + \" \");\n// Push right child first (since it needs to be processed after left child)\nif (node.right != null)\nstack.push(node.right);\n// Push left child\nif (node.left != null)\nstack.push(node.left);\n}\n}\n1public static void iterativeDFS(BinaryTreeNode root) {\n2 if (root == null)\n3 return;\n4\n5 Stack < BinaryTreeNode > stack = new Stack < > ();\n6 stack.push(root);\n7\n8 while (!stack.isEmpty()) {\n9 BinaryTreeNode node = stack.pop();\n10 System.out.print(node.val + \" \");\n11\n12 // Push right child first (since it needs to be processed after left child)\n13 if (node.right != null)\n14 stack.push(node.right);\n15\n16 // Push left child\n17 if (node.left != null)\n18 stack.push(node.left);\n19 }\n20}\nAbout the Author\nKenny is a software engineer and technical leader with four years of professional experience spanning Amazon, Wayfair, and U.S. Digital Response. He has taught courses on Data Structures and Algorithms at Galvanize, helping over 30 students land new software engineering roles across the industry, and has personally received offers from Google, Square, and TikTok.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/binary-trees-interview-questions",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Three Sum (Interview Solution)",
      "content": "How to Solve Three Sum\nThree Sum Introduction\nThree Sum Introduction\nThe Three Sum problem involves finding all unique triplets of numbers in an array that sum up to a given target. As an extension of the classic Two Sum problem, it can be solved efficiently by building on top of that problem and applying a variety of sorting and hashing approaches.\nThree Sum Problem\nThree Sum Problem\nGiven an array of integers, return an array of triplets (in any order) such that i != j != k\nand nums[i] + nums[j] + nums[k] = 0\n. Note that the solution set must not include duplicate triplets (i.e., [1, 0, 0] and [0, 1, 0] are duplicative).\nExample Inputs and Outputs\nExample 1\nInput: [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]]\nExample 2\nInput: [1,2,7,12] Output: []\nExample 3\nInput: [7,4,-7,0] Output: [[0,-7,7]], OR [[7,-7,0]], etc.\nThree Sum Solutions\nThree Sum Solutions\nThis problem is a continuation of a similar problem aptly-named \"Two Sum\" in which the premise is very similar. As with that problem, for Three Sum there are naive, combination-driven approaches as well as more-efficient approaches.\n1. Brute Force\nWhen approaching an algorithms problem, particularly when thinking about the brute force approach, it is often easiest to start by thinking about how you would solve a given problem if you were to solve it by hand. Take Example 3, [7, 4, -7, 0]\n. While the answer for this example input may be obvious by simply looking at the array and thinking about the problem, you could also solve it by generating all the possible triplet combinations and evaluating which triplets meet the required criteria A + B + C = 0\n.\nInput: [7,4,-7,0] Triplets: [[7, 4, -7], [7, 4, 0], [7, -7, 0], [4, -7, 0]]\nNow the task becomes how we can generate the above list of triplets using code. For brute-force combinations problems the answer is often nested for loops, and given we are generating a list of triplets (vs. pairs or quadruplets) we can utilize three nested for loops to generate our list of triplets. From there we can scan the list and check whether each triplet meets our requirement of summing to zero.\nThe \"no duplicates\" requirement adds a bit of complexity. If we were to utilize three for loops, there would be no way to eliminate duplicates and thus it would be impossible to find a valid solution; however, we can tackle this by sorting the triplet before saving it to a hash map using a stringified-triplet as the key.\nThree Sum Python and JavaScript Solutions - Brute Force\ndef threeSum(nums: List[int]) -> List[List[int]]:\nthree\\_sums = {}\nfor i in range(0, len(nums)):\nfor j in range(i+1, len(nums)):\nfor k in range(j+1, len(nums)):\nif nums[i] + nums[j] + nums[k] == 0:\nsorted\\_answer = sorted([nums[i], nums[j], nums[k]])\nthree\\_sums[str(sorted\\_answer)] = [nums[i], nums[j], nums[k]]\nreturn three\\_sums.values()\n1def threeSum(nums: List[int]) -> List[List[int]]:\n2 three\\_sums = {}\n3 for i in range(0, len(nums)):\n4 for j in range(i+1, len(nums)):\n5 for k in range(j+1, len(nums)):\n6 if nums[i] + nums[j] + nums[k] == 0:\n7 sorted\\_answer = sorted([nums[i], nums[j], nums[k]])\n8 three\\_sums[str(sorted\\_answer)] = [nums[i], nums[j], nums[k]]\n9 return three\\_sums.values()\nTime/Space Complexity\n- Time Complexity:\nO(n³)\n- Space Complexity:\nO(len(answer))\n(space complexity will scale in line with the number of triplets found)\n2. Two Sum Hashmap\nNow that we've solved the problem using a brute-force, combinations driven approach let's think about how we can leverage common data structures to find a more efficient solution.\nThinking back to the Two Sum problem described earlier, consider the following nums\narray and target value: nums = [1, 7, 12, 4], target= 19\n.\nIf we are iterating over this list ([1, 7, 12, 4]\n) and on the 0th index, our current value is 1\n. Therefore, in order to sum to our target\nof 19\n, we are looking for 18\n. From an algebra perspective we know this because if X + 1 = 19\n, so X = 19 - 1\n.\nFrom here, the naive approach would be to scan the list looking for 18\n, however we can leverage a data structure that allows for constant time lookups (namely, a set or hashmap) in order to avoid repeatedly scanning the list. To translate the above logic to code, our Two Sum algorithm (which is relevant to Three Sum, I promise) looks like this:\n# Prompt: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\nnums\\_dict = {val: idx for idx, val in enumerate(nums)}\nfor idx, val in enumerate(nums):\nlooking\\_for = target - val\nif looking\\_for in nums\\_dict and nums\\_dict[looking\\_for] != idx:\nreturn [idx, nums\\_dict[looking\\_for]]\n1# Prompt: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n2def twoSum(self, nums: List[int], target: int) -> List[int]:\n3 nums\\_dict = {val: idx for idx, val in enumerate(nums)}\n4 for idx, val in enumerate(nums):\n5 looking\\_for = target - val\n6 if looking\\_for in nums\\_dict and nums\\_dict[looking\\_for] != idx:\n7 return [idx, nums\\_dict[looking\\_for]]\nWith that idea in mind, we can turn our attention back to Three Sum and consider how we can use a similar approach to solve the problem at hand. In this case, we can generate a hashmap that contains all two-item combinations in the array keyed by the sum of those two items, then use that hashmap to determine which tuples can be combined with any item in the array to sum to 0 (roughly, sum(Tuple[X, Y]) + otherIntegerZ == 0\n).\nThree Sum Python and JavaScript Solutions - Two Sum Hashmap\nfrom collections import defaultdict, Counter\ndef twoSumsMap(nums: List[int]) -> Dict[int, Tuple[int, int]]:\ntwo\\_sums\\_map = defaultdict(set)\nfor i, val\\_one in enumerate(nums):\nfor j, val\\_two in enumerate(nums[i+1:]):\ntwo\\_sums\\_map[val\\_one + val\\_two].add(\n(val\\_one, val\\_two)\nif val\\_one <= val\\_two else\n(val\\_two, val\\_one)\n)\nreturn two\\_sums\\_map\ndef threeSum(nums: List[int]) -> List[List[int]]:\n# O(n^2)\ntwo\\_sums\\_map = self.twoSumsMap(nums)\n# O(n)\ncounter\\_for\\_nums = Counter(nums)\nthree\\_sums = {}\n# iterating on the dictionary instead of `nums` in order to avoid duplicative work\nfor curr\\_val in counter\\_for\\_nums.keys():\ntwo\\_sum\\_tuples\\_for\\_val = two\\_sums\\_map[-curr\\_val]\nfor val\\_one, val\\_two in two\\_sum\\_tuples\\_for\\_val:\nif (curr\\_val != val\\_one and curr\\_val != val\\_two) or counter\\_for\\_nums[curr\\_val] >= 3:\nsorted\\_vals = sorted([curr\\_val, val\\_one, val\\_two])\nthree\\_sums[str(sorted\\_vals)] = sorted\\_vals\nreturn three\\_sums.values()\n1from collections import defaultdict, Counter\n2def twoSumsMap(nums: List[int]) -> Dict[int, Tuple[int, int]]:\n3 two\\_sums\\_map = defaultdict(set)\n4 for i, val\\_one in enumerate(nums):\n5 for j, val\\_two in enumerate(nums[i+1:]):\n6 two\\_sums\\_map[val\\_one + val\\_two].add(\n7 (val\\_one, val\\_two)\n8 if val\\_one <= val\\_two else\n9 (val\\_two, val\\_one)\n10 )\n11 return two\\_sums\\_map\n12def threeSum(nums: List[int]) -> List[List[int]]:\n13 # O(n^2)\n14 two\\_sums\\_map = self.twoSumsMap(nums)\n15 # O(n)\n16 counter\\_for\\_nums = Counter(nums)\n17 three\\_sums = {}\n18 # iterating on the dictionary instead of `nums` in order to avoid duplicative work\n19 for curr\\_val in counter\\_for\\_nums.keys():\n20 two\\_sum\\_tuples\\_for\\_val = two\\_sums\\_map[-curr\\_val]\n21 for val\\_one, val\\_two in two\\_sum\\_tuples\\_for\\_val:\n22 if (curr\\_val != val\\_one and curr\\_val != val\\_two) or counter\\_for\\_nums[curr\\_val] >= 3:\n23 sorted\\_vals = sorted([curr\\_val, val\\_one, val\\_two])\n24 three\\_sums[str(sorted\\_vals)] = sorted\\_vals\n25 return three\\_sums.values()\nTime/Space Complexity\n- Time Complexity:\nO(n²)\n- Space Complexity:\nO(n²)\n3. Sorting, Iterating and Two Point\nWhen given a list of strings or numbers during an algorithms interview we should always pause to consider whether sorting the input would allow the problem to be solved in a more efficient way, and in this case the answer is yes.\nConsider the following array: [-2, 3, 1, 7, -4, 9]\nAnd the same array sorted: [-4, -2, 1, 3, 7, 9]\nWhen iterating over an array we should also pause to consider whether adding a second pointer, known as the \"two pointers\" approach, would be helpful.\nIn this case we can design an algorithm that combines both of the approaches above. We first sort the array, then iterate over it (index I\n), placing two pointers (L\nand R\n) at the beginning and end of the other already-sorted numbers. To iterate the two pointers, we can conditionally moving either the left or right pointer based on whether the current triplet sum is larger or smaller than zero. If at any point arr[I] + arr[L] + arr[R] = 0\nthat means we have found a triplet that sums to zero.\nI L R\n[-4, -2, 1, 3, 7, 9] arr[I] (-4) + arr[L] (-2) + arr[R] (9) = 3, which is >= 0 --> move right pointer\nI L R\n[-4, -2, 1, 3, 7, 9] arr[I] (-4) + arr[L] (-2) + arr[R] (7) = 1, which is >= 0 --> move right pointer again\nI L R\n[-4, -2, 1, 3, 7, 9] arr[I] (-4) + arr[L] (-2) + arr[R] (3) = -3, which is <= 0 --> move left pointer\nI L R\n[-4, -2, 1, 3, 7, 9] arr[I] (-4) + arr[L] (1) + arr[R] (3) = 0, we found a match! Then move left pointer\nI LR\n[-4, -2, 1, 3, 7, 9] L = R, while loop no longer true, iterate `I`\nI L R\n[-4, -2, 1, 3, 7, 9] arr[I] (-2) + arr[L] (3) + arr[R] (9) = 10, which is >= 0 --> move right pointer\netc.\n1 I L R\n2[-4, -2, 1, 3, 7, 9] arr[I] (-4) + arr[L] (-2) + arr[R] (9) = 3, which is >= 0 --> move right pointer\n3 I L R\n4[-4, -2, 1, 3, 7, 9] arr[I] (-4) + arr[L] (-2) + arr[R] (7) = 1, which is >= 0 --> move right pointer again\n5 I L R\n6[-4, -2, 1, 3, 7, 9] arr[I] (-4) + arr[L] (-2) + arr[R] (3) = -3, which is <= 0 --> move left pointer\n7 I L R\n8[-4, -2, 1, 3, 7, 9] arr[I] (-4) + arr[L] (1) + arr[R] (3) = 0, we found a match! Then move left pointer\n9I LR\n10[-4, -2, 1, 3, 7, 9] L = R, while loop no longer true, iterate `I`\n11 I L R\n12[-4, -2, 1, 3, 7, 9] arr[I] (-2) + arr[L] (3) + arr[R] (9) = 10, which is >= 0 --> move right pointer\n13etc.\nThree Sum Python and JavaScript Solutions - Two Sum Hashmap\ndef threeSum(self, nums: List[int]) -> List[List[int]]:\nsorted\\_nums = sorted(nums)\nthree\\_sums = []\nfor i in range(len(sorted\\_nums)):\n# avoid duplicates\nif i > 0 and sorted\\_nums[i] == sorted\\_nums[i - 1]:\ncontinue\ntarget = -sorted\\_nums[i]\nl, r = i + 1, len(sorted\\_nums) - 1\nwhile l < r:\nif sorted\\_nums[l] + sorted\\_nums[r] == target:\nthree\\_sums.append([sorted\\_nums[i], sorted\\_nums[l], sorted\\_nums[r]])\nl += 1\n# avoid duplicates again\nwhile l < r and sorted\\_nums[l] == sorted\\_nums[l - 1]:\nl += 1\nelif sorted\\_nums[l] + sorted\\_nums[r] < target:\nl += 1\nelse:\nr -= 1\nreturn three\\_sums\n1def threeSum(self, nums: List[int]) -> List[List[int]]:\n2 sorted\\_nums = sorted(nums)\n3 three\\_sums = []\n4 for i in range(len(sorted\\_nums)):\n5 # avoid duplicates\n6 if i > 0 and sorted\\_nums[i] == sorted\\_nums[i - 1]:\n7 continue\n8 target = -sorted\\_nums[i]\n9 l, r = i + 1, len(sorted\\_nums) - 1\n10 while l < r:\n11 if sorted\\_nums[l] + sorted\\_nums[r] == target:\n12 three\\_sums.append([sorted\\_nums[i], sorted\\_nums[l], sorted\\_nums[r]])\n13 l += 1\n14 # avoid duplicates again\n15 while l < r and sorted\\_nums[l] == sorted\\_nums[l - 1]:\n16 l += 1\n17 elif sorted\\_nums[l] + sorted\\_nums[r] < target:\n18 l += 1\n19 else:\n20 r -= 1\n21 return three\\_sums\nTime/Space Complexity\n- Time Complexity:\nO(n²)\n- Space Complexity:\nO(n)\n(orO(1)\nif sorted in-place)\nPractice the Three Sum Problem With Our AI Interviewer\nPractice the Three Sum Problem With Our AI Interviewer\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/three-sum",
      "author": "",
      "user_id": ""
    },
    {
      "title": "System Design Distributed Databases (Interview Solution)",
      "content": "What Is The Distributed Databases Problem?\nWhat Is The Distributed Databases Problem?\nThe Distributed Databases Problem provides us with a scenario in which we have an SQL database and asks us to create a solution that allows us to add more machines once the first has reached capacity. In simple terms we must find a way to distribute this database. The caveat to this is that we do not have access to any automated tools for distributing. This problem demands consideration for the bottlenecks that may occur while manually distributing a SQL database.\nAn Example of the Distributed Databases Problem\nAn Example of the Distributed Databases Problem\nHow would you organize a SQL database like MySQL such that you can add more machines once your current ones reach maximum capacity? With the limitation that you do not have access to any automated tools for distributing.\nHow to Solve the Distributed Databases Problem\nHow to Solve the Distributed Databases Problem\nTo handle the increasing capacity in our SQL-based database system without relying on automated distributing tools, we can take a manual sharding approach. This means we'll manually divide the data across multiple machines or servers, allowing us to scale the system and add more machines when needed.\nSQL Databases\nLet’s start by talking about SQL databases:\n- SQL guarantees atomicity and isolation of transactions.\n- SQL seamlessly supports multi-table queries (JOINs).\n- SQL optimizes both indexes and queries on the DB level.\nBefore we go further, let’s clarify the functional requirements for this problem. Making an RDMBS (a relational database management system, the generalization of the loose term “SQL database”) horizontally scalable is, in general, a next-to-impossible task. For the purposes of scoping this [interview] conversation, let’s agree what we should focus on, and what can be left outside the spotlight.\nSpecifically, there are several optimization directions:\n- Scale to support more data volume (capacity),\n- Scale to support more query throughput (TPS, transactions per second),\n- Scale to support faster queries (tail latency), and\n- Scale to enable broad cross-shard complex queries with JOINs and other cross-shard data transfer.\nOption #4 is the holy grail, which we’d rather not touch today. Let’s assume, for this 45-minute discussion, that most high-throughput / low-latency queries only need to access the data that lives on one shard. The queries that require the data from multiple shards are allowed to be slow.\n(A useful exception: if some small amount of metadata exists, we can keep this data copied on every single shard, duplicated N times.)\nSo let’s focus on #1 while considering the original problem statement of “you can add more machines once your current ones reach maximum capacity”.\nSharding the database\nNext, the question is: how do we go about sharding our database? First, we have to identify the sharding key. We’ll choose a column or attribute in our table that can act as a sharding key. This key can help to evenly distribute the data across multiple machines if we can assume even load. In situations where performance is a consideration and we have a key that is hit more often than others, we may need special considerations to distribute the data unevenly to instead even out the load. Common examples include things such as user IDs. For this question we aren’t given any information about the data we have, but it may be worthwhile to ask for this information from your interviewer.\nOnce we have identified the sharding key, we can employ consistent hashing as our sharding technique. Consistent hashing ensures that the distribution of data across shards is balanced and minimizes the amount of data that needs to be remapped when adding or removing machines from the system. With consistent hashing, we can achieve a scalable sharding strategy that can handle the increasing data volume.\nWhen it comes to partitioning the data, we can split it based on our sharding key among the different machines in the network. Each machine will be responsible for storing a specific range or subset of data based on the sharding key value.\nKeep in mind that we’ll have to adjust our SQL queries to include the sharding key in the WHERE clause. This ensures that the queries are routed to the appropriate machine holding the relevant data.\nNow that we’ve determined the sharding strategy, we'll set up multiple instances of the SQL database, each running on a separate machine. Each instance will be responsible for storing and serving a specific shard of the data. We'll configure our application to interact with the appropriate database instance based on the shard key/criteria we used for sharding.\nLoad Balancer\nTo ensure the requests hit the correct shards, we introduce a load balancer into the system architecture. The load balancer acts as a traffic controller, receiving incoming requests and routing them to the correct database shards. In addition to routing the traffic correctly, if our consistent hashing approach keeps each data element on more than one shard, the load balancer can balance the load over these shards, thus evening the load and improving top-line performance.\nIndexing\nEven in a system with a distributed SQL database, optimizing query performance is still vital. We'll create appropriate indexes in our database schema to improve search and retrieval efficiency. As long as the requested data lives within one shard, a local DB index on this shard would improve query performance (e.g., looking for my WhatsApp messages to my friend Dima from July 2017, as long as the DB of messages is sharded by sender ID). For cross-shard queries, however, we will need far more sophisticated, custom, outside-the-DB indexes.\nBut what do we mean by indexing? In the context of an individual database (a single shard in our current design), indexing is the process of creating a data structure that enhances the speed and efficiency of data retrieval operations. An index is essentially a separate data structure that may contain a sorted copy of specific data fields, and/or reference these fields in other ways, which allows for faster lookup and retrieval of information.\nWhat about \"indexing” the sharding key? Well, that’s a little different. Logically, it does mean creating an index specifically on the column or attribute that is used as the sharding key in a sharded database setup.\nBut we already decided to use consistent hashing for shard selection. So, yes, it is a custom data structure, but it is not a database index that maps the sharding key values to the corresponding shard or machine; it’s “the ring” of the consistent hashing. This “ring” data structure enables the load balancer to quickly determine the location of the data based on the sharding key value, which improves the efficiency of data retrieval operations and effectively acts as the index on this “column,” despite living outside the very DB realm, but rather inside the load balancers.\nHere’s an example: if the sharding key is the user ID, and we want to retrieve all the data related to a specific user, querying the database using the user ID as a filter would be faster with the indexing in place. This allows the database system to quickly locate the shard or machine where the data for that user is stored, reducing the number of network requests and tail latency.\nIn summary, indexing the sharding key involves creating a separate data structure that helps optimize the process of locating and retrieving data stored in specific shards or machines based on the sharding key value.\nBenefits\nHow does this benefit us? Realistically, this is a fairly advanced topic, as it will come into play once we are talking about cross-shard data retrieval. Indexing the sharding key in a sharded database setup primarily improves the performance of SELECT statements, specifically those that involve filtering or searching based on the sharding key. These select statements benefit from the index by enabling faster data retrieval from the relevant shards or machines. Note that, in a simple version, making use of this newly created index would require the user to write their SELECT statements while keeping in mind the very fact that the data is sharded; an “automagical” SQL query engine that runs queries cross-shards as needed is a far more complex problem for this margin to contain.\nHowever, indexing the sharding key may not have a direct impact on the speed of UPDATE or MERGE statements. UPDATE and MERGE statements typically involve modifying or merging existing data rather than searching or filtering based on the sharding key. The performance of update and merge operations in a sharded database is more influenced by factors such as network latency, data synchronization, and other factors pertaining to the underlying database management system. Our design approach might be different if our optimization criteria had been to allow for faster data querying; since we are optimizing for capacity, however, the above should be good enough.\nWhile this manual sharding approach requires more effort and management compared to automated distributing tools, it gives us flexibility and control over our database infrastructure. We can scale the system by adding more machines (up to a certain point) while still benefiting from the advantages of a SQL-based database. It’s important to note that the critical mass for this is quite low; after just a dozen or so machines simply adding more instances may very well slow the whole system down, not speed it up. To resolve this, we have DBAs to not just add machines but understand exactly what the query patterns are, configure load, and manual sharding to keep the data local for the most expensive and/or most frequent queries.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/distributed-databases",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Intersection of Linked List",
      "content": "How to Solve Intersection of Linked List\nIntersection of Linked List Introduction\nIntersection of Linked List Introduction\nThe Intersection of linked list problem (also known as the Intersection of two linked list problem) asks us to return the node at which two linked lists intersect, if none then we return None. This problem requires us to consider the lengths of the given linked lists before using our pointers. Using the lengths we can adjust our starting positions accordingly. By using these two pointers effectively to traverse the lists we can find the point in which they intersect without comparing every node.\nIntersection of Linked List Problem\nIntersection of Linked List Problem\nGiven the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return none.\nIntersection of Linked List Solutions\nIntersection of Linked List Solutions\nWe can solve this problem using two-pointers. We start by finding the lengths of the two linked lists and adjust the starting positions of the pointers accordingly. This step ensures that both pointers are at the same relative position from the end of their respective lists. Next, we traverse the linked lists simultaneously using the two pointers. We keep moving the pointers one node at a time until either they meet at an intersection point or both reach the end of their lists. By doing this, we can search for the intersection point without having to compare every node.\nIf the pointers meet, it means we have found the intersection point. We can return that node as the result. If the pointers reach the end of their lists without meeting, it let's us know that there is no intersection between the two linked lists. In this case, we return 'None' to signify the absence of an intersection.\nclass ListNode:\ndef \\_\\_init\\_\\_(self, val=0, next=None):\nself.val = val\nself.next = next\ndef getIntersectionNode(headA, headB):\n# Check if either list is empty\nif not headA or not headB:\nreturn None\n# Get the lengths of both lists\nlenA, lenB = 0, 0\nnodeA, nodeB = headA, headB\nwhile nodeA:\nlenA += 1\nnodeA = nodeA.next\nwhile nodeB:\nlenB += 1\nnodeB = nodeB.next\n# Move the longer list's head pointer to align the lengths\nwhile lenA > lenB:\nheadA = headA.next\nlenA -= 1\nwhile lenB > lenA:\nheadB = headB.next\nlenB -= 1\n# Traverse both lists to find the intersection point\nwhile headA != headB:\nheadA = headA.next\nheadB = headB.next\n# Return the intersection node (or None if no intersection)\nreturn headA\n# Create linked lists for testing\n# Intersection point at node with value 8\ncommon = ListNode(8, ListNode(4, ListNode(5)))\nheadA = ListNode(4, ListNode(1, common))\nheadB = ListNode(5, ListNode(6, ListNode(1, common)))\n# Test our solution\nintersection = getIntersectionNode(headA, headB)\nif intersection:\nprint(\"Intersection at node with value:\", intersection.val)\nelse:\nprint(\"No intersection\")\n#Expected output: 8\n1class ListNode:\n2 def \\_\\_init\\_\\_(self, val=0, next=None):\n3 self.val = val\n4 self.next = next\n5\n6def getIntersectionNode(headA, headB):\n7 # Check if either list is empty\n8 if not headA or not headB:\n9 return None\n10\n11 # Get the lengths of both lists\n12 lenA, lenB = 0, 0\n13 nodeA, nodeB = headA, headB\n14 while nodeA:\n15 lenA += 1\n16 nodeA = nodeA.next\n17 while nodeB:\n18 lenB += 1\n19 nodeB = nodeB.next\n20\n21 # Move the longer list's head pointer to align the lengths\n22 while lenA > lenB:\n23 headA = headA.next\n24 lenA -= 1\n25 while lenB > lenA:\n26 headB = headB.next\n27 lenB -= 1\n28\n29 # Traverse both lists to find the intersection point\n30 while headA != headB:\n31 headA = headA.next\n32 headB = headB.next\n33\n34 # Return the intersection node (or None if no intersection)\n35 return headA\n36\n37# Create linked lists for testing\n38# Intersection point at node with value 8\n39common = ListNode(8, ListNode(4, ListNode(5)))\n40headA = ListNode(4, ListNode(1, common))\n41headB = ListNode(5, ListNode(6, ListNode(1, common)))\n42\n43# Test our solution\n44intersection = getIntersectionNode(headA, headB)\n45if intersection:\n46 print(\"Intersection at node with value:\", intersection.val)\n47else:\n48 print(\"No intersection\")\n49\n50#Expected output: 8\nTime/Space Complexity Analysis\n- Time Complexity: O(m + n), where m and n are the lengths of the two linked lists. We need to traverse both lists to calculate their lengths and then traverse them again simultaneously until we find the intersection point or reach the end. This means that the time complexity is linear with respect to the lengths of the lists.\n- Space Complexity: O(1), as we only use a constant amount of extra space to store the two pointers and a few other variables.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/intersection-of-linked-list",
      "author": "",
      "user_id": ""
    },
    {
      "title": "K Largest Elements",
      "content": "How to Solve K Largest Elements\nK Largest Elements Introduction\nK Largest Elements Introduction\nThe K Largest Elements problem asks us to print k largest elements in an array, from largest to smallest. We can easily solve this problem by iterating through the array and adding elements to our heap and maintaining the size to be at most K.\nK Largest Elements Problem\nK Largest Elements Problem\nWrite an efficient program for printing k largest elements in an array. Largest elements are returned in order largest to smallest.\nExample Inputs and Outputs\nExample 1\nInput: nums = [3, 7, 2, 1, 8, 5, 9], k = 3\nOutput: [9,8,7]\nK Largest Elements Solutions\nK Largest Elements Solutions\nHeap:\nTo find the k largest elements in the array, we utilize a heap/priority queue data structure. Both the Python and Java solutions follow a similar approach. We iterate through each number in the array and add it to the heap. However, we maintain the size of the heap to be at most k, ensuring that it contains the k largest elements encountered so far.\nIn the Python solution, we use the heapq module to create a min heap. For each number, we push it onto the heap using heapq.heappush. If the size of the heap exceeds k, we remove the smallest element from the heap using heapq.heappop. After iterating through all the numbers, the top k elements in the heap will be the k largest elements in the array. We retrieve them from the heap using heapq.heappop and return them as the result.\nPriority Queue:\nSimilarly, in the Java solution, we use the PriorityQueue class, which by default implements a min heap. We create a PriorityQueue object called minHeap to store the numbers. For each number in the array, we add it to the minHeap using the offer method. If the size of the minHeap exceeds k, we remove the smallest element from the minHeap using the poll method. Finally, the top k elements in the minHeap will be the k largest elements in the array. We retrieve them from the minHeap by repeatedly calling the poll method and store them in an array called kLargest. Since the PriorityQueue stores elements in ascending order, we populate kLargest in reverse order (from the end to the beginning) to obtain the k largest elements in descending order.\nWe utilize a heap data structure in JavaScript. We maintain a heap array that contains the k largest elements encountered so far. For each number in the input array, we add it to the heap array. If the heap size exceeds k, we sort the heap in descending order and keep only the top k elements. By the end of the iteration, the heap array contains the k largest elements in descending order. We can then return this array as the result.\nimport java.util.PriorityQueue;\npublic class KthLargestElement {\npublic static int[] findKLargest(int[] nums, int k) {\nPriorityQueue minHeap = new PriorityQueue<>();\nfor (int num : nums) {\nminHeap.offer(num);\nif (minHeap.size() > k) {\nminHeap.poll();\n}\n}\nint[] kLargest = new int[k];\nfor (int i = k - 1; i >= 0; i--) {\nkLargest[i] = minHeap.poll();\n}\nreturn kLargest;\n}\npublic static void main(String[] args) {\nint[] nums = {3, 7, 2, 1, 8, 5, 9};\nint k = 3;\nint[] result = findKLargest(nums, k);\nSystem.out.print(\"The \" + k + \" largest elements in the array are: \");\nfor (int num : result) {\nSystem.out.print(num + \" \");\n}\n}\n}\n1import java.util.PriorityQueue;\n2\n3public class KthLargestElement {\n4 public static int[] findKLargest(int[] nums, int k) {\n5 PriorityQueue minHeap = new PriorityQueue<>();\n6 for (int num : nums) {\n7 minHeap.offer(num);\n8 if (minHeap.size() > k) {\n9 minHeap.poll();\n10 }\n11 }\n12\n13 int[] kLargest = new int[k];\n14 for (int i = k - 1; i >= 0; i--) {\n15 kLargest[i] = minHeap.poll();\n16 }\n17 return kLargest;\n18 }\n19\n20 public static void main(String[] args) {\n21 int[] nums = {3, 7, 2, 1, 8, 5, 9};\n22 int k = 3;\n23 int[] result = findKLargest(nums, k);\n24 System.out.print(\"The \" + k + \" largest elements in the array are: \");\n25 for (int num : result) {\n26 System.out.print(num + \" \");\n27 }\n28 }\n29}\nTime/Space Complexity Analysis\n- Time Complexity: O(n log k), where n is the length of the array.\n- Space Complexity: O(k), we use a heap/priority queue to store the k largest elements, so the space required is proportional to the value of k. In the worst case, if k is equal to the length of the array (k = n), the space complexity would be O(n).\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/k-largest-elements",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Simplify Path (Interview Solution)",
      "content": "Simplify Path Introduction\nSimplify Path Introduction\nThe Simplify Path problem involves taking a path as a string and returning the shortest equivalent path by removing redundant elements such as \"..\" and \".\". This problem can be solved using a variety of techniques such as string manipulation, recursion, or using a stack.\nSimplify Path Problem\nSimplify Path Problem\nYou are given a path to a file as a string. The path can contain the symbols: “..” for the parent directory and “.” for the current directory. Convert the path into its simplified form.\nExample Inputs and Outputs\nExample 1\nInput: path = \"/home/../etc\"\nOutput: \"/etc\"\nExample 2\nInput: path = \"/home/./me\"\nOutput: \"/home/me\"\nExample 3\nInput: path = \"/home//me/\"\nOutput: \"/home/me\"\nConstraints\n- The path is absolute, meaning it always starts with \"/\"\nlength(path)\n> 0- path is composed of alphanumeric, \".\" or \"/\" characters\nSimplify Path Solutions\nSimplify Path Solutions\nThe path we are given is like any file path on your computer. The file path is made up of a series of directories separated by \"/\". In addition to regular directories, there are two other symbols: \".\" which refers to the current directory and \"..\" which refers to the parent directory. By following each step of the path we can find the file.\nOur goal is to simplify the file path. Meaning we need to return the path in its most direct form.\nLet's have a look at what simplifying a file path means with a diagram which follows an example of \"/home/../etc/.\"\nWe can break down the path into a series of steps separated by \"/\". Starting at the root directory \"/\":\n\"home\"\n: go to the home directory\"..\"\n: go up one directory - which brings us back to the root directory\"etc\"\n: go into the etc directory\".\"\n: remain in the current directory\nThe simplified path is the direct path to the file. In this case, it is \"/etc\". Notice how we don't include the \"home\" directory because we navigated out of it.\nWith this in mind we can divide our approach into three steps:\n- Parse the path string into a series of directories;\n- Move directory according to each step;\n- Return the direct path to the final directory we are in. Let's break down each step in turn.\nStep 1: Parse the path string into a series of directories\nHow can we extract a series of steps from the string? We can see that each directory is separated by a \"/\" or a series of \"/\" characters.\nExtracting out each directory is then a matter of getting the substring that is in between each \"/\" character. Most modern programming languages provide utility functions to split a string by a delimiter.\nWe need to be mindful that consecutive \"/\" should be considered as a single directory delimiter, and there may or may not be trailing slashes.\nStep 2: Move directory for each path step\nFor each directory we encounter we need to move our directory. There are three step types that we need to handle. Each of these we can identify according to the value of the directory step.\n\".\"\n: the current directory, don't change directory\"..\"\n: the parent directory, go up one directory- Everything else: a genuine directory, go into the directory of that name\nHow do we record what directory we are currently in? One approach would be to record the current directory as a string. Another option would be to use a stack where each item is a directory. We’ll examine each of these approaches in the solution.\nStep 3: Return the direct path to the final directory we are in\nDepending on the format used for tracking the current directory we may need to convert the path before returning it.\nApproach 1: Directory stack\nWe utilize the \"split\" string utility function which returns an array of substrings split by a \"/\". This allows us to easily convert the path into a series of steps. This has the side effect of generating directories of \"\" when there are consecutive \"/\", however we can filter these out and move on to the next directory.\nWe also use the stack data structure to keep track of our current directory. A stack is a data structure in which items can be added to or removed from the end of the stack in constant time, and in our case the items are directories.\nFor each directory step, we can push when we need to move into a directory and pop when we need to navigate to the parent directory.\nLet's take the example of \"/home/./me/../you\" and see how we can use a stack to keep track of our current directory.\nWe have been keeping a track of our current directory as a stack. While this is convenient for us as we have been evaluating each step, we need to return the result as a string. To convert our stack to the simplified path we can insert a \"/\" char in between each item in the stack and return the result.\nclass Solution:\ndef simplifyPath(self, path):\n# Create the stack where we'll keep track of our current directory\npathStack = []\n# 1: Convert the path string into directories\nfor curDir in path.split(\"/\"):\n# 2: Move directory for each path step\nif not curDir:\n# Consecutive \"/\" will result in empty directories - skip these\n# Alternatively, we could filter out duplicate “/” by iterating over string before splitting it up by “/”\npass\nelif curDir == \".\":\n# \".\" means don't modify current directory\npass\nelif curDir == \"..\":\nif pathStack:\n# Don't pop stack if we're already at the root directory\npathStack.pop()\nelse:\n# A \"genuine\" directory, navigate into it\npathStack.append(curDir)\n# 3: Return the final directory\nreturn \"/\" + \"/\".join(pathStack)\n1class Solution:\n2 def simplifyPath(self, path):\n3 # Create the stack where we'll keep track of our current directory\n4 pathStack = []\n5\n6 # 1: Convert the path string into directories\n7 for curDir in path.split(\"/\"):\n8 # 2: Move directory for each path step\n9 if not curDir:\n10 # Consecutive \"/\" will result in empty directories - skip these\n11 # Alternatively, we could filter out duplicate “/” by iterating over string before splitting it up by “/”\n12 pass\n13\n14 elif curDir == \".\":\n15 # \".\" means don't modify current directory\n16 pass\n17\n18 elif curDir == \"..\":\n19 if pathStack:\n20 # Don't pop stack if we're already at the root directory\n21 pathStack.pop()\n22\n23 else:\n24 # A \"genuine\" directory, navigate into it\n25 pathStack.append(curDir)\n26\n27 # 3: Return the final directory\n28 return \"/\" + \"/\".join(pathStack)\n29\nTime / Space Complexity\n- Time Complexity:\nO(n)\n, wheren\nis the number of characters in the path. Every character of the string is parsed in this solution. The stack push and pop operations takeO(1)\ntime. - Space Complexity:\nO(n)\n, where n is the number of directories in the path. In the worst case, the stack will only be pushed to and so will be of sizeO(n)\n. This solution also contains the array of directories which will also be of sizeO(n)\n.\nApproach 2: Character-by-character parsing\nAs an alternative to using a stack, we can parse the path string character by character. The current directory is also stored directly as a string rather than using a stack.\nAs we parse each character there are two cases. The character is a \"/\" or it isn't. If it isn't a \"/\" then it is part of a directory so we add it to our current directory string. When we encounter a \"/\" it means we are at the end of a directory and so we can evaluate the directory. Like before, the loop may produce empty directory strings so we need to make sure to filter those out.\nThe evaluation of each directory is handled in the same way as the previous method. The main difference is that we store our current directory as a string.\nWhen we need to add a directory we can append the string to our path. When we need to go up a directory the solution is not so straightforward. We need to modify the string so that everything from and including the last \"/\" is removed. To do that we can locate the index of the last \"/\" character in the string, we can then slice the string so that everything from that index is removed.\nclass Solution(object):\ndef simplifyPath(self, path):\n# Store the current directory as a string\nsimplifiedPath = \"\"\ncurDir = \"\"\n# Add an ending \"/\" so that we always evaluate the final directory\npath += \"/\"\nfor ch in path:\nif ch == \"/\":\nif not curDir:\n# Consecutive \"/\" will result in empty directories - skip these\npass\nelif curDir == \".\":\n# \".\" means don't change directory\npass\nelif curDir == \"..\":\nif simplifiedPath:\n# Remove the last dir by locating the last \"/\" char\ni = simplifiedPath.rfind(\"/\")\nsimplifiedPath = simplifiedPath[:i]\nelse:\n# A \"genuine\" directory, navigate into it\nsimplifiedPath += \"/\" + curDir\n# Reset the directory string\ncurDir = \"\"\nelse:\ncurDir += ch\nif not simplifiedPath:\n# Return the root directory if the final path is empty\nreturn \"/\"\nreturn simplifiedPath\n1class Solution(object):\n2 def simplifyPath(self, path):\n3 # Store the current directory as a string\n4 simplifiedPath = \"\"\n5 curDir = \"\"\n6\n7 # Add an ending \"/\" so that we always evaluate the final directory\n8 path += \"/\"\n9 for ch in path:\n10 if ch == \"/\":\n11 if not curDir:\n12 # Consecutive \"/\" will result in empty directories - skip these\n13 pass\n14 elif curDir == \".\":\n15 # \".\" means don't change directory\n16 pass\n17 elif curDir == \"..\":\n18 if simplifiedPath:\n19 # Remove the last dir by locating the last \"/\" char\n20 i = simplifiedPath.rfind(\"/\")\n21 simplifiedPath = simplifiedPath[:i]\n22\n23 else:\n24 # A \"genuine\" directory, navigate into it\n25 simplifiedPath += \"/\" + curDir\n26\n27 # Reset the directory string\n28 curDir = \"\"\n29\n30 else:\n31 curDir += ch\n32\n33 if not simplifiedPath:\n34 # Return the root directory if the final path is empty\n35 return \"/\"\n36\n37 return simplifiedPath\n38\nTime / Space Complexity\n- Time Complexity:\nO(n)\n, wheren\nis the number of characters in the path. As in the previous solution, every character of the string is parsed. Within the loop, we are calculating the position of the last “/” character. At first glance, it appears this could make the solutionO(n^2)\n. However, each time we do this calculation we are only evaluating the last directory string and then removing that directory from the path. In the worst case we’d only be iterating over the entire path again. This makes the solution not as fast as the previous but in terms of time complexity it is still linear. - Space Complexity:\nO(1)\n. Disregarding the output and input strings all the other variables have constant space. This assumes the length of a directory is much less than the size of the path itself.\nApproach Comparison\nWhile both approaches have linear time complexity, the latter solution is not as fast. This is because going up one directory requires us to reparse the string which is not as fast as popping from the stack. However, the latter solution has constant space complexity because it does not require any extra memory.\nVerbally noting these tradeoffs in an interview can be a great way to signal your knowledge to the interviewer.\nPractice the Simplify Path Problem With Our AI Interviewer\nPractice the Simplify Path Problem With Our AI Interviewer\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/simplify-path",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to Find the Missing Number in an Array",
      "content": "An Overview of the Find Missing Number in an Array Problem\nAn Overview of the Find Missing Number in an Array Problem\nThe Find Missing Number in an Array problem involves identifying the missing number between two almost identical arrays. While the task is straightforward, the challenge in this problem is appropriately communicating the time and space complexity tradeoffs offered by data structures with constant time or linear time lookups.\nExamples of the Find Missing Number in an Array Interview Question\nExamples of the Find Missing Number in an Array Interview Question\nGiven an unsorted array of unique integers (size n + 1) and a first array identical to the second array, but missing one integer (size n), find and output the missing integer.\nInput: list1 = [1, 2, 3, 4] list2 = [1, 2, 3, 4, 5] Output: 5\nInput: [1], [] Output: 1\nConstraints\n-inf\n≤n\n≤inf\n- All entries are unique\n- length(list2) - length(list1) == 1\nHow to Find the Missing Number in an Array: 4 Approaches\nHow to Find the Missing Number in an Array: 4 Approaches\nLet’s start by reframing this problem as a real world problem. Imagine you're a warehouse supervisor and you have to conduct a roll call every morning.\nTo keep the problem statement analogous to our real-world example, let’s refer to the longer list as the register\n, which enumerates all the workers who are supposed to show up to the warehouse on a given day. Let’s refer to the smaller list as the actual attendance\n, denoting who actually showed up.\nApproach 1: Brute Force\nIn a warehouse, the supervisor typically has a list of all the workers for a given shift. As the workers arrive, they're crossed out on the list, leaving the absentees.\nTo conduct our roll call, we run through the register\n(or longer list), verifying that we have the integers in the attendance\nlist (the smaller list). If any of the workers are missing, we would have found our absentee, so we return it, or break out of the loop and return the integer at which we stopped iterating. The code for this in Python would be as follows:\nlist1 = [1,2,3,4]\nlist2 = [1,2,3,4,5]\ndef find\\_missing\\_number(list1, list2):\nfor integer in list2: # Conduct our roll call against the list2\nif integer not in list1:\nreturn integer # Break when an absentee is found\nfind\\_missing\\_number(list1, list2) # returns 5\n1list1 = [1,2,3,4]\n2list2 = [1,2,3,4,5]\n3\n4def find\\_missing\\_number(list1, list2):\n5 for integer in list2: # Conduct our roll call against the list2\n6 if integer not in list1:\n7 return integer # Break when an absentee is found\n8\n9find\\_missing\\_number(list1, list2) # returns 5\nThis approach works, but isn't very efficient, as we have to scan the entire attendance\nlist every time we look up a number. Scanning is an O(n)\n(linear) operation; thus, we have an O(n²)\nsolution (Our example models the worst case as we have to scan both lists exhaustively). The space complexity is O(1)\nas we only need to keep tracking one integer at a time, the index.\nTime/Space Complexity\nTime Complexity: O(n²)\nSpace Complexity: O(1)\nCan we do better? Of course! Let's think a bit more. What if we didn't have to scan the register each time we wanted to look up a worker? Hash tables / dictionaries and sets to the rescue.\nApproach 2: Leveraging O(1)\nLookups\nThe first approach works, but scanning the attendance list every time isn't optimal. Can we leverage any data structures that optimize for lookups? Both hash maps and sets allow for O(1)\nlookups. We can optimize for time by converting the smaller list into a set, then searching for every item in the longer list within the set. The tradeoff with this approach is increased efficiency from a time-complexity perspective at the expense of additional memory / space complexity, as we need an auxiliary hash table or set to do the O(1)\nlookups.\ndef find\\_missing\\_number\\_sets(list1, list2):\nlist1 = set(list1) # ’Setify’ the list\nfor integer in list2: # Conduct our roll call against the list2\nif integer not in list1:\nreturn integer # Break when an absentee is found\nprint(find\\_missing\\_number\\_sets(list1, list2)) # returns 5\ndef find\\_missing\\_number\\_dict(list1, list2):\nlist1 = {elem:True for elem in list1} #Turn into a dict\nfor integer in list2: # Conduct our roll call against the list2\nif integer not in list1:\nreturn integer # Break when an absentee is found\nprint(find\\_missing\\_number\\_dict(list1, list2)) # returns 5\n1def find\\_missing\\_number\\_sets(list1, list2):\n2 list1 = set(list1) # ’Setify’ the list\n3 for integer in list2: # Conduct our roll call against the list2\n4 if integer not in list1:\n5 return integer # Break when an absentee is found\n6\n7print(find\\_missing\\_number\\_sets(list1, list2)) # returns 5\n8\n9def find\\_missing\\_number\\_dict(list1, list2):\n10 list1 = {elem:True for elem in list1} #Turn into a dict\n11 for integer in list2: # Conduct our roll call against the list2\n12 if integer not in list1:\n13 return integer # Break when an absentee is found\n14\n15print(find\\_missing\\_number\\_dict(list1, list2)) # returns 5\n16\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(n)\nDue to the constant time lookup, we have now achieved O(n)\nlookup time but now use O(n)\nspace. It seems like the classic quip, ‘throw a hash-map at it’, actually holds its weight.\nIs this the best we can do? For time complexity, sadly, yes. But can we optimize for space?\nApproach 3: Supervisor Keeping Track of Orders Filled\nConsider the list [1, 2, 3, 4, 5]\n, which sums to 15. Now consider another list [1, 2, 3, 5]\n, which sums to 11. Notice anything about these two numbers? The difference between 11 and 15 is 4, which is our answer.\ndef find\\_missing\\_number\\_simple\\_sum(list1, list2):\nexpected\\_sum = 0\nfor integer in list2: expected\\_sum += integer # Calculate expected total\nfor integer in list1: expected\\_sum -= integer # Subtract filled orders\nreturn expected\\_sum # Return pending orders\nprint(find\\_missing\\_number\\_simple\\_sum(list1, list2))\ndef find\\_missing\\_number\\_sum\\_simultaneous(list1, list2):\nexpected\\_sum = 0\nfor idx in range(len(list1)):\nexpected\\_sum += list1[idx]\nexpected\\_sum -= list2[idx]\n# Include last entry of the list2\nreturn expected\\_sum + list2[-1] # Return pending orders\nprint(find\\_missing\\_number\\_sum\\_simultaneous(list1, list2))\n1def find\\_missing\\_number\\_simple\\_sum(list1, list2):\n2 expected\\_sum = 0\n3\n4 for integer in list2: expected\\_sum += integer # Calculate expected total\n5 for integer in list1: expected\\_sum -= integer # Subtract filled orders\n6\n7 return expected\\_sum # Return pending orders\n8\n9print(find\\_missing\\_number\\_simple\\_sum(list1, list2))\n10\n11def find\\_missing\\_number\\_sum\\_simultaneous(list1, list2):\n12 expected\\_sum = 0\n13\n14 for idx in range(len(list1)):\n15 expected\\_sum += list1[idx]\n16 expected\\_sum -= list2[idx]\n17\n18 # Include last entry of the list2\n19 return expected\\_sum + list2[-1] # Return pending orders\n20\n21print(find\\_missing\\_number\\_sum\\_simultaneous(list1, list2))\n22\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(1)\nfor most cases, but technicallyO(n)\n. On the surface this seems like anO(1)\nspace complexity solution, however if the sum of the numbers exceeds the 32-bit or 64-bit integer memory limit the space complexity will actually beO(n)\n. This is why we see the Big Int / Big Integer construct in certain languages.\nApproach 4[Advanced Technique]: Bit Manipulation\nPlease note that this is an advanced technique that is not expected to be known for most programming interviews, so if you are studying for an entry-level, mid-level or Senior position this content is likely overkill relative to what you need to know.\nAll integers can be represented as 0s and 1s. With just 2 bits, 0 is equivalent to 00, 1 is equal to 1, and 3 is 11. There are only 10 types of people in the world, those who understand binary and those who do not. Ensure you do before proceeding to the next section :)\nXOR\nXOR stands for 'exclusive OR'. Simply put, it is an OR operation without the possibility of equality. True OR True would be True, but True XOR True would be False. How does this help us?\nIntegers typically are represented using 32 bits, at least in Python.\nThe number 1 as base 2 is:\n\"00000000000000000000000000000001\"\nThe number 10 would be equivalent to the following:\n\"00000000000000000000000000001010\"\nSo long as an entry is an integer, we only need 32 bits to keep track of it.\nIf we start with a clean slate, i.e., the value 0, we would have the following:\n\"00000000000000000000000000000000\"\nNow, what if we did a bitwise XOR between 0 and 1?\n“00000000000000000000000000000000” XOR “00000000000000000000000000000001”\nEach positionally equivalent bit will be compared, and we will end up with a 1:\n“00000000000000000000000000000001”\nConverting this back to base 10 returns 1.\nNow let us ask ourselves, what if we did an XOR of 1 and 1?\nWe would return 0 for that first bit, thus reverting to a clean slate again.\n“00000000000000000000000000000001” XOR “00000000000000000000000000000001”\n= “00000000000000000000000000000000”\nYou can play around with bitwise operations here: https://unsuitable001.github.io/BitViz/\nNow how is this useful for our problem?\nFor each integer both in the attendance list and the registry, so long as an XOR operation is performed, equal integers will cancel out their corresponding bit flips and restore the clean slate of the result, all but 1. The absentee integer in the registry will perform bit flips that will not be canceled out. As a result, once we are done with the XOR operations over all entries, the only 1 bits standing will represent the absent number once we are done.\nIn Python and JavaScript, ^ is used to perform the bitwise XOR operation. As such, you can do 1 ^ 1, which should return 0.\nprint(1 ^ 1) # 0\n1print(1 ^ 1) # 0\nBuilding on this logic, we can start with a 0 as our slate and XOR all integers in both lists against the slate. Upon iterating through all elements, we will be left with our absent integer:\ndef find\\_missing\\_number\\_simple\\_bitwise(list1, list2):\nslate = 0\nfor integer in list2: slate ^= integer # XOR integers against slate\nfor integer in list1: slate ^= integer\nreturn slate # Whatever we are left with is the missing int\nprint(find\\_missing\\_number\\_simple\\_bitwise(list1, list2))\ndef find\\_missing\\_number\\_bitwise\\_simultaneous(list1, list2):\nslate = 0\nfor idx in range(len(list1)):\nslate ^= list1[idx] # XOR against slate simultaneously\nslate ^= list2[idx]\n# Include last entry of list2\nreturn slate ^ list2[-1] # Return pending integers\nprint(find\\_missing\\_number\\_bitwise\\_simultaneous(list1, list2))\n1def find\\_missing\\_number\\_simple\\_bitwise(list1, list2):\n2 slate = 0\n3\n4 for integer in list2: slate ^= integer # XOR integers against slate\n5 for integer in list1: slate ^= integer\n6\n7 return slate # Whatever we are left with is the missing int\n8\n9print(find\\_missing\\_number\\_simple\\_bitwise(list1, list2))\n10\n11def find\\_missing\\_number\\_bitwise\\_simultaneous(list1, list2):\n12 slate = 0\n13\n14 for idx in range(len(list1)):\n15 slate ^= list1[idx] # XOR against slate simultaneously\n16 slate ^= list2[idx]\n17\n18 # Include last entry of list2\n19 return slate ^ list2[-1] # Return pending integers\n20print(find\\_missing\\_number\\_bitwise\\_simultaneous(list1, list2))\n21\nAnd there we have it, a clean approach that uses a constant number of bits and thus is precisely constant space.\nTime/Space Complexity\n- Time Complexity:\nO(1)\n- Space Complexity:\nO(1)\n, as we will only ever need 32 bits for so long as all our entries are integers.\nPractice the Find the Missing Number in an Array Problem With Our AI Interviewer\nPractice the Find the Missing Number in an Array Problem With Our AI Interviewer\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/find-missing-number-in-array",
      "author": "",
      "user_id": ""
    },
    {
      "title": "It's OK to postpone your interviews if you're not ready",
      "content": "At interviewing.io, we’ve seen hundreds of thousands of engineers go through job searches, and the biggest mistakes we see people make are all variations on the same theme: not postponing their interview when they aren’t ready.\nI’ve found myself repeating that it’s OK to postpone interviews so often that I finally broke down and decided to make it a blog post. It’s very simple advice, so the bulk of this post will be spent trying to convince you that it’s fine to postpone. And then of course I’ll tell you what to say.\nDo any of these situations sound familiar?\nBoth of these situations are extremely common, but they’re both preventable. You can just ask to postpone. There are a few edge cases where that’s not a good idea, but in most situations, it’s the right thing to do.\nIf you’re applying to a large company with a centralized process (in other words, a process where you interview first and get matched with a team later), postponing is almost always OK. These companies are perpetually hiring, and their open roles are evergreen.1\nEven if you’re applying to a large company with a decentralized process (where you interview for a specific team), we recommend postponing unless you’re extremely excited about the team you’re talking to. In that scenario, it’s possible that if you postpone, the slot will be filled. But if it’s not a perfect fit and you’d be OK with another team, we recommend postponing — in the worst case, you’ll simply get slotted into a different team.\nThe only time when postponing isn’t a good idea is when you’re applying to a very small company that has just one open headcount. In that scenario, it is possible that postponing will cost you the opportunity because they’ll choose another candidate. However, you can ask how likely that is to happen, up front.\nWith that edge case out of the way, here’s a little-known fact about how timing works at large companies: Recruiters don’t really care when you interview. Though they’d prefer that you interview sooner rather than later so they can hit their numbers, at the end of the day, they’d rather be responsible for successful candidates than unsuccessful ones.\nEvery recruiter, in every job search, will tell you that time is of the essence because of all the other candidates in the pipeline. Most of the time, that is irrelevant and just something they say to create an artificial sense of urgency. There are always other candidates in the pipeline because the roles are evergreen. But they have nothing to do with your prospects.\nYou can use this text verbatim when postponing your interviews, and, with some small edits, you can even use it several times (e.g., before the phone screen and then again before the onsite).\nI’m really excited about interviewing at [company name]. Unfortunately, if I’m honest, I haven’t had a chance to practice as much as I’d like. I know how hard and competitive these interviews are, and I want to put my best foot forward. I think I’ll realistically need a couple of months to prepare. How about we schedule my interview for [date]?\nOne important thing to remember is to be conservative about how long it will take. You’ve probably heard the adage about how, when you have to estimate the time an engineering task will take, you should think of a number and double it. Here, you may even want to triple it.\nI’ve seen many candidates ask for 2 weeks because that feels like a reasonable thing to ask for, only to have it blow up in their face when they realize they need to ask for another extension (which is still worth doing but harder because the company may think you’re taking them for a ride). If you need two months, ask for two months.\nThis section is extra credit, but once you get comfortable with postponing your interviews when you’re not prepared, you can use the same skills to batch your interviews and ultimately control the timing of your job search.\nWhat does it mean to control the timing of your job search? Ideally, you want all of your offers to come in at the same time, both because it maximizes optionality (one company that arbitrarily offers first doesn’t rush you into making a decision) and maximizes leverage (you can negotiate from a position of power).\nIf you want to dive deeper into this process, take a look at a book I recently co-wrote, Beyond Cracking the Coding Interview. It includes a full chapter about how to manage your job search, which covers everything from determining the order in which to approach companies to how to speed them up and slow them down once you’re in process. There’s a lot more detail than I can touch in this post, and much of it depends on your specific circumstances, but you can probably get 50% of the way there just by postponing your interviews in batches.\nThe big insight here is that, except for the edge cases we discussed above, a recruiting process can be paused at any point.\nIn other words, you can do a bunch of outreach to companies, then do a bunch of enthusiastic recruiter calls, and THEN pause all the processes until you’re prepared to do technical phone screens.\nThen, you batch the phone screens.\nFinally, if needed, you pause again to give yourself time to prepare for onsites. Onsite interviews require a different skill set than technical phone screens. The technical phone screen isn’t about depth or fit — it’s just a way to cut people who aren’t likely to pass the onsite.\nThe onsite, on the other hand, isn’t just meant to cut poor performers. It’s at once a deeper dive into your technical ability and a way to gauge fit. If you’ll be interviewing with your future team (typical at companies with a decentralized process), it’s also meant to assess your ability to work together, collaborate on hard things, complement the team's existing skillset, and so on. It usually has some coding (to verify that your technical phone screen wasn’t a fluke), but the focus is usually on system design and behavioral interviews2, which are also the interviews commonly used for leveling decisions.\nSo, onsite prep is much more about system design and getting your stories right for your behavioral interviews. Some people can pull off prepping for both coding and sys design/behavioral at the same time. For many, depending on their existing familiarity with the material, it’s a tall order. So, it’s wise to take the time you need and prepare.\nThen, once you’re ready, you batch the onsites.\nWhen your offers come in, you should ask for extensions as needed, speed companies up, and start negotiating (which we’ve written about in the past and which, of course, is covered at great depth in the book).\nFootnotes:\nYes, it’s true that in 2022, we saw several FAANGs and many other companies freeze hiring, and if you had postponed your interviews, you’d have been left out in the cold. Despite how devastating these freezes were to affected candidates (and to the tech economy as whole), they are extremely rare, and in our humble opinion, not worth optimizing for or worrying about. You are very unlikely to have to deal with an impending freeze. ↩\nSome companies will also have technical deep dives, project presentations, assessments of niche skills, and so on. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/its-ok-to-postpone-your-interviews-if-youre-not-ready",
      "author": "",
      "user_id": ""
    },
    {
      "title": " Read nine chapters of Beyond Cracking the Coding Interview for free",
      "content": "Along with Gayle Laakmann McDowell, Mike Mroczka, and Nil Mamano, I wrote the official sequel to Cracking the Coding Interview. It's fittingly called Beyond Cracking the Coding Interview..\nNow, we're releasing 9 chapters of the book for free! There are two PDFs in the linked folder:\nTake a look, and let me know what you think. You can reach me at aline@interviewing.io.\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/nine-free-chapters-of-beyond-cracking-the-coding-interview",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to get in the door at top companies: cold outreach to hiring managers. Part 2 of 2.",
      "content": "In part 1 of this post, we talked about which channels are most effective for getting in the door and did an analysis of those channels along two axes: effectiveness and how much control you actually have. Here’s a quick summary.\nIn the quadrant above, you can see that while getting contacted by an in-house recruiter is very effective, whether you get contacted or not is largely out of your hands. The channel that maximizes both effectiveness and control is cold outreach to hiring managers (not recruiters!) “done right”. What does “done right” mean? That’s what we’ll talk about in this post (part 2 of 2). Most people do this type of outreach incorrectly. Here, we’ll get very tactical and tell you exactly what to say and do to reach out to hiring managers at the companies you’re interested in and actually get responses.\nHere’s our recommended, hyper-practical approach.\nIf you’re an engineer, chances are you haven’t ever done sales (maybe you had a job in high school selling Cutco knives or magazines, in which case what we’re about to say will resonate). But if you do sales for any appreciable amount of time, you’ll start thinking about everything in life as a funnel.\nFunnels are wide at the top and narrow at the bottom. That’s why they’re such an apt metaphor for the sales process — you do a lot of outreach, and you don’t get many responses. Of the responses you do get, relatively few will do the thing you want them to do. And even fewer will ultimately “close” (aka, buying — or, in this case, hiring).\nIn your engineering career, you’ve intellectually mastered many abstract concepts that are much more complex than a funnel. Despite its simplicity, however, the funnel is one of the hardest concepts to internalize emotionally, especially for people who are used to having control over outcomes. When you write code for n hours, you can expect that you will build m features.\nIn sales though, you do a lot of work, very little of it will pan out, and when it does pan out, it can feel almost random; an impersonal, mediocre email gets a response while your beautifully targeted email is met with deafening silence.\nAnd then there’s rejection. When you apply to jobs online and don’t hear back, it stings, but the sting is softened by the possibility that a human never even saw your application. You’re not reaching out to people when you apply online; you’re dealing with a bureaucratic machine.\nOn the other hand, when you email a real human and they don’t respond, that hurts: you put yourself out there, someone made a value judgment about you, and you lost.\nThe good news is that, after a while, the pain lessens, and you build up some useful emotional calluses and acquire the thousand-yard stare of someone who’s been rejected a million times for a million reasons, ranging from soul-crushingly legitimate to incontrovertibly random. Sadly, there’s no shortcut. You’ve got to do the reps, you’ve got to get the rejections, and you’ve got to pick yourself up again. You get used to it, and then it doesn’t hurt as much, because experience has taught you that if you keep going, you will eventually get to a yes.\nFirst, come up with a target list of companies. How to do that is out of scope for this post, but we may write about it in the future. For now, we’ll assume you have a list.\nOnce you have your list of companies, use LinkedIn Sales Navigator to find hiring managers at those companies (or founders or directors or VPs, as above). Below is an example query where we look for Google hiring managers.\nYou might think that Google is so big that sifting through all their various hiring managers will be intractable. Fortunately, you can whittle down the list to a pretty manageable size by applying some filters.\nHere are our filters:\nOnce you have your list, put their LinkedIn URLs into a spreadsheet. Then, do a pass through your targets’ profiles and see if any of them link to personal websites, social media accounts, blogs, or anything else that will help you find common ground with them. Add any useful links in your spreadsheet because we’ll be mining them when we actually write our emails.\nOnce you have your list of LinkedIn URLs, use a tool like RocketReach to look up their emails.\nWhy not reach out on LinkedIn? While recruiters live on LinkedIn, managers generally do not. Possibly, they don't even like or check LinkedIn much. They live in their emails, so that's where you want to target them.\nRocketReach is a nice tool for email discovery because 1) it takes LinkedIn URLs as inputs and 2) its email database is generally up-to-date and correct.1\nIf RocketReach fails or you don't wish to pay for it, you might just be able to guess their email address, as email addresses tend to follow common forms: aline@interviewing.io (my actual email address), alerner@interviewing.io, or aline.lerner@interviewing.io.\nWhere possible, contact managers via their work email address.2 In some cases, you won’t be able to find their work email, in which case it’s acceptable to fall back to their personal email.\nNext, compose a fairly personalized, yet short, email. All too often, candidates write a long, generic cover letter that’s obviously been sent to a ton of people. I get many emails that look like this:\nDon’t do this!\nDon’t do this either! There is nothing here about why this candidate is a good fit for interviewing.io, and the bullets aren’t compelling enough on their own. Note that this particular email is from a marketer, not an engineer, but the anti-patterns are the same.\nEmails like the above are impersonal, but worst of all, they have a poor signal-to-noise ratio — I want to find a reason to say yes and to invest my valuable time into this person. But they’re not giving me one, and they’re making me work for it in the process.\nMore broadly, if you want someone to go out on a limb for you, make it dead simple for them to justify expending their social/political capital on you. Hiring managers, as a rule, want to help. Make it a no-brainer for them.\nThere are three components to a great cold email:\nNot every cold email will have (1) because you won’t always be able to find common ground with everyone — there’s simply not enough information out there about some targets to be able to craft a compelling narrative that’s highly personalized to them.\nBut every cold email you write should have (2). It is your job to sell yourself quickly and succinctly. You want your target to feel like they’d be an idiot to pass up the chance to talk to you.\nThe email below is personal, succinct, and finds common ground. Not only that, but it conveniently finds common ground that benefits the candidate (a soft-spot for non-traditional candidates, like himself!).\nTo find common ground, reference something your target cares about. Then either show them that you care about it too or that helping you would fit into their worldview and further that cause.\nAs we mentioned above, finding common ground may be tough because there might not be enough information available about your target, but it’s important to do the work before you give up on this route — finding common ground is the tactic that’s going to get you the highest response rates.\nHere are some examples of great ways to build common ground:\nWe understand that you won't always be able to find common ground. But if you can, it'll help you a lot, especially if you’re light on social proof or accomplishments.\nSelling yourself is usually about one of two things:\nSome people are fortunate enough to have both, but many will have just one. That’s okay. We’ll work with what you have!\nWhat have you done that most other people haven’t? What have you done that, if you were to tell it to a stranger, would cause them to pause and think you're special or interesting?\nBelow are some examples:\nSocial proof is more about your pedigree. If you attended a top school or worked at a company known for having a high engineering bar, you should absolutely mention it! People won't click on links or open your resume until after they're interested, so you need to get them interested right away. That is: you should spoon feed them the most impressive-sounding things about you out of the gate. This may feel strange and uncomfortable, like you’re bragging. We assure you, however, that it’s necessary to get your target’s attention. They’re not thinking you’re bragging. They’re thinking, “Is this worth my time?” Your job is to convince them that it is.\nAlso, don’t forget to link to your LinkedIn or personal website. Attaching a resume may feel too heavy-handed for a first conversation, as we discussed above.\nHere's an example of a prospective intern, leveraging both social proof and accomplishments, to write a compelling email. His email isn't super personalized, but he did make some effort to say that what we do at interviewing.io is important.\nA call to action is an invitation for the recipient to do something. You can go one of two ways with your call to action: ask for a job interview or start a conversation. Which you do should be a function of how much firepower you have in the way of social proof and accomplishments. It’s not fair, but if you can get your target’s attention with one or both of those, being bold and asking for a job interview makes sense. This approach can be effective, but it won’t work for most people… because most people don’t have enough social proof or accomplishments to justify this type of request.\nIf you can’t leverage social proof or accomplishments, you’re going to have to work harder and bank entirely on building common ground, which will likely take some time and effort and involve a live conversation before they’re convinced to expend their social capital on you.\nIf you’re asking for an interview, just come right out and say it. You can use the intern candidate’s email from earlier as a guide. However, this isn’t our preferred way to do it, and we really recommend starting a conversation instead.\nTake a look at the email below.\nIn this email, the candidate doesn’t ask me about jobs — he just asks to meet to discuss a topic. Indeed, he’s done his research. I write a ton about judging resumes, and it’s a topic I could go on about for hours if you’ll let me. His email read like he’s genuinely interested in the subject and that we’d have a good conversation, so of course I responded. You’d be surprised how rare emails like this are. If you can find the topic your target cares about and write something that shows earnest, genuine interest, they’ll respond.\nWith these emails, you’re asking for a conversation, not a job interview… because the conversation is what will hopefully prove to the hiring manager that you’re worth interviewing. Then, once you have a conversation, the hiring manager will walk away with the impression that you’re a competent, thoughtful human being who’s interested in this sort of work. From there, getting a job interview will feel like an afterthought.\nAs such, don’t talk about jobs at all in this type of email, and in this particular case, don’t attach your resume — that will feel out of place and transactional. You can and should link to your LinkedIn so they know who you are and have some context. But spend the bulk of the email building common ground and coming up with an interesting reason for the two of you to talk.\nThis approach is much more effective than asking for an interview out of the gate! You’re not going to land a job from one email, so, as with any seemingly insurmountable goal, it’s important to think of your outreach as a series of steps where you put one foot in front of the other. Like in sales, all you need is to get to a conversation.\nIf your call to action is to set up a time to talk (which it probably should be because it’s specific), we recommend providing them with a time window. \"Would you want to meet up sometime?\" puts the burden on the recipient to pose a time, while \"Can we talk next Monday at 3pm?\" is problematic because, most likely, they aren't free then. Instead, try something like the candidate above did: \"Would you be available sometime within the next two weeks for a thirty-minute call? I'm free most weekdays between X and Y and can pretty much do any time on weekends if those are better for you.\"\nBelow are two templates you can use for cold outreach. The first one is ideal but requires more effort and can't always be used. The second one is weaker but more generic. You can choose what fits your needs best. We expect both of these templates to be far more effective than throwing your resume into the blackhole of online portals.\nThis template includes common ground, accomplishments/social proof, and a call to action. It will get you the highest response rates, possibly anywhere from 25-50%. However, it can be challenging to use because it requires you to 1) do a deep dive into their online presence and 2) tie what you find back to something you’re doing. Sometimes, that tie-in might be tenuous or non-existent (in which case, maybe skip it).\nHey {Their First Name},\nI’ve read your work on {insert some details about their writing}, and I {insert your thoughts on the work}.\n{If you can make the connection between their work and yours, talk about something similar you’ve been working on.}\n{If you cannot, ask them a specific, thoughtful question about your work. Don’t worry about making it “the perfect question” like you might when you attend a talk and want to sound smart. Any earnest question will do. You don’t have to use this as a chance to show off!}\n{Finally, close with a sentence or two about you, if you have some social proof or impressive accomplishments you can share.}\nWould you be up for a quick chat this week or next?\nBest,\n{Your name}\n{Insert 1-2 useful links about you. If you have a personal site, that’s great. If not, a LinkedIn will do.}\nNote that in this template, we leave some places for you to insert some social proof and your accomplishments. Even though this email is primarily about them and their work, and your references to yourself are primarily through that lens, it never hurts to drop in a few pieces of evidence that you’re someone who’s accomplished things and/or someone who looks good on paper.\nThe reality is that you won’t always have enough information about your target to find common ground. In this case, you’ll lead with accomplishments/social proof and a strong call to action. We expect this template will get you response rates anywhere from 5-25%, depending on the strength of your achievements and pedigree. That said, we recommend treating this template as a last resort. Using it means you’ve exhausted any possibility of writing something personal.\nHey {Their First Name},\n{List 2 things about you. They can be impressive accomplishments of yours or social proof, as above.}\nI’m really interested in the work you’re doing at {Company Name}. {If you know what team they’re on and are interested in that specific team or are familiar with that team’s accomplishments, great! If not, just write a few earnest sentences about why the company is interesting to you.}\nWould you be up for a quick chat this week or next?\nBest,\n{Your name}\n{Insert 1-2 useful links about you. If you have a personal site, that’s great. If not, a LinkedIn will do.}\nKeep your note short. The intent here is to make your target believe you’re an entity worth paying attention to, rather than them doing the easy thing: deleting your email.\nRegardless of which template you use, just like you have to manage your psychology when you prepare for technical interviews, you have to manage your psychology when doing outreach like this. You have to:\nNow that you’ve girded your proverbial loins, it’s time to do the work. If you follow our advice, you’ll get 1-2 orders of magnitude more responses than from applying online, and with this approach, you’ll have at least a hiring manager at that company rooting for you!\nFootnotes:\nRocketReach also has a LinkedIn-like faceted search you can use to find engineering managers, but we’ve found that it’s not nearly as reliable or rich as LinkedIn, which is why we recommend using LinkedIn for search and then RocketReach for email discovery. ↩\nRecruiters should not contact candidates on their work email address, but that's because they're trying to make the candidate leave their job. You are trying to join the manager, which is why it's okay to use their work email address. ↩\nMany people think that for something to be worth mentioning, it has to have gone viral. That’s simply not correct — in our niche space, a few hundred likes or a few thousand upvotes is already really impressive. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/how-to-get-in-the-door-at-top-companies-cold-out-reach-to-hiring-managers-part-2",
      "author": "",
      "user_id": ""
    },
    {
      "title": " Are recruiters better than a coin flip at judging resumes? Here's the data.",
      "content": "This post is a very exciting first for interviewing.io because it’s about a proper experiment run by a real, live academic research lab. If you’ve been reading my work for the past decade, you know that I’ve always been something of an armchair researcher. I ran some experiments before starting interviewing.io, and since then, my team and I have kept it up.\nOne of the experiments I ran before I founded interviewing.io was an attempt to figure out how good recruiters were at judging candidate quality based on resumes. I ran it 10 years ago and discovered that not only was everyone bad at judging resumes (about as accurate as flipping a coin), they all disagreed with each other about what a good candidate looked like.\nEven though these results were shocking at the time, the study had some serious limitations. First, I had no objective measures for which candidates were actually good. I was working as a recruiter at the time, so I knew whom I had been able to place, but that’s obviously not the be-all and end-all of engineering ability. Second, I had a non-representative sample of software engineers. Due to my brand, I had managed to attract a lot of excellent, non-traditional candidates — engineers who were actually very good but didn’t look good on paper. These types of resumes are the hardest for recruiters to judge, and the data was full of them. Finally, my sample size wasn’t that big: I ended up with 716 data points in total, only about half of which came from recruiters (the rest came from engineers and hiring managers — my original hypothesis was that they might be better at the task, but I was wrong… everyone was bad at judging resumes).\nSo, now that I’m CEO of interviewing.io, with access to a lot more data, resources, and a team of excellent academics at Learning Collider, we decided to run this study again, but with a more rigorous treatment and better conditions, to see if we could replicate the results. This time, we focused just on recruiters, given that they’re most often the gatekeepers who decide which candidates get an interview.\nBelow are all the details, but here’s the TL;DR: we reproduced my results from 10 years ago! Our new study showed that recruiters were only a bit better than a coin flip at making value judgments, and they still all disagreed with each other about what a good candidate looks like.\nIn this piece, we also talk about:\nThe rest of this piece is co-authored by Peter Bergman, Tushar Kundu, and Kadeem Noray of Learning Collider.\nIn the real world, resumes (or LinkedIn profiles) are evaluated by recruiters in minutes — even seconds — and these evaluations are THE thing that determines who gets an interview.\nBut what do these word walls tell recruiters? How predictive are their evaluations of actual interview success? Ultimately, how good are recruiters at judging resumes?\nTo answer these questions, we designed a study approximating technical recruiters’ decisions in the real world. We asked1 76 technical recruiters (both agency and in-house) to review and make judgments about 30 engineers’ resumes each, just as they would in their current roles.\nThey answered two questions per resume:\nWe ended up with nearly 2,200 evaluations of over 1,000 resumes.\nThe resumes in this study belonged to interviewing.io users (with their consent) — actual engineers currently on the job market.\nCollaborating on this study with interviewing.io is an ideal scenario, precisely because outcome data were available for comparison purposes. Each engineer in this study has completed multiple mock interviews on the platform. Performance in these interviews is quite predictive of performance in real interviews: top performers (roughly the top 5% of users) on interviewing.io are 3X more likely to pass technical interviews at top-tier companies than candidates from other sources. Even passing a single interview on interviewing.io is a strong predictor of outcomes; it's associated with a 32% increase in the chance of working at a FAANG company post-interview.\nOnce we had recruiters’ evaluations of the resumes, we compared them to how those engineers actually performed on interviewing.io: skills scores, feedback from interviewers, and ultimately, whether they passed or failed their mock interviews.\nIn aggregate, recruiters in the study recommended 62% of candidates for an interview. But how did recruiter evaluations stack up against candidates’ performance on the platform?\nWe calculated recruiter accuracy by treating each candidate’s first interview (pass/fail) as the truth, and recruiters’ decision to interview as a prediction. It turns out that recruiters chose correctly 55% of the time, which is just slightly better than a coin flip.\nRecruiters predicted the likelihood that each candidate would pass the technical interview. In most hiring processes, the technical interview follows the recruiter call and determines whether candidates proceed to the onsite. Being able to accurately predict which candidates will succeed at this stage is important and should inform the decision about whether to interview the candidate or not.\nWhat we found most surprising is how far their predictions were from the truth:\nBelow is a graph that shows recruiter predictions vs. actual performance. The x-axis is the bucketed recruiter rating. In other words, the first point is all the candidates that recruiters assigned a 0-5% likelihood of passing. The y-axis is the average interviewing.io pass rate for those candidates. The red dotted line represents 100% accuracy – in an ideal world, the higher a recruiter's ranking of a candidate, the higher their actual performance would be. The orange line represents reality – as you can see, there isn’t much correspondence between how recruiters predicted candidates would perform and their actual performance.\nRecruiters’ predictions below 40% underestimate these candidates by an average of 23 percentage points. Above 60%, they’re overestimating by an average of 20 percentage points. If this was predicting student performance, recruiters would be off by two full letter grades.\nClearly, there is lots of noise in resume evaluations. Were recruiters’ noisy judgments at least consistent when reviewing the same resumes?\nNearly 500 resumes were evaluated by more than one recruiter. Based on a random selection of two evaluations per resume, the overall likelihood of two recruiters agreeing to either interview or not interview a given candidate was 64%.\nSince recruiters also guess the probability a candidate will pass the technical interview, we can compare how different these guesses are for a given candidate. The average differential between two randomly selected recruiters’ evaluations of the same resume was 41 percentage points. So, let’s say one recruiter predicts a 30% probability the candidate would pass; another recruiter evaluating the same resume would predict, on average, a 71% probability of passing.\nTo further understand just how prevalent the disagreement is, we looked at the standard deviations for across-candidate evaluations and same-candidate evaluations:\nSo, when two recruiters are asked to judge the same candidate, their level of disagreement is nearly the same as if they evaluated two completely different candidates.\nDespite the noise and variability in the study’s resume evaluations, there were some characteristics that recruiters consistently favored: experience at a top-tier tech3 company (FAANG or FAANG-adjacent) and URM (underrepresented minority) status (in tech, this means being Black or Hispanic).\nMost predictive for Question #1 (whether a recruiter would want to interview that candidate) was experience at a top company — these candidates were 35% more likely to be picked. Black or Hispanic candidates are also associated with an increased likelihood a recruiter would interview a candidate — by 21%.4\nWith Question #2 (how likely the candidate was to pass a technical interview), having a top company on your resume is associated with a 21% increase in the likelihood that recruiters believe the candidate will pass the interview. Compared to the actual pass rates, recruiters’ predictions of FAANG candidates are generally accurate (average 4 percentage point overestimate).5 Unlike the presence of a top company, URM status didn't appear to influence recruiter decisions here.\nSo, we know what recruiters tend to favor, whether they’d admit to it or not: 1) FAANG/FAANG-adjacent experience and 2) URM status. But what’s even more interesting than why a recruiter would say yes is why they would say no.\nWhen we asked recruiters to judge a resume, we also asked them WHY they made that decision.6 Below are recruiters’ stated reasons for rejecting candidates. As you can see, “missing skill” is the main reason by far, with “no top firm” a distant third.\nSo, then, we wondered… How do recruiters’ stated reasons for rejecting candidates line up with reality? To figure that out, we analyzed the resumes that ended up in the rejected pile and looked at common traits.\nBelow is a graph of actual rejection reasons, based on our analysis. The main rejection reason isn’t “missing skill” — it’s “no top firm.” This is followed, somewhat surprisingly, but much less reliably (note the huge error bars), by having an MBA. “No top school” and having a Master’s degree come in at third and fourth. Note that these top four rejection reasons are all based on a candidate’s background, NOT their skill set.\nAnother key piece of this study is time. In hiring settings, recruiters make decisions quickly. Moving stacks of candidates through the funnel gives little room to second-guess or even wait before determining whether or not to give a candidate the opportunity to interview.\nIn our study, the median time spent on resume evaluations was just 31 seconds. Broken down further by Question #1 — whether or not the recruiter would interview them — the median time spent was:\nGiven the weight placed on single variables (e.g., experience at a top firm), how quickly recruiters make judgments isn’t surprising. But might they be more accurate if they slowed down? It turns out that spending more time on resume evaluations, notably >45 seconds, is associated with more accurate predictions — just spending 15 more seconds appears to increase accuracy by 34%.7 It could be that encouraging recruiters to slow down might result in more accurate resume screening.\nAs a gaggle of technologists and data geeks, we tested whether algorithms could quiet the noise and inconsistencies in recruiters’ predictions.\nWe trained two local, off-the-rack machine-learning models.8\nJust like human recruiters, the models were trained to predict which candidates would pass technical interviews. The training dataset was drawn from interviewing.io and included anonymized resume data (years of experience, whether they had worked at a top firm, and whether they had attended a top 10 school for either grad or undergrad), candidates’ race and gender, and interview outcomes.9\nDespite the very limited types of data we input into both models, when presented with out-of-sample candidate profiles, both models made predictions more accurately than human recruiters.\nRandom Forest was somewhat more accurate than recruiters when predicting lower performing candidates. XGBoost, however, was more accurate across the board than both the Random Forest model AND recruiters.\nIn this section, when we say “we,” we are speaking as interviewing.io, not as the researchers involved in this study. Just FYI.\nAt interviewing.io, we routinely get requests from our users to add resume review to our list of offerings. So far, we have declined to build it. Why? Because we suspected that recruiters, regardless of what they say publicly, primarily hunt for name brands on your resume. Therefore, highlighting your skills or acquiring new skills is unlikely to make a big difference in your outcomes.\nWe are sad to see the numbers back up our intuition that it mostly is about brands.10 As such, here’s an actionable piece of advice: maintain a healthy skepticism when recruiters advise you to grow your skill set. Acquiring new skills will very likely make you a better engineer. But it will very likely NOT increase your marketability.\nIf enhancing your skill set won’t help, what can you do to get in front of companies? We’re in the midst of a brutal market, the likes of which we haven’t seen since the dot-com crash in 2000. According to anecdotes shared in our Discord community, even engineering managers from FAANGs are getting something like a 10% response rate when they apply to companies online. If that’s true, what chance do the rest of us have?\nWe strongly encourage anyone looking for work in this market, especially if you come from a non-traditional background, to stop spending energy on applying online, full stop. Instead, reach out to hiring managers. The numbers will be on your side there, as relatively few candidates are targeting hiring managers directly. We plan to write a full blog post on how to do this kind of outreach well, but this CliffsNotes version will get you started:\nWe know that recruiting is a tough job, especially in the current climate, where there are more applicants than ever and fewer recruiters to parse through them. So, it rationally makes sense to us that a recruiter would spend no more than 30 seconds per resume and focus primarily on looking for top brands.\nWe hope, though, that this piece may have given a measure of pause about your approach, and we’d like to leave you with two actionable pieces of advice. First, if you do nothing else, please slow down. As you saw above, taking just 15 extra seconds to read a resume could improve your accuracy by 34%.11\nOur second piece of advice is this. Freada Kapor Klein from Kapor Capital coined the term “distance traveled” more than two decades ago. It refers to what someone accomplished, in the context of where they started. For instance, Kapor Klein recommends that, in their admissions processes, universities should consider not just the number of AP tests a candidate has passed but the number of AP tests divided by the total number offered at their high school. For example, if an applicant took 5 AP tests and their school offered 27, that paints a very different picture from another applicant who also took 5 AP tests when that’s the total number offered at their school. Kapor Capital uses distance traveled as one of their metrics for determining which entrepreneurs to fund. One can easily apply this concept to hiring as well.\nTake a look at the resume below. \"John\" (name has been changed; scrubbed resume shared with permission) studied chemical engineering and worked his way into software engineering by starting as a service engineer focused on pen testing. In the meantime, he completed a bootcamp, attended the Bradfield School of Computer Science (a school dedicated to teaching computer science at a depth beyond what many university programs, and certainly most bootcamps, offer), and ended up with a senior title in just three years.\nJohn was consistently rated poorly by recruiters but is one of the top performers on interviewing.io.\nIt takes just a bit more time, so please spend a little longer reading resumes, and evaluate candidates’ achievements in the context of where they came from. Think about the denominator. But don’t think for a moment that we recommend that you lower the bar — absolutely not. On interviewing.io, we regularly see candidates like John objectively outperforming their FAANG counterparts.\nThe last time I did this research, I wrote about how being bad at judging resumes isn’t anything to be ashamed about and that comes down to the resume itself being a low-signal and not-very-useful document.\nI held that same opinion for the last decade (and even wrote a recent post about how AI can’t do recruiting)… right up until we ran this study and successfully built two ML models that outperformed recruiters.\nSo, I stand corrected.\nAs you saw above, both models were limited – they were looking at the same types of features that recruiters do when they quickly scan a resume, certainly fewer features than recruiters have access to. But, despite that, the AI models still outperformed humans. What happens then, if you can build a model that behaves like a recruiter who really slows down and reads everything? These results make me believe that resumes do carry some signal, and you can uncover it if you carefully read what people write about their jobs and themselves and also analyze how they write it. Unfortunately, this takes more time and effort to uncover than most human recruiters are able to devote. And, in retrospect, that’s a good task for AI. Though we haven’t built a model like that for this post, I’m optimistic that we may be able to do it in the future.\nAs I said in the AI piece I linked above, in order for AI to do useful recruiting work, rather than just perpetuating the biases that human recruiters hold, it needs a data set that contains some objective measure of performance. Most recruiting AI models today do one of three things: glorified keyword matching, training on what recruiters prefer (the outcome is whether a recruiter would want to talk to the candidate, NOT whether the candidate is good), or live on top of existing tools like ChatGPT (which we recently showed doesn’t perform very well and is biased against non-traditional candidates). These three approaches just result in the wrong thing being done, faster.\nI hope that, in the not too distant future, we can use AI to make less-biased decisions, using meaningful performance data. And I hope that this type of AI solution can get adoption among the recruiting community.\nFootnotes:\nParticipating technical recruiters were paid a base rate and then received additional $$ for each accurate prediction. ↩\nDifferent roles have different requirements. To correct for that, we asked each candidate to specify which eng role they were applying for: Software Engineer (back-end or full-stack), Mobile Engineer, Front-end Engineer, ML Engineer, Data Engineer, or Engineering Manager. Then we prompted recruiters to evaluate them specifically for that role. If no role was specified by the candidate, the default role to evaluate for was Software Engineer (back-end or full-stack). ↩\nTop firms = Airbnb, Amazon, Anthropic, AWS, Apple, Asana, Atlassian, Bloomberg LP, Checkr, Coinbase, Coursera, Cruise, Dropbox, Etsy, Facebook, Flexport, GitHub, Google, Gusto, HashiCorp, Instacart, Instagram, Jane Street, Jump Trading, Khan Academy, LinkedIn, Lyft, Medium, Microsoft, Mozilla, Netflix, Oculus, OpenAI, Palantir, Peloton, Pinterest, Postmates, Quora, Reddit, Robinhood, Roblox, Salesforce, Segment, Slack, Snap, Snowflake, SpaceX, Spotify, Square, Stripe, Tesla, Thumbtack, TikTok, Twilio, Twitch, Twitter, Two Sigma, Uber, Udemy, Waymo, Whatsapp, Yelp, and Zoom. ↩\nWe corrected by FAANG & FAANG-adjacent experience (and all of our other variables) before making this statement, i.e., the effect existed for engineers from underrepresented backgrounds who did not have FAANG/FAANG-adjacent companies on their resumes. We expect that recruiters favor underrepresented minority candidates because of guidelines from their employers to focus on sourcing these types of candidates, as part of DEI initiatives. Discussion about the magnitude of this effect and its implications is out of scope of this piece. ↩\nInterestingly, recruiters might penalize, for example, alternative education. Candidates with only alternative education pathways post-high school — coding bootcamps or digital certifications — appeared to be penalized by recruiters in this study. However, with limited observations (n=11), it’s inconclusive without further study. ↩\nThat field was optional, so most of the reasons recruiters provided were in cases when they said no — presumably because the reasons for saying yes may have seemed self-evident. ↩\nIt’s not that recruiters who generally take their time make more accurate judgements. Any recruiter slowing down might make them better at judging resumes! ↩\nIt’s important to stress that neither algorithm was custom-built. The models, one using a Random Forest algorithm and the other an XGBoost algorithm, are distinct but interrelated approaches akin to Decision Tree algorithms. Decision trees sort data into groups based on features. Random forest algorithms combine multiple decision trees to improve predictions. XGBoost builds multiple decision trees one after another, with each new tree focusing on prediction errors from the previous trees. ↩\nTraining data excluded data in this study. We take user privacy very seriously, and we want to stress that all models were local and anonymized and that no data in this study was shared with cloud LLMs. ↩\nTo see a particularly egregious example of recruiters favoring brands over substance, take a close look at this fake resume that got a bunch of recruiter responses. And this one too. ↩\nWe haven’t proven causality here, but when we just scoped our analysis to the same person, it appeared that taking more time did help (in other words, it’s not just that recruiters who spend more time usually are more accurate; it’s the added time). Still, this is something that merits more work, and we'll try to investigate it causally in the future. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/are-recruiters-better-than-a-coin-flip-at-judging-resumes",
      "author": "",
      "user_id": ""
    },
    {
      "title": "The unwritten rules (till now) of negotiating with Meta",
      "content": "If you don't like reading, here's me presenting the contents of this blog post in a video. Pick your poison.\nEDIT: This post is based on stories from users who were interviewing for E4-E6 SWE and MLE roles at Meta. Other, more specialized roles may have different processes than what's described here.\nEDIT 2: As of Q1 2025, it looks like Meta is sometimes foregoing team matching in favor of driving candidates to their Monetization org (which apparently has a lot of open headcount). If this happens to you, after you pass the hiring committee, instead of entering team matching, your recruiter will tell you that you’ve been assigned to this particular org and, if you proceed, you’ll just get an offer. You won’t get to talk to your future manager, and you’ll find out team details a week after you join. From what we know, it’s possible to insist on team matching instead, with the downside that it’ll take an unknown amount of time rather than certainty.\nWhy does this matter?\nIf you’re looking to use your Meta offer primarily as leverage with other companies, this is a great thing because you’ll get numbers quickly. If you’re seriously interested in Meta, then this could be good or bad and depends where you are in the process and how much you want to work on monetization versus other things/how much you want to meet your manager before you work for them.\nSo if you’re seriously interested in Meta, whether this is good or bad depends on where you are in the process. If you need them to move quickly, it’s great because you know you won’t be stuck in team matching. However, if you need them to slow down because you aren’t as far along with other companies or because you want to work in a different org, you may want to ask your recruiter to stick with the old team matching process. In our experience, it’s ok to ask this. Your recruiter may not tell you outright that that’s an option, but if you ask, they will probably do it. Of course, you may be stuck longer than you want. But at least then you will have more of a say in what you work on.\nAt interviewing.io, one of the services we offer our users is salary negotiation. Even though I’m the founder, I still do many of the sessions myself because they give me an invaluable insider’s perspective on what’s actually going on in the engineering market, what different companies’ offers look like, how companies extend offers, what kinds of deadlines they give, and how much they go up in compensation, under what circumstances.\nAccess to this kind of data is great because it helps me make better business decisions. But sometimes I see questionable patterns of behavior among companies. Recently, I’ve observed a string of practices at Meta that I find reprehensible, and that’s what this post is about. I’ve seen the same practices with enough candidates, and across enough different titles and positions, that it’s become clear to me that they are not isolated incidents or a rogue recruiter’s doing but rather a consistent implementation of a deliberate strategy that comes from the top.\nI’m writing about this for two reasons. First, if you’re negotiating with Meta, you need to know how they operate and understand the unwritten rules of the game. If you do not know the rules, you will fail — long before you even start negotiating.\nSecond, I’m hoping that someone at Meta sees this post and that maybe it’ll spark an internal discussion about changing the rules.\nBy the way, if I’m wrong, I will gladly issue a retraction and a public apology. Please contact me if you’re a recruiter at Meta and find something incorrect in this post. My email is aline@interviewing.io.\nLastly, if you’re about to interview there or are interviewing there already, please read our free, long-form guide to their interview process and questions.\nI mentioned above that we do salary negotiation, but our main business is mock interviews. We offer anonymous mock interviews in the style of a bunch of different companies (mostly FAANGs). This means we know how many people are practicing for interviews at Google vs. Meta vs. other FAANGs, and that lets us guess (pretty accurately) how much hiring is actually happening at these companies.\nYou can read in way more detail about how all the FAANGs are doing in our recent blog post where we made 2024 predictions based on our proprietary data. But while I was writing that post, I noticed something odd. Meta was hiring way more engineers than any of the other FAANGs. In fact, Meta hiring is up more than 10X since January of last year. You can see that more recently Amazon has picked up a bit, but it’s very recent and not enough to drive major change in other companies’ behaviors (at least not yet). And, yes, Netflix is hiring too, but Meta’s eng team is more than 10X the size of Netflix’s, so in the absolute, Netflix’s hiring volume isn’t enough to balance Meta out. For all intents and purposes, Meta’s the only FAANG that’s really hiring at scale — and they’re currently getting away with treating candidates really poorly as a result.\nHere’s how Meta runs their hiring process. These practices have been consistent across every negotiation client we’ve had in the past 6 months or so.\nMeta’s hiring is centralized, which means that you enter one big interview process that’s completely divorced from which team you might end up on and you interview with people whom you might never work with again. If you do well, there will be a team matching component after you pass the onsite but before you get an offer1. With that in mind, here’s how they run their process, once you get the green light.\nBelow are the steps for negotiating with Meta in a hard climate where they have a monopoly on hiring. We hope that most of these won’t be necessary in the future. They are:\nWe wrote a whole post about how to avoid sharing information with your recruiter and why this is so vital. If you share where you’re interviewing or how far along you are, or if you start negotiating prematurely, the strategies below won’t work.\nPlease read our post on not shooting yourself in the foot during negotiations before you continue!\nYou should also be aware of a few tricks specific to Meta recruiters. If you're not forthcoming about where else you're interviewing, they may say a few sneaky things.\nFirst, they may say something like, \"Well, we just want to know where you're interviewing so we can intro you to others who interviewed at those companies but ultimately chose Meta.\" Don't fall for that early in the process. It's a trap to get information out of you. You can always ask for those intros later, when you're negotiating and it's the right time information about your other offers.\nThe other thing they do is fish, saying something like, \"Well, in case you're interviewing at {Google, Netflix, some other big company they don't want to lose candidates to}, just so you know, they move kind of slowly, so we may not be able to wait.\" There, the Meta recruiter's goal is to get you to say, \"Oh, no, don't worry, I'm not interviewing at Google!\"\nNow, you've lost leverage in their eyes because that's one less competitive company they might lose you to... and they'll be more confident about lowballing you later on.\nAs you may have guessed from reading the previous section, it’s critical to have other offers, and not just any offers but ones from top-tier companies who pay very competitively3.\nWe realize that saying “have other offers” doesn’t capture the blood, sweat, and tears that go into months of interview prep, applications, emails, recruiter calls, and interviews. We know it’s hard, but as you’ll see, it makes a huge difference in your compensation.\nGetting those offers doesn’t start when you’ve received your Meta offer. It starts months before. Make sure that you get enough initial conversations with other FAANGs, FAANG-adjacent companies, and late-stage sexy startups to end up with at least one other offer, ideally at least two. Depending on your interview performance, this might be anywhere from 4 to 10 initial conversations.4\nHaving your offers come in around the same time is critical for any negotiation, but it’s especially important with Meta because they take such a hard line — without other offers, they will not meaningfully budge.\nObviously, you’ll want to start your conversations with other companies well in advance of your Meta interviews and do everything you can to make sure they all come in at the same time. However, even with your best efforts, it’s not guaranteed that your timing will match up. Here’s how to make sure that your offers come in at the same time: slow-play Meta’s team-matching process.\nTeam matching is actually the part of your Meta journey where you have the most leverage and power. Why leverage? At this point, they know they want you, but they can’t yet hold an offer deadline over you. We’ve already mentioned that once they make the offer, your recruiter is going to push very hard to have you accept, often giving you a deadline of something like two days. In your recruiter’s eyes, you’re a ticking time bomb, where for every day you don’t sign, the deal loses momentum, and your odds of signing drop off. Recruiters are also evaluated on how many candidates they close, so it’s in their interest to create a false sense of scarcity in order to rush you and to use high-pressure sales tactics to get you to seal the deal.\nAnd what power do you have? It turns out you can really control how long team matching takes, within reason. If you’re still wrapping phone screens with other companies, slow-playing is the best thing you can do. Here’s how to do it.\nWe’ve recently heard that Meta is now insisting that hiring manager conversations happen in series, but even if Meta lets you talk to multiple hiring managers concurrently, try to serialize those conversations as much as possible. For instance, if you hear from your recruiter that you’re going to start team matching on a Monday, and they offer to set up some calls for Wednesday, ask to do the first call on a Friday and the next call the following Tuesday. When we advise our users to do this, we often get pushback because they’re worried that slowing things down will make them look disinterested/not serious. We promise you that’s not the case. The biggest risk you run when you slow-play team matching scheduling like this is losing the chance to work on a specific team. If you find that your recruiter has proposed what seems like the perfect team for you, you can and should prioritize doing that call as soon as possible.\nIn addition to serializing your hiring manager conversations, for each team, ask to talk to a few individual contributors on teams that you’re serious about. This isn’t just a stalling tactic. These are the people you’ll be working closely with every day, and they’re the ones doing the job you may have in the future. They’re also less likely to do hard sells, and if you ask thoughtful questions, you’ll learn a lot about what to expect. We’re always surprised by how few candidates ask to speak to their future peers, out of a mistaken concern that asking for too much will make them look disinterested or unengaged. Just like with hiring manager calls, if you need to slow things down, we recommend scheduling calls with your peers a few days apart.\nWe have seen two instances when our advice about slow-playing could backfire. You probably remember when companies started to freeze hiring aggressively in mid-2022 — if you didn’t get matched before the ax came down, you were left out in the cold. Much more recently, we heard from some of our users that Meta put a pause on team matching for E4 roles (largely outside the Bay Area), and many candidates were stuck in a holding pattern (while Meta figured out headcount constraints, though it looks like it’s since been resolved, and picking back up in earnest. Slow-playing and then getting stuck is obviously an unfortunate situation, as is being on the wrong end of a hiring freeze, but these situations are rare, and in our humble opinion, not worth optimizing for — in most cases, you will not be dealing with an impending freeze or stalled matching. If you’re unsure about team supply or the state of hiring, you can do two things:\nThere's one more situation where slow-playing may bite you. If you match with a team and really click well with the manager, to the point where you have your heart set on it, it may be wise to accept that team instead of trying to drag things out. We've heard of times where, even if the candidate asked the manager about open headcount and confirmed they didn't have to rush, the role got filled from under them (they were able to talk to other teams afterwards but missed the chance to be on that specific team). If a specific team feels irreplaceable to you and you'd be crushed if you didn't get it, then that may be more important than maximizing your negotiation.\nOutside of using the team-matching process to control your timeline, there is one other important tactical piece of advice: Do your best to build rapport with hiring managers.\nAs we said above, recruiters are trying to close the deal. That’s their job. Hiring managers, on the other hand, are trying to lay the groundwork for a good working relationship with you. As a result, their interests are much more aligned with yours. Of course, they still want to close you, but it’s not worth it to them to employ high-pressure tactics, and it’s not something they’re trained in or comfortable with (in fact, many of them hated these tactics when they were on the other end of it while looking for work)5.\nAs such, hiring managers will generally be a lot more transparent with you about how much time you actually have to make a decision, and their answers will likely be very different from the ones you get from recruiters.\nWe’ve advised all of our Meta candidates to ask their prospective hiring managers about when they realistically have to make a decision by, and the differences between what the hiring manager has told them (“Take your time; you have a few weeks at least.”) and what their recruiter has told them (“We’re talking to a lot of candidates for that team. To ensure your spot, you should make a decision in the next few days.”) are stark.\nThere’s simply no downside to building rapport with hiring managers. At worst, you make a professional connection. At best, you get a head start on a great working relationship with your new boss.\nOne practical note: Always ask your hiring manager for their email address in case you have more questions later. This way, if your recruiter starts telling you that you need to make a decision by Friday, you can ping your hiring manager, explain that you’re still thinking, and ask if it’s OK to take a few more days. Almost always they will say yes.\nIf you’ve done everything else in this post, the negotiation is the easy part. By now, you’ve wrapped up team matching, chosen a team, and have likely gotten an aggressive offer deadline.\nYou have also not shared any offer details till now. As we said at the beginning of this post, the success of your strategy hinges on the recruiter not being aware of the other companies you’re interviewing with. This will be the first time they find out about it, and that will put them on their proverbial back foot.\nTo respond to the offer, you can send an email6 that looks something like the below. The details will differ, and how much you reveal about the other offers will vary, but here’s the general idea.\nHey [Recruiter name],\nThank you so much for the offer, for working with me throughout this process, and for all your help with team matching. I wanted to share some details with you. I currently have offers from {Company 1}, {Company 2}, and {Company 3}.\n{Company 1} has offered me a significantly higher base salary of $220k. {Company 2} has a comparable base but has offered me significantly more equity: $500k. I know {Company 2} is a startup, but they’re late stage and handing out RSUs. Those RSUs are as valuable to me as public company equity.\nFinally, {Company 3} has thrown in a meaningful signing bonus, and their performance bonus is actually at 25%, not 15%.\nI’m very excited about the opportunity to work at Meta and about the team. {Insert some authentic reasons why you’re excited about the company, the team, your new boss, etc.} It’d be great to see a meaningful increase in compensation to make my decision easier.\nThank you, and I look forward to hearing from you.\nBy the way, this isn’t the only approach you can take, and with other companies, you might have better luck with the Reverse Used Car Salesman. However, in our experience, if you don’t share offer details, your Meta recruiter will immediately ask you to share, so you might as well control the flow of information.\nIn the template above, I’ve assumed that not all of your offers are stronger than Meta’s across the board, which is why I’ve cherry-picked which pieces to share. Sometimes, if you’re lucky, you’ll have multiple offers that have a higher base, more equity, and a higher signing bonus. In that case, it’s less of a game of skill — just throw the numbers at them, and they’ll exceed the other offers without much prompting.\nIf you run this play, your recruiter will apologize for low-balling you, blaming the “computer” for giving them those numbers. Then, like clockwork, you will see a $50k to $150k jump in your offer (precisely how much depends on where your other offers are from and how strong they are).7\nNow, whether you take that offer is up to you.\nSome closing thoughts. I’m a capitalist. Meta’s behavior here is aggressively capitalistic, if short-sighted – once other FAANGs start meaningfully hiring again, and Meta employees figure out that there’s a $150k comp differential between people with the same job title, they’re going to pay the piper and likely see a bunch of attrition. Ultimately, the market will correct these practices. However, I also believe that individuals have the right and duty to be as informed as possible and to wield whatever weapons in their arsenal to advocate for themselves, rather than waiting on the mercy of slow, indifferent market forces.\nAs such, we hope this post has given you some ammunition in your negotiations and helped reduce the information asymmetry between you and Meta, a huge, aggressive player with basically a monopoly on eng hiring at the moment. And we hope that if anyone from Meta is reading this, it’ll spark some internal conversations about what’s right. And if they don’t, other FAANGs’ recruiters will swoop in soon enough.\nWant to know if you’re ready to interview at Meta? Do anonymous mock interviews with real Meta interviewers, and see exactly where you stack up.\nHow team matching works changed fairly recently. In the past, you’d get an offer before you matched with a team and do a 6-week “bootcamp” where you’d get up to speed on Meta’s tech stack, infrastructure, and systems, followed by a multi-week “speed dating”-esque team matching cycle. Bootcamp still exists, but now it's much shorter (2-4 weeks), and the focus is getting new engineers ramped up on generic tools. After that, new engineers continue to ramp up on their specific teams. ↩\nWe’ve recently heard that Meta may now be insisting that team matching conversations happen in serial, i.e., you can only do one at a time. However, this doesn’t meaningfully change our advice. ↩\nYou might say, “Aline, why can’t I just make up offers?” We could never, in good conscience, advise that. It’s unethical, and though I’d argue that while Meta’s negotiation practices are also unethical, that’s not the way to win. Outside of ethical considerations, while the risks of getting caught are low, they’re not zero. Lying about offers, in our mind, is the last refuge of the incompetent. ↩\nThe advice in this post is orthogonal from your career goals and what you want to work on. This blog post is about navigating an unfair system filled with opaque rules while maximizing your cash. It is not about self-actualization, though we’d argue that creating the most optionality for yourself helps with self-actualization as well. You can also talk to smaller companies and use your big-co offers as leverage to increase your startup equity. There’s nothing wrong with that, but more detail on optionality and self-actualization is outside the scope of this post. ↩\nOf course, some hiring managers will use high-pressure sales tactics or create false timelines to try to close you. But that’s the exception rather than the rule. You can decide if that’s something that you want to weigh when judging whether or not you want to work for them. ↩\nWe strongly urge you to avoid negotiating over the phone and over text, whenever possible. Your recruiter does 5 of these calls a day. You might do one of these calls every few years. Do the hard part over email. It’s the best way to level the playing field. Read this post to learn how to avoid synchronous phone negotiations (just look for “phone”). ↩\nOne advanced maneuver is to pit all your other companies against each other and raise up their initial offers BEFORE talking to Meta. We’ll likely write about how to run this play in a future post. ↩\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/how-to-negotiate-with-meta",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to sabotage your salary negotiation efforts before you even start",
      "content": "Note: If you’d like a practical primer on negotiation, read my previous post on negotiation first — it tells you exactly what to say in a bunch of situations. This post is longer and more academic, but of course I include some practical tips and teach you what to say in a few situations, as well.\nAt interviewing.io, we’ve coached hundreds of people through salary negotiation. We’re good at it — our average user gets $50k more in cash, and we have a 94% success rate.\nHaving done this a lot, we’ve seen our users make the same two mistakes, over and over, BEFORE they start working with us. These mistakes are costly and make it harder for us to do our jobs. Our advice is applicable to everyone, but I wrote this post primarily to share with interviewing.io’s user base, so that future clients of our negotiation service don’t shoot themselves in the foot.\nThese are the two things you must avoid. Both involve how you talk to recruiters at the start of your job search, way before there’s an offer:\nIn this post, I’ll explain why these two mistakes routinely sabotage salary negotiation efforts and what to say to recruiters instead. In a nutshell, if you can just be in “passive information gathering” mode (more on that later) for most of your recruiter interactions, you’ll be golden. It’s hard to not to share info about your job search with your recruiter, especially as you build more rapport with them, but we’ll tell you exactly what to say instead.\nBefore we get into all of that, I want to go over two foundational things about negotiation.\n“It is difficult to get a man to understand something when his salary depends on his not understanding it.”\n-Upton Sinclair\nI used to be a recruiter. I ran my own agency, and I also worked in-house before starting interviewing.io. That means that I’ve had to struggle with the tangled incentive structure that comes with being a recruiter (see the section called “You should write down your principles”). There’s always a tension — recruiters are, by and large, good human beings who genuinely want to help their candidates, but they also have an employer they’re beholden to, as well as a comp/bonus structure that rewards certain behaviors, some of which run counter to candidates’ best interests.\nThere’s some distinction between in-house recruiters and third-party recruiters (recruiters who work for an agency that does placement, rather than a specific company that’s hiring engineers).\nMy general policy with third-party recruiters is to not tell them ANYTHING and to always deal directly with the companies they introduce you, once you establish a point of contact there. You should assume that anything you tell your recruiter is going to get back to every company you’re working with. Why? Because their primary objective is to place your butt in the seat of one of the companies they’re working with, and they will do whatever they need to do to make the deal happen. Often, those things will run counter to your interests.\nA big misconception that many candidates labor under is the idea that because third-party recruiters get paid every time they make a placement, their interests are fundamentally aligned. At a high level, this is kind of true, but once you dig into the details you'll see a lot of nuance.\nA recruiter, depending on market conditions, gets anywhere from 8%-25% of the candidate’s base salary when they make a placement. In the current climate, it’s around 10%. However, that cut is going to the recruiting agency as a whole rather than to the individual recruiter — you will almost always end up working with large agencies rather than a sole-proprietor shop where the owner gets to take all of it home.\nLet's say that you get an offer with a base salary of $150,000. You talk to your third-party recruiter and tell them that you would like more money. The recruiter may go to the hiring manager and try to advocate for you, but they're not going to push very hard because the incremental difference in their cut is going to be pretty small and to them the thing that matters most is getting butts in seats. After all, they're evaluated on the number of hires they make, first and foremost, independent of comp. Understanding that, let's do the math anyway. Say that they’re able to risk closing the deal and get you $165k. Before, the agency would have gotten paid $15k. Now the agency gets paid $16.5k. That incremental $1.5k isn’t worth risking a deal over (even a few thousand dollars would not justify jeopardizing the deal). On top of that, the individual recruiter is only going to maybe get a few hundred dollars total from that increase. So for them the difference really isn’t worth it. Third party recruiters are incentivized to get the deal done, not to risk the deal by negotiating hard for you.\nMoreover, because they’re incentivized to get the deal done, you should assume that your recruiter will share anything you share with them with the company or companies they’ve introduced you to. If you tell them that a company is your first choice and that you’re tempted to accept, they will likely share that with the company and may even recommend that they not raise your comp, since you’re already so enthusiastic. If you share that you’re not very interested in a company, and the recruiter has other candidates they’re presenting, they will prioritize those candidates’ experience over yours and will possibly tell the company not to invest in you as hard.\nWhat about in-house recruiters? In-house recruiters may or may not get a bonus for hires that happen on their watch; it depends on the company. But if they do, that bonus is generally NOT tied to your compensation, and in some cases, they may get a bigger bonus if they’re able to negotiate you down. At big companies, in particular, in-house recruiters follow a playbook. They’re trained to make offers within specific bands, and they’re trained to mobilize such that they don’t lose candidates to other big companies — if you wave a Facebook counteroffer in front of Google, they will act. If you tell them you’re interviewing at a startup, they will not, because they know that startups don’t pay as much. They’re actually evaluated on how well they follow the playbook. Because of that, there is no reason to assume that their incentives align with yours. They’re incentivized, first and foremost, to follow the rules their head of department sets for them. This is true for how they evaluate candidates, who they let through, and how they read resumes. And it’s definitely true for how they negotiate.\nIf you’re interested in peeking behind the curtain on how recruiters think, I interviewed three of the best ones in the industry recently. You can watch that below:\nProbably because of bad books and airplane magazine ads (for those of you old enough to remember those), people often think that negotiation is all about saying the right thing, or how firm your handshake is, or any other amount of silly nonsense. The reality is that negotiation is all about preparation and leverage.\nDon't forget to prepare for your technical interviews too. Sign up today for anonymous mocks with senior engineers from top companies.\nPreparation and leverage means doing the work to make sure that you have multiple offers, that all your offers come in at the same time, and that you don’t tip your hand too early. Laying this foundation is 80% of the work. You’ll need to slow some companies down, speed some companies up, and hold off questions from recruiters until you’re ready to negotiate, and not before. If you do this right, the actual negotiation part will be easy and almost a foregone conclusion.\nIs it possible to negotiate when you don’t have multiple offers and when you haven’t done the foundational work? Sure, it is, and we’ve sometimes had success with our users doing that. But it’s much harder, and the ceiling on how much more money you can get is lower.\nWith all that out the way, let’s talk about how the two biggest mistakes people make and how to not make them!\nYou’ve probably never been arrested, but if you’re like me, you’ve watched a lot of police procedurals on TV. You know the bit where they read the suspect their Miranda rights? They start like this:\nYou have the right to remain silent. Anything you say can and will be used against you in a court of law…\nTalking to recruiters is exactly the same, and one of the biggest mistakes we see our users make is sharing information too early. This is generally the only mistake we can’t walk back — once you share information, you can’t undo it, and sharing information actually has no upside, only downside. When you’re ready to negotiate, you’re doing so deliberately because you already know the state of the world, and you’re choosing to reveal the parts that set you up for success. Before that, you’re just revealing stuff that can be used against you.\nSpecifically, do not share with recruiters anything about your salary history (though it’s illegal in many states to ask this directly, there are indirect ways of asking, and many still do), your salary expectations, where else you’re interviewing, and how far along in the process you are with other companies. In short, don’t share any information about money or other interviews.\nThe main question recruiters ask up front about money is: “What are your compensation expectations?” They claim that it’s because they want to make sure that you’re not so far off in your expectations that interviewing with that company would be a waste of time. This is a nonsense reason — very few companies pay so much below market that it would be a nonstarter. Those companies know who they are, and they know to give you a heads up that they pay below market. Moreover, with the recent advent of companies sharing salary bands, you’ll have some idea if they're grossly below market before you interview. The real reason recruiters ask about compensation expectations is so that they can use it against you later in negotiations.\nAs such, if you answer this question with a number, you set an artificial ceiling on your offer. Do not even utter a single number to a recruiter until you’re ready to bargain. Do not go on levels.fyi and comment on the ranges listed for your level, even if you’re currently underpaid and an average offer from them would be life changing. Do not say a number first — ever.\nYou can see exactly what to say when you get asked about compensation expectations in the section called “How to handle recruiter calls” below.\nThe most obvious way to lose leverage is revealing information about money. The other way to lose leverage is by sharing information about where else you’re interviewing. If you share this information, you risk prematurely scaring off smaller companies because they don’t think they can win in a bidding war with FAANG. You also risk cornering yourself into a situation where the company knows your options are limited, and they might be inclined to lowball you as a result. Finally, you risk getting an exploding offer to try to force you to make a decision before you’re ready.\nBelow are some examples that I hope will drive these points home.\nLet’s say that you’re currently interviewing at Google, Meta, and two startups (let’s call them A and B). You’re at the onsite stage with Google, you’re doing technical phone screens at both startups, and you’re just doing your first recruiter call with Meta. This is actually a very strong position to be in!\nOf course, your Meta recruiter asks you about your comp expectations and where else you’re interviewing.\nIf you reveal your comp expectations, it will be hard to walk them back:\nIf you reveal that you’re at the onsite stage with Google and talking to some startups, here's what will happen:\nThough you started in a strong position with multiple interviews, including at companies that are known to pay well, you’ve now weakened that position by sharing details.\nHere’s another thing that could happen in this scenario. Let’s say that it’s the same set of companies as above, but this time you’re talking to the recruiter from startup A. The recruiter asks you where else you’re interviewing.\nIf you mention that you’re interviewing at both Google and Meta, they might get spooked.\nHere’s a different example. Let’s say that you work at a startup, and you’re up for a promotion soon. You figured it’d make sense to see what’s out there as well, so you’ve started interviewing with another startup.\nYour recruiter asks you in your first call about where else you’re interviewing and what your comp expectations are. You may be tempted to mention that you’re up for a promotion because that feels like it’ll give you leverage — if you get a promotion, the startup will have to work harder to entice you to leave, after all. Not so fast!\nIf you mention that you’re up for a promotion:\nIf you mention that you’re not interviewing anywhere else, that’s just a giveaway that you have no leverage:\nThe details may differ in your case, but the fundamental mechanics are the same. When you reveal information before you know what hand you’ve been dealt, it can only hurt you. I’m struggling to think of a scenario where revealing something has been beneficial.\nI suppose the one exception to revealing information is this: Sometimes it can be useful to give your recruiter a rough estimate for when you’ll be collecting offers, e.g., “I’ve just started interviewing. I expect to get through all my interviews and onsites in the next 6 weeks and start collecting offers 2 months from now. Does that timeline work for you?”\nThis technique can be helpful for aligning expectations up front and then keeping recruiters off your back, as they won’t need to chronically text you to make sure you haven’t taken another offer yet (we’ll talk more about texting with recruiters in the next section). But note that even in this example, we’re not actually revealing any information about where you’re interviewing, how long it’s taking, or compensation. You’re just setting a timeline based on hypotheticals without giving out any details that can be used against you later. When you share the actual timeline you’re working with, you no longer control the timing of your job search, and a huge part of negotiation is controlling timing so you can make all your offers come in at the same time.\n“Don't fire until you see the whites of their eyes!”\n-Unknown officer at the Battle of Bunker Hill\nJust like not revealing information too early, you also want to avoid negotiating too early. They’re two sides of the same coin.\nThink of it like a hand of cards. At the beginning, you have no idea what you’re going to draw. The longer you wait to negotiate, assuming you’ve timed things correctly, the more information you have. Then, when you’re ready to negotiate, you can look at your hand and selectively share information that puts you in the strongest position. For instance, if you have a high base salary from one company, a great equity package from a public company, and a signing bonus from a third company, you can strategically share those portions of the offers without sharing the weaker parts. Each negotiation is different, and it’s hard to give catch-all advice, but that’s generally the situation you should set yourself up to be in.\nWith that in mind, I’m a firm believer in negotiating when you’re ready and not before. Until you know what else is on the table, it’s really hard to 1) have the bravado that comes with actually having multiple offers (this is possible to fake, but trust me, it’s hard) and 2) negotiate effectively — you will never know as well as your recruiter what salary bands are like, what market comp is, and so on. They do this all day. This may be your first or fifth time doing it, but there’s massive experience and information asymmetry. There are two ways to combat this power imbalance: have as many of your interactions be asynchronous as possible (we discussed that earlier) and do everything you can to negotiate when you’re at the point of maximum information, and not before. Daniel Biales, one of our former negotiation clients, explained the latter really well.\nWhen I received a low offer, my first inclination was to start the negotiating process. Aline helped me to realize that this was not the best course of action. The problem with this approach is that I wanted to start negotiating before receiving my highest offer. If I negotiated an increase then, I would have had to renegotiate when I received the higher offer. This will cause negotiating fatigue for you and the company. They will be less likely to negotiate a second time because they don’t know how many times you will ask them for more. First, focus on strategies to draw out your decision. Then, when you have all your offers, start negotiating. There may be a couple of back and forth communications, but they will be over a short time span rather than drawn out.\nLet’s review our first example again. Imagine that you’re interviewing at Google, Meta, and two startups, A and B, just like before. Startup A makes you an offer: $160k base, 0.1% of the company in options over four years, no signing bonus. You react to it and say that you were hoping for a signing bonus. The recruiter comes back with a $10k signing bonus quickly and pressures you to make a decision, saying that they have other candidates waiting.\nBy starting to negotiate, you accelerated their timeline, and this is going to make it hard to go back and ask for more signing bonus.\nYou try to stall, and then a few days later, Google makes you an offer that includes a $25k signing bonus. You’re still excited about the startup for reasons other than compensation, but now you have to go back to them and say that you actually got a $25k signing bonus at Google. They are unlikely to move again.\nSo, don’t negotiate until you’re ready. It’s hard to walk things back.\nThat doesn’t mean it’s not possible to negotiate in stages and gradually start bringing up all your offers. In my experience, however, this is a much more difficult maneuver, takes way more experience, is much more stressful for the candidate, and often ends up with the same results as laying a solid foundation and just negotiating once at the end.\nSo what do you say when you get asked pointed questions by your recruiter about your comp expectations or where you’re interviewing? And how do you delay negotiation until you’re ready?\nUntil you’re ready to negotiate, your default mode should be “passive information gathering.” This means that you listen rather than talk. I coach all of our negotiation clients to be in this mode when they get on a call with a recruiter.\nIn all the snippets below, you’ll notice that they end with the same sentence: I promise not to accept other offers until I have a chance to discuss them with you.\nThis is deliberate, and it’s there because it’s disarming. Fundamentally, recruiters ask you all of these questions because they don’t want to lose out on you and have you go to another company. If you can speak to that worry head-on, there’s not much they can say back.\nFor questions about comp expectations at the beginning of the process:\nAt this point, I don’t feel equipped to throw out a number because I’d like to find out more about the opportunity first – right now, I simply don’t have the data to be able to say something concrete. If you end up making me an offer, I would be more than happy to iterate on it if needed and figure out something that works. I promise not to accept other offers until I have a chance to discuss them with you.\nFor questions about comp expectations at the end of the process:\nIt sounds like there’s an offer coming, and I’m really excited about it. I’m not sure exactly what number I’m looking for, but if you’d be able to share what an offer package might look like, then I will gladly iterate on it with you if needed and figure out something that works. I promise not to accept other offers until I have a chance to discuss them with you.\nFor questions about where else you’re interviewing at the beginning of the process:\nI’m currently speaking with a few other companies and am at various stages with them. I’ll let you know if I get to the point where I have an exploding offer, and I promise not to accept other offers until I have a chance to discuss them with you.\nFor questions about where else you’re interviewing at the end of the process:\nI’m wrapping things up with a few companies and in process with a few more. I promise to keep you in the loop, and I promise not to accept other offers until I have a chance to discuss them with you.\nFor when a recruiter provides you a salary range and asks you to comment on it, at the beginning of the process:\nThank you for sharing that with me. Right now I don’t know enough about the opportunity to value it concretely, and I honestly haven't done my market research. If you end up making me an offer, I would be more than happy to iterate on it if needed and figure out something that works. I promise not to accept other offers until I have a chance to discuss them with you.\nFor when a recruiter provides you a salary range and asks you to comment on it, at the end of the process:\nThank you for sharing that with me. I haven't done my research, so I am unable to comment on that range. However, if you do make me an offer, I promise to iterate on it if needed and figure out something that works. I promise not to accept other offers until I have a chance to discuss them with you.\nI said it in the beginning, and I’ll say it again. Negotiation isn’t about saying the right thing. It’s about laying a foundation: not revealing anything until you’re ready to negotiate, not negotiating too early, and making sure that you’ve set yourself up to have multiple offers.\nThen, once those offers come in, you swoop in with sharp precision, negotiate once (possibly with just your top choice company), and be done with it.\nIf you’ve set yourself up for success, done the foundational work, and haven’t made the mistakes in this post, the negotiation will feel like a foregone conclusion.\nIf you need some hands-on help navigating salary negotiation, sign up for our salary negotiation package. You don't pay anything unless you get more, and we’ll be with you every step of the way, for every recruiter call, every email you need ghostwritten, and every strategy discussion. Unlimited sessions, unlimited help, whatever we need to do to get you results.\nInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/sabotage-salary-negotiation-before-even-start",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Google Systems Design (Mock Interview)",
      "content": "Interview Transcript\nIntergalactic Avenger: Hello?\nSpace Pheonix: Hi.\nIntergalactic Avenger: Hey, how's it going?\nSpace Pheonix: Good, how are you?\nIntergalactic Avenger: Good, good, doing good. Alright, so if it's okay, I'll just jump right in with a technical question.\nSpace Pheonix: Yes, sure.\nIntergalactic Avenger: Yeah, so I think we'll do some not necessarily coding but more system design question today, just to keep it... I'm sure you've answered enough questions about hash tables for for one day, so let's start with a distributed systems question. So the idea is that you've got a database that you're keeping in MySQL, some some standard off-the-shelf database system like a SQL database and we could even say for this purpose, for simplicity there's just one one table and it's just... You're getting more and more rows in that table and eventually you found there's more rows than can fit in one machine. So you have access to multiple machines and they're all networked together somehow. So can you think of a way to to organize the database just given that you just have access to SQL, you don't have anything like... you know, any automated tools for distributing and... So just kind of generally describe what this is going to look like.\nSpace Pheonix: Okay sure, so the idea is you just have an access to SQL database from multiple machines where I can store the data. Right now it's going to the one machine and it cannot scale for the data that we are getting. I'm just making sure that I understood correct. And somehow we need to partition this database in a way to query in future, so distributed in multiple machines. So let me first ask a couple of questions, like before splitting the data, is it... so there are a few ways. One is like usually like some geographically like if you have some countries related to the database, for example if you have a country code, we could potentially have our country, our region code, like we can split the universe in like a multiple regions, like one is like North America, South America, or Africa and Asia Pacific, kind of probably like a three regions we can split into three different machines to go like at any that are related to the three specific regions, go into specific machine. Probably one layer, one machine where it load balances these things. Somewhere we need to have a component where the data and then decide which machine to go store this data.\nIntergalactic Avenger: So the idea that... so yeah that makes sense that there's going to be a lot of... if you have so much data, it might be coming in from different sources, so would the idea be that country code is just something that's in the database or is that also relative to who's asking for that data? Like do the European users talk to the European data and the North American users talk to the North American data?\nSpace Pheonix: Okay, well...\nIntergalactic Avenger: That kind of brings up the question of, is that is that how you were thinking about it?\nSpace Pheonix: That was probably my next question was, so how the database will be coded in future, whether like a different regions will ask for different region or they will just look for their own region data when they worry, so that's debatable or a clarification question if it's going to be like Asia Pacific people asking for data from Europe, then you're pulling the data from two different machines and then merging and then responding is going to be complicated so we have to think a different way of partitioning this, probably like anything like an old data we can keep it in like in a backup database, like one transaction database where you have only current months data. If anything older, you go to different machine, pull it from there. So depending upon the query pattern, whether always you get quite often you get for last week's, last month, or last six months data that being coded, that can be kept in the main machine where we do the transactional and the rest all can go into like jobs analytics that are... this kind of model I would think of.\nIntergalactic Avenger: Okay, let me just yeah... there's a couple questions back in there so with respect to the geographical regions, so that's definitely a very good way to start. So if this was the kind of system where there were country specific data that was being read from and written to just with respect to that country and that was... and people in that region were the only ones doing it then that's an excellent way to start. But let's say for the purposes of this exercise that that's not the case. Let's say that all the data is stored centrally in one data warehouse that's located in one geographic area, so that's just to cover the first one. So then that was an interesting point with respect to the the recency, so can you just sort of sketch out for me an algorithm of how that would work. So for example, let's say that you know if I'm reading from... as I'm understanding it, there's going to be one machine in the front that is going to take in the query and it's going to look at the time range that you are looking at and based on the time range it will farm that off to different machines. So how then does that work with respect to... so is there going to be... are you going to... so let's say that you are going to have that split into day or I guess you said month, so by month. So is the idea that every month, you would add a new machine for that month so that there's a machine for 2015 December and then for next month you'll need to make a new machine that is going to host the new data or do you migrate the old data backwards?\nSpace Pheonix: Yeah so migration is what I was thinking. I wasn't proposing to add the new machine every month. Yeah since being the transaction database that is the bottleneck where everyone insert an SQL query for the same month that is going to be one machine and the rest all like... a machine can probably can accommodate more than a month data. So requests will go to probably one machine or two machine depending upon the size, whether it can hold in this one machine, then it could be just one machine. Or it could be like more than one machine, depending upon the size of the database. That was what I was thinking.\nIntergalactic Avenger: Okay, I like that idea. So this is the interesting point. So okay, so you have one machine that's kind of the the current ones and then you have maybe multiple machines that are holding the older data. So how do you... how do you split that up? So let's say that you right now maybe you have one machine for December and then one machine for all past data. Then, you're looking at this in the future and you say oh whoops, the machine that right now has all the past data in it is about to be full. So now how do we split up that data?\nSpace Pheonix: Yes, so in that case... not in that case. So we have to design to accommodate this... definitely is going to be full is the one machine for all past that's not going to just hold everything for next 10 years or 20 years so definitely does miss this for adding more machines as and when needed in the design to go get the backup database from multiple machines. So in a way I would rather say probably like to go for like a five years, ten years kind of a database. So these are all like a kind of a parallel partition right? There is completely a new concept for virtual partitioning a table can be like... so I I'm not technically like completely aware how the whole thing works like a for example the big data thing, how do they completely vertically partition the table first off of like probably 20 columns, first ten columns would be stored in one and the remaining ten columns will be stored in different machine. But I don't have the technical depth of knowledge for explaining how that is completely implemented or how the whole thing works, the vertical partitioning.\nIntergalactic Avenger: Let's not worry too much about vertical partitioning. I mean that's certainly one way you could do it, but let's just assume that there's a relatively small number of columns. It's just that there's more and more and more and more and more rows.\nSpace Pheonix: Yeah okay okay so yeah so considering there are a number of backup databases, I would probably suggest like going back like completely like up to five years one machine and complete the past like for more than five years running on more than one machine kind of approaches what I would think of.\nIntergalactic Avenger: So let me see if I have this correct, if I understand the scheme correctly. So you've got some... or I guess the one piece that's unclear for me is how does the data then sort of move and get migrated from how it is now into the past? Like once you've decided that some row is old by some definition of old, maybe it's one month or one year whatever, how do you decide where it goes? And how does the migration sort of work? So my question is when you do that migration, do you go over all the data like in the entire history as you redistribute it or when you redistribute it are you going... you just take the current data and then push it sort of somewhere?\nSpace Pheonix: Right so... yeah so what I would do... let's say this is what my addition, like in the component which decides to go find where to find the data, so that knows which server I need to go find the data. Depending how it knows, the strategy is let's say I have the current machine which does the transactions and everything for the last just one month. That's all I'm going to keep in a different machine.\nIntergalactic Avenger: Just so you know, if you want it, there's a little whiteboard if you want to draw on a little whiteboard and there's also like just the text if you want to draw little boxes in the text, so if that helps you to explain it or to think about it, you have those options open to you.\nSpace Pheonix: Yeah sure, let me try that. This is my second interview, just trying this one.\nIntergalactic Avenger: Yeah there's a little button that has like a pen on it, and that's a little whiteboard so you can you can draw stuff.\nSpace Pheonix: Oh yeah, so yeah. So this is let's call it OLTP this one, like a transaction database. So this is the current data. So even before this, let's say we have a component called the load balancer or whatever, which decides where the data, this should be queries. So all the queries coming in here. The load balancer decides where to go, so this OLTP queries the transactions in the last month, so less than one month old here. And the query here, let's say we get for old data here, so greater than one month old data is going to be stored in this backup server. So in a point where this is going to be filled completely, there should be a way like I said, this is going to be filled up, for example we have for now 10 years of data here. So right now we filled it up and then there is no space in here. At this point, I want to completely split this thing, I think my suggestion would be to just add up one more server where the new data, whatever we backup from this server will get into this machine, like I have one month old here, now I'm in the second month, so just one month old database is that I will fit into this new server. Now I need to find a way where to query from these two machines and then written back somehow that has to be, that has to happen based upon the query in the load balancer. Depending upon the query, I have to find whether just I need to go to backup server or also backup server 1 and backup server two backup server three. Depending upon the quarry I would just add this up, so that probably is what I was thinking out. I wasn't thinking... so there is one other way like I have the backup complete backup of ten years of data. I wasn't thinking of splitting this into like I have four machines now, splitting into all four machines, I wasn't thinking of that.\nIntergalactic Avenger: Yeah that's fine. So let me see if I understand the path here. I guess I'm a little bit confused... so the load balancer at the beginning looks to see if it's within a month or greater than a month and so then it can choose one or the other, but what is this other piece in in the middle, this this one right here? I guess I'm confused as to okay what its role is in the... because it seems like if the data is either split into less than one month or greater than one month... I guess I don't understand what...\nSpace Pheonix: Yeah, yeah so let me clarify that... So this one, let's say for example I am in 2015 now, my first date observer is filled out, so anything older than 2015... anything older than 2015, we get into this machine.\nIntergalactic Avenger: I can help erase the old stuff if we want to erase it.\nSpace Pheonix: Yeah sure. Is there a way?\nIntergalactic Avenger: Yeah, you just have to make the eraser a little bit bigger. It's fine yeah okay.\nSpace Pheonix: Okay so this one contains less than 2015 data. And then anything so now we learn this database is filled... filled up and then we we are adding a new machine and this will contain anything greater than 2015 like greater than or equal to 2016 for example. So going forward from the OLTP machine, I'll just start backing up things every month to get into this database machine two, that's kind of the backup service that we will write it which will run in offline mode. So this load balancer itself could understand the machine 1 and machine 2 and depending upon the query, we can pass... we have to split the query depending upon... let's say someone else, since it is like a pretty recent and if someone asks like a two month of 2015 and one month of 2016, then definitely this load balances really have to pass the query and send to the two machines. So that way we get both the roles and then join and then it sends it back. So that's kind of the load balances job and it can be considerable, we can say ok year 2015 machine one and all that probably you can put it in some xml configuration of something where this strategy kind of easily changeable and stuff so we can add more machines going forward. When we add machine three, we can just say 2017 and beyond, so that can be configured just like that in the configuration file here. So this will be written by program or something like that.\nIntergalactic Avenger: Okay, now that makes sense. Okay so it seems like... so we started off with the idea of it being geographically partitioned and that's good, that will work with some some things. Snd this is partitioned by time, so in what type of scenario is this going to be ideal? Like what kind of query patterns of people querying the database are you going to see that this is optimal for?\nSpace Pheonix: So this is completely for like a transaction database where like it's a Amazon order service, where you get plenty of orders every minute and every day, so probably that's kind of amount of data where later you get it from same country and and you would get a lot of orders that's probably one scenario, where you get like a tons of records every day.\nIntergalactic Avenger: Well, let me put it this way. So for example, let's say we're talking about an Amazon like database. And the things you're storing are things like orders, like who ordered what right? And I could imagine that in this type of situation, people are looking up recent orders more often than they're looking up past orders. They're probably looking up something they just ordered this past week to see its status, but they're probably not looking up very often their old orders. It kinda feels like you're going to get a lot of traffic going to this one machine. Then all of the backup machines are going to be less utilized. So can you think of a way... so let's even just keep going with the this sort of Amazon style database and let's just say that you know after putting this into place you notice that this one machine here gets kind of most of the action and becomes the bottleneck and these older ones, people aren't really querying for it that often and so they are less utilized. Can you think of some way that will sort of better distribute the workload between all of these different machines so that you don't have this one as the bottleneck?\nSpace Pheonix: Yeah, sure definitely. So I think, so the other way to distribute would be probably like going by... since country wasn't a thing because every order is coming from same country let's say for example it was from North America, in that case I would say just go with a last name. Usually like every go by last name, people query by... so the user identification, user ID of course it's not the thing we can do. Probably I would go with last name starting from A to like your let's say P to machine 1, from Q to Z to machine 2 and depending upon number of machines I have, I can split evenly to all the machines. But this scenario I'm thinking about is just the orders, like it can vary the condition that we are trying to... the approach we are trying to split the data between the machines depending upon the data we are getting. For example, right now we are thinking everything is orders, everything is placed by some first name A and last name B. That's the scenario I'm completely talking about. So that way any user come to query something, they go to just one machine. They will never get into multiple machines and there is no question of joining queries and merging the data from two different machines and then solving the users. So that's probably one approach I would go with.\nIntergalactic Avenger: Okay, no that's essentially... because that's definitely going to spread it out so that all of the machines are getting you know the current orders and the past orders so all the machines are kind of spreading them out. Another challenge for you here... so if you split it up by letter, some letters are going to be more popular than others, so there's many more last names that start with the letter T than start with the letter W.\nSpace Pheonix: So I have a strategy coming to it. So I was thinking of see the pattern of orders coming from... we really have to study the pattern last like a few months and see where the number of orders really coming and then that's how we have to decide the number of letters to go on to some machine X and machine Y. There is no way we can really distribute just 4 letters to sorry... like 13 letters to one machine and remaining 13 letters to the other machine. Definitely we have to see the pattern and how the last couple of months went through and depending upon that we have to say it okay probably like five letters, first 5 just to machine 1, remaining 21 letters to machine 2, probably something like that. And one more problem with this again for example since you are storing order and everything here splitted into multiple machines, in the case of like where the same order data database will be accessed by some people like who's fulfilling the orders. In that case, we have to really query, we cannot really query by name or anything, they have to see all orders today and then definitely we run into issues of pulling the data from two different machines and then merging and then assigning everything and then returning all the data, so there is no way we can get around like you're always hitting one machine, that's not high likely... like it is just one side we are solving the problem but the other side we still have the problem of solving coding from multiple machines and unwinding, so yeah.\nIntergalactic Avenger: That's a very good point, it's a good point. So just going back to that last issue like if you said that you wanted to find all the orders... so let's say we're going into the way you said before with all the last names and so that's now distributing the data a little bit better, but now the dates are are not distributed very essentially centrally. So now you want to issue a query that says you know, show me all of the orders today. Where is the bottleneck going to be in that case?\nSpace Pheonix: It's all going to be the load balancer, where... so the load balancer is the one that will get all the requests. Now it has to decide where to go pick the data. Now machine one, machine two, machine three if for example if you want everything from today, it has to go to all the machines and you got all the data from all the machines, you have the job of joining everything, and then you like union all the results and then returning to the client so the load balancer kind of becoming a bottleneck yeah.\nIntergalactic Avenger: So that's certainly true if you're doing some aggregation of all the data. So let's say that you wanted to sort all of today's orders, then certainly you're right that the the load balancer becomes the bottleneck because it would have to aggregate all of them and then sort them. But what happens if they just ask \"give me all of today's purchases in any order, I'm not concerned about the order.\"\nSpace Pheonix: Okay, so in that case, so there could be one more possibility where you get the client requests and I know the load balancer knows where all the data is and we could potentially return the results directly from machine 1, machine 2, machine 3 to the client possibly. The way is you get only if the load balancer is probably act like a probably like a velocity server where the client will get the data, the information where to go pick actual data. So I will return back machine 1, machine 2, machine 3 to the client and then client will query on more like a three parallel queries or whatever kind of the way, it can just go query directly from those machines so the balance that the load completely is between all the machines.\nIntergalactic Avenger: That's an idea, I like that. Okay, so last one. So we're... these are all excellent ideas... so let's just dig a little bit deeper into the last name issue. So you're right, I really like that idea of looking over some past data like usage patterns to sort of see who are the types of users that use it more often and that kind of thing and that's certainly something you do dynamically, but let's try to think of something that you can do more statically without looking at the usage patterns to try to clear up this issue of you know more people have last names with the letter T than have the last names letter W. So is there some way that you can distribute the records so that so that even if... so let's just say for example that you have you know 100 machines and hypothetically this would mean you would put four letters on each machine because there's basically 25 letters in the alphabet but...\nSpace Pheonix: You mean each letter in four different machines.\nIntergalactic Avenger: Yeah so you would put like the first the first quarter of the letter A would go in one machine and the order of A gets in the second machine set. So that's the sort of one way to do it but it turns out that if you put like you could fit all of the complete letter Z in one machine and actually all of letter Y too, because there's not very many people with last name Y. So two people can actually fit in Y but the letter T needs ten machines. So I mean one way you could do it is you could just sort of keep a table of each individual row with... So I mean one sort of simple way of doing it would be to create a table with each individual row in which machine is going on or you could create like a range you could say well this person to that person is on this one machine but there's kind of a lot of bookkeeping to do there. Can you think sort of a simpler way so that when a query comes into this load balancer, it knows exactly where to go very quickly and easily for which machine is holding that person's data and you don't need to keep any type of like bookkeeping around. So the bookkeeping is fine except that you know let's say you wanted to add someone to the database or you want to add an order, well you would kind of be constantly shifting around how they're all migrated if you wanted to optimize it. So can you think of a way that is going to distribute all of these people in a way that each machine is not overloaded, that all of the machines have roughly the same number of records and that you don't need to do any type of like heavy duty bookkeeping or shifting around data as say more people come online or the orders are made.\nSpace Pheonix: Okay so I was just quickly thinking of just putting the machine and mapping the machine with the user table where each record will say okay this user always goes to this machine blah, but that's easy in a way to just to return the machine or whatever the detail we want to store the data, but in a way it becomes complicated, let's say what happens if I have to bring one machine down? I have to really go back, find all the users assigned to that machine and then update with some new machine. Those are the things we have to really think about but let me think about a little more... so what I was thinking was giving some weightage, but again that sounded like a heavy duty bookkeeping kind where I say starting letter A gives some weightage 1, so a T with a lot of who orders with a weightage 10, something like... so giving weightage for the letter again I think kind of a high bookkeeping, I wouldn't suggest.\nIntergalactic Avenger: How would you pick the weight? It's the idea that the weight is the number of users with that letter, so like the wait for the letter P is how many users last names start with the letter P? That kind of thing? Well there's something to that, that's an interesting one, I hadn't thought of that one before, but that makes some sense. So then what would you do with that weight?\nSpace Pheonix: Yeah so the weight tells you... let's say you have 100 machines, it will just split up with... that weight will tell you how many machines, what is the percentage of machines that you need for each letter, so you just sum up and then find the weighted percentage for each letter and then depending upon number of machines you can just have those many machines for that specific letter, but that's again another bookkeeping. The other approach I was thinking was since we evenly need to distribute every order comes in... so let's say we want to like a very highly distributed model where you get order one go machine one, order two machine two, order three machine three, and an order n go to machine n, and order n plus 1 goes to mention one again.\nIntergalactic Avenger: I like that idea.\nSpace Pheonix: Yeah but how we really achieve that is what really becomes more of questionable where let's say if I have order one, order two, order three, I get from one user, let's say if I go to machine one and I say okay machine one order one from user 1 is always machine one I could assign the user one from then on go to always machine one and the next order goes from user 2, goes to machine 2. I will assign that users for the machine two. But again that becomes static afterwards, that's not more of dynamic anymore, so there should be a better way of distributing always all the machines used is like equally that's what I'm what...\nIntergalactic Avenger: Actually let's explore this latest idea that you had, which I actually think is quite elegant because of its simplicity that you'll have the load balancer as you're writing new things will just have a counter that will roll over, super simple to to figure out where it's going to go. And so then the only question is how do you retrieve it?\nSpace Pheonix: Yeah, so the reporting again becomes complicated there...\nIntergalactic Avenger: Um well maybe not. I mean so if you think about it so let's say that you say well give me all the orders from today for some certain user? That's what you want to query right? What can the load balancer do to find that information, given that it is totally forgotten where it put that person. Because maybe it saw that person a million transactions ago and it didn't keep track of where it put that person. So how do you get at the, you know, so how do you get that the answer to that query of you know how many purchases did that person make today right?\nSpace Pheonix: So one... these are all reporting afterwards we could potentially... I'm just thinking of these sources. There are two things right? One is OLTP and the other one is the analytics server, which is just for used to file a reporting server. Quite possibly that we can have all these machines data and the transaction data gets duplicated or are pushed to some reporting servers where this load balancer always can go query the data from... so that's... let me think, so let's say we have 100 machines here. The main reason we are distributing is because users are being online and we need to serve them quicker and faster, that's the main reason that we are distributing all these transactions during the insertion. But the reporting usually can like a couple of seconds can take, can take couple of seconds more. We could potentially have the reporting servers separate where all the data gets synced to the reporting servers, always it is the load balancer notice. If any query falls for just coding the data always pointing to the reporting servers, that is one possibility, but let's think of if there is any other way that we can always pull this data from the same machines therein. So I don't see because we lost the pattern as you said the load balancer forgot where the data is and there is no way that load balancer is keeping this mapping between the machines and the pattern of queries. Let me think a bit more.\nIntergalactic Avenger: So one thing that you're optimizing for, which is which is generally a good thing, is that you're trying not to ask more machines than necessary. So for example with this first you know description that you have here where it's charted by time, you have the less than one month and then 2016, 2015, you have the the load balancers up at the front that decides I'm going to ask only one of these machines and that saves CPU cycles obviously because you're only asking the one proper machine where it is, but that's not necessarily a restriction. You could asked more than one machine.\nSpace Pheonix: Yeah definitely, so in case of let's say we have hundred machines, we store the data like evenly from the load balancer, now the query is to select something. I could go ask more machines, but whether... but my worry is that would slow down things when someone wants the report of today's orders or last weeks orders or whatever, querying more machines will slow down things if it is just from the load balancer.\nIntergalactic Avenger: Well, actually if you think about it, so if you are the reporting server and you are trying to get the all the days orders, you still have to ask every single machine because you know, somebody with the last of the name with the letter P is going to have an order and someone with the last name of the letter Q is going to have an order, so you have to still ask all the machines when you're reporting, so that's I think that's actually not a big problem. I don't think it slows down the reporting aspect of it.\nSpace Pheonix: Okay um yeah, so could be so that's again that load balancer probably let's say if it is just a select query, then we could have and so probably we need to distribute the load balancer now. The problem is all the insertion going through the load balancer on single servers balancing everything and if it find something select query or the report query, it should just give it back to the client, go find the other load balancer or something on that machine and the other load balancer is just mainly for the reporting load balancer and this is probably just the transaction load balancer. So the second load balancer where all the reporting code will go in and that would probably easily to query from all machines and then respond, serve the user. So that way we could just split the load between the load balancers potentially. But I would not really suggest just this machine coding all the machines for the reporting purpose and as well as the same load balancer doing all the insertions to all different machines. That will really become a bottleneck I think.\nIntergalactic Avenger: So other question is I wonder starting this iteration, there's going to be multiple load balancers and each one of them is going to query all of the machines or is going to query some subset of machines? I guess I don't understand the multiple levels of load balancing. And then the other question is why can't the original load balancer just ask all of the machines in parallel what all the results are?\nSpace Pheonix: It can, it can. I'm just worried whether it will become a bottleneck for responding the queries because it's doing all the insertion as we are thinking about, we are talking all the data like Amazon sites, like this all the orders coming through this load balancer and as soon as you are doing the reporting through the same load balancer which is querying all different machines, I am really worried that will become really a bottleneck and slow down things. So what I was proposing was if whenever this load balancer gets a reporting query, I know ok this is just a report, go back to the client saying okay this is just reporting. Go to the other load balancer, so now the client hits this load balancer too, this knows okay I deal with just the reporting part of it, that will still query all the machine, but not the same load balancer. So this load balancer one will just do the insertions and stuff like that, all reporting will go through the load balancer two, which will finally query from all the machines and then serve the user. Does it make sense?\nIntergalactic Avenger: Okay yeah, so I mean if I'm understanding that, so the... it would sort of be introducing like a priority or a tier for the different load balancers and depending on what they were doing, they would sort of have a higher/lower priority to use up the resources, that's very smart yeah because you're right, that the usage of the database is not going to be the same so the... you know a user who's just logging into the site, is going to want to see a small number of records very quickly whereas the reporting server is looking at a very large number of records, but can see them more slowly. So that's great, that make sense. Yeah that's kind of all I had. I know it's a very open-ended question, but I was just curious, wanted to just talk with you about that. I don't know if you've ever done any thinking about this, it seems like you must have thought about this some because yeah you have all this ideas about load balancing and OLTPs and usages and charting, it sounds like you know all of the concepts very well, so do you do this in your in your work already? I know that I normally don't see people that have this much background in this and all the varying context.\nSpace Pheonix: Sure, I did some amount of this work in the past, so I was working really the same kind of ordering platform enough, with like a million users kind of database I was dealing with, so we ran into similar kinds of issues when we were trying to do like multiple computing things like this and exploring it was all again learning and settling down things. There is no just one best solution for everything. So that's why I was trying understand these patterns a little bit and then making sure we balance things like evenly, is really important. But did you have any other better ideas, just in case?\nIntergalactic Avenger: So I do like the one idea of the just having a round robin where you'd put each record, just over that kind of thing. The other way to do it by the way is with respect to the names. If you wanted to do it based on names, what you could do is instead of it being based on the first letter, you could just take a hash of the entire name or the entire user ID or something like that, so then what that hash will do is say you know take some space of you know a hundred thousand, a million, two million users and break it down into a number between you know one and however many machines you have, so just design your hash function so that it takes whatever your identifier is, be it their name or their ID or something like that, and remap it into a space that is exactly how many machines you have, so that way you avoid the problem of querying too many machines and and there's sort of a lot of network traffic that's excessive, but what you could do is you could do is just hash the persons identifier and then you know that that identifier will go exactly to that one machine, and that way as you add more and more users, they just get a randomly assigned according to that hash function. As you said, there's no one right answer. You know, the the practical nature of your data will will pick whatever the right one is and I thought you had a lot of really good ideas, so that's great.\nSpace Pheonix: Alright, yeah. That's good thinking of doing the hash function, that's yeah. That's something new I learned today.\nIntergalactic Avenger: Good, great. Alright, so you have a good day.\nSpace Pheonix: Thank you so much, you too. Bye-bye.\nIntergalactic Avenger: Take care, bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/google-system-design-distributed-databases",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Java Mock Interview (Google Engineer)",
      "content": "Interview Transcript\nIntergalactic Avenger: Hello?\nSupersonic Taco: Hi!\nIntergalactic Avenger: How's it going?\nSupersonic Taco: Good, how are you?\nIntergalactic Avenger: Doing good, doing good. Yeah sorry, couldn't hear you for a second so I just wrote this on the screen there. Have you ever used the platform before?\nSupersonic Taco: Yes, a couple times.\nIntergalactic Avenger: Okay so then I guess you're familiar with how it all works, so I'm just going to jump straight into a coding question.\nSupersonic Taco: Alright.\nIntergalactic Avenger: So the first question is: are you familiar with the concept of order statistics. Have you heard that term before?\nSupersonic Taco: No\nIntergalactic Avenger: It's actually a very simple thing with an overly complicated name. So, given an unordered set of numbers like what I've written here: 1, 6, 3, 9, 8, 5, the order statistics are like the nth element in the list if it were sorted. So, the first smallest number in this list would be 1, and the second smallest number is 2, and basically the nth order statistic is then the nth smallest. That make sense?\nSupersonic Taco: Yeah\nIntergalactic Avenger: Alright so we're just going to have some algorithmic questions about finding some of these nth order statistics. Just to get started as sort of a warm-up problem: how about you write a function that, given a list of numbers that are out of order, you just find the smallest. So basically the first order statistic.\nSupersonic Taco: Okay sounds good.\nSupersonic Taco\nSupersonic Taco: So I'll just declare it here: public static int is the return and I'll just call it min, and this takes an int I'll call it n.\nIntergalactic Avenger: So this should be like an array.\nSupersonic Taco: Yeah, sorry. So then I'll loop through the array, and the for each of those iterations I'll compare it against a min that I've already set up. So I'll set the min to be arr[0], and so what should I return if the array is null, or if there's no value?\nIntergalactic Avenger: Don't worry about that case. We'll just assume it'll always have some values in it.\nSupersonic Taco: Okay, sounds good. So then we'll set the min to the first one. So then moving through the array, if the element at the index of i is less than min then we make that the new min. And at the very end of the for loop you return. So just to test it to make sure, I'll write a litte test here: int[] input = {2, 3, 0, 6} should give us 0.\nIntergalactic Avenger: Yup, sounds good.\nSupersonic Taco: And let's try that then. Alright there we go: it returned 0.\nIntergalactic Avenger: Perfect, and what's the runtime of this algorithm?\nSupersonic Taco: O(n)\nIntergalactic Avenger: And is there any faster way for you to do it?\nSupersonic Taco: For an unsorted array that I know of, no.\nIntergalactic Avenger: Correct. Okay, so now you get the idea, let's make this a little harder, a little trickier. How about you give me the second smallest number?\nSupersonic Taco\nSupersonic Taco: Okay, so for the second smallest number, then I think what we would need to do is maintain two variables and check accross both of them to see...like a larger min and a smaller min so we can check if there's a number that's smaller than both of them then we would put it into the smaller min, and if it's only smaller than the larger one then we can put it into the larger min. So once again are we assuming that the array's length is two or greater?\nIntergalactic Avenger: Yep\nSupersonic Taco: Okay, then I'll just call this min2 and we'll put this at the second element of the arr[], and if the arr[] is greater than the min then it's the very smallest one so the min becomes arr[1]. min2 should be set to min and min is set to the new minimum. And then otherwise, if arr[i] is less than min2 whereas it's still greater than min then this means min2 becomes the arr[i] and instead min becomes min2.\nIntergalactic Avenger: min2 becomes arr[i], but what happened to min then?\nSupersonic Taco: Oh sorry yeah, this is maintained the same I think, because if it's less than min2 then min is still the smallest so it should stay the same, but min2 gets updated\nIntergalactic Avenger: Okay, let's run this.\nSupersonic Taco: I have to return min2 this time. Okay this should give me 2. There, it gave me 2.\nIntergalactic Avenger: Perfect. Okay, I'm trying to think if there is a corner case here. What if these were the numbers here: {3, 2, 5, 6}. It should actually be 3, because 3 is the second smallest.\nSupersonic Taco: Yeah, it returns 3.\nIntergalactic Avenger: What if...Oh because you start back at 0 again, then you flip it all around, I got it. Alright, yeah perfect. And what's the runtime of this one?\nSupersonic Taco: This one is still O(n).\nIntergalactic Avenger: Okay, so we're going to want to move this and turn it into n. So we're going to want to add another parameter here that says I want to find the nth smallest. One way you could do it is you could just expand on this idea and you could just create a list of all of the mins up to n.\nSupersonic Taco: Right.\nIntergalactic Avenger: Now, what would the runtime of that algorithm be?\nSupersonic Taco: Well if we're storing them all, then we need to check across each of them each time which would become O(n^2) because we're running through all of the previous values every time we look through the array.\nIntergalactic Avenger: Yep, so to get the 1st, it just took O(n). To get 2 it took O(n). But now if you expand this in that same sort of pattern it actually becomes O(n^2). So is there a way you can improve on that O(n^2) time?\nSupersonic Taco: Alright let's see. One way to improve would just be to sort the array and that would make it O(nlogn) immediately and then all we have to do is find the nth index in the sorted array.\nIntergalactic Avenger: Okay perfect. Now here's the real challenge. Can we do better than O(nlogn) for any arbitrary m we're trying to find? So we saw that when m is 1, we can do it in O(n) time. When m is 2, we can still do it in O(n) time. You think there's a way that you could extrapolate on that sort of patter and say: oh, I can always do it in O(n) time, no matter which of these I'm trying to find.\nSupersonic Taco: Right. So the reason that we could do it in O(n) time for this m = 1 is because we could just go through and compare them all and see which one is smallest. For m = 2, we had to compare it with each of them and also the previous minimum. Without having to compare it to all the previous minimums I'm trying to think if there's a way to figure out the nth smallest.\nSupersonic Taco: Maybe if we delete for an object but then that wouldn't help either because if we go through…\nIntergalactic Avenger: But if you delete? So certainly it's tricky. If you get stuck, I have some hints for you.\nSupersonic Taco: Yes, I'd appreciate a hint.\nIntergalactic Avenger: Okay so, you mentioned the O(nlogn) case of sorting and then picking the mth item in the list. So in that sense, once we sort this input, you have: [2, 3, 5, 6]. And then let's say m = 3, you go straight for the 5, and you know that 5 is in the correct place, that everything of the left is below it and everything to the right is above it, and it's in position number 3. So that means it is necessarily correct. If we expand this out a little bit more [2, 3, 5, 6, 10, 15, 21], what you can see is that number 5 is in the correct position, but also every single other number is in the correct position. So you've also done work to make sure the 3 is the 2nd position and the 2 is in the 1st position and the 10 is in the 5th position and you've put them all in the right places even though at the end of the all you really cared about is that the 5 is in the right place. Because whatever order any of these other ones are in, it doesn't really matter, you don't really care because you're only really interested in this one.\nSupersonic Taco: Right, okay. So basically we're looking for a way to ensure that a certain value is in a certain spot but all the other values don't have to be sorted.\nIntergalactic Avenger: Correct.\nSupersonic Taco: And the one we want to be in the right place is at the m index.\nIntergalactic Avenger: Right.\nSupersonic Taco: So if we did this for the first minimum then basically we would have to go through each of the elements and then put all the ones that are larger than a certain minimum to the right of it if so that is would be at the beginning. So basically we would have to go through and figure out how many numbers are lower than that number and how many numbers are larger than that number.\nIntergalactic Avenger: Right.\nSupersonic Taco: So what if we do that then. So say we want m to be 2 like in this case where the index is 2 that means we want two numbers to be less than the one at m, and four numbers to be to the right. Somehow there should be a way that we can go through and figure out and make it balanced so that it's like equal on both sides even though those aren't sorted. But we would need to know what the number 5 already is in order to go through and actually put that in the right spot. So there needs to be a way where we can figure that out without already knowing 5.\nIntergalactic Avenger: Right.\nSupersonic Taco: Yeah and if we just chose a random number or when one by one like we did here then it wouldn't work because then we would still go back to being O(n^2). We just still have to go through all the numbers to see which one was right.\nIntergalactic Avenger: But let's take a look at example. You could have described this process where you take this input array, you take the first number you found, and you made sure it went in the right spot. So you described a process of saying: take this number 3, and put it (just that one number) where it goes. So everything to the left is less than it, and everything to the right is greater than it.\nSupersonic Taco: A binary search tree?\nIntergalactic Avenger: Yeah. That's kind of a part of it. So describe how you might do that. You don't really much information about this array coming into it, because it's unsorted, in any order. So you might as well just start with the first number you find and say: I'm just going to put the first one where it belongs and I'll tackle the rest of the problem after that. For example, you can think of what it would look like afterwards: [2, 3, 5, 6, 10, 21, 15]. If you can imagine that this might be what the array would look like after you found the first place. So 3 goes in this spot and everything to the left is less than 3 and everything to the right is greater than 3, and you don't really know what's going on on either side and you haven't really sorted it altogether, but you do know that 3 is in the right spot.\nIntergalactic Avenger: So does this then give you some additional information in terms of how you would proceed from here? So keep in mind we're still looking for the third largest number and you just figured out that the number 3 goes in position number 1.\nSupersonic Taco: So then I know that the number 3 is the second largest number and at this point I would have enough information to find the third largest number using the technique that I just did before where I find the previous minimum then I just have to run through the array one more time to find the next minimum.\nIntergalactic Avenger: Right, that's true. And which part of that array would you run that algorithm on? The whole thing, or a part of it?\nSupersonic Taco: The right, because the right is unsorted.\nIntergalactic Avenger: Well, in a sense the left is also unsorted kind of. Because we don't really have any guarantees about what's going on to the left. In this case you do because there's only one element so there's not really much sorting to do. But what else is an interesting property? So now that you have this 3 in the right spot, in term of what you're looking for are you interested in anything on the left, or are you interested in anything on the right, or are you interested in anything on both sides?\nSupersonic Taco: Well, right now looking at this array, I would be interested in the right because the 3 is only at index 1 and we're looking for index 3. But the 2 could be the 5 too, like what if there was a 5 here instead of the 2.\nIntergalactic Avenger: It couldn't be. It couldn't be because you've split this array up. Let me start by rearranging this more: {10, 2, 5, 6, 11, 3, 15}.So you start with this 10 and you first make sure that everything on your left is less than 10 and everything on your right is greater than 10. So this might look like this: [2, 5, 6, 3, 10, 15, 11]. So you've shifted things around but you've shifted them around in a way so that everything on the left is less than 10 and everything on the right is greater than 10. So it's not just that you've found the one right place for it, but you've done a little bit extra to make sure that you split the array in two pieces.\nSupersonic Taco: Yeah, so then this is actually pretty helpful. If the 10 is over here and this is in the 4th index and m has to be to the left of it, so we don't really need to worry to the right any more because those are greater than 10 anyways.\nIntergalactic Avenger: Exactly. So then when you repeat this and you go for another iteration of it, you're only going to be looking at the left side, right?\nSupersonic Taco: Yeah.\nIntergalactic Avenger: Okay so, does that give you some ideas about how this algorithm might work?\nSupersonic Taco: Yeah it does. Because then in the first time around I'd be iterating through all the numbers to find where it belongs and the second time around I'm only iterating through the left side. So this kind of reminds me a little bit of binary search so the runtime might get a little better than O(n^2) when we do it this way.\nIntergalactic Avenger: Okay\nSupersonic Taco: Alright so, should I start implementing it then?\nIntergalactic Avenger: Yeah let's see what happens.\nSupersonic Taco\nSupersonic Taco: Alright so we're outputting just the number, and this is NthSmallest(). I'm just going to write the code for the first time and we can probably iterate through and make that repeat. So the first time around I'll have to go through the entire array. So if I look at the first one, I'll have to put it in the right spot so then I'll take int index = 0 before this loop. We're going through them and if we say: if(arr[index] > arr[i]) then we need to move it to the right, or swap it. Yeah so if the arr[] at index is greater than the arr[] at i then we need to do some swapping here. So should I just abbreviate it and just write swap here, or do you want me to write the whole swap?\nIntergalactic Avenger: You can just write swap.\nSupersonic Taco: Okay. Well actually I'm going to need to test it later so I might as well just do it now. So then we'll write int temp = arr[i] and then arr[i] = arr[index] and arr[index] = temp. So this switches them around if its greater than, but if it's less than, then essentially we need to keep moving so we don't need to do anything there. But if they're equal to each other then we stop. So we start with index = 0, oh there's a problem here because if it's starting with first one then it'll just stop immediately because it's the same one. So then we'll start at the first one, then index = 0 and the first element is 10, and then it checks to see arr[1] which is 2 and 10 > 2 so then it swaps and now it's 2 and then 10 and then it compares it again, 5: 10 > 5 so it swaps, 6: 6 > 5 so it swaps and it looks at 11. This breaks now because it'll stop since it's greater than, but it needs to continue and look for that 3.\nIntergalactic Avenger: Wait, if those numbers don't equal each other…\nSupersonic Taco: Yeah it wouldn't stop but it still needs to...yeah it would stay there and then it would go through and check against 3 and now that it's less than 3 it'll swap with that one instead and 10 will be where the 3 was and then it'll check against 15, which is greater than so it'll stay there.\nIntergalactic Avenger: So that would actually work for this specific input but think about what would happen if the input was something like this: [10, 2, 5, 6, 11, 3, 0]. First you swap the 10 with the 2 so that's right, and then you swap the 10 with the 5 which is totally right then you swap the 10 with the 6 then you leave that. Then you swap the 3 with the 10, so that's cool, and then you swap the 0 with the 10.\nSupersonic Taco: Yeah that's not right.\nIntergalactic Avenger: Not quite right because when you skipped over the 11 now you have something on the left that is bigger than it should be.\nSupersonic Taco: So then I think maybe we have to move the 11 along with the 10 every time, so maybe we can swap the 11 with whatever's next to it so it keeps moving away.\nIntergalactic Avenger: So you had this point with the 10 and the 0 like this, then what were you going to do? Move up the 0 and the 11?\nSupersonic Taco: No it was like the 10 was here: [2, 5, 6, 10, 11, 3, 0] and then you would check the 10 and the 11, and since the 11 is greater you could swap it away. Yeah you could actually just swap it with the end of the array so this becomes 0 and this becomes 11. And then here we check against the 0 is greater than and it swaps, and then it checks the 10 and the 3 is greater so it swaps.\nIntergalactic Avenger: Okay.\nSupersonic Taco: And that would put it in the right place.\nIntergalactic Avenger: So then presumably if there was another number that was greater than 10 you would swap it so like...we had it here that was like: [2, 5, 6, 10, 11, 3, 15].\nSupersonic Taco: So then it would first compare the 10 and the 11. Okay, now I see what you're saying: if it swaps there it would skip over and it wouldn't work.\nIntergalactic Avenger: But you're definitely on the right track. This is definitely the kind of manipulating that you're going to want to be doing in this kind of array. And you're definitely on the right track with respect to looking at each one of these numbers as you're going up and as long as it's less than then you're keeping it to the left and as long as its greater than you're keeping it to the right. So that's kind of how you're kind of scanning this list of numbers. So you're getting into this one sort of problematic case that when you start to have multiple numbers that are bigger it gets kind of tough with how do you deal with the bookkeeping of where does it go and who can you swap it with.\nSupersonic Taco: Yeah I can think of one way to solve that which would be to create another array and then if it's less than whatever we want we put it into the beginning of the array and hold two counters for where the beginning of the array is and then where the end of the array is and if the number is larger we add it to the end until there's only one spot left and then that's where the 10 has to go.\nIntergalactic Avenger: That's a good way to do it.\nSupersonic Taco: Alright so then I'll try to implement that instead.\nSupersonic Taco\nSupersonic Taco: Okay so then we have now two counters int start = 0 and int end = arr.length and then we loop through and so we know the number that we're looking for I'll put that in as index again and that'll start at 0 this time. So basically if the number that we're looking at right now which is arr[i] is less than the arr[index] then we put it to the right. So then we have this new array that we have to create that's the same length. And then if the arr[i] < arr[index] then it should go in the beginning so we do newArray[start] = arr[index] and start++ to show that we've added an element.\nIntergalactic Avenger: So in this line here you set newArray[start] = arr[index] is it arr[index] or arr[i]?\nSupersonic Taco: Oh sorry, yeah that's completely different thing. And are there going to be duplicates in this array or no?\nIntergalactic Avenger: Let's just say no for now.\nSupersonic Taco: Okay so if there's no duplicates then any other element we look at cannot be the one we're searching for so then we can just do an else here and this basically says that the arr[i] is greater than what we're looking for so it needs to go to the right. So it goes to newArray[end] = arr[i]. And then do end-- and this loop has to end whenever start and end are one apart from each other, because then that means we've found our index. So if end - start == 1 we return start+1. Alright so I think this should work just for the first one to place it in the right spot. So let's try it.\nIntergalactic Avenger: So I see you're returning the number right away but I'm wondering...so this is going to return not the nth smallest, but some smallest that the...you're returning which condition the first element will have gone to.\nSupersonic Taco: Yes, yes. I just wanted to break down the problem\nIntergalactic Avenger: Got it. Okay.\nSupersonic Taco: Okay, in this specific array...Oh I'm missing a return statement.\nIntergalactic Avenger: Here's an interesting question: so when will end - start == 1? When will this be true?\nSupersonic Taco: end - start will be 1 when we've gone through all the elements in the array and now we're looking at that one empty space where the element should go.\nIntergalactic Avenger: Okay, so if that's goign to happen once you're already completed with this array will this ever be see?\nSupersonic Taco: Yeah you're right. We can just recognize those and return start+1.\nIntergalactic Avenger: IndexOfOfBounds?\nSupersonic Taco: Oh end has to be arr.length-1.\nIntergalactic Avenger: Okay. I think actually because you incremented start right here, you don't need to increment start there. I think that's what's going on.\nSupersonic Taco: Alright and let me try it with another m just to make sure. If we deleted one of these, it should become 3 I believe.\nIntergalactic Avenger: Yep.\nSupersonic Taco: Okay, alright.\nIntergalactic Avenger: So now I have the functionality for figuring out the spot where one specific element should go but I have to repeat until I find wherever the element at the mth index is. So essentially this whole start...if start is m then we know that we've found our element.\nSupersonic Taco: Right.\nIntergalactic Avenger: But the thing is this index has to change every time. So I'm thinking maybe we could do this like a binary search where we choose the middle number in each half and we try to put that where it belongs, and if m is greater than the index there then we run it on the right half and if m is less than then we run it on the left half.\nSupersonic Taco: Okay so then we'll start with, instead of 0, index = start + end/2 and then looking at the end….\nIntergalactic Avenger: The index is representative of the index of the number you're comparing everything with. In that sense index represented this number 10 here. Does it get you anything to pick the number in the middle? This number here is the number in the middle, does it really matter that you take index = 0 or index=start+end/2? It's going to be 50-50 right? It's not going to be exactly in the middle there. There's kind of no way to tell how well this number you're picking at random is going to split this array in tWo. I mean you can do that, but I think that starting at index=0 is an totally reasonable way to go because at this point it's just a random array, there's no order. You might as well pick anything and then go from there.\nSupersonic Taco: Yeah, I think that's fine, we can use 0 then. We can actually make this recursive to do a little less work where once we find where the spot that index should go, we'll determine if m is in the right or left and then we will again do it. But actually that might be….yeah I think that might be one way of implementing because we can always keep index at 0 because the array that we're looking at is now a subarray so the index will always be 0. Or a way we could do this is just have index at start and then move through and then kind of keep doing it with a new start and end and that would be another way of doing it. Or we could just make new parameters here for start and end and implement it as recursive.\nIntergalactic Avenger: So I like your recursive idea because it's definitely going to make the code a little simpler. Do you actually need to add more parameters here if you do is as a recursive algorithm?\nSupersonic Taco: No, I don't have to. If I change the array then I don't have to. I was just wondering like that would still take up more memory because technically I would have to somehow cut off the array...We'll just keep it like this for now and turn it into a subarray.\nSupersonic Taco: Okay so then we're using index = 0 and we're returning start which ends up being the index of whatever element is at 0. So what we need to do is determine if m is greater than or less than start. If m is greater than start, we need to redo this on the right side of the array, so we should perform NthSmallest() on...I actually forgot the method for sub-arrays in Java.\nIntergalactic Avenger: I think there's a thing called range? Subset? Fill? I mean, you could just use copy of range if you wanted to.\nSupersonic Taco: I think I got it, there's a code completion on here and it says that it's a method so I'll just use that then. So then the original would be arr[] and I'm assuming the from is inclusive so we'd use start+1 because start we've already looked at and that's the one we've already found and the end would just still be end. And here it would just be the other way around so if we have NthSmallest() then it would be arr[] and instead of start+1 this would be 0 and this would be just start. And else that means that m = start which means we've found the element at the index we want so we just return start.\nIntergalactic Avenger: Okay, so NthSmallest() actually takes two parameters.\nSupersonic Taco: Oh right, so m minus needs to be add in.\nIntergalactic Avenger: Is it m? Because that's relative to the entire…\nSupersonic Taco: Right so if the m that we're looking for is greater than start then it would need to be m-start and if the element that we're looking for is....so if m < start then now we're looking for still m.\nIntergalactic Avenger: Right.\nSupersonic Taco: I'm going to test this now to see if there's any issues. Let's just see if we get 0 as m then we should still get back 10.\nIntergalactic Avenger: We should get 3. So 3 is the smallest one.\nSupersonic Taco: Oh yeah yeah. So it should give back 3.\nIntergalactic Avenger: We need to import ArrayLists? Or is it Arrays. Oh it's a lowercase c\nSupersonic Taco: Oh okay, let's see what happens now? I'm missing a return statement?\nIntergalactic Avenger: You don't have return in these ones. Wait which ones are they looking at?\nIntergalactic Avenger: So 52 and 54, you're calculating it without returning it.\nSupersonic Taco: Got it, alright. Now it's giving me 0, which that's not even in the input array. Oh I returned the index, I never returned the element.\nSupersonic Taco: Oh that's still not right. Alright, let's see.\nIntergalactic Avenger: So definitely the logic looks right, I'm guessing there must be some off by 1 bug. So we already figured out that with this list when you go the first time, start equals...oh wait start was 3 before, so it should have put it in the...So maybe there's some need to do some debugging with some print statements to see...because yeah the logic here is definitely looking solid.\nSupersonic Taco: Maybe here I'll just print out newArray[]. Okay.\nIntergalactic Avenger: Interesting that you have the 10 in there. So in that sense you want your newArray[] to be one element smaller. So if you see what's happening here is you started with index 0, and you're also checking index 0 again. The size is going to be 1 less because you're kind of taking one out then sort of partitioning it after you've taken that one out. So then now that you've reduced the size by a little bit you have to make up for that when you make this copy.\nSupersonic Taco: Well that wouldn't be affected by the newArray[] would it?\nIntergalactic Avenger: Well now the end actually has to be an array of length-2. Because the end is actually the end of newArray[].length-1.\nSupersonic Taco: Right. Well it's the initial array minus one so it's like the ending, but in the newArray[] it's not…\nIntergalactic Avenger: In the new array, you're copying these values over into the newArray[] so the newArray[] has to…\nSupersonic Taco: Yeah, all I had to do was arr[].length here because the end is not actually the end.\nIntergalactic Avenger: I'm looking at line 38 here.\nSupersonic Taco: Oh yeah.\nIntergalactic Avenger: So that end is actually the end of newArray[].length-1, which is the original arr[].length-2.\nSupersonic Taco: Oh okay.\nIntergalactic Avenger: And then in this one, you're not actually copying the original arr[], you want to copy the newArray[] because the original array is totally out of order and the newArray[] is the one...and you'd need the newArray[].length.\nSupersonic Taco: Okay, I get it and newArray[] has to be smaller. Yeah it should be 1 smaller....\nIntergalactic Avenger: Right, so in this one, you just want to copy to newArray[].length.\nSupersonic Taco: Well newArray[].length would include the values above it wouldnt it?\nIntergalactic Avenger: Well newArray[].length is the end of the new array, and you're trying to copy from your position all the way to the end.\nSupersonic Taco: And here there's still something wrong with the size of newArray[].\nIntergalactic Avenger: Wait can you try running again? What's wrong with the size of newArray[]? Line 46. Oh this one here: line 38, you had just changed this.\nSupersonic Taco: So this should be at minus 2?\nIntergalactic Avenger: Or you could just send end underneath the newArray[] or you could move this one up and just say end = newArray[].length-1. Either way it's the same number.\nSupersonic Taco: Oh okay, and this is still arr[].length-1. Okay now 3, okay now that's actually right.\nIntergalactic Avenger: There it is, not bad.\nSupersonic Taco: Now let's try it for some other other numbers too. So if we tried like 1, then that should give us 5. No..\nIntergalactic Avenger: Close. All right yeah, I think there must be some...I'm guessing there's an off by one in either in this m-start or this m here or the zero to start or what. I'm guessing there's a tiny little off by one bug here. So not a big deal, just because we're running a little short on time. So you did all this work and now you're inspecting smaller and smaller pieces of the array as you recurse into it, what is the runtime of this algorithm? So the question is that you did all this work, or there's all this extra code to be careful not to do any more work than you need to so the question is has this actually sped it up or is it still O(nlogn) or is it even greater than O(nlogn).\nSupersonic Taco: Well I think it depends on the case. Say for example this array was sorted in backwards order. Then the first one we'd look at would be the end and then the next one would be the end again. Say our m was 0 then we'd have to keep going through that array over and over and so we'd basically be looking at the entire array...which in the end still comes out to O(n^2). So I think the worst case our algorithm is still O(n^2).\nIntergalactic Avenger: Okay. But what about the average case. What if you randomized...That's sort of a common thing people do with these sort of divide and conquer algorithms is that if there is kind of a poisonous input then you just kind of randomize it to make sure that it's just in this big old jumbled order. So what can we expect sort of on the average case? You're totally right that there is a worst case input that makes it O(n^2), but what can we generally expect this to be in the average case.\nSupersonic Taco: I think this is still O(nlogn) then. Wait actually, in the average case it would be like we're looking at half the array since then it wouldn't be too much or too little. Wait no we're only looking at half, we'd look at 6 then 3 then 1 which is like O(nlogn).\nIntergalactic Avenger: Close. Can you see me typing up above the NthSmallest()? So the first time you run through this in the first iteration you have n elements that you're going over. Then like you said, you break it down by half and the nex time you just go over the n/2 and the next time is n/4 and n/8 et cetera. So what is that going to add up to?\nSupersonic Taco: O(logn)?\nIntergalactic Avenger: Is it?\nSupersonic Taco: Oh no it's just O(n).\nIntergalactic Avenger: Right, exactly.\nSupersonic Taco: Yeah it just becomes O(n)\nIntergalactic Avenger: Yep! So you did it. You got it down from O(nlogn) to O(n). And the trick is when you do the sort you have this halving you do each tie but you keep doing more and more work. Yeah so when you do a sort, you split it in half and then you do both sides, and so even though it's getting smaller and smaller you have more and more of them that you have to deal with, and so the length of this is logn. So like the number of iterations is logn so that's why it becomes O(nlogn). But in your case you don't have this ever increasing coefficient in front of it, so it just adds up to 2n and it's bounded.\nIntergalactic Avenger: So you got it! Very good.\nSupersonic Taco: Alright, thank you. This is a very interesting problem.\nIntergalactic Avenger: I'm glad you liked it. So I'll leave some comments on the platform but just before we go if you have any questions for me about interviewing or anything else I'd be happy to answer them.\nSupersonic Taco: I think I'm all set.\nIntergalactic Avenger: Okay awesome, then you have a good night and good luck with all your future practice rounds.\nSupersonic Taco: Thank you. Have a good night.\nIntergalactic Avenger: Okay. Bye bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/google-java-order-statistic-of-an-unsorted-array",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Java Interview with a LinkedIn Engineer (Reverse Word in String)",
      "content": "Interview Transcript\nIce Gyro: Yeah can you hear me?\nSpace Dragon: Yeah I can hear you now, thank you.\nIce Gyro: Yeah I can hear you. Thanks for the skype invitation.\nSpace Dragon: Let's jump in the question right away. Just one quick question: are you actively interviewing right now? How much are you prepared?\nIce Gyro: I'm not very prepared. I'm not actively interviewing right now. I work as a programer. I'd like to get better. This is my first every time doing interviewing.io\nSpace Dragon: Okay cool. What programming language are you most comfortable with?\nIce Gyro: Java.\nSpace Dragon: Okay cool, I'll just write the question on top here. So you basically have an array and it has something like this….So here is the array: [ 'p', 'e', 'r', 'f', 'e', 'c', 't', ' ', 'm', 'a', 'k', 'e', 's', ' ', 'p', 'r', 'a', 'c', 't', 'i', 'c', 'e' ] If you notice there is a space character and another space character later on as well. We want to convert this array into “practice makes perfect.”\nIce Gyro: So it's moving the letters around is what you want to do.\nSpace Dragon: Yeah, but what's important is that we have an array of characters and spaces in between. This whole list basically has words in reverse order, you know? So this array is basically: “perfect makes practice” and you convert it to “practice makes perfect.”\nIce Gyro: Yeah I think I understand.\nSpace Dragon: And the only thing that is given is that there can be one or more space characters between two words. So you have to make such a string into this, but it has to be in-place, you cannot use any extra anything.\nIce Gyro: Oh, in-place. I was thinking to make a brand new array.\nSpace Dragon: Do it in-place. Maybe before even writing the code we can discuss how you plan to do it?\nIce Gyro: Yeah so. If it was not in-place. I would allocate a brand new array, find where the spaces are and read them with indexOf() and copy the words into the spot. But since I don't have an extra array to work with that makes it a bit more tricky especially because I'm assuming the length of the words are not going to be the same. I'm not counting but the last word of the list might be shorter or longer than the first word in the list.\nSpace Dragon: Exactly. That is true.\nIce Gyro: And when you say swap it in place I'm thinking that I can't use any kind of temporary array. The most I could use is a single character array. So I need to basically move the first letter of the first word and swap it with the first letter of the last word and then the second letter of the first word with the second letter of the last word and so on. And when I do that one of the problems I think might happen is: suppose the first word is quite a bit longer than the last word, then I'm going to have all these blanks and in order to make everything fit, I wonder if I'm going end up sliding over the letters and stuff. So the requirement that it be done in-place seems to make the problem more difficult.\nSpace Dragon: Yeah exactly.\nIce Gyro: Yeah I don't mind, I'm here to get better. And if this first word is very very short. Like if this first word is just “g o,” then I would have to move things over quite a bit before I was able to put in this eight letter word. I would have to swap the first two letters, then go “golly I'm out of space,” and move things over a little bit. One of the things I'm not good at yet is recursive solutions and I kind of think this is perhaps is a thing that a recursive solution would be really good for, but even though I can kind of smell the recursion, I don't think I could do that in the half an hour we have.\nSpace Dragon: Maybe think about this. This is a relatively easier question once you know how to do it. There's something over there if you could think about that. Just think what strategies are there to make the last word in the beginning.\nIce Gyro: So just start with the last word in the beginning, is that it?\nSpace Dragon: So basically you can do some interplay of words here. I mean you can just look at the list and….There's one small thing that will make the whole question solved in that aspect, so a hint would be giving you an answer, but if you just look at the structure of the array, then you can think about how you could iteratively think about how you can get the last word in the beginning and the second last word in the second place and so one.\nIce Gyro: By pasting it down here and reformatting it a little bit I'm hoping I'll see the thing that will help. Not very familiar with the editor but in eclipse this is the trick for telling it not to format. So I wonder if I can take advantage of the letter being the same like: the first letters are both “p”s I don't have to move it, then I swap the e and the r then I swap the r and then swap the f and the c the e and the t the c and the i the c and the t and the space and the e. And then there actually I don't want to swap a space with anything. If I get a space then I just put a space here so we can have multiple spaces around things. So I could try that, but I still don't think that's the answer because if this were a very short word up front….\nSpace Dragon: Let me put it like this: what if the input array was something like this: ['a', ' ', 'b', ' ', 'c']. How would we approach this sort of input?\nIce Gyro: Right so, here I would want to swap a and c. I wonder if what I should do is have something like front is where the a....\nSpace Dragon: Try to build the algorithm first. If you know this sort of input the output would have been like: ['c', ' ', 'b', ' ', 'a'].\nIce Gyro: Right, that's correct.\nSpace Dragon: So for this input we have the reverse of output. This is the reverse of input.\nIce Gyro: So you don't have to be aware of where the words are at, you can just swap things sometimes.\nSpace Dragon: Yeah, if word is just one character, you could simply reverse the whole array. What if word is more than a character? What would happen then?\nIce Gyro: Then instead of reversing the whole thing you would want to treat the sequence of characters as one unit.\nSpace Dragon: Exactly, exactly. One is to do that even if you don't do that, what will happen is something like this: if you had a and say, b together and then we had space c and space d together ['a', 'b', ' ', 'c', ' ', 'd'] this would return something like ['d', ' ', 'c', ' ', 'b', 'a'] right?\nIce Gyro: Yeah, yes yes.\nSpace Dragon: But this is not something you're looking for. d is fine, c is fine, but this word is reversed right?\nIce Gyro: Yeah that should be “'a', 'b'”\nSpace Dragon: Yeah, so how can you fix that then.\nIce Gyro: I could go through and find the individual words and then just reverse them in place. I think I see it now: you reverse the entire string, then you reverse each word in place.\nSpace Dragon: Or: you reverse each word in place, and then reverse the entire string. That is also fine.\nIce Gyro: Very nice, thank you! That's an absolutely delightful problem, I like it very much.\nSpace Dragon: Yeah that's the problem with this: if you start helping the person it's very easy that you just tell the whole solution. Anyways let's start the coding.\nIce Gyro\nIce Gyro: Sure sure sure. So, code it up?\nSpace Dragon: Yeah. Let's do it.\nIce Gyro: Alright, good.\nIce Gyro\nIce Gyro: Alright, so it seems to me that there might be two cases: one where it's an odd number and one where it's an even number but I'm not sure about that. So I'm just going to have front and tail and…\nSpace Dragon: Can you use the function reverseTheWords() in the reverseWholeString()? Oh sorry my bad my bad.\nIce Gyro: Oh no worries, I appreciate your suggestions. You're a very good teaching interviewer, it's very nice.\nSpace Dragon: Okay so that looks okay to me and if I were at my desk in my old friend Eclipse I'd do this inside of some unit tests and have some asserts, but that's not the style of interviews just yet. So that's okay. current is going to just start there, and we're going to say while current spot in the array, word front is equal to the current and word tail is equal to....So if it was a string it would have an indexOf() but since it's a character array it doesn't have an indexOf(). And we're going to look for space, so we find the first space and now we know where the word is, so it's time to reverse the string there. I think I can reuse this reverse the string business by passing in the front and the tail. This version's going to take a start and stop and this one's just going to call the version with start and stop being set to 0 and the length.\nIce Gyro: Yeah.\nSpace Dragon: And then here this front and tail are really the badly named variables, but in the interest of time I'm not going to change their names. Alright so, reverseWholeString(), and once that's done then we need to move current up to the tail plus one and that looks reasonable to me. Then we're going to have this indexOf() guy, and it's going to go and look for a particular character.\nIce Gyro: Maybe one more thing you want to put in indexOf(): from where to start looking for.\nSpace Dragon: Oh that's a great idea, thanks.\nIce Gyro: Okay so, makes lots of sense. Off the top of my head, it looks pretty good. What I would do if I was just doing this for fun to learn is I'd do it as J in it, but since I don't think I have that, I'm just going to output the input array. Is it okay if I run it?\nIce Gyro\nSpace Dragon: Okay yeah we have some errors that you can address. One more thing that you did is while reversing the string….Here is main, from here we go to reverseTheWords(), reverseTheWords() calls reverseWholeString() then reverseTheWords(). Your small string is basically just reverseWholeString() with this input and reverseTheWords() I would create from current is less than this thing. w start is correct your t is the end….So basically on line sixty when you pass reverseWholeString(), maybe you're looking to pass wt minus one.\nIce Gyro: On line 60? Yes yes, you're absolutely correct.\nSpace Dragon: And then the current word increment by plus one and next you enter the loop, here are just wf and wt and in reverseWholeString() while f is less than t, we get the f element out, you're not implementing f here, in this while loop. While loop at 47.\nIce Gyro: Yes, that is a big problem.\nSpace Dragon: And I like the thing you did at line 60 where you wrote -1 before wt. Oh so this is a problem: so if current is length then it breaks right? Here you just need t--? No no, you set temp as the element at f, you put inputArray[f] as inputArray[t], and inputArray[t] is temp now. So at 51, f should go up and t should come down right?\nIce Gyro: Okay, yeah that makes sense.\nSpace Dragon: Yeah exactly. It's fine to me now.\nIce Gyro: Let's just try it.\nSpace Dragon: On line 43, reverseWholeString()….Yeah you also need to pass in the initial word. You have to pass in the array as well.\nIce Gyro: Okay let's try that.\nSpace Dragon: At line 61 there's another error. It cannot find inputArray? inputArray is misspelled here.\nIce Gyro: Okay, I'll fix that.\nSpace Dragon: Yeah I guess it's fine can you run it again?\nIce Gyro: Yeah let's try it. Okay one more: on line 61. And do you think twenty two is the value? Oh I don't think that IndexOutOfBoundsException give you the value.\nSpace Dragon: Probably we are looping something wrong. We are sending f in?\nIce Gyro: Yeah.\nSpace Dragon: So what is f?\nIce Gyro: So little off, way to high. So line 43 is calling it. Ah here we go: like that.\nSpace Dragon: Yeah so the last one is wrong here: “perfect.” So we never entered the loop for the last one right? So we can address that very easily.\nIce Gyro: So here's where we're reversing the individual words in place.\nSpace Dragon: The last word didn't.\nIce Gyro: Oh right here, what if we just say...and instead of wt we're just going to do the length of the inputArray.\nSpace Dragon: Yeah.\nIce Gyro: That was really fun, what a good time.\nSpace Dragon: Yeah someone asked me and never gave me any clue and took me like thirty minutes to think how to do it. Yeah you did good, you created a function and used those functions and that's very nice because that isn't something that comes to mind intuitively. So yeah, it was great work here.\nIce Gyro\nSpace Dragon: And can you tell me the asymptotic bounds on it? What would be the runtime of this?\nIce Gyro: So we loop through the entire array and we do that a couple of times so I think if the size of the input is the length of the character array I think this is a linear time complexity: O(n). And in space complexity I think it's O(1), actually it's really fuzzy in space complexity because you're going to need that input array. So space complexity is either constant O(1), or O(n).\nSpace Dragon: It isn't O(n). It's always constant right because we're not building any extra space anywhere so it will always remain constant, apart from the array that was given to us. That's why it's in-place right. And as the runtime is concerned you inverted a string once, O(n) and plus you invert each word again and that at most is O(n). So O(n) plus O(n) is O(n).\nIce Gyro: Yeah yeah I agree and you're saying in space complexity it's constant O(1).\nSpace Dragon: Yeah because we aren't creating any extra anything at all. Yeah that question you solve in 35 minutes yeah, less than that maybe.\nIce Gyro: Well thanks, thank you very much. This was really fun I'd like to do this again. It was really nice practice.\nSpace Dragon: Which languages do you general program in?\nIce Gyro: I just Java day to day. There's JavaScript in my shop as well. I'd like to learn JavaScript and start interviewing in JavaScript. There's some Scala in my shop, and so I'm taking the Coursera Scala class right now. And I like Ruby on Rails even though I'm working on my first Ruby on Rails project for fun and so I'd like to do Ruby as well. I think Go is very interested but one thing at a time. I think my highest priority is the JavaScript.\nSpace Dragon: And how many years have you been programming?\nIce Gyro: I've been programming for….I think I got my first programming job in 1988.\nSpace Dragon: Oh okay, okay. Your experience is my age.\nIce Gyro: That's alright. I'm used to that kind of thing. I have a lot of co-workers in their twenties and thirties.\nSpace Dragon: So where are you based. Are you based in Bay Area or are you based somewhere else?\nIce Gyro: Well, I kind of like the anonymity so I'll just say I'm based somewhere else is that alright?\nSpace Dragon: Yeah that's fine. I'm just asking because in Bay Area usually don't see people with this much experience, mostly younger people. Yeah I'm surprised. Yeah it was nice working with you.\nIce Gyro: Yeah you too, you too. So my understanding of how this works is we each fill out some feedback and since this is my very first interview I probably won't see your feedback until I interview several more times….\nSpace Dragon: No no, so you will see my feedback when you give me feedback and I give you feedback, then we can see each other's feedback.\nIce Gyro: Oh good. Well I plan to do that and I'd really like to do an interview once a week or something, cause I really do want to get better, and I think gone are the days of just talking to someone for forty minutes and getting a job. I think you have to do the interviews like this.\nSpace Dragon: Yeah yeah.\nIce Gyro: I really like your interviewing style I think you did a great job, and I'll write up the feedback in the next few minutes and maybe we'll talk to each other again sometime.\nSpace Dragon: Great, thank you. See you man, see you. Good luck.\nIce Gyro: Thanks, bye bye.\nSpace Dragon: Yeah, definitely\nIce Gyro: Have a great day! Bye!\nSpace Dragon: Bye!",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/linked-in-java-reverse-word-in-string",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Python Mock Interview",
      "content": "Interview Transcript\nThe Legendary Artichoke: Hello?\nMammoth Avenger: Hello?\nThe Legendary Artichoke: Hey can you hear me?\nMammoth Avenger: Yeah I can hear you pretty well.\nThe Legendary Artichoke: Okay perfect, so why don't you go ahead and pick whatever language you want to work in?\nMammoth Avenger: Okay it's going to be python.\nThe Legendary Artichoke: Okay cool. Alright so let's start with a quick little warm-up. So why don't you write me a function that reverses a string?\nMammoth Avenger: Okay, this is my first time doing interviewing.io so...So like the cheeky python answer is that you can just return a reversed() string for the input.\nThe Legendary Artichoke: Yeah, you could do that...although I'd prefer if you did the reversing yourself.\nMammoth Avenger: I expected. I just changed the variable name there because input is actually a built-in python function. So we could do...start with an empty string. For character in our input we would just prepend it to our output. And I think you can just add characters to a string like that. Should I go ahead and run it?\nThe Legendary Artichoke: Yeah go ahead and run it, let's see if it works.\nMammoth Avenger: Yep that seems to work.\nThe Legendary Artichoke: Yeah that looks like it works.\nMammoth Avenger: I was going to take a look at some edge cases usually as well make sure it handles non-string input like NaN stuff like that which it wouldn't do so great right now.\nThe Legendary Artichoke: I wouldn't worry about non-string inputs, we can assume that if it's not a string that numPy isn't blowing up. So what would be the time and space complexity here of your reverse() function?\nMammoth Avenger: Time is going to be O(n), basically looking at every character once which I don't think you could do better than...you could do it in half the passes if you did it in place and swapped characters but you're still going to be O(n). And space complexity: we're adding another variable output here of the same size, so we could reduce that to O(1) by doing it in-place in the same string. So actually you cannot do that because strings are not mutable.\nThe Legendary Artichoke: Correct, so there's no way to do this in O(1) space in python because you cannot mutate a string. So you are correct on that O(n) is the best you can do on space. But you're actually not correct about the time complexity.\nMammoth Avenger: Okay so...interesting. So I would have thought we looked at every character once.\nThe Legendary Artichoke: So you're correct: you look at every character once, but it's not the only thing you're doing.\nMammoth Avenger: Right, of course, yeah. So this isn't actually O(n) I think correctly that we cannot get better than O(n), so the concatenation right here is probably another O(n) actually because it's adding the whole string that we've created character by character to create a new copy of output.\nThe Legendary Artichoke: Correct: again because strings are immutable.\nMammoth Avenger: So one opportunity we could...yeah python is weird for string based interview questions but we could treat it as a array and swap each character in the correct index as we work our way either forwards or backwards. And we can get the length of the string in O(n) so then we can do it in O(n) that way? Do you want me to code it up?\nThe Legendary Artichoke: Yeah, why don't you go ahead an code that up?\nMammoth Avenger: Okay so treating it as a character array makes sense to you?\nThe Legendary Artichoke: Yeah I think that's probably a better approach.\nMammoth Avenger: So basically as we look at each character we're going to put it into the string starting from the back. So output\\_index = len(x) -1 and then output[output\\_index] = c and output\\_index -= 1. That should do it, I'll just run it see what that does. Okay off by one errors are usually the things that sneak in here so in the case length of x is 4, output\\_index is starting at 3. Right, I think we...yeah so we need to initiate this to make it like an empty array. Let's see if that works. Then we just want to join this back to a string at the end. Okay so I think that should do it, we have O(n) for the length and similar for creating the new output array and we're just doing a single character assignment per loop so I think this whole thing should be O(n) now.\nThe Legendary Artichoke: And what would happen if you just had an empty string?\nMammoth Avenger: I think empty string would return here.\nThe Legendary Artichoke: Okay cool.\nMammoth Avenger: Still this works. Yeah the whole array complication thing is a little not straightforward.\nThe Legendary Artichoke: Okay yeah, that was good. Let me go ahead and give you the meatier problem that we're going to work on. So I want you to write a function and you're function is going to be called find\\_missing() and it's going to take two arguments: the first argument is going to be an array that has some elements in it [4, 12, 9, 5, 6]. You can assume they're all unique to make the problem simpler. And it's going to take a second array that's going to contain the elements in the first array but with one element missing. And what I want this function to return is the missing element which in this case is 5.\nMammoth Avenger: And you said that we can assume they're all unique.\nThe Legendary Artichoke: Yes you can assume they're all unique.\nMammoth Avenger: So my first instinct here is to go to hash tables although we could also use sets in python I believe. So let's see...So I think if we, there's probably a very easy python way to do this where we could actually just make a set of the first array and then I think it's just like subtraction. We can just try that and we can also do it manually as well. Yeah so I'm going to say that's the super easy version which is…missing\\_items = set(full\\_set) - set(partial\\_set). And we assert(len(missing\\_items) == 1) and we return missing\\_items[0].\nThe Legendary Artichoke: I don't think you can index into a set? I take it python has a weird api for sets?\nMammoth Avenger: There's probably a way to pop things out of there but casting to a list is probably the easiest thing for now. So that will work pretty like just putting the work in python. So I can also do it with a hash table?\nThe Legendary Artichoke: No I mean this solution is good. So what would be the time and space complexities of this solution here?\nMammoth Avenger: So converting to a set assume it's going to take linear time because you're basically just populating a hash table I assume it's similar to how python implements it. So if you have m and n as the sizes of the two arrays, so they're both going to be linear and finding the difference should also be a linear operation.\nThe Legendary Artichoke: Why do you say that?\nMammoth Avenger: So at least to do this specific problem if we were doing it ourselves we would basically just be walking through the second array and removing things from the first when they match and because it's a hash table it's constant operation finding and removing them. So I don't know for sure what the full python set difference would take because you might have to walk through both of them but I think it would be linear.\nThe Legendary Artichoke: Yeah I mean let's give python the benefit of the doubt and that it's not doing this in a totally stupid way for set subtraction. So I think you can say pretty safely that this is going to be linear. Cool, and how much space would this take?\nMammoth Avenger: Right so we're going to be creating another full copy of m and n and basically just a hash table version but on that order of size and then the missing\\_items is just going to be one extra thing assuming that our input matches our criteria. So it would on the order of O(m + n) or it might be O(m) + O(n) I don't remember what the specific different between those two are.\nThe Legendary Artichoke: Well there'd be no difference between those two but what is m in this case?\nMammoth Avenger: I guess m and n are only one off so they're basically the same so we're talking linear on the size of either set really.\nThe Legendary Artichoke: Yeah, exactly. Yeah that sounds correct, you are correct. So is there any way you think I could do better than linear time here?\nMammoth Avenger: Let's see....so the only way to do better than linear time would be to not look at every item and the case where that could happen is if we...well missing item is by definition a number in the first set but not in the second. I'm trying to figure out if there's a way we can short circuit the check from looking in either array. So in the case the 5 is missing, so we're looking at the second array we don't know until the very end until we've looked at all the items we don't know for sure that there's no 5 in there. Actually that's not true we could sort it.\nThe Legendary Artichoke: If we sort it, how long would it take to sort?\nMammoth Avenger: Oh but that's O(nlogn), that's longer. So that doesn't work. So if it's not sorted then we can't know for sure until we get to the very last element that there isn't a 5 in the second one and if we go through the first one we can't know looking at any item that it's not in the second set until we've gone through so I'd say you can't do better than linear.\nThe Legendary Artichoke: Yep, you are correct and your argument is sound. There's no way to do better than linear time, because if there's at least one element we haven't looked at, that could be the missing element if we don't have any guarantee on order which we don't. Okay so linear time is the best we can do here, but let's say we want to trade off time for space. I'm very space constrained and I don't have enough memory to create a whole copy of my dataset. How would you lower the amount of space that this solution takes?\nMammoth Avenger: So if we don't care about time at all, one option is we sort both arrays and then you can just walk through them one by one you sort them in place so it takes the same amount of space, walk through them index by index and as soon as you find a difference in two elements you've found the missing item.\nThe Legendary Artichoke: Yeah, and what sorting algorithm would you use for that?\nMammoth Avenger: Just, we don't have any expectation given on the the specific kind of data that we're working with so probably just go with Quicksort or general data sanity, I think that's what python uses by default to sort data or it might be some slightly modified version of Quicksort.\nThe Legendary Artichoke: Yeah I'm pretty sure it uses a modified Quicksort and what would the be the space complexity if we used Quicksort?\nMammoth Avenger: My sorting algorithms are a little bit rusty but I did forget that it can add extra space complexity as well so that might be an issue. But I think that Quicksort is a variant of Mergesort I believe which picks a pivot and is just swapping items around. Oh but it's recursive, so it's probably bad for the space complexity. So if we really didn't care about the time complexity we could just do a Bubble sort or something that doesn't take any extra space but I think there are also better sorts that don't take any extra space.\nThe Legendary Artichoke: Yeah, you are correct. In particular there are a number of sorts that are O(nlogn) time while O(1) space such as Heapsort which you may vaguely remember.\nMammoth Avenger: Yep, okay.\nThe Legendary Artichoke: So if you use a sort like Heapsort, you could get it in O(1) space. Quicksort would be O(logn) for the reason you just mentioned which is because its recursive we need stack writes. But yeah okay you could go look up a sort that's O(1) space and if you needed to bite that bullet you could get O(nlogn) time and O(1) space. So that's good it gives us different ways to approach this problem. Let's say we need O(n) time, like O(nlogn) is not the trade off I'm willing to make. Do you think there's a way we can improve the space from O(n) to being less than O(n)?\nMammoth Avenger: This require the constraints to be fairly specific but if we're guaranteed that they're integers and they're all unique then we can just sum up the first list and subtract the sum of the second list and that should give us the missing item? And that's a very simply algorithm and that would be linear time and constant space.\nThe Legendary Artichoke: That would work. Why would you say it's constant space?\nMammoth Avenger: Because we're just doing two sums and then a subtraction?\nThe Legendary Artichoke: That's true but that doesn't guarantee that it's constant space. Do you know why?\nMammoth Avenger: I guess because we don't know how big the sum is going to be?\nThe Legendary Artichoke: Correct.\nMammoth Avenger: Gotcha, so if we're dealing with very large integers.\nThe Legendary Artichoke: Right if we're dealing with very large integers or just sufficiently many integers then clearly the size of the sum we're going to store is, in some way, going to scale with the size of the input right?\nMammoth Avenger: Yeah, is this one of the things where you could use an XOR?\nThe Legendary Artichoke: How would you use an XOR? How would you do that?\nMammoth Avenger: I think if you just XOR a series of integers and then….how does this work? I'm just going to..is it okay if I just look up what the python XOR function is and just play with it in the console for a bit?\nThe Legendary Artichoke: Yeah it's the ^, I'm fairly certain.\nMammoth Avenger: So we do 4 ^ 12, then I think it's like if you XOR with the same number again it gets you back to….basically if you have any number and you XOR it with an integer and you XOR with that integer again it undoes the effect. Yeah which is like topological because it's just flipping the bit. So I believe we would just XOR all of the integers in both lists. It feels kind of strange because you're treating the two lists differently but I believe the end result should end up with 5, and that one is actually constant space because it's only an integer at any point.\nThe Legendary Artichoke: Yeah, that sounds perfect, why don't you go ahead and write that up real quick?\nMammoth Avenger: Alright. I don't know what you would call this but XOR\\_sum seems close enough. That's it.\nThe Legendary Artichoke: Yeah let's give that a quick run and make sure that works.\nMammoth Avenger: That looks good. Don't know if that would handle negative numbers. Interesting…\nThe Legendary Artichoke: No it does because negative numbers, because the XOR is going to respect the negative bit.\nMammoth Avenger: You could use this on any binary datatype like find a missing object from a list of binary objects.\nThe Legendary Artichoke: Yeah as long as you only have one of the them right? Otherwise you would just get the XOR as the two objects. But yeah you pretty much got it, it was perfect. I don't have anything else for you so: well done.\nMammoth Avenger: Thank you. How does this work from here? Do you have a feedback form afterwards, or do we just chat about it for a bit?\nThe Legendary Artichoke: It's up to you we can chat about it if you want. We both get feedback forms and we send them to each other and then we can mutually read the feedback. If you have any questions I'm happy to answer them.\nMammoth Avenger: Yeah I'm just back on the job scene after a couple years of running my own startup so it's been a long time since I've done technical interviews any constructive criticism or things that I could do better or work on would be appreciated.\nThe Legendary Artichoke: Yeah my feedback is honestly you pretty much knocked this one out of the park and you're probably the fastest person I've seen solve this and get to the optimal solution. And you're coding is clearly strong. You're familiar with python you're pretty comfortable I can tell. The only thing that was a slight irk was calling variables x like that's just a peeve of mine, but different interviewers aren't going to care so that's totally and idiosyncrasy that doesn't matter in the long run.\nMammoth Avenger: I always struggle with variable naming in interview questions, I always seem to be vary ambiguous quantities. Any suggestions on what to call a variable for like a string input for like the reverse() function for example?\nThe Legendary Artichoke: Usually I just call it str for string. As long as there's nothing descriptive of it other than its datatype then I would just name it by its datatype. But again this is not nearly egregious enough for me to mark you down for it. Like I've done interviews where people are writing a fairly complicated function and they're calling things x and y and g and things like that or they call a function f() you know, that sort of thing. So honestly calling the input to a reverse function x is not enough of a violation that I care.\nMammoth Avenger: Cool\nThe Legendary Artichoke: Overall I'd say you solved this strongly.\nMammoth Avenger: Alright, thank you very much.\nThe Legendary Artichoke: Cool yeah, no problem take care.\nMammoth Avenger: You too, bye.\nThe Legendary Artichoke: Bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/airbnb-python-missing-item-list-difference",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Golang Mock Interview (Microsoft Engineer)",
      "content": "Interview Transcript\nIndelible Raven: Can you hear me?\nMassively Parallel Llama: Hi I can hear you, I'm on the phone.\nIndelible Raven: Awesome, yeah it's been having problems all day, for a while. So have you done this before?\nMassively Parallel Llama: I have done one before, yes.\nIndelible Raven: On here?\nMassively Parallel Llama: On here, yeah.\nIndelible Raven: Awesome, I do it just a little bit different. I do the same interview, like 35 minutes. But also at the end I can give you some feedback verbally as well. I do that with most people. So if you want to hear it just let me know. Other than that, let's see where you're at in your career.\nMassively Parallel Llama: In my career I'm about 2 or 3 years in experience.\nIndelible Raven: Alright, so I used to work at Google, but I don't know Go, and I feel bad for that.\nMassively Parallel Llama: That's okay, it's a language you'll be able to understand.\nIndelible Raven: No it's just like: if you work at Google, you really should know Go. It's like their language. Awesome well I'll just start you out with something, and ideally we'll get into a second part of the same question, so just keep that in mind.\nMassively Parallel Llama\nIndelible Raven: I'm going to give you a bunch of points on a 2 dimensional graph. It can either give its own class or do a pair. So it would just be [x,y]. It would be a list. Point[] of points, where it's something like [[1,2], [3,-1], [2,1], [2,3]], right? And then I'll give you a point, the vertex, so in this case it's not going to be [0,0], it's going to be [2,2] or anything I give. And I'm going to give you int k = 2. So what I want you to do is take the list of points on the graph and find the closest ones that are around the vertex and I want you to return the k closest.\nMassively Parallel Llama: Okay so let me just reiterate the problem so I have an understanding of it. You're going to give me a list of [x,y] coordinates and you'll give me a vertex, some ideal [x,y] coordinate and you need me to return the k closest [x,y] coordinate in the original point[].\nIndelible Raven: Yes, to the vertex\nMassively Parallel Llama: Okay, what would you define as the closet?\nIndelible Raven: Distance wise, so kind of the general Euclidean distance.\nMassively Parallel Llama: Cool. And these points, they're not in any sorted order are they?\nIndelible Raven: No.\nMassively Parallel Llama: No. Okay. So, my first intuition to this problem is to go over the [x,y] coordinates and for every single [x,y] coordinate compute the distance to the vertex and store that in some sort of...via min heap. And then once we have all of the elements stored in the min heap, we can pop out the top k from the heap and that will be the answer.\nIndelible Raven: Okay.\nMassively Parallel Llama: Does that make sense?\nIndelible Raven: Yeah that sounds reasonable.\nMassively Parallel Llama\nMassively Parallel Llama: So let me try to code this up. At the same time, before I start, maybe we can just discuss time complexity. Before I start coding maybe I'll think of something better? So the first step is to compute all distances to the vertex and that is going to take O(n) because we have to visit every single element and once we computed, we're pushing it onto the heap. Now when you insert something into a heap, we need to make sure that the heap....so inserting into a heap is actually constant, we don't need to worry about that yet. And then we need to perform k pops from the heap, and when you do a pop from the heap we need to figure out the next minimum element from the heap, so that's going to be O(k), because we need to pop k times and the bubble up operation can be performed in O(klog(n)) because heap has n elements. Yeah so that's one solution so if we just look at the worst case it's still O(n), that's out dominant time complexity right there. And of course we'll have to use space, our space is going to be our heap which is also O(n). Yeah so we could have another solution if we didn't have access to space, we just had to do it without using any extra memory, you could just sort of do a O(n)....that would be O(n^2) solution or….I can't think of a way where….\nIndelible Raven: So you're worried about space right?\nMassively Parallel Llama: Yes.\nIndelible Raven: How much space are you using?\nMassively Parallel Llama: O(n)\nIndelible Raven: Right, so how many points do I want to return?\nMassively Parallel Llama: Oh yes, so it could just be k. We need to only keep a heap of size k, everything else larger than k we can just throw out.\nIndelible Raven: Yeah, so how does that change the complexity overall?\nMassively Parallel Llama: Space complexity goes to O(k). And time complexity becomes O(klog(k)) for the pop.\nIndelible Raven: I'm not entirely sure your complexity is right. It is for pop, but not the push. Every time you insert it needs to keep track of something which means it re-heapifies, that's O(log(n)) so it should be O(nlog(k)).\nMassively Parallel Llama: Right, so if you already have a heap and you're pushing onto a heap you have to figure out what the next minimum element is so you would have to heapify. So yes this would also be O(klog(k)). Every time you're inserting or removing from the heap you have to find the next minimum so it would both be O(klog(k)).\nIndelible Raven: No it's actually O(log(k)) but's it's n times that.\nMassively Parallel Llama: Right, so for the push right, the push will be...we're going to do that n times and it's O(log(k)) right. But for pop we don't actually need to do anything here because we already have the k minimum elements and we can just return so this just goes away. So if that's the case our dominant time complexity will be the push.\nIndelible Raven: Try it out\nMassively Parallel Llama\nMassively Parallel Llama: Sure let's try it out. Okay so let's call this...for the points I'm just going to define a structure...it's going to have 2 elements and our input is going to be Points and we're also going to be given…\nIndelible Raven: Wait really, it works right to left in this case? That's weird\nMassively Parallel Llama: Yeah, it takes a while. And let's say we're going to return a list of a []points of of k closest points. So I guess while I was checking this another obvious way of doing this was compute all distances and just sort and once you sort you have your k closest element sorted already. I guess another clarification: would you like the original point or do you just want the distance?\nIndelible Raven: I don't want the vertex in the output but if there is a point on the vertex then that could be returned. So if that []point had [2,2] in it then yes.\nMassively Parallel Llama: Okay so just a special case if it's exactly the vertex then you want to return the point otherwise the distances is fine?\nIndelible Raven: No I want all the points.\nMassively Parallel Llama: Oh okay, you want all the points.\nIndelible Raven: Obviously a point on the vertex would be 0 distance so it would be the closest.\nMassively Parallel Llama: No I was wondering if the return should just be list of distances or the actual points.\nIndelible Raven: No, points.\nMassively Parallel Llama: Okay. So if that's the case I'm just going to add an extra element to our point struct and this could definitely be an option element that just has the distance.\nIndelible Raven: Actually I want you to leave the point class alone.\nMassively Parallel Llama: Okay let's just figure it out as we move forward then. How we can figure out which point to return after we have our heap. Alright let's just figure out how to compute the distances first, we're going to go through all the points. And for each point we're going to want to calculate the distance. So let's just assume we have a function that can do that for us. Once we have the distance we want to push it on to some sort of heap. We need some sort of heap, in Go, if you want to use a heap you have to use a priority queue and you have to write out the interface for it, so is it okay if I assume that I have a heap?\nIndelible Raven: No, I want to see the priority queue. It's that way in most languages.\nMassively Parallel Llama: You have to implement all of the interfaces for it.\nIndelible Raven: What do you mean?\nMassively Parallel Llama: The priority queue is offered as an interface and you have to implement the pop and the push based on the struct and how you want to compare each element on the heap.\nIndelible Raven: That's interesting. Then assume you can, but come up with...I don't know if Go has something like a comparative function, like a lambda function for it.\nMassively Parallel Llama: We don't really need a priority queue for this, a priority queue is more involved than a heap. We could write one.\nIndelible Raven: Just assume you have it.\nMassively Parallel Llama: So we have to initialize it somehow, and once we have that we can actually give it a size. We only want k elements in the heap and over here we can just do heap.push()\nIndelible Raven: No, I want you to handle the k yourself.\nMassively Parallel Llama: You want me to handle the k myself?\nIndelible Raven: Like I don't want it to limit the k, I want you to do that.\nMassively Parallel Llama: Okay. So if that's the case we need to figure out what the size of the heap is, assuming we can get the size of the heap by looking at the length of it. If this is the case then we need to find the element that's the largest in the heap.\nIndelible Raven: So is there a data structure that will let you find it in O(1)?\nMassively Parallel Llama: That will let you find the largest?\nIndelible Raven: Data structure or algorithm.\nMassively Parallel Llama: So let's assume our heap is represented as an array. If it is, we can actually keep track of each index in a map.\nIndelible Raven: I don't want to do it that way. Assume your heap works with push and pop and stuff, think about what the heap really is. What kind of heap is this?\nMassively Parallel Llama: It's a min heap? Actually it doesn't have to be a min heap, since we're only storing the k element that we're going to return, it could actually be a max heap and if it's a max heap we can just find the largest element.\nIndelible Raven: There you go.\nMassively Parallel Llama: Yeah so if our heap is a size k, then what we need to do is a heap.pop() and that will get rid the largest element and then we can just push()….even if it is full and we turn directly to a pop(). So let's assume we have some sort of peek() function so we can see what the largest element is and if its larger than our current distance, then only we need to do a heap.pop() and we need to push() our new element. So that's sort of our special case and if it's not then we don't have to worry about the dist, we can just continue and we just need to have an else here to take care of the case when our heap isn't full yet to go ahead and just push.\nIndelible Raven: So your heap is just distances, right?\nMassively Parallel Llama: Right now yes, it's just the distances.\nIndelible Raven: So how are you going to get the k closest out of that?\nMassively Parallel Llama: Right so I think it's best to define the new object or struct heapNode, and in this heapNode we can actually have a Dist and we can have a Point and for our comparative function for our heap, we don't care about the point we're just worried about the distance when we do the pop() and push(). Which means we just directly insert the distance and we should put it in this struct here. Okay so now that we have our heap, we should have k elements and I guess how you kind of write a while loop in Go, there's no while loops so you just write a for instead. So while our length of heap is not equal to 0, we keep pop() to our ans, and storing the point and returning it. And you mentioned a little bit earlier in the conversation that you want the vertex to be the first element in our answer?\nIndelible Raven: No, I literally just want the k closest.\nMassively Parallel Llama: Cool so we just append this to our list, and we don't care about the distances anymore we just want the point?\nIndelible Raven: Just the point.\nMassively Parallel Llama: And after this is done we'll have the k element and we can return our answer.\nIndelible Raven: Okay, there's more to this but I want to stop here and I want to take this to a different approach. This obviously works for k if I give you a list of points. What if my list is roughly a petabyte worth of points?\nMassively Parallel Llama: So our list of points is huge? If that's the case can we assume that the list of points coming in to program or function is element by element and not just as a giant list?\nIndelible Raven: You could. That would work.\nMassively Parallel Llama: That's a big assumption right. But this function would potentially work.\nIndelible Raven: I mean it generally would work, but it's a petabyte of points. I know Go is suppose to be fast but how long would that take?\nMassively Parallel Llama: So if its a petabyte of points just computing of every distance in our list is going to take some time. So if our point array is too big, we can just throw more resources at it and divide up the point[] to a more manageable chunks and send it to multiple machines I guess. And after they've all figured out their k lowest, we can do a merge operation to find out the k lowest afterwards.\nIndelible Raven: Sorry could you repeat that?\nMassively Parallel Llama: Yeah so my first thought is if it's too many points we divide up the points to manageable chunks and we divide up the work to multiple machines that hey here's a set of points, find the k closest and once every machine has done its work we have a merge operation to find what the actual k closest is at the end. That's my initial thought process if the points[] is too big.\nIndelible Raven: I mean that makes sense but what is that?\nMassively Parallel Llama: What is that? Like just a term for it? It kind of reminds of MapReduce a little bit?\nIndelible Raven: There you go, MapReduce.\nMassively Parallel Llama: Yeah you have a bunch of workers that are parsing various chunks and combining it afterwards once their done.\nIndelible Raven: So that's kind of what I'm looking for and how you would set up the MapReduce and stuff like that.\nMassively Parallel Llama\nIndelible Raven: Let's stop here that way I can give you your feedback if you want.\nMassively Parallel Llama: Sure sure.\nIndelible Raven: Usually I evaluate people's ability to code, especially when it comes to style guide. But truth be told I still don't really know how Go works or what style guide would look like. But based on general style guide it looks good. Still confusing but….\nMassively Parallel Llama: Just to touch on Go a bit. Go actually forces you to follow style. If you look at every codebase it'll look identical no sort of tabs versus spaces. So for example if I had line 48 on line 49 this actually won't compile. So it has to look like this, Go sort of forces the same sort of standards on everybody.\nIndelible Raven: I really wish you got those semicolons, drives me nuts that there aren't semicolons.\nMassively Parallel Llama: I think in Go they are optional, you can use them if you want.\nIndelible Raven: I really wish you had your edge cases. Say hey, what happens when k is less than 0 or if k is greater than the number of points. And actually wrote out test cases and error checking in the code. That's something I look for. Your algorithm design is pretty good, you're able to come up with a semi-optimal solution and I gave you a very very subtle hint and you were able to come up with a much more optimal solution as a result. I would have liked to see you go faster, time is not your solution in an interview. Ideally when we come up with these questions we plan for us to solve it in 15 minutes and since we know these questions it's going to take longer for the person but I still would have liked to see if go a little bit faster that way we could spend a little more time talking about MapReduce and what the Map would look like and how you would Reduce it. So I used to work at Google and I work at Microsoft. There's a different mentally when you work with an excessive amount of data. You don't think about how it works in one program you don't think about how it works linearly. Your brain automatically switches to: how do I spread this out to thousands of machines. I wish you went there first, instead of saying: hey we're just going to use a datastream and it'll work perfectly fine. When I switch to that, when I come up with something new the obvious answer is not the right answer. It may use some of the same code but it's not going to use the exact same code, so your first thought should not have been that. I kind of wish you started talking about MapReduce instead of the general concept of one. It kind of gives me the impression that you never really use one right?\nMassively Parallel Llama: I honestly haven't.\nIndelible Raven: The reason I bring this up is, at the two companies I worked for, it's big there. If you're interviewing for me there, I kind of expect that. If you're not interviewing there then that feedback is kind of pointless but take it as your want. Overall I think you did well, I would have liked to see you go faster and talk a little more but I think you did well. Took you a little while to figure out to use a max heap for sure. It's really all I have, you did pretty good. Do you have any questions?\nMassively Parallel Llama: In terms of coding fluency, I need to just solve more problems and get faster before I actually go into the real interviews.\nIndelible Raven: Not even faster the speed at which you're coding is fine. You need to come up with a way to make it fluid, make one step into the next into next to the end. I know that doesn't make sense in real life coding, but it has to be a very fluid operation and if it is, you're going to go fast. You don't need to speed up how you're coding, you just need to speed up your fluidity.\nMassively Parallel Llama: Yeah that definitely makes sense.\nIndelible Raven: Yeah so you talked a little about the scale. Do you think, when we started off with the problem, maybe I should have asked you how big the points array could be?\nMassively Parallel Llama: I would have told you it would have fit in an array. I wanted this answer first because this teaches me how well you code. MapReduce and this are two different things. So you would have still ended up with this but then I would have shifted to MapReduce. What I wanted to see was your mindset shift once you knew what the data was. It's always good to ask how much data there is, but I would have not told you a petabyte at the beginning.\nIndelible Raven: Yeah I don't think I have anything. This was great. This was a great experience looking back.\nMassively Parallel Llama: Thanks for interviewing with me. I think you did well. I would have definitely moved you on-site, I might have even said yes to a hire. So I have feedback, some is negative but that's just other stuff you can improve on.\nIndelible Raven: I'm going to jump off, write your feedback. It's probably not going to be much because you did well. Just going to hit on the speed part. That's all I have so I wish you the best in the future and good luck!\nMassively Parallel Llama: Yeah thanks man, thanks a lot. Bye\nIndelible Raven: Bye.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/mocks/microsoft-go-vertex-distance-order-statistic",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Apple Interviews + Questions",
      "content": "Apple’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Apple? Do anonymous mock interviews with real Apple interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Apple’s hiring process, evaluation criteria, and interview experience.\nHumans in groups act out a chosen metaphor; Apple isn’t a sports team. They’re an army. Their army is made up of people obsessed with making great products. And they look to hire people who’ve embedded Apple products into their lives. Armies reward loyalty more than sports teams. Apple also has the longest tenured employees in FAANG (we're including Microsoft with FAANG for the purposes of this guide).\nApple is decentralized and lets candidates interview with different teams concurrently; if you want to maximize your odds interview with as many teams as you have the appetite for.\n“I interviewed with like 12 teams. I got 2 offers. Along the way, I told one of the Apple recruiter’s I was interviewing for another Apple team and they shrugged it off; they didn’t care.”\nApple’s interview process is more like what you might see at a startup than any other FAANG – from assigning which questions to ask to interviewer training to how hiring decisions get made. Significant inter-team variance is the norm, with each team essentially acting like a startup that’s coming up with its own way of conducting interviews.\nAt Apple, there’s no formal interviewer training. It’s very ad hoc. Every team is different. There is literally no process. What each of the teams does is rely on one of their very senior engineers or someone very experienced. Apple has a lot of people with long tenures, like 15 years. One of my colleagues had been there for 22 years. At Apple, the more senior you get the more the team trusts you to come up with your own questions. So what the interviewers at Apple typically do: you come up with a question that's not online, and you make sure it’s relevant to what your team is doing. Then you pitch it to your manager or tech lead. Then you run with it.\n“One thing not enough candidates know about is this: there’s no such thing as an Apple interview. You apply for a team. Not the company. When people ask me “How to prepare for an Apple interview?” I say ask the recruiter. Because they usually know what types of questions are asked. The recruiter spends 30 minutes or an hour per debrief where engineers are talking about the details about the code. So if the recruiter is paying attention or is at least a little bit technical, they should have a clue whether it’s LeetCode-style questions or embedded style questions. So ask your Apple recruiter a forced-choice question like, ‘Is this interview more X or more Y?’”\n“I was one of the people to come up with a take-home assignment for candidates. Which was my favorite part of the process at Apple. We were hiring people for full-stack but not just any full-stack – we wanted people who were coding in Python on the back-end and a particular framework on the front-end. We cooked up a take-home which was a scaled down version of what they’d be doing on the job: an internal tool built in those exact technologies. We gave them that take home and had them work on it for a week. Then we discussed it at the onsite where we’d live-debug it and talk about architecture. I really liked this ‘Try before you buy’ style process. Because Apple really wants you to be productive in week 2, if not at the end of week 1.”\nApple is the most likely to shock you; they’re more likely to ask you something you didn’t prepare for. Out of all the FAANGs, they’re the ones you can expect to do something unexpected, and some of their tactics can seem mercenary. Apple is the only FAANG which sometimes has a process to cut interviews short if the candidate clearly isn’t meeting the bar – if you don't perform above the bar for the first half of the interview, they’ll cancel the rest.\n“If by the fourth round, the hiring manager has gotten consistent feedback that doesn’t meet the bar, then they’d end the onsite early and reject the candidate.”\nApple is not results or process oriented. They’re motivation oriented. In other words, they care more about the “Why” than the “What” or the “How”, and as such, they value behavioral interviews more than coding.\nApple employees are obsessed with privacy. It’s not just marketing lip service. When asked if “privacy” is a buzzword at Apple, our interviewers said…\n“Privacy isn't just a buzzword. We are obsessed with it. To drive that part home. Because it’s so important. And as I mentioned, I was a part of a group focused on gathering user data - users here being Apple internal employees – to inform future products.\nEven at Apple, when we’re just getting data from internal employees, we anonymized the data. Just to practice what we preach. Privacy is huge. Another example to illustrate that is that people get fired for torrenting music.”\n“Unless you’re interviewing for a security role, very rarely. Technical people at Apple are hired to do what they do best. They have a whole army of compliance folks and lawyers to take care of that stuff. They also have an internal police force called “InfoSec”, which is the team which takes care of the secrecy stuff. Engineers are needed to do what they were hired to do: engineering.”\nPlease see the section above called “A note about recruiter calls” for what to expect. We do encourage you to ask your recruiter what to expect for the rest of the process because as you’ll see, there is a lot of variance from team to team.\n“Ask your Apple recruiter forced choice questions with two options, such as, ‘Is this coding round more of a typical LeetCode round, or more of a domain-specific open ended deep dive into a specific technology?’”\nLike everything else at Apple, the format and technical questions presented in Apple phone screens can vary a ton. Verify this by asking your recruiter!\nTechnical phone screens are coding interviews that range from 30 minutes to an hour. This tech interview may be between you and a single interviewer or sometimes a panel of interviewers. It may even be a hiring manager screen with a mix of behavioral questions and coding.\nIn any case, the general format is a shared coding environment where the interviewer(s) can assess your ability to utilize basic data structures and algorithms concepts. Being able to provide a solution for coding questions and quickly analyze the runtime complexity of your solution are key skills to have going into this interview.\nThe tooling used in Apple’s technical interview rounds depends on the team you’re interviewing with, but we’ve heard that some teams use CoderPad.\nSome teams give candidates a take-home assignment. They can give this around the same time they schedule a phone screen. The hiring manager is usually the person to decide whether or not candidates get one.\nThere will be roughly six to eight in-person rounds of interviews, each of which will be with your future teammates. Each round will have least one, or possibly two, interviewers.\nNote that an onsite loop with one team at Apple will look very different than an onsite loop with another.\nInterviewers can ask whatever behavioral, coding, or system design questions they want; there is no standardization for Apple interview questions. However, before an interview loop takes place, some teams will do a quick, informal assignment of what kinds of questions each interviewer is supposed to ask so that they don’t all end up asking the same things.\nMoreover, Apple interviewers are untrained, and as soon as a senior engineer is hired they can start conducting interviews.\nApple’s unpredictable nature makes it so some of their interview rounds can’t be categorized into behavioral, coding, or system design. Is a philosophical question about products a behavioral question? Not really. But they might ask one in a behavioral round. Are rapid fire infrastructure-focused open-ended trivia questions more system design or coding? It depends.\nFor example, here’s how one Apple interviewer describes the behind-the-scenes top-down directive before an upcoming onsite. “Go find a question that would be a good one to ask for our team.” That interviewer then ran it up the chain to an engineer above them. Then, that question immediately got asked in the next interview.\nAt Apple, each interview loop is specific to the needs of individual hiring managers – there is no canonical “Apple interview”, and everything is “made to order” for each specific team. That makes it difficult for candidates to prepare.\nSome teams at Apple prefer practical rounds. Sometimes, they’ll have you write a program on your own laptop and IDE. Other times, they’ll spend the whole round deep diving into a specific technology/use case that’s relevant for their team. For example, a team that wrote in Java and did a lot of work with concurrency had a whole round focused on concurrency in Java!\nOther teams do medium-ish LeetCode-style questions.\nAt the end of the day, these interviews vary so widely it’s hard to give a specific directive, other than: ask your recruiter. For senior and above candidates, it’s more about demonstrating competence rather than needing to ace the question.\nFor everything you need to prepare for Apple’s coding interview, check out the section called \"Apple coding interview preparation resources\" below.\nApple interviewers tend to ask questions relevant to a specific team’s work. For instance, a team focused on building web services will tend to ask questions about that, while front-end teams may ask UI-related questions. It may be good to try to get a feel for the day-to-day work from the recruiter/hiring manager, as the job descriptions are not always the most helpful (remember: privacy!).\nIn system design rounds, Apple interviewers love to hear about reliability. If you don’t know what else to talk about, dig into reliability.\nApple’s most important round is usually behavioral or system design. Behavioral rounds are more important than coding rounds.\n“In behavioral, you gotta be a rockstar. You gotta be a leader. If you’re abrasive, or if you’re not a cultural fit, how are you going to lead the juniors? And system design is going to weigh a little more than behavioral. If you can’t code or if you’re a little rusty –if you’re good at system design and behavioral–we’ll forgive the subpar coding rounds.”\nAn interesting paradox at Apple is: they highly value behavioral rounds but they don’t have a standardized way to assess candidates in those interviews\n“Towards the end of my career at Apple, we had a huge need for mobile developers. People who were able to do iOS apps. I was part of an R&D team. We mainly built web products in the beginning, but towards the end of my career we started doing more mobile stuff. We didn't want to hire someone who could only do mobile. We wanted someone who would be half as good at mobile stuff and half as good at web stuff, so they could plug themselves in anywhere.\nIf the interview process was standardized across the whole company - you can imagine how hard that would be to test specifically for the niche skill set we needed. Within two days we cooked up a whole new homework assignment just for the ios candidates, we cooked up a whole new set of interview questions. We kept the behavioral part the same. But the technical part - we flipped it over just like that. And it was really good. We changed the way we graded, we were able to filter candidates based on the new set of questions. It was just fast. We didn't get any pushback from HR. We didn't have to work with compliance. We just did it. Really fast. Really nimble.”\nBecause Apple doesn’t standardize their interviews, they’re particularly prone to bias. Sometimes the top down guidance to Apple interviewers is something like: “In the behavioral round, just see if you like them. See if you’d like to get a beer with them.”\n“[Interviews are never standardized.] And i’ll tell you why. Apple is a very secretive company. Everything is on a need to know basis. Also, it's a hugely political place. It was good for me because I understood the game. I didn’t blame the players I played the game. For those who understand the intricacies of politics, and simply accept the fact that it will happen when you have all Type-A people being paid a tremendous amount of money to do shitty little things, it's bound to happen. You have to accept it or you’re not going to play the game. Everything at Apple is very siloed. Even when it comes down to the cost center. Everything is super independent of one another. That's actually one of the strengths and weaknesses of Apple. We double effort for sure. But that doesn't matter to Tim Cook. They have billions of dollars to afford this – not a problem. I also really liked how it was siloed because teams and their priorities change, leadership changes, a lot of things change. Being able to decouple from the greater company enabled them to become one of the biggest, if not the biggest tech company in the world.”\nEven if rounds aren’t standardized, you will definitely be asked “Why Apple?”, and your answer needs to be on point. Some interviewers reject candidates solely for not having a good answer to this question. “Why Apple?” isn’t always a single question; they can spread this out into multiple questions and drill down on this for a good portion of a behavioral round. You can also expect other motivation-based (or “why”) questions.\n“A common red flag is giving generic answers to the ‘Why Apple?’ questions. If I didn't feel their passion or if they’re just treating Apple as another job, that’s usually a red flag for me regardless of their technical competence. They really have to somehow convince me – and this is an emotional response they have to bring out of me – they really have to convince me they really want to work at Apple, they really want to roll up their sleeves, and they really believe in our values: delighting the customer, sweating the details. Making awesome products… We only care about that. We don't care about anything else. That emotional response has to be drawn from me and if they don’t then I’m likely to say, ‘They were good but meh.’”\n“I can tell you about a great answer one candidate had for ‘Why Apple?”. He said something like… His wife and him were university students dating across two continents. This person said they shared a recent feature – I think it was like when you facetime and you can watch video in sync – he shared how that changed his life. His wife and him went through the whole international relationship because of that. That significantly helped their relationship.”\nApple wants to hire candidates whose lives have integrated with the Apple products. And the reverse is true too. It's a fatal flaw to say, “I've never used an iPhone or a Macbook or an iPad” because those people clearly haven’t integrated Apple products deeply in their lives.\nApple knows what they like, and they like their products! That doesn’t mean all you have to do is gush about the products to pass the behavioral round. It means you have to tell a genuine story which connects you and Apple products or services. Ideally, a story they will remember.\nAnother behavioral factor debated among Apple interviewers is whether or not they agree with the idea that Apple is “cult-ish.”\n“Apple cares most about the ‘Why’. You see that rooted deeply in every apple person's DNA. ‘Why Apple?’ Right? I guess this is where people get this notion of Apple being a ‘cult-ish’ company. Much like Tesla, actually. They have a huge customer following, but you also see the same pattern with their employees. Actually, I totally subscribe to this ideology. Because you want a person you work with day in and day out to have that same passion. Sometimes you're going to have to work overtime. You're not going to get paid extra for that. Sometimes you're going to work weekends. Sometimes shit’s gonna hit the fan. You don't want to work with someone who whines about it.\nOur theory is that Apple is more likely to reward employees (and candidates) who act like the leader. If you listen to 1:00:36 - 1:02:05 in an interview with Steve Jobs, you’ll see some stark similarities to how Apple interviewers talk about the organization. In this clip, he says, “You know how many committees we have? None. We are organized like a startup.” He then describes the benefits of silos and dividing things up.\nPrivacy and politics are the natural consequence of a place intentionally designed to be siloed and divided up and kept separate. It’s a cost that Apple accepts because the gain is increased productivity. Put people in closed systems (teams and orgs that don’t talk to other teams and orgs) and watch them get more done. This system works like blinders on a racehorse: it keeps vision focused down the track, on the goal, minimizing peripheral distraction. That’s all they need to see and they run/work faster because of it.\nOne final aspect of Apple’s behavioral rounds is that they will ask you specific questions about relevant skills. For example, if a team works with big data, they will ask specifically about a time you have worked with large-scale distributed systems in the context of your answer. If you don’t have direct experience with the field, they will try to get as close as possible, like asking you for what tradeoffs you’ve made when choosing a storage system. These behavioral interview questions serve two purposes: showing you have had relevant experience in the context of what the team is hiring for and trying to get you to talk about a particular behavioral skill (e.g., leadership, conflict resolution).\nAs evidenced by the highest chaos score, Apple doesn’t do many things in hiring consistently, across the whole company. One trend is that Apple teams rely on post-interview live discussions to make hiring decisions. This varies from somewhat informal (compared to the rest of FAANG) to laughably informal.\n“Post-onsite feedback for my org was 100% live discussions. At Apple I never had to write feedback. Which made me do more interviews. We made the decision on the same day. Everyone had to make a decision at the end of the day. Do an onsite, then at 5pm, we gather in a single meeting room, we do on the count of three: thumbs up, down, or in the middle. Then we talk after seeing the thumbs. And try to convince the people on the other side. If there’s less than 5 thumbs-up, then that might be an instant rejection. If there’s 6 or 7 or more thumbs up, the ‘thumbs up’ people try to convince the other side. Or in that same situation, the 3 or 4 thumbs down will try to convince the other side.”\nBecause of the informal decision-making process and reliance on live discussion, managing the impressions of your interviewers is more important at Apple than at other FAANG. In these decision-making meetings, if there’s dissent, they strive for consensus. The people on one side try to convince the other side. This process can last 15-30 minutes on average; all FAANG companies say interviewers fight for candidates, but Apple tends to fight more than most of them.\nBecause of their patterns of live-discussions and striving for consensus, Apple interviewers are more likely to fight for or against you (if your performance was on the fence) than any other FAANG, except maybe Netflix.\nUltimately, the hiring manager for that particular role has the most say, which means that that’s the person you should be working to impress the most.\n“My manager wanted to hire this person. But he failed my interview so badly. I didn't want to argue with my manager but at the same time I didn't want to work with this person. Because we are hiring people we’d work with on a daily basis. So arguments happen a lot. And in this case, I was the only ‘no’ on the board and the candidate got rejected.”\nWe’ve aggregated a bunch of useful Apple content for you! We have replays of candidates doing mock interviews with Apple interviewers, long-form solutions to common Apple questions, and deep dives into technical topics that tend to come up in Apple interviews.\nBelow are a series of mock interview replays, conducted by Apple interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Apple ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Apple interviews, we did two things. First, we spoke to a bunch of Apple interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Apple. Based on all of the above, here are the technical topics you’re likely to encounter:\nFor more in-depth information on Apple and their hiring process, or to learn more about Apple’s company culture, be sure to check out the resources listed below. These documents will help you better prepare for software developer and software engineer interviews.\nWant to know if you’re ready to interview at Apple? Do anonymous mock interviews with real Apple interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/apple",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Netflix Interviews + Questions",
      "content": "Netflix’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Netflix? Do anonymous mock interviews with real Netflix interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Netflix’s process, evaluation criteria, and interviewers.\nEvery human organization views themselves as a metaphor; Netflix doesn’t view themselves as a family like some other tech companies, they view themselves as a high-caliber sports team (in fact, Netflix calls their employees a “dream team”). They explain this metaphor themselves in their infamous culture memo.\nFinally, Netflix’s interview process is decentralized and team-dependent. Moreover, you can interview with multiple teams at Netflix concurrently, which can help you increase your odds of securing a job offer.\nPlease see the section above called “A note about recruiter calls”\nThis is a 30 minute call. A former Netflix employee called this round “Very chill, especially compared to the onsite.” This round consists of bidirectional surface-level questions.\nThe hiring manager will also be selling you on Netflix. Hiring managers doing selling is business as usual, but in this case, it serves an additional purpose – because their onsite is by far the most intense, they have to sell harder upfront because the onsite is a bigger commitment for the candidates.\nThe Netflix technical phone screen is a coding interview that typically lasts 45-60 minutes. There is significant inter-team variation on what these interviews cover, and the tooling you use during these interviews also varies by team,\nOnsite interview structure varies from team to team, but you’ll have roughly 8 interviews focused primarily on system design, then behavioral, and then coding.\nDepending on the length of the onsite, Netflix recruiting may ask you if you’d prefer to split the onsite over two days, and we recommend that you proactively ask to do that, given how taxing the behavioral and system design portions are!\nNetflix is the only FAANG that routinely includes 1-2 directors in their onsite loops. If your loop has two, it’ll be one director will be from your org and another from a partner org. Netflix does this to reduce bias. One director may do a system design interview, and the other will do a behavioral interview.\n“Don’t be thrown off by having to talk to directors. Just stick to the principles: when you speak about technical stuff you’ve worked on, focus on scale, availability, and security. When you speak about behavioral stuff: use shared ideas from their culture deck, take accountability for your wins and failures, and demonstrate metrics and impact.”\n“The HRBP [which is basically a very senior recruiting function] and the director would typically focus on behavioral rounds. I have also seen directors spending time (30 mins) just letting candidates ask and clarify any questions that they might have regarding the team, Netflix culture, career growth path or any other aspects. So, a strong recommendation would be to be ready with your genuine questions list and get things clarified in such interviews. Candid conversation is one of the key values at Netflix and asking genuine concerns if any is seen through good lenses, as that establishes candidates' seriousness about the role to some extent.”\nThe technical questions Netflix asks vary from team to team. Some teams don’t ask LeetCode questions. Other teams will ask medium-difficulty LeetCode-style coding questions with a creative/practical twist.\nThese rounds are going to change team by team, but the pattern we’ve noticed is that Netflix coding questions often come in two parts.\nTypically there is one question and, in scenarios where edge cases and tests are done early, say within 45 minutes, the interviewer may choose to spend some time discussing general large scale engineering concepts and distributed systems (like microservices, scalability, etc.). For instance, some expansions could be:\nThis is the most important round at Netflix. Coding carries the least weight, behavioral carries a lot, and system design has the most.\nNetflix system design rounds are highly unique and highly challenging. Netflix is to system design as Google is to coding; these technical interview rounds include the most difficult and bespoke questions.\nSimilar to how Amazon loves Leadership Principles, Netflix loves system design so much they even throw it into coding rounds sometimes – first, you solve a LeetCode-style problem. Then they ask you to apply it to a real-world use case.\nThat said, Netflix system design rounds are easier to prepare for if you know the patterns: Netflix loves scale. Netflix never wants to go down, and Netflix hates when things aren’t secure. Availability is super important to them; they want to ask and hear about tactics to scale systems, keep systems highly available, and maintain secure systems.\nAt Netflix, you’re likely to see unique questions that you won’t get anywhere else, and the system design round is the part of the process that Netflix interviewers take the most pride in, so they make up hard, one-of-a-kind questions from scratch. Thematically, their questions are more likely to be focused on scaling. They also like to ask about security and availability.\nIn fact, Netflix is more likely than the rest of FAANG to give you a system design round focused solely on security. For instance, you might get asked what you would do during a DDoS attack, and the entirety of the session will be spent drilling down into the details. And because they’re also obsessed with availability, you might get questions around backups and what to do if a service goes down.\nMoreover, as with their coding rounds, Netflix prefers questions with a practical application, and they’re likely to ask you about something they’re working on right now. If you research the hell out of their architecture – specifically the service that particular team is in charge of – and the other services this service interacts with, you’ll be in good shape.\nYou’re also likely to see a “reverse system design” round, where your interviewer will ask you pointed questions about the systems you’ve worked on before, e.g., the largest scale system you’ve worked on, how did you manage it, how did you scale it, etc.\nQuestions they most likely won’t ask are product-focused questions, such as “Design Spotify”.\nLearn about Netflix’s overall architecture so you can a) speak their language, and b) build or speak of something similar (in the interview) that Netflix has already built but simpler.\nFor the team you interview with: what’s their tech stack? What open source stuff do they do? With which other services might their service interact? That last question is most critical. If you can put forethought into how their current system works, you’ll have a huge leg up; then all you’ll need to do is discuss what you learned about their system to score a bunch of points with any of their interviewers.\nWhat tooling you use in these interviews depends on the team you’re interviewing with.\nAnswers to behavioral questions are almost as important as system design at Netflix. You’ll get rejected if you fail the behavioral screen.\nThese interviews have a heavy emphasis on the candidate being a cultural fit, being able to work in a team, having curiosity, and being product minded, highly motivated individuals capable of driving products forward.\nA unique part of Netflix’s behavioral interview is the “Dream Team” interview. This is a slightly more intense behavioral round conducted by a director. The \"volume\" is turned up on all of the things you might see in a typical behavioral round at Netflix (scale, accountability, open communication about concerns, high risk and high reward.)\n“Netflix doesn’t hire as much as other FAANGs, so they want to make sure you're a star. That’s what the ‘Dream Team’ interview is about.”\nOne key thing you need to do before your Netflix behavioral interview is read their culture memo. Our interviewers tell us that if you don’t do this, you will fail the behavioral round.\n“The culture illustrated in the culture memo is sort of accurate to how the culture at Netflix actually is, but the actual culture is less intense. Team members tend to get along really well. You don’t compete with others in your performance review like it is at companies like Facebook. We’re not ranked against peers, so people are more willing to help each other out.”\nNetflix will ask about impressive things you’ve done, as well as dig into your motivation (your “why”). This round will feel like you’re doing self-promotion. Typical questions will ask about your favorite project, latest project, and most significant project, as well as open-ended questions about what you’re looking for in your next role and why you’re interested in Netflix.\nPromote yourself early and often in Netflix behavioral rounds. Promote yourself proactively. Metrics and impact statements are effective ways to promote yourself because they convey a sense of scale and complexity.\nIt can be nerve-wracking to talk to a director for 45-60 minutes. It’s more nerve-wracking when, out the gate, they ask you to describe the biggest thing you’ve ever worked on. When talking to a director, it’s more important to have metrics and impact statements.\nNetflix interviewers are untrained, their questions are unstandardized, their interviews are team-dependent, and their decision-making north star is “Why”. You can interview with multiple teams concurrently, effectively giving you multiple shots on goal.\nThere’s also no specific company-wide scale for performance at Netflix. This is different from, say, Google, where all candidates are graded on the same “Strong Hire, Hire, Neutral, No Hire, Strong No-Hire” scale. Different teams have different processes, but most decisions are made based on live post-onsite discussions.\n“Netflix hiring decisions are black and white: pass or fail. And then you discuss if you'd be open to changing your mind. The only difference between Apple and Netflix was how they defined cultural fit. Besides that the hiring decisions were made in the same way: informal, mainly based on live discussions, binary decisions, and striving for consensus.”\nImpression management is more powerful at companies that do live feedback discussions. To learn more about impression management, check out the resources to prepare for Netflix later in this section.\nWe’ve aggregated a bunch of useful Netflix content for you! We have replays of candidates doing mock interviews with Netflix interviewers, long-form solutions to common Netflix questions, and deep dives into technical topics that tend to come up in Netflix interviews.\nBelow are a series of mock interview replays, conducted by Netflix interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Netflix ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Netflix interviews, we did two things. First, we spoke to a bunch of Netflix interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Netflix. Based on all of the above, here are the technical topics you’re likely to encounter:\nThe resources listed below are designed to help with various aspects of Netflix interview prep, from technical problem-solving to understanding the company’s core values.\nSince Netflix has the most difficult system design screen (and their version of this round has a lot of overlap with other FAANGs), if you prep for Netflix, you’re also upskilling for system design rounds at all FAANGs. We recommend the following resources to all engineers interviewing at FAANG:\nThese resources will help you “learn their language.” Then, when you communicate with Netflix, speak their language.\nWant to know if you’re ready to interview at Netflix? Do anonymous mock interviews with real Netflix interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/netflix",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Senior Engineer’s Guide to Microsoft Interviews + Questions",
      "content": "Microsoft’s interview process consists of the following steps:\nWant to know if you’re ready to interview at Microsoft? Do anonymous mock interviews with real Microsoft interviewers, and see exactly where you stack up.\nSee available timesBefore we get into the details of each of these steps, here are a few general notes about Microsoft’s process, evaluation criteria, and interviewers.\nMicrosoft lets you interview with different teams at the same time; if you want to maximize your chances interview with several of them simultaneously.\nMicrosoft’s process is mainly (though not fully!) team-dependent. That means that while you interview for a specific team, you may not necessarily be interviewing just with people on that team. For example, sometimes you might interview with the hiring manager for a specific team, and your other interviewers will be individual contributors from other teams.\nEach team runs their own processes, which can vary quite a bit from team to team as well. Sometimes Microsoft bakes a quasi-team-matching activity into an interview process: where a candidate can meet multiple hiring managers in the same loop. Another variation is some candidates’ first round screens are with a hiring manager instead of a recruiter.\nPlease see the section above called “A note about recruiter calls”\nMicrosoft’s technical phone screen is a traditional LeetCode-style coding interview, with technical questions ranging from easy to medium. Interviewers aren’t given a rubric. Some of them get training, others don’t. They have freedom to ask whatever they want and judge your technical skills however they want in this round.\nIf you end up getting the asynchronous Codility quiz instead, you sign on and have to answer several algorithmic questions in a short amount of time. In some ways, this is harder than the technical phone screen with the human because if you don’t pass the test cases, you get filtered out. You’re judged on several factors including: test cases, correctness, and code quality.\nThe onsite format can vary per org, but it typically includes the following round of interviews:\nThis is the most important round at Microsoft.\n“Since most engineers at Microsoft use C#, if you can, you should use C#, Java, or Python in the technical rounds. This way, your interviewer will be able to understand your code better and may even be able to help.”\nMicrosoft usually asks LeetCode-style medium-difficulty questions in coding rounds. Interviewers get to pick their own coding questions, but, according to interviewers, Microsoft favors the following topics (in no particular order):\nLeetCode’s Top Questions for Microsoft is also a helpful resource.\n“Tree questions are most popular, e.g., various types of tree sum, tree traversals of certain orders, subtrees, etc.”\nDynamic programming used to basically never happen, but now it’s a little more common. When you do get dynamic programming problems, it’s usually the classic ones like coin change, stair steps, edit distance, and various types of counting problems.\nTooling for coding interviews is at the team’s discretion, but many teams use Codility.\nFor everything you need to prepare for Microsoft’s coding interview, check out the section called \"Microsoft coding interview preparation resources\" below.\nSystem design is tied for the second most important round at Microsoft, and it’s sometimes conducted by a hiring manager. One idiosyncratic aspect of Microsoft’s process is their penchant for asking questions about compliance-related topics.\n“My Microsoft interview was insanely easy. I tried to step it up when I started being an interviewer at Microsoft. But then I realized that's how it has to be. Technical is like 25% of it. It’s not a generic FAANG interview. It’s more about three things: a) ‘How well does this candidate know this system they’re going to be working on?’, b) ‘How do they meet the exact needs we have on this team?’, and c) ‘Do they understand the little things we value? Like compliance, manipulating data, data pipelines, EU data processing, etc.’”\n“Microsoft is obsessed with the details of compliance. I don’t think I have seen a system that is as set up for auditing as Microsoft. Employees are asked to log so much. There’s a centralized grid system which is built into Azure. All logs are to be routed into that. This allows for centralized log spanning and auditing. Which I have not seen anywhere else.”\nOutside of compliance-related questions, here are examples of other system design questions you might encounter:\nTooling for system design interviews is at the team’s discretion, but many Microsoft employees use Codility Canvas or Excalidraw.\nThe domain-specific round is tied for the second most important round at Microsoft. Microsoft is more likely to do these types of rounds than other FAANGs, and these rounds can feel similar to system design but involve some coding.\nUsually, domain-specific rounds are customized to the domain a given team works on and dives deep into that technology. So, whatever area this team is in (cloud networking, big data, etc.), that’s what they’ll ask you about.\nOn some occasions, Microsoft customizes a round to the candidate’s skills. For example, if you’re a backend engineer, they might ask you to design an API or design a database. They also may ask you open ended trivia questions about the programming language you are most familiar with.\n“Another thing that happens in these rounds is they’ll ask you to discuss a complicated problem you have solved at your job. It's good for candidates to prepare to discuss 2-3 projects in detail: how did they implement caching, deal with scaling issues, and so on.”\nFinally, you may get a scenario question that’s commensurate with your skill set. For instance, if you’re a back-end engineer, you may get a question like, “Imagine you're in a team and we're building a credit card registration system. And it's used by different firms. How do you build the interface?”\nThis is the least important round at Microsoft: the lowest effort way to pass is to not blame your teammates, not show red flags, and stay positive.\nMicrosoft doesn’t have a specific set of traits they’re looking for. You can expect the usual questions about your strengths and weaknesses, failure, conflicts with colleagues, projects, and lessons you’ve learned from past experiences in your career.\n“A lot of people struggle with ‘What are your top 2 strengths and weaknesses?’ probably because they are trying to make up an answer on the spot. Good to prep answers to typical behavioral questions in advance.”\nUltimately, they are screening for three soft skills: positivity, ownership, and communication. They want to hire friendly people who can do the work and not blame others. This is not Apple or Netflix, where they want a particular flavor of personality, or where they ask interviewers to hire candidates they’d like to befriend. It’s more neutral.\nBehavioral rounds can sometimes have a coding component as well. When this happens, it might be an easy/medium-difficulty 20-min LeetCode-style problem.\nInterviewers grade candidates on different scales, depending on the team.\nSome orgs have an asynchronous feedback process, other orgs rely on live discussion, and still-other orgs do both. Some orgs have rubrics, and others don’t. Here’s how a rubric looks at one org:\nHere are a few more interview tips and resources to help you prep for a software developer or software engineer interview at Microsoft.\nIn addition, we’ve aggregated a bunch of useful Microsoft content for you! We have replays of candidates doing mock interviews with Microsoft interviewers, long-form solutions to common Microsoft questions, and deep dives into technical topics that tend to come up in Microsoft interviews.\nBelow are a series of mock interview replays, conducted by Microsoft interviewers on our platform. Watch them so you can learn from others’ mistakes.\nBelow are common questions that interviewers from Microsoft ask on our platform. Since our data comes from mock interviews, questions may not be exactly the same as what you'd see in real interviews.\nTo figure out what technical topics will come up in your Microsoft interviews, we did two things. First, we spoke to a bunch of Microsoft interviewers in our community. Then we cross-referenced all the anecdotes we heard with Glassdoor data AND our own data-set of mock interviews in the style of Microsoft. Based on all of the above, here are the technical topics you’re likely to encounter:\nWant to know if you’re ready to interview at Microsoft? Do anonymous mock interviews with real Microsoft interviewers, and see exactly where you stack up.\nSee available timesInterview prep and job hunting are chaos and pain. We can help. Really.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/guides/hiring-process/microsoft",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to Reverse a String [Interview Question + Solution]",
      "content": "How to Reverse a String (With Solutions in Python, Java & JavaScript)\nHow to Reverse a String: Problem Overview\nHow to Reverse a String: Problem Overview\nThe Reverse String problem involves taking a given string of characters and reversing the order of the characters. This problem, despite its simplicity, invites many advanced approaches, such iteration, recursion, or multiple pointers, each presenting a unique time and space complexity tradeoff.\nAn Example of the Reverse String Problem\nAn Example of the Reverse String Problem\nWrite a program to reverse the given string. The program's output would be a string with all characters in reverse order.\nInput: \"hello world\" Output: \"dlrow olleh\"\nInput: \"aba\" Output: \"aba\"\nInput: \"ab\" Output: \"ba\"\nInput: \"\" Output: \"\"\nConstraints\nThe number of characters in the string would be in the range [0, 100000].\nHow to Reverse a String : 4 Approaches in Python, Java & JavaScript\nHow to Reverse a String : 4 Approaches in Python, Java & JavaScript\nThe most straightforward answer is to use an inbuilt library-provided function that is usually available in most languages. But the interviewer is probably not interested in our knowledge of library functions. This means the ideal solution would be similar to how a library would implement a reverse\nfunction (i.e., Python, JavaScript, Ruby). There are several approaches, and we'll discuss some of them here.\nApproach 1: Build String Iteratively (Brute Force)\nThe original string's first character turns into the reverse string's last character. The second character of the original string becomes the second last character of the reversed string. And so on.\nWe can loop through each character of the original string and build the reversed string iteratively. We start with an empty string and append the characters to it as we loop across the original string. Please note that we are appending the characters to the beginning of the string. By doing so, we ensure that the characters appearing later in the original string appear earlier in the reversed string.\nAlgorithm\n- Initialize an empty string\nreversed\\_string\n. - Loop through each character of the original string.\n- Append the character at the beginning of\nreversed\\_string\n. - Return the\nreversed\\_string\n.\nReverse String JavaScript, Python and Java Solutions - Brute Force\nfunction reverseString(string) {\nlet reversedString = \"\";\nfor (char of string) {\nreversedString = char + reversedString;\n}\nreturn reversedString;\n}\n1function reverseString(string) {\n2 let reversedString = \"\";\n3 for (char of string) {\n4 reversedString = char + reversedString;\n5 }\n6 return reversedString;\n7}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n²)\n. A common mistake is to think of the time complexity of this approach asO(n)\n, but this is not the case. The time complexity isO(n²)\nbecause each time we append a character to the end of the string, we end up creating a new string. This new string then gets assigned to the variablereversed\\_string\n. This is anO(n)\noperation, and we are doing this for each character in the string. So the total time complexity isO(n \\* n) = O(n²)\n.If we are coding in a language that support string mutability, then appending a character would be a constant time operation. So the time complexity would be\nO(n)\n. -\nSpace Complexity:\nO(n)\n. We are creating a new string of lengthn\n, which is the only memory space we use.\nApproach 2: Build String Iteratively (Linear Time)\nIn the previous approach, we noted that it was not the optimal solution because we were creating a new string each time we added a character to the end of the string, which is an O(n)\noperation. Can we find a way to bring this operation down to O(1)\n?\nInstead of creating a new string every time we need to find a data structure that we can append individual characters to in constant time, and to this we can use a stack. A stack is a data structure that follows the LIFO principle. In this approach, we push all the characters of the original string onto the stack and then pop them one by one in order to build the reversed string.\nAdditionally, while building the reversed string, we use a dynamic array to store the characters. By using a dynamic array, we avoid creating a new string every time we append a character to the end of the string, making the operation O(1)\ninstead of O(n)\n.\nAlgorithm\n- Initialize an empty stack\nstack\n. - Loop through each character of the original string.\n- Push the character to the stack.\n- Initialize an empty dynamic array\nreversed\\_string\n. - Loop until the stack is empty.\n- Pop the top character from the stack. Append it to the end of\nreversed\\_string\n. - Create a string from the dynamic array\nreversed\\_string\nand return it.\nReverse String Javascript, Python and Java Solutions - Using a Stack\nfunction reverseString(string) {\nlet stack = [];\nfor (char of string) {\nstack.push(char);\n}\nlet reversedString = [];\nwhile (stack.length > 0) {\nreversedString.push(stack.pop());\n}\nreturn reversedString.join(\"\");\n}\n1function reverseString(string) {\n2 let stack = [];\n3 for (char of string) {\n4 stack.push(char);\n5 }\n6 let reversedString = [];\n7 while (stack.length > 0) {\n8 reversedString.push(stack.pop());\n9 }\n10 return reversedString.join(\"\");\n11}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n)\n. We are looping through the original string once and pushing the characters to the stack. Then we loop across the string again and pop all the characters from the stack. Finally, we join all the characters of reversed\\_string, so the total time complexity isO(n + n + n) = O(3n) = O(n)\nPlease note that an algorithm that takes3n\ntime is classified withO(n)\ntime complexity. Big-O notation is a measure of how an algorithm scales as the size of the input grows. As the size ofn\nincreases, the constant factor3\nbecomes insignificant. -\nSpace Complexity:\nO(n)\n, as we use a stack that storesn\ncharacters.\nApproach 3: In Place Reversal (Two Pointers)\nWhen a string is reversed, the last character becomes the first character, and the first character becomes the last character. Similarly, the second last character becomes the second character, and the second character becomes the second last character. And so on. In other words, characters at the same position relative to the start and the end of the string are swapped.\nWe iterated from one end of the string to the other in the previous approaches. It is also possible to iterate from both ends of the string simultaneously. Let's have two pointers, one pointing at the start of the string and the other at the end of the string. We can swap the characters at these two pointers. Then we can move the pointers toward the middle of the string. We can keep doing this until the two pointers meet each other.\nIn most languages, a string is immutable. This means that we cannot change the characters of the string. We can only create a new string. So we need to convert the string to a character array. Then we can swap the characters at the two pointers. After swapping all the characters, we can transform the character array back to a string.\nIf the language supports mutable strings (e.g., Ruby, PHP, Swift), we can directly swap the characters at the two pointers. Some languages don't support mutability directly, but might have a class or a standard library that provides a mutable string. For example, there is StringBuilder in Java.\nAlgorithm\n- Convert the string to a character array\nchar\\_array\n. - Initialize two pointers,\nstart\nandend\n, to point at the start and the end of the string, respectively. - Loop until\nstart\nis less thanend\n. - Swap the characters at\nstart\nandend\n. - Increment\nstart\nand decrementend\n. - Convert the character array back to a string and return it.\nReverse String Javascript, Python and Java Solutions - Using In Place Reversal\nfunction reverseString(string) {\nlet charArray = string.split(\"\");\nlet start = 0;\nlet end = charArray.length - 1;\nwhile (start < end) {\nswap(charArray, start, end);\nstart += 1;\nend -= 1;\n}\nreturn charArray.join(\"\");\n}\nfunction swap(charArray, start, end) {\n// using destructuring assignment to swap the characters\n[charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n}\n1function reverseString(string) {\n2 let charArray = string.split(\"\");\n3 let start = 0;\n4 let end = charArray.length - 1;\n5 while (start < end) {\n6 swap(charArray, start, end);\n7 start += 1;\n8 end -= 1;\n9 }\n10 return charArray.join(\"\");\n11}\n12\n13function swap(charArray, start, end) {\n14 // using destructuring assignment to swap the characters\n15 [charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n16}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n)\n. Both pointers traverse the string from opposite ends until they merge. So every character is processed once in this process. Swapping two characters takes constant amount of time. So the overall time complexity isO(n)\n. -\nSpace Complexity:\nO(n)\n. We are using a character array to store the characters of the string. So the space complexity isO(n)\n. If the input to the function is a character array itself or the language supports string mutability, then the space complexity would beO(1)\n, because the algorithm does an in-place reversal of the character array / string.\nApproach 4: In Place Reversal (Recursion)\nNote: While recursion will work for this problem, it overcomplicates the problem without added benefit and as such many interviewers will prefer one of the non-recursive approaches above. We have included the recursive solution here for completeness.\nIn the previous approach, we iterated two pointers toward the middle of the string and used them to swap the characters at the index of each pointer. While this method works well, we want to present a similar approach that uses recursion.\nWe define a recursive function that receives the character array and pointers for start and end as input. The function swaps the characters at the start and end pointers. Then it calls itself with the start pointer incremented by 1 and the end pointer decremented by 1. This way, the function keeps swapping the characters at the start and end pointers until the start pointer is greater than the end pointer. The function returns when the start pointer is greater than the end pointer. This way, we can reverse the string in place.\nIn the end, we convert the character array to a string and return it.\nAlgorithm\n- Convert the string to a character array\nchar\\_array\n. - Call the recursive function\nreverseStringHelper\nwithchar\\_array\n,0\nandchar\\_array.length - 1\nas input. - Convert the character array back to a string and return it.\nRecursive function reverseStringHelper\n:\n- Base case: If\nstart\nis greater thanend\n, return. - Swap the characters at\nstart\nandend\n. - Call the recursive function\nreverseStringHelper\nwithchar\\_array\n,start + 1\nandend - 1\nas input.\nReverse String Javascript, Python and Java Solutions - Using In Place Reversal with Recursion\nfunction reverseString(string) {\nlet charArray = string.split(\"\");\nreverseStringHelper(charArray, 0, charArray.length - 1);\nreturn charArray.join(\"\");\n}\nfunction reverseStringHelper(charArray, start, end) {\nif (start > end) {\nreturn;\n}\nswap(charArray, start, end);\nreverseStringHelper(charArray, start + 1, end - 1);\n}\nfunction swap(charArray, start, end) {\n// using destructuring assignment to swap the characters\n[charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n}\n1function reverseString(string) {\n2 let charArray = string.split(\"\");\n3 reverseStringHelper(charArray, 0, charArray.length - 1);\n4 return charArray.join(\"\");\n5}\n6\n7function reverseStringHelper(charArray, start, end) {\n8 if (start > end) {\n9 return;\n10 }\n11 swap(charArray, start, end);\n12 reverseStringHelper(charArray, start + 1, end - 1);\n13}\n14\n15function swap(charArray, start, end) {\n16 // using destructuring assignment to swap the characters\n17 [charArray[start], charArray[end]] = [charArray[end], charArray[start]];\n18}\nTime/Space Complexity\nLet's assume that there are n\ncharacters in the given string.\n-\nTime Complexity:\nO(n)\n. Both pointers traverse the string from opposite ends until they merge. We swap two characters in the main body of recursion, which is a constant time operation. So the overall time complexity isO(n)\n. -\nSpace Complexity:\nO(n)\n. We are using a character array to store the characters of the string. On top of that, we are using the call stack to store the function calls. We maken/2\nfunction calls, which isO(n)\n. So, the space complexity isO(n)\n.\nPractice the Reverse String Problem With Our AI Interviewer\nPractice the Reverse String Problem With Our AI Interviewer\nReverse String Frequently Asked Questions (FAQ)\nReverse String Frequently Asked Questions (FAQ)\nWhy can’t you just use reverse() when reversing a string?\nIn real life, you probably would. However, in an interview, you’ll want to demonstrate to your interviewer that you understand what programming languages do under the hood when they call a function like reverse(). That’s why it’s important to be able to implement it from scratch. It’s also an opportunity to demonstrate to your interviewer that you know if strings are mutable or immutable in your language of choice.\nHow do you reverse a string in place?\nTo reverse a string in place means to modify the original string directly without using any additional memory. There are two ways to do this: the first is iterative, and the second uses recursion. Note that the recursive approach isn’t as efficient and overcomplicates the problem needlessly.\nWith the iterative approach, you’d use two pointers to swap characters symmetrically from both ends of the string: the first with the last, the 2nd with the 2nd to last, and so on. We’d repeat this approach until the two pointers met each other. Depending on whether strings are mutable or not in your programming language of choice, you might have to convert the string to a character array before doing the swaps.\nWith the recursive approach, we convert our string to a character array, and then pass it into the recursive function, along with pointers for the start and end. The function swaps the characters at the start and end pointers. Then it calls itself with the start pointer incremented by 1 and the end pointer decremented by 1. The function returns when the start pointer is greater than the end pointer.\nWhat’s the difference between reversing a string and reversing an array of integers?\nHow different these are depends on whether strings are mutable or not in your language of choice.\nWhen reversing a string, you are dealing with a sequence of characters. Strings are typically treated as immutable in many programming languages, including Python, which means you cannot modify them directly. To reverse a string in place, you need to convert it into a mutable data structure (like an array) first, perform the reversal, and then convert it back to a string.\nOn the other hand, when reversing an array of integers, you are working with a collection of numeric values. Arrays of integers are mutable data structures in most programming languages, allowing direct modification. You can reverse the order of elements in an array by swapping elements at symmetric positions, without needing to convert the array into a different data type.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/reverse-string",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Longest Substring Without Repeating Characters (Solved)",
      "content": "How to Solve Longest Substring Without Repeating Characters\nWhat is the Longest Substring Without Repeating Characters Problem?\nWhat is the Longest Substring Without Repeating Characters Problem?\nThe Longest Substring Without Repeating Characters problem involves searching through a given string and identifying the longest sequence of non-repeating characters. This problem can be solved with a brute force search approach, or with a more advanced and efficient sliding window technique.\nLongest Non-repeating Substring Example Inputs and Outputs\nLongest Non-repeating Substring Example Inputs and Outputs\nGiven a string s\n, find the length of the longest substring without repeating characters.\nExample 1\nInput: \"abcabcbb\"\nOutput: 3\nThe longest substrings without repeating characters are abc\n, bca\n, and cab\n, all with length 3.\nExample 2\nInput: \"bbbbb\"\nOutput: 1\nThe longest substring without repeating characters is b\n, with length 1.\nExample 3\nInput: = \"pwwkew\"\nOutput: 3\nThe longest substring without repeating characters is wke\n, with length 3.\nConstraints\n- 0 <= s.length <= 1000000\n- The character set for\ns\nis ASCII.\nSolution to the Longest Substring Without Repeating Characters Interview Question\nSolution to the Longest Substring Without Repeating Characters Interview Question\nThere are three ways to approach the longest substring problem. Before we talk about them in detail, note that when asked to explore a \"subsection\" of an array or string, you should always confirm your understanding of the search space. Remember that a substring is a contiguous slice of characters taken from a string (similar to a subarray), as opposed to a subsequence which can skip characters, or a permutation which can be out of order. With this knowledge, we can rule out any need for backtracking, and instead start to think more greedy.\nAnother important thing to confirm with your interviewer when handling strings is the character set, as this will help us define the space complexity of the problem. A safe assumption is that our solution will implement ASCII (128 characters) or Extended ASCII (256 characters).\nNow, here are the three approaches you can take.\n1. Brute Force\nWith the search space defined, a naïve approach becomes fairly straightforward: generate each substring from the input string, check if there are any repeating characters for each, and use a standard-library function (such as math.max()\nin Java) to record the max length found for valid substrings.\nWe can separate this work into two subproblems. First, we need a helper function to determine if a given string has any repeating characters - this can be done by scanning a given range and counting character occurrences with a hash map.\nNext, to generate each substring from the input string s\n, we can enumerate all substrings with two nested loops. Given i\nand j\nas all possible start and end indices for a substring of s\n, we have 0 <= i <= j <= n\n, where n\nis the length of the input string.\nLongest Substring Without Repeating Characters Python and JavaScript Solutions - Brute Force\nclass Solution:\ndef is\\_unique\\_within\\_range(start: int, end: int) -> bool:\nchars = set()\nfor i in range(start, end + 1):\nchar = s[i]\nif char in chars:\nreturn False\nchars.add(char)\nreturn True\ndef length\\_of\\_longest\\_substring(s: str) -> int:\nresult = 0\nfor i in range(len(s)):\nfor j in range(i, len(s)):\nif (self.is\\_unique\\_within\\_range(i, j)):\nresult = max(result, j - i + 1)\nreturn result\n1class Solution:\n2 def is\\_unique\\_within\\_range(start: int, end: int) -> bool:\n3 chars = set()\n4 for i in range(start, end + 1):\n5 char = s[i]\n6 if char in chars:\n7 return False\n8 chars.add(char)\n9 return True\n10 def length\\_of\\_longest\\_substring(s: str) -> int:\n11 result = 0\n12 for i in range(len(s)):\n13 for j in range(i, len(s)):\n14 if (self.is\\_unique\\_within\\_range(i, j)):\n15 result = max(result, j - i + 1)\n16 return result\nTime/Space Complexity Analysis\n- Time Complexity: O(n³). Two nested loops is O(n²), and the helper function makes an additional nested loop.\n- Space Complexity: O(min(n, m)), where\nn\nis the length of the strings\nandm\nis the size of the character set.\n2. Sliding Window\nTo optimize the naïve approach, let's see where duplicate work is being performed.\nConsider this example: if the string \"abc\" has no repeating characters, and we append a new character \"d\" at the end to make the string \"abcd\", do we need to re-check if \"abc\" has repeating characters? Our two nested loops are doing just that - repeatedly checking sections of the string that have already been evaluated - and our helper function is re-checking for repeat characters without using information from overlapping checks.\nInstead of naively enumerating each substring, how can we intelligently skip substrings that we already know to be invalid? Let's use the string “kadbakf” as an example.\nkadb\nis a valid candidate for longest substring since it has no repeating characters.\nIf j\nmoves to index 4 though, the new substring kadba\nwould be invalid. So, we can deduce that with i\nat position 0, all subsequent iterations of j\nwill be invalid, since they will contain this invalid substring. We can confidently stop iterating j\nat this point.\nSo, let's iterate i\nand begin considering new candidate substrings, since we've already seen the longest possible substring with i\nat index 0. But adba\nis also invalid, so any iteration on j\nwill remain invalid.\nLet's increment i\nuntil the substring in the range i\nto j\nis valid again. Here, once i\nis at index 2, there is only one a\ncharacter in the substring, so we can again try to increase the length by iterating j\nanew.\nThis technique is known as a sliding window, and it is approach applicable to a wide variety of leetcode / algorithms problems. The window represents a candidate substring bounded by a start and an end pointer, which expands and contracts based on what we're looking for. Sliding windows are commonly used when searching for an optimal range in an iterable data structure like a string or an array. This is because the algorithm will first search for a possible answer before then expanding (or contracting, whichever is the priority) to try to optimize. For example, if we were searching for the shortest substring that contains the letters a\nand b\n, we would only contract our window if those letters existed in the current substring (valid condition), otherwise we're adding characters until the condition is met.\nConversely, when looking for the maximum possible length, as in the problem at hand, we can only expand the window when the current substring is valid (otherwise, we must first arrive at a valid state by removing characters from the left). Looking back at the example above, j\nonly iterates forward while the condition is satisfied - in this case, all characters between i\nand j\nare unique - and i\nonly iterates forward while the condition is not satisfied.\nHaving made this insight on our substring enumeration, we can further improve the way we check for substrings with unique characters. Remember that a sliding window allows us to take advantage of overlapping subproblems - so, instead of re-checking each window for distinct characters, let's track the current character count of the window and evaluate the new state when a single character is added or removed.\nMore formally, if we know that a substring in the range i\nto j\nhas no repeating characters, then when adding the next character at j+1\n, we simply need to check if that character already exists in the previous range. And because we established the character set at the beginning of our solution, this can be determined in constant time using an array of length 128 to represent character occurrence in a substring.\nNote that, although there are still two nested loops in our code, the time complexity of the iteration is now linear, as i\nand j\nwill only iterate over each character once. Unlike our naïve implementation, the two pointers are not dependent on one another, and instead iterate based on the state of the range between them, which can be determined in constant time and space.\nLongest Substring Without Repeating Characters Python and JavaScript Solutions - Sliding Window\nclass Solution:\ndef length\\_of\\_longest\\_substr(s: str) -> int:\n# List representing ASCII characters to track occurences\nchars = [0] \\* 128\nresult = 0\ni = 0\nj = 0\nwhile j < len(s):\nright\\_char = s[j]\nchars[right\\_char] += 1\nwhile chars[right\\_char] > 1:\nleft\\_char = s[i]\nchars[left\\_char] -= 1\ni += 1\nresult = max(result, i - j + 1)\nreturn result\n1class Solution:\n2 def length\\_of\\_longest\\_substr(s: str) -> int:\n3 # List representing ASCII characters to track occurences\n4 chars = [0] \\* 128\n5 result = 0\n6 i = 0\n7 j = 0\n8 while j < len(s):\n9 right\\_char = s[j]\n10 chars[right\\_char] += 1\n11 while chars[right\\_char] > 1:\n12 left\\_char = s[i]\n13 chars[left\\_char] -= 1\n14 i += 1\n15 result = max(result, i - j + 1)\n16 return result\nTime/Space Complexity Analysis\n- Time Complexity: O(n). At worst, the two pointers both perform linear scans of the string, which would be O(2n). This can be interpreted as O(n) in Big-O notation, since constants are ignored when determining order of magnitude.\n- Space Complexity: O(1). Limited to 128 ASCII characters, space is constant.\n3. Sliding Window Optimized\nAs a marginal optimization, we can avoid two passes with our pointers by improving how we cache character occurrences and update our pointers.\nRemember what we determined in the previous approach: once a duplicate character is found in a given window, this candidate substring will remain invalid until one of the dupes is removed. Seeing that we need to arrive at a valid state before we can continue iterating our right pointer, can we improve how we iterate the left pointer? Indeed! Instead of iteratively searching for the next valid position, we can deduce where it would necessarily be: the index directly after the first occurring duplicate's index in the substring. Moving i\nto this position effectively removes the duplicate from the substring.\nTracking character counts in our hash map won't serve us anymore - instead, let's record the last index at which each character was encountered, so the left pointer can be updated in constant time. Thus when the right pointer finds a repeat, we simply update the left pointer to the position of the last occuring repeat (plus 1).\nLongest Substring Without Repeating Characters Python and JavaScript Solutions - Sliding Window Optimized\nclass Solution:\ndef length\\_of\\_longest\\_substr(s: str) -> int:\nresult = 0\nhash\\_map = {}\ni = 0\nj = 0\nwhile j < len(s):\nchar = s[j]\n# If a duplicate is found, update i to our stored next valid position\nif char in hash\\_map:\ni = max(hash\\_map[char], i)\nresult = max(result, j - i + 1)\n# Store the next index for this character, as this will be the next valid position to de-duplicate\nhash\\_map[char] = j + 1\nreturn result\n1class Solution:\n2 def length\\_of\\_longest\\_substr(s: str) -> int:\n3 result = 0\n4 hash\\_map = {}\n5 i = 0\n6 j = 0\n7 while j < len(s):\n8 char = s[j]\n9 # If a duplicate is found, update i to our stored next valid position\n10 if char in hash\\_map:\n11 i = max(hash\\_map[char], i)\n12 result = max(result, j - i + 1)\n13 # Store the next index for this character, as this will be the next valid position to de-duplicate\n14 hash\\_map[char] = j + 1\n15 return result\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(1)\nPractice the Longest Substring Without Repeating Characters Problem With Our AI Interviewer\nPractice the Longest Substring Without Repeating Characters Problem With Our AI Interviewer\nLongest Substring Without Repeating Characters Frequently Asked Questions (FAQ)\nLongest Substring Without Repeating Characters Frequently Asked Questions (FAQ)\nHow do you find the longest substring without repeating characters?\nThere are three ways to solve this problem. First, there’s the brute force approach, where you generate each substring from the input string, check if there are any repeating characters for each, and record the max length found for valid substrings. This approach runs in O(n³)\ntime. A more efficient way to do it is with a sliding window approach, where you look at substrings bounded by a start and an end pointer, which expand and contract. To start, you create a new set where you track what characters you’ve seen. If the next character is not already in the set, you add it to the set and expand your window by moving the end pointer to the right. If the next character is already in the set, you remove the character at the beginning of the window from the set and contract the window by moving the start pointer to the right. At each step, you calculate the length of the current window and compare it to the previous maximum length. This approach runs in O(n)\ntime. Finally, there’s the optimized sliding window approach, where you can avoid two passes by improving on how you cache character occurrences and update your pointers. This approach also runs in linear time.\nWhat’s the most efficient way to find the longest substring without repeating characters?\nThe most efficient solution to this problem is an optimized sliding window approach.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/longest-substring-without-repeating-characters",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Longest Common Subsequence (Problem & Solution)",
      "content": "Longest Common Subsequence (With Solutions in Python, Java & JavaScript)\nWhat is the Longest Common Subsequence Problem?\nWhat is the Longest Common Subsequence Problem?\nThe Longest Common Subsequence (LCS) problem is a common technical interview question where you're asked to find the longest sequence of characters present in two strings. Variations of this problem are commonly found in real-world applications such as bioinformatics, natural language processing, and text comparison. This problem can be solved using dynamic programming techniques, which involve breaking down the problem into smaller subproblems and then solving them iteratively.\nExamples of the Longest Common Subsequence Problem\nExamples of the Longest Common Subsequence Problem\nGiven two strings, return the longest common subsequence between the two strings. A subsequence of a string is a string that contains characters from the original string in the same order as the original, but may have characters deleted.\nExample 1\nInput: s1 = \"abccba\", s2 = \"abddba\" Output: \"abba\"\nExample 2\nInput: s1 = \"zfadeg\", s2 = \"cdfsdg\" Output: \"fdg\"\nExample 3\nInput: s1 = \"abd\", s2 = \"badc\" Output: \"ad\" (or \"bd\")\nConstraints\n-\n1 <= s1.length, s2.length <= 1000\n-\nThere may be multiple valid answers, but they'll all have the same length.\nHow to Solve the Longest Common Subsequence Problem\nHow to Solve the Longest Common Subsequence Problem\nTo solve the longest common subsequence problem (also known as longest common substring), it is helpful to first consider a couple of important properties of the lcs\nfunction. Firstly, if two strings s1, s2\nend in the same substring then their lcs\nis the lcs\nof the two strings without their common substring concatenated with said substring. For example, lcs(\"abccba\", \"abddba\") = lcs(\"abcc\", \"abdd\") + \"ba\"\n, since the length of the longest common subsequence between the two input strings is at minimum the length of the common consecutive string they share.\nSecondly, if two strings do not have a common ending substring, the lcs\nof the two strings will be the same as the lcs\nresulting from removing the ending of one of the strings. Put another way, lcs(s1, s2)\nis one of two recursive possibilities:\nlcs(s1[:-1], s2)\nlcs(s1, s2[:-1])\nwhere s1[:-1]\nis a string with the last character removed. For example, suppose s1=\"abcd\", s2=\"zdef\"\n, then lcs(s1, s2) = lcs(\"abcd\", \"zde\") = lcs(\"abcd\", \"zd\") = \"d\"\n. But note in this example that lcs(\"abcd\", \"zde\")\nis clearly not equal to lcs(\"abc\", \"zde\")\n.\nRecursive Approach\nLeveraging the above two properties, we can use a recursive solution to approach a longest common subsequence algorithm and solve this using backtracking.\nStarting at the end of the two strings:\n- If the characters at the end are the same, we can return\nlcs(s1[:-1], s2[:-1]) + s1[-1]\n. - If the characters are not the same, we must compute both\nlcs(s1[:-1], s2)\nandlcs(s1, s2[:-1])\n, and return the longer given sequence.\ndef solution(s1, s2):\nif len(s1) is 0 or len(s2) is 0:\nreturn ''\nelif s1[-1] == s2[-1]:\nreturn solution(s1[:-1], s2[:-1]) + s1[-1]\nelse:\nsub1 = solution(s1[:-1], s2)\nsub2 = solution(s1, s2[:-1])\nreturn sub1 if len(sub1) > len(sub2) else sub2\n1def solution(s1, s2):\n2 if len(s1) is 0 or len(s2) is 0:\n3 return ''\n4 elif s1[-1] == s2[-1]:\n5 return solution(s1[:-1], s2[:-1]) + s1[-1]\n6 else:\n7 sub1 = solution(s1[:-1], s2)\n8 sub2 = solution(s1, s2[:-1])\n9 return sub1 if len(sub1) > len(sub2) else sub2\nTime/Space Complexity\nLet m\nand n\nbe the length of the two strings.\n- Time Complexity:\nO(2^m \\* 2^n)\nin the worst case. This algorithm computes all possible subsequences for both strings, resulting in time complexity of2^(len(s))\nfor a string, but it also computes all possible subsequences per subsequence of the other string, hence the product. - Space Complexity:\nO(max(m,n))\n. The space complexity is due to the height of the recursion call stack being the maximum length between the two strings.\nRecursive Solution With Memoization\nWhen implementing a recursive algorithm, one optimization to always look out for is to address repeated work. For example, if we employ the above algorithm on a string that includes the substring \"abc\" in three different locations we will effectively be calling lcs(abc)\nthree different times within the recursion tree. How can we avoid this and improve the time complexity? By storing the lcs\ncomputations in a lookup table, otherwise known as memoization.\ndef solution(s1, s2):\nreturn solution\\_recur(s1, s2, {})\ndef solution\\_recur(s1, s2, solutions):\n# use a frozenset here because (1) frozenset is hashable, so can be\n# used for a key, and (2) order of the inputs does not matter for this function.\ninputs = frozenset([s1, s2])\nsolved = solutions.get(inputs, None)\nif solved is not None:\nreturn solved\nif len(s1) == 0 or len(s2) == 0:\nsolved = ''\nelif s1[-1] == s2[-1]:\nsolved = solution\\_recur(s1[:-1], s2[:-1], solutions) + s1[-1]\nelse:\nsub1 = solution\\_recur(s1[:-1], s2, solutions)\nsub2 = solution\\_recur(s1, s2[:-1], solutions)\nsolved = sub1 if len(sub1) > len(sub2) else sub2\nsolutions[inputs] = solved\nreturn solved\n1def solution(s1, s2):\n2 return solution\\_recur(s1, s2, {})\n3def solution\\_recur(s1, s2, solutions):\n4 # use a frozenset here because (1) frozenset is hashable, so can be\n5 # used for a key, and (2) order of the inputs does not matter for this function.\n6 inputs = frozenset([s1, s2])\n7 solved = solutions.get(inputs, None)\n8 if solved is not None:\n9 return solved\n10 if len(s1) == 0 or len(s2) == 0:\n11 solved = ''\n12 elif s1[-1] == s2[-1]:\n13 solved = solution\\_recur(s1[:-1], s2[:-1], solutions) + s1[-1]\n14 else:\n15 sub1 = solution\\_recur(s1[:-1], s2, solutions)\n16 sub2 = solution\\_recur(s1, s2[:-1], solutions)\n17 solved = sub1 if len(sub1) > len(sub2) else sub2\n18 solutions[inputs] = solved\n19 return solved\nTime/Space Complexity\nDue to how the recursive function is formulated, the lcs\nof (m + 1) \\* (n + 1)\ndifferent input pairs will be computed. Since this solution caches those results, it has:\n- Time Complexity:\nO(m \\* n)\n- Space Complexity:\nO(m \\* n)\nDynamic Programming Approach\nNotice that in the previous approaches, we relied on the fact that the problem being solved had very similar subproblems which were used to ultimately solve the original problem. Of course, these types of situations can be tackled using memoization as seen above. However, an even more powerful approach can be used to tackle overlapping subproblems: dynamic programming.\nTo solve this using a dynamic programming approach, this solution will construct a table of results, and then trace back through the table from the bottom up to construct the longest subsequence. Letting s1=\"abd\"\nand s2=\"badc\"\n, the initial table would look like:\nNotice that the table has been augmented with a row and column for no characters in a string. The added row and column serve as a base case upon which to fill out the rest of the table.\nThe table can be constructed row by row (or column by column). At each cell the character of the row is compared with the character of the column, and based on the result the following items are stored:\n- The length of the longest subsequence between the two substrings up to and including the characters at the current cell. The value will be one plus the \"previous\" cell's value if the characters match; otherwise it will be the \"previous\" cell's value.\n- The direction of the cell \"prior\" to the current cell which has the largest value. If the characters match, then the \"previous\" cell is up one and to the left one. Otherwise it is whichever cell has the larger value between the cell to the left and the cell above.\nContinuing with the example, to fill in the first row the following would occur:\n- 'a', 'b': unequal; above and to the left are 0; so store 0 with direction of \"both\"\n- 'a', 'a': equal; upper left is 0; so store 1 with direction of \"up-left\"\n- 'a', 'd': unequal; above is 0, but left is 1, so store 1 with direction of \"left\"\n- 'a', 'c': unequal; above is 0, but left is 1, so store 1 with direction of \"left\"\nNext we fill in the second row via:\n- 'b', 'b': equal; upper left is 0, so store 1 with direction of \"up-left\"\n- 'b', 'a': unequal; above and to the left are both 1; so store 1 with direction of \"both\"\n- 'b', 'd': unequal; above and to the left are both 1; so store 1 with direction of \"both\"\n- 'b', 'c': unequal; above and to the left are both 1; so store 1 with direction of \"both\"\nFinally, the last row:\n- 'd', 'b': unequal; above and to the left are 0, so store 0 with direction of \"both\"\n- 'd', 'a': unequal; above is 1 while to the left is 0; so store 1 with direction of \"up\"\n- 'd', 'd': equal; upper left is 1; so store 2 with direction \"up-left\"\n- 'd', 'c': unequal; above is 1, while to the left is 2; so store 2 with direction 'left'\nNow that the table is completed we can trace back through the table to construct the lcs\n. To do so, we start in the bottom right corner of the table, which will have the largest number. At each cell, check the direction. If the direction is \"up-left\", then the character at the current cell is part of the lcs\n, so prepend it to the result (since the traceback goes through the table in reverse). Whether the character is part of the lcs\nor not, follow the direction encoded in the cell to navigate the table until the value of the cell is zero.\nUsing the example above, the traceback would proceed as follows:\n- Start in the bottom right corner, where the value stored is 2. This indicates any\nlcs\nhas a length of 2. As the direction isleft\n, move to the cell(d,d)\n- In the cell\n(d,d)\n, the direction isup-left\n, so'd'\nis the last character in anlcs\n. Prepend'd'\nto the result, which is then just\"d\"\nso far, and move to the cell(b,a)\n. - In the cell\n(b,a)\n, the direction isboth\n, and the algorithm could choose to go either to theleft\norup\n(with different resulting strings). For this example, the canonical direction isup\n, so navigate to the cell(a,a)\n. - In cell\n(a,a)\n, the direction isup-left\n, so'a'\nis the penultimate character in anlcs\n. Prepend'a'\nto the result to end up with a string of\"ad\"\nso far, and move to the cell('',b)\n. - In the cell\n('',b)\n, the value stored is 0, so the algorithm stops, and thelcs\nis\"ad\"\n.\nNote 1: In step 3, had the algorithm gone to the left\ninstead of up\n, the lcs\nwould have been \"bd\"\ninstead of \"ad\"\n.\nNote 2: It is possible to store the actual subsequences inside each cell, but such a solution would need to include all subsequences that could be arrived at in each cell, which would add to the space complexity.\nclass SolutionNode:\ndef \\_\\_init\\_\\_(self, direction=\"sink\", value=0):\n# valid directions are: sink, up, left, up-left, or both\nself.direction = direction\nself.value = value\ndef solution(s1, s2):\nif len(s1) == 0 or len(s2) == 0:\nreturn ''\n# building the table with the extra row and column\nlcs = [[SolutionNode() for x in range(len(s2)+1)]\nfor y in range(len(s1)+1)]\n# skip first row; it is supposed to be all zeros anyway\nfor i, row in enumerate(lcs[1:], 1):\n# skip first row; it is supposed to be all zeros anyway\nfor j, cell in enumerate(row[1:], 1):\nif s1[i-1] == s2[j-1]:\ncell.value = lcs[i-1][j-1].value + 1\ncell.direction = 'up-left'\nelif lcs[i][j-1].value == lcs[i-1][j].value:\ncell.direction = 'both'\ncell.value = lcs[i][j-1].value\nelif lcs[i][j-1].value > lcs[i-1][j].value:\ncell.direction = 'left'\ncell.value = lcs[i][j-1].value\nelse:\ncell.direction = 'up'\ncell.value = lcs[i-1][j].value\n# The table is built; now to traceback\ni = len(s1)\nj = len(s2)\nnode = lcs[i][j]\nval = node.value\nresult = ''\nwhile val > 0:\n# Could instead go 'left' on 'both'\nif node.direction == 'up' or node.direction == 'both':\ni -= 1\nelif node.direction == 'left':\nj -= 1\nelse:\ni -= 1\nj -= 1\n# need to prepend since this constructs the lcs in reverse\nresult = s1[i] + result\nnode = lcs[i][j]\nval = node.value\nreturn result\n1class SolutionNode:\n2 def \\_\\_init\\_\\_(self, direction=\"sink\", value=0):\n3 # valid directions are: sink, up, left, up-left, or both\n4 self.direction = direction\n5 self.value = value\n6def solution(s1, s2):\n7 if len(s1) == 0 or len(s2) == 0:\n8 return ''\n9 # building the table with the extra row and column\n10 lcs = [[SolutionNode() for x in range(len(s2)+1)]\n11 for y in range(len(s1)+1)]\n12 # skip first row; it is supposed to be all zeros anyway\n13 for i, row in enumerate(lcs[1:], 1):\n14 # skip first row; it is supposed to be all zeros anyway\n15 for j, cell in enumerate(row[1:], 1):\n16 if s1[i-1] == s2[j-1]:\n17 cell.value = lcs[i-1][j-1].value + 1\n18 cell.direction = 'up-left'\n19 elif lcs[i][j-1].value == lcs[i-1][j].value:\n20 cell.direction = 'both'\n21 cell.value = lcs[i][j-1].value\n22 elif lcs[i][j-1].value > lcs[i-1][j].value:\n23 cell.direction = 'left'\n24 cell.value = lcs[i][j-1].value\n25 else:\n26 cell.direction = 'up'\n27 cell.value = lcs[i-1][j].value\n28 # The table is built; now to traceback\n29 i = len(s1)\n30 j = len(s2)\n31 node = lcs[i][j]\n32 val = node.value\n33 result = ''\n34 while val > 0:\n35 # Could instead go 'left' on 'both'\n36 if node.direction == 'up' or node.direction == 'both':\n37 i -= 1\n38 elif node.direction == 'left':\n39 j -= 1\n40 else:\n41 i -= 1\n42 j -= 1\n43 # need to prepend since this constructs the lcs in reverse\n44 result = s1[i] + result\n45 node = lcs[i][j]\n46 val = node.value\n47 return result\nTime/Space Complexity\n- Time Complexity:\nO(m \\* n)\n. - Space Complexity:\nO(m \\* n)\n.\nAdditional Reading\nThe final solution can be further improved. One such way is the Hunt-Szymanski Algorithm.\nPractice the Longest Common Subsequence Problem With Our AI Interviewer\nPractice the Longest Common Subsequence Problem With Our AI Interviewer\nLongest Common Subsequence Frequently Asked Questions (FAQ)\nLongest Common Subsequence Frequently Asked Questions (FAQ)\nWhich approach to solving longest common subsequence is the most efficient?\nThe optimal time complexity of the longest common subsequence (LCS) algorithm is O(m \\* n)\n, where m\nand n\nare the lengths of the input strings. This is typically implemented using dynamic programming, where we create a matrix of size (m+1) x (n+1) to store the prefix lengths and fill the matrix iteratively, requiring examining each cell, which takes constant time. Another way to achieve this time complexity is using recursion with memoization, where we ensure no duplicate computations are made when visiting each node in the resursive tree. As a result, the overall time complexity is determined by the number of cells in the matrix or nodes in the recursive tree.\nWhat is the brute force approach to solving the longest common sequence problem?\nThe longest common subsequence (LCS) algorithm can be solved naively with recursion - the algorithm exhaustively explores all possible combinations of characters in both strings and returns the longest length. Without cacheing, this results in a large number of redundant computations, which leads to an exponential time complexity - O(2^(m + n))\n, where m and n are the lengths of the input strings. This inefficiency makes the brute force recursive approach impractical for larger input sizes.\nCan there be more than one longest common subsequence?\nNo, by definition, there can only be one longest common subsequence (LCS) between two strings. The LCS is defined as the longest subsequence that is common to both strings, meaning it appears in both strings in the same order but not necessarily consecutively.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/longest-common-subsequence",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Container With Most Water (Interview Solution)",
      "content": "What Is The Container With Most Water Problem?\nWhat Is The Container With Most Water Problem?\nContainer With the Most Water is a coding problem that involves finding the largest possible area that can be formed by two vertical lines on a graph, bound by the height of the shorter line. This problem can be solved using a two-pointer approach, which involves traversing the array from both sides and keeping track of the maximum area found so far.\nAn Example of the Container With the Most Water Problem\nAn Example of the Container With the Most Water Problem\nGiven n\nnon-negative integers a0, a1, a2, ..., a[n-1]\n, where each represents a point at coordinate (i, a[i])\n, n\nvertical lines are drawn such that the two endpoints of the line i\nis at (i, 0)\nand (i, ai)\n. Find two lines that, together with the x-axis, form a container that can hold the most amount of water possible.\nExample\n- Input:\nheights\n= [3, 9, 4, 8, 2, 6, 1] - Output: 24\nConstraints\n- number of integers n: [2, 10,000]\n- each integer a[i]: [0, 1,000]\nTwo Ways to Solve the Container With the Most Water Problem\nTwo Ways to Solve the Container With the Most Water Problem\nThere are two ways to approach the Container With the Most Water technical interview question: brute force or two pointers.\nApproach 1: Brute Force\nIn the context of this problem, the size of the 2D container is determined by multiplying its width by its height. The brute force approach is to use nested for loops to calculate all possible containers to find the largest one.\nTo accomplish this, we can iterate over the heights with an outer loop, and form a container with every other height to its right using an inner loop. Each subarray that we generate this way is a possible container - the container's size will be the lower of the two heights, multiplied by the distance between the heights.\nWe can track the max container size as we go and return the max container size at the end of our iteration.\nContainer With the Most Water Python, Javascript and Java Solution - Brute Force\ndef max\\_water(heights: list[int]) -> int:\nln = len(heights)\nmax\\_area = 0\nfor left\\_index in range(ln):\nleft\\_height = heights[left\\_index]\nfor right\\_index in range(left\\_index + 1, ln):\nright\\_height = heights[right\\_index]\nwidth = right\\_index - left\\_index\nheight = min(left\\_height, right\\_height)\narea = width \\* height\nmax\\_area = max(area, max\\_area)\nreturn max\\_area\n1def max\\_water(heights: list[int]) -> int:\n2 ln = len(heights)\n3 max\\_area = 0\n4 for left\\_index in range(ln):\n5 left\\_height = heights[left\\_index]\n6 for right\\_index in range(left\\_index + 1, ln):\n7 right\\_height = heights[right\\_index]\n8 width = right\\_index - left\\_index\n9 height = min(left\\_height, right\\_height)\n10 area = width \\* height\n11 max\\_area = max(area, max\\_area)\n12 return max\\_area\nTime / Space Complexity\n- Time complexity:\nO(n²)\n- Space complexity:\nO(1)\n. No need for extra space, since we’re just iterating over the matrix.\nThe nested loops produce O(n²)\ntime complexity.\nApproach 2 (Optimal): Two Pointers\nAlthough the brute force approach does not repeat any calculations, it ignores useful information that can help eliminate unnecessary calculations. For example, if a container has sides a[i]\nand a[j]\nsuch that a[i] < a[j]\n, all containers with sides a[i]\nto a[i+1], ... a[j-1]\nwill have a maximum height of a[i]\nwith a smaller width than j - i\n, producing less area than the original container. Thus, these possibilities do not need to be considered when we're looking for maximum area.\nInstead of trying every combination, we start the 2 pointers at opposite ends (indexes 0\nand n-1\n) to represent the sides of the container. After computing the area using the lower height and distance between the pointers, the options are to increment the left pointer or decrement the right pointer.\nBecause we want to maximize the water contained, move the pointer with the lower height toward the other pointer. If the heights are equal, we can update either pointer because any potential increase in the next height is limited by one of the equal existing heights. The process is repeated until the pointers meet.\nContainer With the Most Water Python, JavaScript and Java Solution - Two Pointers\ndef max\\_water(heights):\nleft\\_index = 0\nright\\_index = len(heights) - 1\nmax\\_area = 0\nwhile left\\_index < right\\_index:\nwidth = right\\_index - left\\_index\nleft\\_height = heights[left\\_index]\nright\\_height = heights[right\\_index]\nmin\\_height = min(left\\_height, right\\_height)\narea = width \\* min\\_height\nmax\\_area = max(area, max\\_area)\nif left\\_height <= right\\_height:\nleft\\_index += 1\nelse:\nright\\_index -= 1\nreturn max\\_area\n1def max\\_water(heights):\n2 left\\_index = 0\n3 right\\_index = len(heights) - 1\n4 max\\_area = 0\n5 while left\\_index < right\\_index:\n6 width = right\\_index - left\\_index\n7 left\\_height = heights[left\\_index]\n8 right\\_height = heights[right\\_index]\n9 min\\_height = min(left\\_height, right\\_height)\n10 area = width \\* min\\_height\n11 max\\_area = max(area, max\\_area)\n12 if left\\_height <= right\\_height:\n13 left\\_index += 1\n14 else:\n15 right\\_index -= 1\n16 return max\\_area\n17\nTime / Space Complexity\n- Time complexity:\nO(n)\n- Space complexity:\nO(1)\nBecause the left or right pointer is moved toward the other in each iteration until they meet, the list of integers is traversed once.\nPractice the Container With the Most Water Problem With Our AI Interviewer\nPractice the Container With the Most Water Problem With Our AI Interviewer\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/container-with-most-water",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to Reverse a Linked List (Python, Java + more)",
      "content": "How to Solve Reverse a Linked List\nWhat is the Reverse Linked List Problem?\nWhat is the Reverse Linked List Problem?\nThe Reverse Linked List problem involves reversing the order of elements in a linked list, a data structure where each node is connected to the subsequent node with a pointer. The goal of this problem is to traverse the linked list while reversing the order of the pointers that link the nodes together.\nReverse Linked List Examples\nReverse Linked List Examples\nGiven the head of a linked list, reverse the list and return the new head.\nExample 1\nInput: [1,2,3,4,5]\nOutput: [5,4,3,2,1]\nExample 2\nInput: [1,2]\nOutput: [2,1]\nExample 3\nInput: [1]\nOutput: [1]\nConstraints\n- The number of nodes in the list is in the range [0, 5000].\n- -5000 <= Node.value <= 5000\nSolution to the Reverse a Linked List Interview Question\nSolution to the Reverse a Linked List Interview Question\nBefore we can reverse a linked list, let’s start our approach with a concrete understanding of how a singly linked list works. After all, this interview question is an opportunity to demonstrate your familiarity with the data structure. Unlike an array, a linked list is a recursive data structure - each node points to another node - which means we don't have random access to its members. Instead, for a singly linked list we're given a head node with a next property that points to the subsequent node in the list. For a doubly linked list, we would also have a prev\nproperty that points to the previous node on the list. Here's an example of a linked list with two listnodes:\nclass Node:\ndef \\_init\\_(self, value=None):\nself.value = value\nself.next = None\nn1 = Node(1)\nn2 = Node(2)\nn1.next = n2\nIn this original linked list, the first node (n1\n) points to the second node (n2\n) with the next\nproperty.\nIf this list were to be reversed, its clear that n2\nwould point to n1\n. But what would n1\npoint to? Recall that while n2\ndoes not have a child because it is at the end of the list, the node's next\nproperty still exists - it simply points to null\n. And while there is no node pointing to n1\n, we can imagine that its parent is null\n. So n1\nwould point to null\n.\nWe can imagine a null\nnode at the head and the tail of the list.\nAt minimum, reversing a given linked list will require updating each node's next\npointer to reference its parent. Since we'll need to visit each node at least once, our solution space is limited to a linear traversal.\nLet's explore how we can update each linked list node in-place with a linear traversal. A linked list can be traversed both recursively and iteratively - in both approaches, we maintain a reference to the current node, its parent, and its child, and re-assign the next\nreference for each node.\n1. Recursive Approach\nSince a linked list is an inherently recursive data structure, it makes sense that we can employ a recursive approach. Let’s consider a post-order recursive traversal to reverse the list. Why \"post-order\"? The key here is to recurse on each subsequent node until the last node is reached, and then update the next\npointers as each execution pops off the call stack.\nEach call to the recursive function reverse\\_list\nis passed in a reference to the current node's child, which adds a new execution frame to the call stack.\nOnce a null\nnode is reached (our base case), we begin the reassignment process. As each context is popped off the stack, we assign the current node's child's next\npointer to the current node, effectively reversing its reference. Then return the reversed list so far.\nWe also set the current node's next\npointer to null\n- this will be overwritten once the subsequent recursive call is resolved, except for the original head which is now the tail and therefore has no next\nnode.\nReverse Linked List Python and JavaScript Recursive Solutions\nclass Solution:\ndef reverse\\_list(curr\\_node: Node) -> Node:\nif not curr\\_node or not curr\\_node.next:\nreturn curr\\_node\nprev = self.reverse\\_list(curr\\_node.next)\ncurr\\_node.next.next = curr\\_node\ncurr\\_node.next = None\nreturn prev\n1class Solution:\n2 def reverse\\_list(curr\\_node: Node) -> Node:\n3 if not curr\\_node or not curr\\_node.next:\n4 return curr\\_node\n5 prev = self.reverse\\_list(curr\\_node.next)\n6 curr\\_node.next.next = curr\\_node\n7 curr\\_node.next = None\n8 return prev\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(n)\nAlthough we are not constructing a new linked list, recursion requires linear space on the call stack to maintain a reference to each execution context.\n2. Iterative Approach\nReversing a linked list with an iterative approach is more space efficient than the recursive solution, and tends to be more easy to grasp. The task of any iterative traversal is managing pointers across iterations.\nFirst, let's set up our state-of-the-world for the head (input) node.\nprev\npoints to null\n(the head has no parent), curr\npoints to the current node (the head), and, if there is indeed a current node, temp\\_next\npoints to the current node's child.\nAt each iteration, we assign the current node's next\npointer to the node at prev\n(reversing the reference). We then iterate forward by pointing prev\nto the current node and curr\nto the original next\nnode.\nWe continue this process until a null\nchild is reached - at which point we can return the most recent prev\nnode which is our new head.\nReverse Linked List Python and JavaScript Solutions - Iterative\nclass Solution:\ndef reverse\\_list(self, node: Node) -> Node:\nprev = None\ncurr = node\nwhile curr:\ntemp\\_next = curr.next\ncurr.next = prev\nprev = curr\ncurr = temp\\_next\nreturn prev\n1class Solution:\n2 def reverse\\_list(self, node: Node) -> Node:\n3 prev = None\n4 curr = node\n5 while curr:\n6 temp\\_next = curr.next\n7 curr.next = prev\n8 prev = curr\n9 curr = temp\\_next\n10 return prev\nTime/Space Complexity\n- Time Complexity:\nO(n)\n- Space Complexity:\nO(1)\nPractice the Reverse a Linked List Problem With Our AI Interviewer\nPractice the Reverse a Linked List Problem With Our AI Interviewer\nReverse a Linked List Frequently Asked Questions (FAQ)\nReverse a Linked List Frequently Asked Questions (FAQ)\nWhat is a linked list?\nA linked list is a data structure that consists of a sequence of nodes, each of which contains two parts: a data element and a reference to the next node in the sequence. The nodes are linked together, forming a chain. Unlike an array, a linked list is a recursive data structure - each node points to another node - which means we don't have random access to its members. Instead, we're given a head node with a next property that points to the subsequent node in the list.\nWhy do you reverse a linked list?\nSince a singly linked list is a directional data structure, the list nodes can only be accessed in a fixed, linear order. There are a few reasons why a software engineer may need to reverse a linked list.\n- Performance optimization: if performing a search operation on a sorted linked list and you're looking for a value at the end of the list.\n- User experience: when displaying a list of messages, you may want the user to be able to reverse the sort order.\n- Traversal: if we are storing something like browser or operation history in a linked list and we want to traverse backward along the same path.\nWhat is the fastest way to reverse a linked list?\nYou can reverse a linked list with either a recursive or iterative approach. Both approaches run in linear time, O(n)\n. The recursive approach requires constant space, and the iterative approach requires O(n)\nspace.\nHow do you reverse a linked list without using recursion?\nYou can use an iterative approach! Reversing a linked list iteratively is more space efficient than recursion and tends to be more easy to grasp. The task of any iterative traversal is managing pointers across iterations. To do this, you’ll need 3 pointers: prev\n, curr\n, and temp\\_next\n. prev\nstarts out pointing to null (the head has no parent), curr\npoints to the current node (the head), and, if there is indeed a current node, temp\\_next\npoints to the current node's child. At each iteration, we assign the current node's next pointer to the node at prev\n(reversing the reference). We then iterate forward by pointing prev\nto the current node and curr\nto the original next node. We continue this process until a null child is reached - at which point we can return the most recent prev\nnode which is our new head.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/reverse-linked-list",
      "author": "",
      "user_id": ""
    },
    {
      "title": "K Closest Points To Origin (Interview Question and Solution)",
      "content": "How to Solve K Closest Points To Origin\nK Closest Points To Origin Introduction\nK Closest Points To Origin Introduction\nThe K Closest Points To Origin problem involves comparing the distance of points plotted on a graph. This is a common problem in data analysis, most often found in the context of generating nearest neighbor sets. Similar to other k-selection algorithms, this problem can be solved with a variety of sorting techniques and challenges us to use a heap data structure to improve time complexity. Before viewing the problem and solution, below are some short video snippets from real mock interviews to help prepare you for some common pitfalls that interviewees stumble into.\n• Problem\n• Solution\n• Interview Analysis: Snippets from Real Interviews 🔥\n-\nCommon Mistakes: Forgetting Data Structures\nEven if you do a good job otherwise, forgetting what a certain data structure looks like could be grounds for failure. Watch this example to see what a real interviewer thinks when this happens. -\nCommon Mistakes: Syntax Errors\nInterviewees often know more than one programming language. Before you interview, you should familiarize yourself with the language you will be interviewing in, especially if it differs from the one you use at work. -\nCommon Mistakes: Variable Names and Data Types\nVariables and data types are foundational concepts, but experienced engineers still make these simple mistakes. -\nSenior Level Extension Question\nSee what separates a senior engineer from a junior/mid-level. -\nPossible Approach: Checking Distance\nFind out how a senior engineer recommends checking distance in this question. It'll surprise you. -\nOptimization: Size Efficiency\nYou've heard the phrase \"Size isn't everything, it's how you use it.\" That couldn't be more true for this question!\nK Closest Points To Origin Problem\nK Closest Points To Origin Problem\nGiven a list of tuples that represent (X, Y) coordinates on an XY plane and an integer K, return a list of the K-closest points to the origin (0, 0).\nExample Inputs and Outputs\nExample 1\nInput:\npoints = [[5, 5], [3, 3], [4, 4]], k = 2\nOutput:\n[[3, 3], [4, 4]] or [[4, 4], [3, 3]]\nExample 2\nInput:\npoints = [[-1, 4], [5, 3], [-1, -1], [8, -6], [1, 2]], k = 2\nOutput:\n[[-1, -1], [1, 2]] or [[1, 2], [-1, -1]]\nConstraints\nThe number of nodes in the list is in the range [0, 5000]\nK is >= 0 and <= the length of the input list\nK Closest Points To Origin Solutions\nK Closest Points To Origin Solutions\nReading through the problem a few ideas immediately jump out:\n- We need to calculate the distance of each point from the origin (or at a minimum convert the coordinate tuple to a numerical value)\n- Once the distance has been calculated we need to determine the K-closest points\nTo solve this problem we will need to do some basic algebra. We have a right triangle and we need to calculate the length of the hypotenuse, and we can do so using the Pythagorean theorem:\nA^2 + B^2 = C^2\nAs a quick aside, we don't actually need to calculate C\n(the hypotenuse, or distance from origin), as simply calculating A^2 + B^2\nfor each coordinate will allow us to order the points from closest to furthest from origin without actually determining the exact distance.\nNow that we know how to calculate the distances, let's explore different ways to find the k-closest points.\n1. Sorting\nGiven we need to find the K\nclosest points to origin, the naive approach should hopefully become clear relatively quickly. If we calculate the distance for each coordinate pair, we can then sort the coordinates by distance and finally slice the list from 0 to K\nin order to return the K\nclosest points to the origin.\nK Closest Points to Origin Python and JavaScript Solutions - Sorting\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n# Note: Sorting the input list mutates the input\n# -> whether the input should be mutated (as opposed to copied and then sorted)\n# -> can be decided collaboratively with the interviewer\npoints.sort(key=lambda xy\\_tuple: xy\\_tuple[0]\\*\\*2 + xy\\_tuple[1]\\*\\*2)\nreturn points[:k]\n1def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n2 # Note: Sorting the input list mutates the input\n3 # -> whether the input should be mutated (as opposed to copied and then sorted)\n4 # -> can be decided collaboratively with the interviewer\n5 points.sort(key=lambda xy\\_tuple: xy\\_tuple[0]\\*\\*2 + xy\\_tuple[1]\\*\\*2)\n6 return points[:k]\nTime/Space Complexity Analysis\n- Time Complexity:\nO(n \\* log(n))\n- Space Complexity:\nO(k)\n, as we are sorting in place and returning a new list withK\npoints\n2. Using a Heap\nGiven we have found a somewhat-obvious, naive solution that runs in O(n\\*log(n))\ntime, we should start thinking about how we can use different approaches or data structures in order to optimize the time complexity of our algorithm. In order to improve our time complexity we will need to avoid fully sorting the input, and if we aren't sorting the input we will need to repeatedly select the point with the smallest distance from the origin.\nIt is here that alarm bells should start to go off in our head. What data structure can be used to efficiently, repeatedly select the smallest (or largest) item in a collection? And the answer is... a heap!\nTo give a quick refresher, heaps are an ordered (but not fully sorted) data structure often backed by an array. They can be created in linear time and they ensure selection of the smallest or largest element at any given time, but they are not fully in order. Read more about how heaps are constructed and used here.\nBack to our problem, we can iterate over the list, calculate the distance from the origin for each coordinate and convert it to a heap in place. From there, in order to find the K\nclosest points to the origin we will need to pop\nfrom the heap K\ntimes, which is often a method exposed via heap library code in a given language.\nK Closest Points to Origin Python and JavaScript Solutions - Using a Heap\nimport heapq\ndef kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n# O(n)\ndistance\\_coordinate\\_tuples = [(x\\*x + y\\*y, [x, y]) for x, y in points]\n# O(n)\nheapq.heapify(distance\\_coordinate\\_tuples)\n# O(k\\*log(n))\nk\\_smallest = heapq.nsmallest(k, distance\\_coordinate\\_tuples)\n# O(k)\nreturn [coordinate for distance, coordinate in k\\_smallest]\n# same as above as a one-liner\ndef kClosest(self, points, k):\nreturn heapq.nsmallest(k, points, key=lambda p: p[0]\\*\\*2 + p[1]\\*\\*2)\n1import heapq\n2def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n3 # O(n)\n4 distance\\_coordinate\\_tuples = [(x\\*x + y\\*y, [x, y]) for x, y in points]\n5 # O(n)\n6 heapq.heapify(distance\\_coordinate\\_tuples)\n7 # O(k\\*log(n))\n8 k\\_smallest = heapq.nsmallest(k, distance\\_coordinate\\_tuples)\n9 # O(k)\n10 return [coordinate for distance, coordinate in k\\_smallest]\n11# same as above as a one-liner\n12def kClosest(self, points, k):\n13 return heapq.nsmallest(k, points, key=lambda p: p[0]\\*\\*2 + p[1]\\*\\*2)\nTime/Space Complexity Analysis\n- Time Complexity:\nO(n) + O(k\\*log(n))\n- Space Complexity:\nO(1)\n(orO(n)\nif you mutate the input)\nPractice the K Closest Points To Origin Problem With Our AI Interviewer\nPractice the K Closest Points To Origin Problem With Our AI Interviewer\nK Closest Points To Origin Analysis\nK Closest Points To Origin Analysis\nCommon Mistakes: Forgetting Data Structures\nOften candidates may have a great understanding of programming and problem solving skills. However if you haven't practised in a while, you may find you have forgotten what some data structures look like or how to fully implement them. In this snippet the interviewer notes that the candidate has a good understanding of algorithms and data structures but struggles with mapping those concepts onto the STL libraries. Noting the fact that the candidate had to look up what a priority queue looked like. In a real interview, this can definitely hinder your chances of passing even though you certainly have the knowledge and capabilities. Practise makes perfect, so ensure you brush up before you interview!\nCommon Mistakes: Syntax Errors\nProspective candidates will often be knowledgeable in more than one programming language. During mock technical interviews, it is important to practise and familiarize yourself with the language you will be interviewing in, especially if it differs from the native language you code in at your current job. In this snippet the the candidate notes that they more comfortable with C++ even though they mainly work with Java on the job. The interviewer points out some syntax errors in the candidate's code, specifically with creating a vector, and suggests a simpler solution. The interviewer speculates that the candidate may be trying to apply Java syntax to their C++ code.\nCommon Mistakes: Variable Names and Data Types\nWhen calculating distance in this question, it is important to use the double data type as opposed to int. This snippet shows the importance of looking out for small mistakes in variable data types and names that can lead to errors when running code.\nSenior Level Extension Question\nMany solutions to the K closest points question do not take into account what would happen if given a large data set of points or a near infinite stream of points. A MapReduce is one solution to this problem. At a mid to senior level there is an expectation that candidates understand how to use a MapReduce. In this example after much deliberation and guidance, the candidate suggests using a MapReduce, but was unsure of the specifics and unable to implement one. The interviewer noted that the candidate's lack of experience with MapReduce could be a concern for a mid-level position, emphasizing the importance of distributed systems in handling large amounts of data. This scenario highlights the practical challenges of scaling algorithms to real-world data and the need for senior-level expertise in handling such issues.\nPossible Approach: Checking Distance\nIn this snippet the interviewer suggests checking if it's the first k instead of checking if the distance is less than the minimum. This is a key tip when tackling similar problems - Often candidates rush into creating a loop and forget to add code to check if you have K.\nOptimization: Size Efficiency\nIn this snippet the candidate suggests optimizing the comparator function by using a map to store distance-to-pair values, rather than recalculating distances each time. The interviewer discuss the potential challenges of working with larger data sets and to explore ways to keep the data size efficient, such as storing only the distance and index of the original point.\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/k-closest-points-to-origin",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Kth Smallest Element (Interview Solution)",
      "content": "How to Solve Kth Smallest Element\nWhat is the Kth Smallest Element Problem?\nWhat is the Kth Smallest Element Problem?\nThe Kth Smallest Element in an Array problem that involves searching through an array of integers and finding the k'th smallest element. Although on the surface this task is trivial, the challenge is in applying advanced sorting algorithms and data structures, such as a heap, recursion, and quickselect, and communicating tradeoffs in time complexity.\nKth Smallest Element in an Unsorted Array Examples\nKth Smallest Element in an Unsorted Array Examples\nGiven an integer array nums\nand an integer k\n, return the kth\nsmallest element in the array.\nExample 1\nInput: nums = [1,5,7,6,4,3,2], k = 3 Output: 3\nExample 2\nInput: nums = [1,1,1,2,2,3], k = 3 Output: 1\nExample 3\nInput: nums = [1], k = 1 Output: 1\nConstraints\n- 1 <= nums.length <= 100000\n- -10000 <= nums[i] <= 10000\nSolution to the Kth Smallest Element Interview Question\nSolution to the Kth Smallest Element Interview Question\nThere are three strategies you can use to solve the kth smallest element in an unsorted array problem — Brute Force, Heap, and Quickselect.\n1. Brute Force\nThe naïve approach to solving the problem would be to:\n- sort the array in increasing order and then,\n- pick the kth element of the array\nHowever, sorting the array would take O(n log(n))\nworst-case time complexity here, where n\nis the size of the array.\nDuring the interview, try not to spend more than 5 minutes discussing the brute force solution. The interviewer will be more interested in the optimal solution(s).\nTime/Space Complexity\n- Time Complexity:\nO(n log(n))\n, wheren\nis the number of elements in nums. - Space Complexity:\nO(1)\n, no additional data structure used.\n2. Heap Approach\nBy using the brute force sorting technique, we are unnecessarily sorting the entire array of n\nelements. Since we are interested only in the kth\nelement in sorted order, we could possibly restrict the sorting/re-arrangement to k\nelements, which would limit the sorted array to a length of k\n. The heap data structure helps us to achieve this optimization.\nHeap Approach Steps\n- Create a max heap of size\nk\n. - Insert each element into the heap - with each insert, we “heapify”, which means we re-sort the elements to satisfy the heap property.\n- If the size of the heap exceeds\nk\n, pop the top element of the heap. - After traversing all the elements of the array, return the top element of the heap.\nNote that if we were looking for the kth largest element, we would perform the same above steps with a min-heap.\nReplacing the top element of the heap of size k\ntakes logk\ntime. So in the worst case, it would be done n\ntimes and effectively, the time taken would be O(nlogk)\n.\nKth Smallest Element Python and Java Solutions - Heap\nimport heapq\nclass Solution:\ndef findKthSmallest(self, nums: List[int], k: int) -> int:\n# 1: Create max heap (simulated by negative values)\nmax\\_heap = []\nfor element in nums:\n# 2: Insert each element to the heap\nheappush(max\\_heap, -element)\n# 3: If the size of the heap exceeds k, pop the element at the top\nif len(max\\_heap) > k:\nheappop(max\\_heap)\n# 4: return top element of max heap\nreturn -heappop(max\\_heap)\n1import heapq\n2class Solution:\n3 def findKthSmallest(self, nums: List[int], k: int) -> int:\n4 # 1: Create max heap (simulated by negative values)\n5 max\\_heap = []\n6\n7 for element in nums:\n8\n9 # 2: Insert each element to the heap\n10 heappush(max\\_heap, -element)\n11 # 3: If the size of the heap exceeds k, pop the element at the top\n12 if len(max\\_heap) > k:\n13 heappop(max\\_heap)\n14\n15 # 4: return top element of max heap\n16 return -heappop(max\\_heap)\nTime/Space Complexity\n- Time Complexity:\nO(n log(k))\n, wheren\nis the number of elements in nums andk\nis the heap size. - Space Complexity:\nO(k)\n, for the heap.\n3. Quickselect Approach\nQuickselect algorithm is an algorithm quite similar to quicksort algorithm where you repeatedly partition a given array based on a pivot element, repeating the process until you have a subarray of length of one. Elements less than the pivot are moved to the left, and elements greater than the pivot are moved to the right. After each partition step, the pivot element is at the correct position in the ordered list. Since we are interested in the kth\nelement, we would have derived that when the pivot element index in the array becomes k-1\n. If the pivot index is greater than target index k-1\n, continue partitioning on the left side; if the pivot index is smaller than target index k-1\n, then partition on the right side. In a particular iteration, if the pivot element index becomes k-1\n, we can return the pivot element itself.\nThe average case time complexity of quickselect algorithm is O(n)\n. However, in the worst case, the time complexity is O(n²)\n— this could be the case when you have lot of repeated elements. Make sure to discuss this with the interviewer before moving on to coding!\nKth Smallest Element Python and Java Solutions - Quickselect\nclass Solution:\ndef partition(self, left: int, right: int, nums: list[int]):\n# get random pivot index\npivot\\_index = random.randint(left, right)\npivot\\_value = nums[pivot\\_index]\n# move pivot element to the end\nnums[pivot\\_index], nums[right] = nums[right], nums[pivot\\_index]\n# when we find an element less than pivot\\_value, move it left of pivot\\_index and increment the swap position\ni = left\nfor j in range(left, right):\nif nums[j] < pivot\\_value:\nnums[i], nums[j] = nums[j], nums[i]\ni += 1\n# move pivot to its final place\nnums[right], nums[i] = nums[i], nums[right]\nreturn i\ndef quickselect(self, left: int, right: int, k\\_target\\_index: int, nums: list[int]):\nif left == right:\nreturn nums[left]\n# find the pivot's correct position\npivot\\_index = self.partition(left, right, nums)\n# if the pivot index is equal to our target, we're done\nif k\\_target\\_index == pivot\\_index:\nreturn nums[pivot\\_index]\nelif k\\_target\\_index < pivot\\_index:\nreturn self.quickselect(left, pivot\\_index - 1, k\\_target\\_index, nums)\nelse:\nreturn self.quickselect(pivot\\_index + 1, right, k\\_target\\_index, nums)\ndef findKthSmallest(self, nums: List[int], k: int) -> int:\nn = len(nums)\nreturn self.quickselect(0, n - 1, k - 1, nums)\n1class Solution:\n2 def partition(self, left: int, right: int, nums: list[int]):\n3 # get random pivot index\n4 pivot\\_index = random.randint(left, right)\n5 pivot\\_value = nums[pivot\\_index]\n6 # move pivot element to the end\n7 nums[pivot\\_index], nums[right] = nums[right], nums[pivot\\_index]\n8 # when we find an element less than pivot\\_value, move it left of pivot\\_index and increment the swap position\n9 i = left\n10 for j in range(left, right):\n11 if nums[j] < pivot\\_value:\n12 nums[i], nums[j] = nums[j], nums[i]\n13 i += 1\n14 # move pivot to its final place\n15 nums[right], nums[i] = nums[i], nums[right]\n16 return i\n17\n18 def quickselect(self, left: int, right: int, k\\_target\\_index: int, nums: list[int]):\n19 if left == right:\n20 return nums[left]\n21 # find the pivot's correct position\n22 pivot\\_index = self.partition(left, right, nums)\n23 # if the pivot index is equal to our target, we're done\n24 if k\\_target\\_index == pivot\\_index:\n25 return nums[pivot\\_index]\n26 elif k\\_target\\_index < pivot\\_index:\n27 return self.quickselect(left, pivot\\_index - 1, k\\_target\\_index, nums)\n28 else:\n29 return self.quickselect(pivot\\_index + 1, right, k\\_target\\_index, nums)\n30\n31 def findKthSmallest(self, nums: List[int], k: int) -> int:\n32 n = len(nums)\n33 return self.quickselect(0, n - 1, k - 1, nums)\nTime/Space Complexity\n- Time Complexity:\nO(n)\nin average,O(n²)\nin worst-case. - Space Complexity:\nO(1)\nPractice the Kth Smallest Element Problem With Our AI Interviewer\nPractice the Kth Smallest Element Problem With Our AI Interviewer\nKth Smallest Element Frequently Asked Questions (FAQ)\nKth Smallest Element Frequently Asked Questions (FAQ)\nHow do you find the kth smallest element in an array?\nThere are 3 ways to solve this problem: brute force, using a heap, and using quickselect. The brute force approach would be to sort the array, and then pick the kth element in the array. This approach runs in O(n log(n))\ntime because you have to sort. A more efficient approach is to use a heap. To do this, you would create a max heap of size k and insert each element into the heap. If the size of the heap exceeds k, pop the top element of the heap. Finally, after traversing all the elements of the array, return the top element of the heap. This approach runs in O(nlogk)\ntime. Finally, you could use quickselect. The idea behind quickselect is similar to quicksort, but instead of sorting the entire array, quickselect only focuses on the elements that are needed to find the kth smallest element. The average case time complexity of the quickselect algorithm is O(n)\n, but in the worst case the time complexity is O(n²)\n- this could be the case when you have a lot of repeated elements.\nWhat's the most efficient way to find the kth smallest element in an array?\nIt depends. Using a heap will run in O(nlogk)\ntime, and using quickselect will run in O(n)\non average but could go up to O(n²)\nin the worst case.\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/kth-smallest-element",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Reverse Words in a String (Python)",
      "content": "What is the Reverse Words in a String Problem?\nWhat is the Reverse Words in a String Problem?\nReverse Words in a String is a programming problem that requires you to take a string of words and return a new string with the order of the words reversed. This problem invites us to use native string and array methods, by looping over the input string in reverse and building a new string to return, and can even be done in-place using languages that permit string mutation.\nAn Example of the Reverse Words in a String Problem\nAn Example of the Reverse Words in a String Problem\nGiven an input string s\n, reverse the order of the words without reversing the words themselves.\nNote that the input string s\nmay contain multiple spaces between any given two words, as well as leading or trailing spaces; however, the return sentence should only have a single space between all words and should not have any leading or trailing space.\nExample 1 Input: s = “This sentence is forwards” Output: “forwards is sentence This”\nInput: s = “ a blue whale rhino Boston arepa heaven “ Output: s = “heaven arepa Boston rhino whale blue a“\nConstraints\n- The string will only contain upper-case and lower-case letters (no punctuation)\n1 <= s.length <= 10,000\nSolutions to the Reverse Words in a String Interview Question\nSolutions to the Reverse Words in a String Interview Question\nThere are two methods for reversing words in a string. One method is splitting on spaces, reversing the list and joining. Alternatively, you can reverse the string in place.\nApproach 1: Split on Spaces, Reverse the List and Join\nThis specific problem can be tackled in a manner similar to how we'd approach it if we were solving manually (remember, in an interview setting you always want to communicate your strategy, especially for multi-step solutions like this):\nIdentify all the individual words at the beginning and end of the string, and then trim/eliminate the unneeded space. Reverse the order of the words and build the string back up to form the result.\nDiving into the code, most modern programming languages provide a standard library method to split a string on a given character, in this case ” “\n.\nReverse Words in a String Python and Ruby Solutions - Split on Spaces, Reverse the List and Join\ns = “ this is a string “\nwords = s.split(“ “)\nprint(words) # ['', 'this', 'is', '', 'a', 'string', '', '']\n1s = “ this is a string “\n2words = s.split(“ “)\n3print(words) # ['', 'this', 'is', '', 'a', 'string', '', '']\nWhen we use this method, note how both trailing and leading spaces end up in the words list as empty strings. We can then filter\nthe words list in order to remove the empty strings:\nwords = s.split(“ “)\nfiltered\\_words = [s for s in words if s != '']\nprint(filtered\\_words) # ['this', 'is', 'a', 'string']\n1words = s.split(“ “)\n2filtered\\_words = [s for s in words if s != '']\n3print(filtered\\_words) # ['this', 'is', 'a', 'string']\n4\nAll we have left to do now is reverse the list and join the words with a space between them, and in the end we have a fairly straightforward algorithm.\nclass Solution:\ndef reverseWords(self, s: str) -> str:\nwords = s.split(' ')\nfiltered\\_words = [s for s in words if s != '']\nreturn ' '.join(filtered\\_words[::-1])\n1class Solution:\n2 def reverseWords(self, s: str) -> str:\n3 words = s.split(' ')\n4 filtered\\_words = [s for s in words if s != '']\n5 return ' '.join(filtered\\_words[::-1])\n6\nTime/Space Complexity\n- Time complexity:\nO(n)\n, as the interpreter iterates over the input string once and the list of words twice. - Space complexity:\nO(n)\n, to store the list of words after splitting by spaces.\nApproach 2: In-place\nLet’s pretend that you find yourself in an interview and your interviewer has asked a follow up question: “Is it possible to solve this problem and be more efficient from a space complexity standpoint?”\nWe already know our first solution is O(n)\n, leaving O(log(n))\nand O(1)\nas the two most common ways to improve. A log(n)\nalgorithm is most often related to dividing and conquering or binary search, and neither of those concepts apply here. So how can we make our solution constant space? We aren’t allowed extra memory, so the only way to do so is by mutating the string in place.\nDepending on the coding language being used, strings are either mutable or immutable. If a given language has immutable strings this means that the string can't be edited in-place without creating a new string in memory (which is a O(n)\noperation, with n\nbeing the length of the string). Conversely, if a given language has mutable strings that means the string can be edited in-place, similar to an array/list.\nFor example, in Ruby:\ns = ‘0123456789’ # note this is a string\ns[1..8] = s[1..8].reverse\n# the ruby version of print() or console.log()\nputs s # ‘0876543219’, as ‘12345678’ has been reversed in-place\n1s = ‘0123456789’ # note this is a string\n2s[1..8] = s[1..8].reverse\n3\n4# the ruby version of print() or console.log()\n5puts s # ‘0876543219’, as ‘12345678’ has been reversed in-place\n6\nTo read more about mutable vs immutable strings, check out this article on the topic by MIT.\nIf coding in a language with immutable strings (Python, Javascript, Java, etc.) mutating the string will not work, however there may be classes or libraries (such as Stringbuilder in Java) that would allow you to employ a similar approach - an interviewer may let you just assume you have one of these imported.\nTo mutate the string in place the algorithm can again be broken down into multiple steps:\n- Identify the distinct words by iterating over the string looking for spaces\n- Reverse the words in place one word at a time, trimming/skipping extra spaces while iterating\n- Trim any unneeded space from the end of the string\nReverse Words in a String Ruby Solution - In-place String Mutation\ndef reverse\\_words(s)\ns.reverse!\nl = 0\nr = 0\ni = 0\nn = s.length\nwhile i < n\n# find the next space\nwhile i < n and s[i] != ' '\ns[r] = s[i]\nr += 1\ni += 1\nend\nif l < r\n# reverse the current word\ns[l..r-1] = s[l..r-1].reverse\ns[r] = ' '\nr += 1\nl = r\nend\ni += 1\nend\n# trim end of string since we have shuffled string to the left\ns.slice!(r..s.length)\ns.strip!\nreturn s\nend\n1def reverse\\_words(s)\n2 s.reverse!\n3\n4 l = 0\n5 r = 0\n6 i = 0\n7 n = s.length\n8\n9 while i < n\n10\n11 # find the next space\n12 while i < n and s[i] != ' '\n13 s[r] = s[i]\n14 r += 1\n15 i += 1\n16 end\n17\n18 if l < r\n19 # reverse the current word\n20 s[l..r-1] = s[l..r-1].reverse\n21\n22 s[r] = ' '\n23 r += 1\n24 l = r\n25 end\n26\n27 i += 1\n28 end\n29\n30 # trim end of string since we have shuffled string to the left\n31 s.slice!(r..s.length)\n32\n33 s.strip!\n34\n35 return s\n36\n37end\n38\nTime/Space Complexity\n- Time complexity:\nO(n)\n, as we iterate over the string with multiple pointers but only do one iteration of each pointer. - Space complexity:\nO(1)\nPractice the Reverse Words in a String Problem With Our AI Interviewer\nPractice the Reverse Words in a String Problem With Our AI Interviewer\nReverse Words in a String Frequently Asked Questions (FAQ)\nReverse Words in a String Frequently Asked Questions (FAQ)\nHow do you reverse each word in a string?\nThere are two approaches you can take. The first is to split the string on spaces, reverse each word individually (see our in-depth solution to “reverse a string”), and then join them back. This approach runs in O(n)\ntime and requires O(n)\nspace.\nA more space-efficient solution is to reverse the entire sentence in place. Note that this approach only works in languages where strings are mutable. To mutate the string in place, you would identify words by iterating over the string looking for spaces. Then you’d reverse the words in place one word at a time. Finally you’d trim any unneeded spaces from the end of the string.\nThis solution still runs in linear time but requires only constant space.\nWhy can’t I just use the reverse() function to solve this problem?\nYou can… if you’re implementing sentence reversal in the real world. In an interview, however, you need to show your interviewer that you know how built-in functions work under the hood – that’s part of why interviewers ask questions like this.\nHow do you reverse each word in a string in Python?\nBecause strings are immutable in Python, you wouldn’t be able to reverse the string in place. As such, you can use the approach where you split the string on spaces, reverse each word, and then join them back, like so:\ndef reverseWords(self, s: str) -> str:\n3 words = s.split(' ')\n4 filtered\\_words = [s for s in words if s != '']\n5 return ' '.join(filtered\\_words[::-1])\nWatch These Related Mock Interviews\nAbout interviewing.io\ninterviewing.io is a mock interview practice platform. We've hosted over 100K mock interviews, conducted by senior engineers from FAANG & other top companies. We've drawn on data from these interviews to bring you the best interview prep resource on the web.",
      "content_type": "blog",
      "source_url": "https://interviewing.io/questions/reverse-words-in-a-string",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Nil Mamano",
      "content": "Media Kit\nBio\nMini\nCS PhD from UCI specializing in algorithm design. Author: Beyond Cracking the Coding Interview. Former senior SWE at Google.\nShort\nCS PhD from UC Irvine specializing in algorithms and data structures. Co-author of Beyond Cracking the Coding Interview. Former senior SWE at Google.\nMedium\nNil Mamano is a computer scientist with a PhD from UC Irvine and the co-author of Beyond Cracking the Coding Interview. His PhD research focused on algorithms and data structures, co-authoring nine peer-reviewed papers with contributions to graph algorithms, computational geometry, computational biology, and recreational mathematics. He previously worked as a senior software engineer at Google, working on scaling the networking infrastructure. Additionally, he developed the technical curriculum for coding interview prep at Pathrise.\nHeadshot\nRegular\nSquare",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/media-kit",
      "author": "",
      "user_id": ""
    },
    {
      "title": "In Defense of Coding Interviews",
      "content": "In Defense of Coding Interviews\nThere is already a lot of discourse about everything wrong with coding interviews. Indeed, one of the first chapters in Beyond Cracking the Coding Interview is What's Broken About Coding Interviews? (it's one of the sneak peek free chapters in bctci.co/free-chapters).\nHere, I want to collect all the arguments for the contrary view: that there are no clear better alternatives to coding interviews at Big Tech companies.\nDisclaimers:\n- I am one of the authors of Beyond Cracking the Coding Interview, a prep book for coding interviews. Thus, I am vested in coding interviews not going away.\n- I love leetcoding and specialized in DS&A for my PhD, so I haven't personally experienced the dread that most people feel grinding it.\n- I've been an interviewer at Google in the past, but I'm not currently working for Big Tech, and I don't have any inside knowledge. This is just my assessment.\n- This post is only about Big Tech. I don't think coding interviews are a good idea for startups.\n- This post contains \"Strong Opinions, Weakly Held\". I believe everything here, but I'm very receptive to pushback and opposing data.\nThe rationale for coding interviews\nI think Big Tech companies understand that being cracked at DS&A is not really necessary to be a good SWE. I don't think coding interviews are about that at all.\nImagine you are a Big Tech company, like Google. You receive a massive stream of applications, and you have to trim that down to a still large number of hires. Your hiring system needs to be scalable:\n- you need to quickly train many interviewers\n- you need a way to evaluate candidates that minimizes interviewer bias (not your bias, or a specific person's bias, but all the biases of a large, heterogeneous group)\nSo, the first thing you do to scale--in true engineering fashion--is decoupling hiring and team matching. But that means you cannot hire for specific tech or domain experience: You don't know in what team candidates will end up, and your teams use a bunch of different languages and tech stacks (and a lot of it is internal anyway, so you definitely can't hire for that).\nSo, you need a competence assessment that is independent of any particulars about the job, much like the role the SAT plays for college admissions. How do you do that?\nIf you are a Big Tech company, what you actually want is candidates who can take any complex software system (that's not part of the candidate's previous expertise) and answer hard questions about it, like what's the best way to add a feature, how to optimize it, or how it should be refactored. In other words, the competence you want to assess is general problem-solving skills, and that's what coding interviews are designed for: you are given a tough problem that you have ideally never seen before (more on this later), and asked to showcase your thought process on how you approach it. When working as intended, I believe it gives more signal about your problem-solving skills and is easier to evaluate impartially than other popular interview formats, like talking about previous experience or take-home assignments. And there's an impartial way to evaluate them, by looking at the optimality of the solution.\nYes, there's a lot more to being a SWE than problem-solving skills--and that's why Google also does system design and behavioral interviews, but you still want to hire for this trait.\nThe two crucial flaws: memorization and cheating\nHopefully, the rationale above covered one of the most common criticisms of coding interviews: that they do not reflect the day-to-day work of an engineer. Instead, I want to focus on what I think are the two biggest issues with coding interviews:\n-\nMemorizing an absurd amount of leetcode problems gives you an edge. This is the classic reason why people hate coding interviews with a passion. It has led to an \"arms race\" where candidates have to memorize more and more problems to improve their odds, and interviewers keep asking about more niche topics. At the extreme, coding interviews end up feeling like a lottery, and candidates find prep a soul-sucking waste of time.\n-\nCheating has become easy with AI. This is a newer issue that's becoming more prevalent due to the fact that LLMs are pretty good at leetcoding. In real time, a cheater can feed the problem statement to an LLM (without obvious tales like \"select all\"), get a solution, and even a script for what to say.\nFrom the company's side, Issue (1) is not much of an issue. It definitely undermines the \"problem-solving\" part of the interview if a candidate is just recalling the question, but, statistically, if they do enough rounds, it's unlikely to happen every round. Some people (not me) also argue that the memorization is even good for the companies because it rewards hard work and dedication.\nFor what it's worth, one thing we hoped to change about the interview prep discourse with BCtCI is that candidates should focus on improving their problem-solving skills rather than memorizing. See, for instance, how we teach binary search or how we approach hard problems. But yes, grinding is still necessary.\nIssue (1) also means that they'll lose a big chunk of candidates who are great SWEs but won't put up with grinding leetcode or that simply don't perform well under pressure (and, from personal experience, many great developers fall in this group). This sucks from the candidate's perspective, but if you are Google, you receive an overwhelming amount of applications from qualified candidates, so you are more OK with rejecting good candidates than accepting bad ones.\nIssue (2), on the other hand, has the potential to completely ruin coding interviews from the company's side. I'm seeing a quick rise of stories from frustrated interviewers who interviewed or even hired cheaters who could then not do the job (Exhibit A).\nI expect to see some kind of systematic response to this from Big Tech, but it's not clear what as of April 2025. This article includes some internal comments from Google execs:\n[Brian] Ong [Google’s vice president of recruiting] said candidates and Google employees have said they prefer virtual job interviews because scheduling a video call is easier than finding a time to meet in available conference rooms. The virtual interview process is about two weeks faster, he added.\nHe said interviewers are instructed to probe candidates on their answers as a way to decipher whether they actually know what they’re talking about.\n“We definitely have more work to do to integrate how AI is now more prevalent in the interview process,” said Ong. He said his recruiting organization is working with Google’s software engineer steering committee to figure out how the company can refine its interviewing process.\n“Given we all work hybrid, I think it’s worth thinking about some fraction of the interviews being in person,” Pichai responded. “I think it’ll help both the candidates understand Google’s culture and I think it’s good for both sides.”\nI thought going back to in-person interviews would be a no-brainer for a company like Google, but my reading of these comments is that they don't seem too bothered for now. ~shrug~\nDisclaimer: I haven't worked for a Big Tech company since before AI cheating went viral, so I don't have internal insight into what people in charge of hiring are actually thinking.\nTwo related arguments that I don't subscribe to are (1) that leetcode-style interviews are no longer relevant because AI can solve them, and (2) that LLMs should be allowed during coding interviews because they are allowed on the job. The fact that AI can solve coding questions doesn't change that it still gives you the important signal that you want from humans: algorithmic thinking and general problem-solving skills. We just need humans to not cheat.\nI'll share my thoughts on how to improve coding interviews to address these issues. First, let's see why I think the alternatives are not better.\nThe problems with the alternatives\nTake-home assignments\nTake-home assignments are even more subject to cheating, so that can't be the answer to cheating. Never mind LLMs, you don't even know who did the assignment. But take-home assignments have other flaws:\n- They create an asymmetry between company and candidate, where the company asks for a ton of work from the candidate without putting any effort in. \"Oh, we have way too many candidates we need to filter down to a shortlist? Send all of them a complex task to do over the weekend.\" I prefer a model where both company and candidate have to put in time. I'm more OK with take-home assignments as the final stage of the process.\n- They favor people who are unemployed and/or have a lot of free time to polish the assignment.\nPrevious experience\nI find this too subjective to give signal about problem-solving skills, and it's more about being a good \"salesperson\". I also think it's more subject to bias: people with a similar background as yours are probably more likely to have similar interests, and thus you may find their side-projects more interesting.\nTrial periods\nThis makes sense to me in smaller companies, where you find a candidate with the perfect profile for the task at hand. It doesn't scale to Big Tech companies.\nOther alternatives\nIf there are other alternatives that fulfill the same purpose as coding interviews but don't suffer from the same issues, I'd love to hear about them.\nOne idea I liked is going through a code review during the interview, but it's not clear that (1) it offers as much signal about problem-solving skills, and (2) it is easy to evaluate impartially.\nHow to improve coding interviews\nRight now, FAANG interviewers focus too much on \"Did they solve the question or not?\" That's because they don't get much training on how to interview well (if at all), and it's the most straightforward way to pass on a hire/no hire recommendation to the hiring committee. This leads to many interviewers just pasting the prompt in and mostly sitting in silence. This is the ideal scenario for cheaters.\nThe obvious things\nThere are obvious ways to improve this situation:\n- In-person interviews. These have other benefits, like allowing the candidate to get a better sense of the company culture.\n- Not using publicly available questions, and actively scanning for leaks.\n- Cheating detection software (privacy is a concern here -- would it be too crazy for a company to ship a laptop to the candidate just for the interview?).\n- Stop asking questions that require knowing some niche trick that a normal person wouldn't be able to figure out on the spot. Those reinforce a focus on memorization.\nLow effort ways of countering cheating\nI also think that measures designed to throw LLMs off could be effective (at least in the short term) and require minimal effort, such as:\n- Stating the question, or part of it, instead of writing the whole thing down\n- Including a 'decoy' question and telling the candidate, \"Ignore that line, it is part of our anti-cheating measures.\"\nSee LinkedIn discussion.\nA fundamental tradeoff\nPerhaps the most effective way to counter both memorization and cheating is to make coding interviews more open ended and conversational. To use a chess analogy, a cheater may make a great move, but if you ask them to explain why they did it, they may not be able to.\nThe interviewer can use a coding question as a launching point, but then drill down on technical topics as they come up. So, e.g., if a candidate chooses to use a heap, the interviewer could go into:\n- What made you think of using a heap? What properties are important for this problem?\n- What are the tradeoffs of using a heap vs binary search trees?\n- How would you go about implementing a heap that supports arbitrary priorities?\n- Why is heapify faster than inserting one by one?\nIf interviewers did that, it wouldn't even be necessary to ask tricky questions. They could even ask Fibonacci.\nThe problem is that, the more open ended the interview is, the more difficult it is to evaluate candidates systematically. To start, you'd need better interviewers and better interviewer training. However, it seems to me that there is a fundamental tradeoff between how objective the evaluation is and how gameable the interview is by memorizing or cheating.\nI don't have a good solution to this--I would love to hear yours.\nMore good things about coding interviews\nOnly one thing to study\nAn underrated upside of leetcode interviews is that you only need to study one thing for all the big companies. I feel like if every company asked different things, interview prep time would decrease for any specific company but increase overall.\nIn fact, a likely outcome of the push for fewer leetcode-style interviews is an even worse compromise: coding interviews won't completely go away, so you'll still need to grind leetcode, but you'll also have to prep a bunch of specialized stuff for each company on top of that.\nSee LinkedIn discussion.\nThey are not based on pedigree\nCoding interviews act as a form of standardized testing, similar to the role of SAT for college admissions in the US. And, much like the SAT allows high-school students from all backgrounds to attend top colleges, coding interviews allow candidates from all backgrounds to get at the top companies. The leetcode grind is the same for everyone.\nIf we kill coding interviews without a good alternative, it seems inevitable that Big Tech companies will give more weight to resume and referrals. We all agree that's a bad thing.\nFinal thoughts\nThe best question we got in our Reddit AMA for BCtCI was whether we'd use coding interviews ourselves if we were in charge of hiring. You can see Gayle's, Mike's (mikemroczka.com), and my answers. We all said no in its current form, but yes with caveats/improvements.\nMy favorite answer was Mike's. He's less of a proponent of leetcode-style interviews than I am, but I think he strikes a thoughtful balance between DS&A and practical stuff:\nBest question so far. Yes, I would ask DS&A questions still, but not exclusively and not difficult ones. Many startups shouldn't ask them though, because most people are bad at discerning what a reasonable question is.\nI would do 4-5 rounds of interviews because less than that is hard to be significant, but more than that and you're wasting too much of a candidate's time (Netflix has a whopping 8 rounds!!). For a senior engineer role, I'd do something like this.\nRound 1: An online DS&A assessment to filter out people that can't do the simple things (easy & very simple medium questions only, not hard)\nRound 2: Live interview of DS&A (simple medium, not hard. essentially just making sure you didn't cheat on the previous round by asking you to explain your answers and code something new from scratch)\nRound 3: System design (no need for perfect answers, but I'd ask an uncommon question to ensure it was something they hadn't memorized)\nRound 4: Behavioral, with a focus on cross-team impact. This would just be a simple pass/fail and just a vibe check. It might also be skipped if the prior two rounds had good signal for emotional intelligence\nRound 5: Remote logging into a server and working on an actual bug that was fixed in our codebase before. There would be no time limit, but time on the server would be logged to weed people out who needed days to complete a simple task.\nThis ends up testing a little bit of theory, practical knowledge, emotional intelligence, and the generalized SWE skillset.\nFull disclosure. This is my answer. Not the answer of every author. Again, I'd stress that the average startup wouldn't benefit from DS&A and shouldn't be asking them\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/in-defense-of-coding-interviews",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Get Binary Search Right Every Time, Explained Without Code",
      "content": "Get Binary Search Right Every Time, Explained Without Code\nOne of the things that makes binary search tricky to implement is that you usually need to tweak the pointer manipulation logic in subtle ways based on the specifics of the problem.\nE.g., an implementation that works for finding a target in a sorted array when the target is present, may not work if the target is missing. Or, it may not be clear how to tweak the code to find the last occurrence of the target instead of the first one. And of course, there are plenty of less conventional applications of binary search where the input is not an array, like catching bike thieves.\nIn Beyond Cracking the Coding Interview, we wanted to simplify this, so we went looking for a general binary search template. Going into it, I thought we might need at least two templates, but we ended up with just one, which we called the \"transition point recipe\", and which works for every problem we tried, including the 17 problems in the binary search chapter of the book. If you find one where it doesn't work, let me know!\nThe transition point problem\nHere is the thesis of the transition point recipe:\nEvery binary search problem can be reduced to the 'transition point problem'.\nIn the 'transition point problem', you are given an array with just two values, say 1\nand 2\n, where all the 1\ns come before the 2\ns, and you need to point where it changes.\nE.g., in the array [1, 1, 1, 1, 1, 2, 2, 2]\n, the last 1\nis at index 4\nand the first 2\nis at index 5\n.\nKnowing how to solve this specific problem is key to our recipe. The specific binary search implementation is not important, but there is an invariant we can follow that makes it quite easy: ensure that the left pointer is always at a 1\nand the right pointer is always at a 2\n.\nWe give code in the book, but remembering exact code in an interview is error prone. Instead, the four bullet points below are all I personally remember, and I feel confident that I can derive the rest easily.\n- Start by handling some edge cases:\n- The array is empty\n- Every value is\n1\n- Every value is\n2\n- Initialize two pointers,\nleft\nandright\n, to the first and last indices, respectively. - For the main binary search loop, always maintain the invariant that the value at\nleft\nis1\nand the value atright\nis2\n. Let this invariant guide your pointer manipulation logic, so that you don't need to memorize any code. - Stop when the\nleft\nandright\npointers are next to each other (i.e.,left + 1 == right\n).\nCombining the invariant with the stopping condition, we get that, at the end, left\nwill be at the last 1\nand right\nwill be at the first 2\n.\nThese bullet points rely on two ideas to make binary search easier: (1) handling edge cases upfront, and (2) letting strong invariants guide the implementation. Notice how the invariant even guides the edge cases at the beginning, as they are the necessary ones to be able to initialize left\nand right\nin a way that satisfies it.\nThe reduction\nOk, so now, let's take for granted that we can solve the transition point problem. How does this help us solve other binary search problems?\nThe idea is to come up with a (problem-specific) predicate, like < target\n, >= target\n, or x % 2 == 0\n, which splits the search range into two regions, the \"before\" region and the \"after\" region.\nThis predicate is a function that takes an element of the search range and returns a boolean, and -- as you probably saw coming -- it is key that all the elements with true\nvalues come before the elements with false\nvalues (or the other way around).\nThen, we can use the solution to the transition point problem to find the transition point between the 'before' and 'after' regions. The only difference is that, instead of checking boolean values directly, we check the result of the predicate.\nYou can even wrap the predicate in a function, which we called is\\_before(x)\nin the book, which tells you whether a given element is in the 'before' region. Then, it's really obvious that we are just solving the transition point problem every time.\nThe only part that requires some thinking is choosing the right transition point. For example:\n- if we want to find the first occurrence of\ntarget\nin a sorted array, we can useis\\_before(x) = x < target\n, which means that, iftarget\nis present, the first occurrence is the first element in the 'after' region (so, we can check/return theright\npointer at the end). - if we want to find the last occurrence of\ntarget\nin a sorted array, we can useis\\_before(x) = x <= target\n, which means that, iftarget\nis present, the last occurrence is the last element in the 'before' region (so, we can check/return theleft\npointer at the end).\nAnd so on for other problems.\nPractice\nYou can try the transition-point recipe on all the problems from the binary search chapter of the book online at start.interviewing.io/beyond-ctci/part-vii-catalog/binary-search, even if you don't have the book. There, you can also find all our solutions using the recipe, in Python, JS, Java, and C++.\nBy the way, the binary search chapter of the book is free -- it's in bctci.co/free-chapters.\nWant to leave a comment? You can post under the linkedin post or the X post.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/binary-search",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Problem Solving BCtCI Style",
      "content": "Problem Solving BCtCI Style\nHere's a thought: You don't want the first time you think about the question \"What should I do if I get stuck in a coding interview?\" to be when you are stuck in a coding interview.\nIn a way, getting stuck in a coding interview is an opportunity. The main goal of the interview is to see your problem-solving thought process, and being stuck is the ideal time to showcase it.\nBut you want to be prepared. It's valuable to have a plan for this exact scenario. We all dread blanking out in an interview, but having a plan makes it easy to simply focus on executing it. So, let's talk about what such a plan could look like in this blog post.\nIn Beyond Cracking the Coding Interview, we go over all the steps in an interview, and our best tips to do well in each of them:\nIn this blog post, I'll zoom in on the problem-solving step, \"Design the Algorithm,\" and illustrate the thought process with a problem.\nAs you can see, we break it down into four steps:\n- Minimally sketch the naive solution to establish a baseline.\n- Identify upper and lower bounds using big O analysis to narrow down the range of possible solutions.\n- Look for triggers (Keywords) that point to a specific approach.\n- Employ boosters: problem-solving strategies that give you the \"boost\" you need when you are stuck.\nThese are not revolutionary ideas -- it's what good problem solvers do and think about instinctively. One of the main goals of the book, and of this blog post, is to spell out the thought process of people who are really good at this in a relatable way so that anyone can reproduce it.\nWe playfully call this the MIKE template (Minimally sketch brute force, Identify bounds, Keywords (triggers), Employ boosters) after Mike Mroczka, one of the authors of BCtCI.\nRather than expanding on these now, we'll see them in action with the following problem.\nProblem Statement\nThe problem is based on LeetCode 3458, which appeared in a recent contest. You can go and give it a try before reading on (it's labeled as medium, but I think it's on the harder end of medium). The thought process I'll walk through here is based on how I solved it during the contest.\nGiven a string s\n, a substring of s\nis special if any character in it does not appear outside it.\nFor example, if s\nis \"abcba\"\n:\n\"bcb\"\nis a special substring because'b'\nand'c'\ndo not appear ins\noutside\"bcb\"\n.\"abc\"\nis not a special substring because'a'\nappears ins\noutside\"abc\"\n.\nGiven a string s\nconsisting of n\nlowercase English letters, determine the maximum number of disjoint special substrings. Two substrings are disjoint if they do not overlap.\nExample 1: s = \"abcba\"\nOutput: 1\nThe special substrings are \"abcba\", \"bcb\", and \"c\". They all overlap with each other, so we can only pick 1.\nExample 2: s = \"banana\"\nOutput: 2\nThe special substrings are \"b\", \"banana\", and \"anana\". We can pick \"b\" and \"anana\".\nConstraints:\n2 <= n <= 10^5\ns\nconsists only of lowercase English letters.\nDigesting the problem\nFirst, we need to digest what the problem is asking. This problem follows a common pattern: it introduces a kind of esoteric definition, \"special substring\", and then asks us to do something with it.\nTo make sure we understand what a special substring is, it's good to look at a few examples, starting with the provided ones. For instance, in \"abcba\"\n, do you understand why \"a\"\nis not special but \"c\"\nis?\nTake some time to come up with your own examples. Rushing to solving a problem before understanding it well is a common but often costly mistake.\nApproach\nSometimes, it helps to tackle just one part of the problem first, so we can start making progress.\nWe can think of an algorithm with 2 parts:\n- Part A: Find all the special substrings.\n- Part B: Find the most non-overlapping special substrings.\nLet's start with part A.\nPart A: Find all the special substrings\nWe'll walk through the MIKE template.\nM: Minimally sketch brute force\nThe key here is to not overthink it. We just want to get the ball rolling and have a baseline we can improve upon.\nSince we don't want to spend too much time in an interview, you could even just describe the idea in a sentence and move on. But we prefer to briefly sketch it in very high-level pseudocode. We call it 'intended English': it's written like English, but with indentation to show the code structure:\nAlgo 1: brute force\nT: O(n^4)\nfor each possible substring start\nfor each possible substring end\n# check if it is special\nfor each letter inside the substring\nfor each letter outside the substring\nif they match, it is not special\nInterviews often involve considering trade offs between algorithms, so it's a good habit to give them names and list their time/space complexity.\nIn this case, the space complexity depends on how many special substrings we might find, which is not clear yet, so we'll leave it out for now.\nSketching the brute force solution helps us ensure we understand the problem (and if we are solving for the wrong thing, we give the interviewer a chance to let us know).\nI: Identify upper and lower bounds\nWe can use big O analysis to narrow down the range of possible solutions. An upper bound means \"we don't have to consider any solution that takes longer than this\", and a lower bound means the opposite: \"we don't have to consider any solution that takes less time than this\". In the book, we go over two ways of establishing an upper bound and two ways of establishing a lower bound:\nUpper bounds:\n- Brute force upper bound: we just saw that we can find all special substrings in\nO(n^4)\ntime, so we don't have to consider any solution that takes longer than that. - TLE (Time Limit Exceeded) upper bound: here is where we use the problem constraints to establish an upper bound. The problem says that\nn <= 10^5\n, which usually means thatO(n^2)\nsolutions are too slow, butO(n log n)\nor faster solutions are fine.\nLower bounds:\n- Output-size lower bound: the space taken by the output is a lower bound for the time complexity, because that's how long it takes just to write the output. In our case, the output of the overall problem is just a number, so this lower bound is trivial:\nO(1)\n. Bounds are not always useful! - Task-based lower bound: some problems involve an inherent task that any solution must fulfill. The runtime of this task is a lower bound. In this case, we know we at least need to read every letter in the input, so we have a lower bound of\nO(n)\n. In other words, we can rule out solutions that takeO(log n)\norO(1)\ntime.\nCombining our findings, we can narrow down our search range to O(n log n)\nor O(n)\nalgorithms (something like O(n log^2 n)\nwould also be fine, it's just less common).\nK: Keywords (triggers)\nThere are certain properties of problems that point to a specific approach. Here are some triggers we can identify for this problem:\n- finding substrings\n->\nsliding windows O(n log n)\npossible target complexity->\nsorting or heaps\nUnfortunately, triggers are not a guarantee, and these triggers don't seem to help for this problem:\n- In sliding windows, once you move past a character, you don't later go back. So, in Example 1, it would be impossible to find both\n\"abcba\"\nand\"bcb\"\n: if you find\"abcba\"\nfirst, the right pointer would have to go back to find\"bcb\"\n. But if you find\"bcb\"\nfirst, the left pointer would have to go back to find\"abcba\"\n. - Sorting doesn't seem like a good fit because the input order is important.\nDo you think I missed any other triggers?\nE: Employ boosters\nSo, triggers didn't help, and brute force is still far from the target complexity. It's time to employ boosters.\nHere's an overview:\nThe boosters are roughly ordered, but we don't always have to use them in order. In fact, here's a plot twist: what we did at the beginning, splitting the problem into two parts, is the third booster: Decrease the Difficulty ->\nBreak Down the Problem.\nBooster 1: Brute force optimization\nThe first booster is straightforward: take the brute force pseudocode we already have and try to optimize it.\nIn the boosters diagram, we list three ways to go about it. One of them is the Data structure pattern. Many bottlenecks come from having to do some calculation inside a loop. In those situations, ask yourself,\n\"Do I know of any data structure which makes this type of operation faster?\"\nFor this problem, we can use a hash set to optimize the innermost loop:\nAlgo 2: set optimization\nT: O(n^3)\nfor each possible substring start\nfor each possible substring end\n# check if it is special\ndump the substring into a set\nfor each letter outside the substring\nif it is in the set, it is not special\nIf you have working code or pseudocode but think of an optimization or better approach, do NOT edit your code. Copy-paste it and work on a separate copy. This way, if you don't have time to finish or realize it's wrong, you'll still have the previous working version.\nBooster 2: Hunting for properties\nWe got down to O(n^3)\ntime, but we know we still need to bring this down to the target complexity.\nLet's say we don't know how to optimize the code further. Often, the breakthrough comes from uncovering some \"hidden\" observation or property not explicitly mentioned in the statement. Our second booster is to go hunting for those.\nIn the book, we discuss a bunch of ways of doing this, but the most basic and effective one is to try to solve the problem manually with a non-trivial example. By non-trivial, we mean that is is not some weird edge case, which would not be helpful for figuring out a general algorithm.\nLet's actually do that: take s = \"mississippi\"\nand manually try to find all the special substrings.\nDon't overthink it. Don't think about algorithms yet. Just write them down.\nDone? Ok, now try to reverse-engineer what shortcuts your brain took. This is one property you may have noticed:\nProperty 1\nProperty 1: a special substring must start at the first occurrence of a letter.\nYou may have noticed this property when your brain skipped over the second, third, or fourth 'i'\ns in mississippi\nand intuitively realized that there is no special substring starting at those. Writing down the property formalizes this instinct and ropes in the interviewer.\nNow that we have a property, we have to find a way to use it. Property 1 allows us to optimize the outer loop: it means we only have 26 = O(1)\npossible starts to check (problems where the input consists of only lowercase letters often have optimizations like this).\nAs we iterate through the possible starts, we can track letters seen so far (e.g., in a hash set):\nAlgo 3: selective start\nT: O(26 \\* n^2) = O(n^2)\nfor each possible substring start i\nif seen s[i] before\ncontinue\nadd s[i] to seen set\nfor each possible substring end\n# check if it is special\ndump the substring into a set\nfor each letter outside the substring\nif it is in the set, it is not special\nWe like to write down the big O simplification (O(26 \\* n^2) = O(n^2)\n), so\nthe interviewer doesn't think we missed steps.\nWe haven't hit our target time complexity yet, so let's keep hunting for properties. Here is another one:\nProperty 2\nProperty 2: of all the special substrings that start at a given letter, we only care about the shortest one.\nOur ultimate goal is to find the most non-overlapping special substrings. If we can choose between two special substrings, one of which contains the other, it is always \"optimal\" or, at least, \"safe\" to pick the smaller one.\nFor instance, if s\nis \"baa\"\n, we have two choices for special substrings starting at 'b'\n: \"baa\"\nand \"b\"\n. We should pick \"b\"\nso that the \"aa\"\npart can be in another disjoint special substring.\nAgain, when we find a property, we need to think of how to apply it. Property 2 means that, for each starting point i\n, we can grow a substring one letter at a time, and stop as we find the first special substring.\nLet's break this down a bit more: say you start at index i\n.\n- If you find a letter\nc\nthat appears at some later point, we need to grow the substring up to that index. - If you find a letter\nc\nthat appears beforei\n, we can stop the search. No substring starting ati\ncan be special.\nFor example, imagine i\nstarts at the first 'b'\nin the following string:\n\"abbbbbabbba\"\n^\ni\nThat means we need to grow the substring at least up to the last 'b'\nin the string:\n\"abbbbbabbba\"\n^ ^\ni need to grow up to here\nAs we grow the substring, we hit an 'a'\n, which appears before i\n, and we realize that no substring starting at i\ncan be special.\n\"abbbbbabbba\"\n^ ^\ni invalid\nWe can now add this logic to our algorithm. We can start the algorithm by computing the first and last index of each letter (this is an example of the preprocessing pattern in the boosters diagram -- it's common for properties from Booster 2 to enable optimizations from Booster 1).\nThen, as we grow each substring, we keep track of the farthest index we need to reach. (This is actually a common pattern in sliding window algorithms, where we maintain information about the window as it 'slides', rather than computing it from scratch every time the window moves. So, the 'sliding windows' trigger wasn't completely off).\nAlgo 4: smallest special substring\nT: O(26 \\* n) = O(n)\nS: O(26 \\* n) = O(n)\npreprocessing: compute the first and last index of each letter\nfor each possible substring start i\nfor each index j starting at i\nif s[j] appears before i\nno special string starts at i\nelse\nmust\\_reach = max(must\\_reach, last occurrence of s[j])\nif j reached must\\_reach:\ns[i]...s[j] is a special substring (the shortest one starting at s[i])\nWe got the time down to O(n)\n. Since we hit the lower bound, we can be confident Part A is as good as it can be, and we can move on to Part B.\nPart B: Find the most non-overlapping special substrings\nLet's be honest: even if in the book we really emphasize developing your problem-solving skills by using the MIKE template and the boosters, knowing a bunch of leetcode questions DOES give you an edge in coding interviews. So, I'll tell you how I actually solved this problem in the contest. I realized that Part B is just a variation of a classic greedy problem: most non-overlapping intervals. Indeed, a substring can be seen as an interval of the string.\nThe \"most non-overlapping intervals\" problem is in BCtCI, so I already knew that it can be solved with a greedy algorithm that sorts the intervals by their end time and then iterates through them, picking the ones that don't overlap with the previous one (here is a similar problem on leetcode). This algorithm fits within our target time complexity, so I didn't have to think beyond that.\nIf I didn't already know the solution, I would have walked through the MIKE template again for Part B.\nFull implementation\nHere is a full implementation:\n# T: O(26 \\* n) = O(n)\n# S: O(26 \\* n) = O(n)\ndef select\\_k\\_disjoint\\_special\\_substrings(s):\nspecial\\_substrings = find\\_special\\_substrings(s) # Part A\nreturn most\\_non\\_overlapping\\_intervals(special\\_substrings) # Part B\ndef find\\_special\\_substrings(s): # Algo 4\n# Preprocessing: compute the first and last index of each letter\nfirst\\_idx = {}\nlast\\_idx = {}\nfor i, char in enumerate(s):\nif char not in first\\_idx:\nfirst\\_idx[char] = i\nlast\\_idx[char] = i\nspecial\\_substrings = []\nfor i in range(len(s)):\nif i != first\\_idx[s[i]]:\ncontinue\nmust\\_reach = i\nfor j in range(i, len(s)):\nif first\\_idx[s[j]] < i:\nbreak\nmust\\_reach = max(must\\_reach, last\\_idx[s[j]])\nif j == must\\_reach:\nspecial\\_substrings.append((i, j))\nbreak\nreturn special\\_substrings\ndef most\\_non\\_overlapping\\_intervals(intervals): # Classic Greedy\nintervals.sort(key=lambda x: x[1]) # Sort by endpoint\ncount = 0\nprev\\_end = -math.inf\nfor l, r in intervals:\nif l > prev\\_end:\ncount += 1\nprev\\_end = r\nreturn count\nYou may think that the bottleneck is the sorting, but it's not. Recall that there are only up to 26 special substrings (by Property 1). Sorting 26\nintervals takes O(26 log 26) = O(1)\ntime.\nConclusion\nI wanted to give an overview of all the high-level ideas for problem-solving in leetcode-style interviews. We could dive a lot deeper into any of those ideas, so this blog post may feel a bit rushed, but the meta-point is that you should have a plan for when you are stuck in an interview (and you should be following it during your practice sessions so it becomes second nature). It's not important that you use the MIKE template -- your plan should work for you. But the ideas covered in this post should probably be part of it.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/problem-solving-bctci-style",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Heapify Analysis Without Math",
      "content": "Heapify Analysis Without Math\nI'm writing about heaps for Beyond Cracking the Coding Interview (beyondctci.com), and the most technical part is the analysis of heapify. It's easy to show that it takes O(n log n)\ntime, where n\nis the number of nodes in the heap, but it's not straightforward to show that this is not tight and the method actually takes O(n)\n. time.\nEvery proof I have found online involves a summation over the levels of the heap that ends up looking something like the one in Wikipedia heap page:\nwhich is more math than I want to put in this book (the bulk of the audience consists of people trying to land a SWE job, not math enthusiasts).\nBelow is the proof \"without complicated math\" I came up with that heapify takes O(n)\ntime. If you are familiar with the classic proof, let me know if you find it easier - I might use it for the book. Also, please let me know if you've seen someone else proving it in a similar way.\nIf you already know what heapify is, you can jump directly to the Proof.\nHeap Recap\nHeaps are binary trees with two special properties:\n- They are complete binary trees: all the levels except the last one have the maximum number of nodes; the last level may not be full, but all the nodes are aligned to the left. (In particular, this implies that heaps have logarithmic height, which is key to the big O analysis.)\n- The heap property: every node is smaller than its children (this is assuming a min-heap - it would be the opposite for a max-heap).\nI will focus on the heapify operation and its analysis, but if you want to learn heaps from scratch, the Algorithms with Attitude Youtube channel has a great video on it. He also covered the classic linear-time proof for heapify, if you want to compare it to mine.\nIn any case, I left a full Python heap implementation at the bottom of this post.\nWhat's Heapify?\nHeapify (invented by Robert W. Floyd) converts a binary tree which is already complete, but may not have the heap property, into a proper heap.\nHeapify uses the \"bubble-down\" procedure, which starts at a node that may not satisfy the heap property, and recursively swaps it with the smallest of its two children until the heap property is restored:\ndef bubble\\_down(self, idx):\nleft\\_idx, right\\_idx = left\\_child(idx), right\\_child(idx)\nis\\_leaf = left\\_idx >= len(self.heap)\nif is\\_leaf: return # Leaves cannot be bubbled down.\n# Find the index of the smallest child\nchild\\_idx = left\\_idx\nif right\\_idx < len(self.heap) and self.heap[right\\_idx] < self.heap[left\\_idx]:\nchild\\_idx = right\\_idx\nif self.heap[child\\_idx] < self.heap[idx]:\nself.heap[idx], self.heap[child\\_idx] = self.heap[child\\_idx], self.heap[idx]\nself.bubble\\_down(child\\_idx)\nHeapify works by \"bubbling down\" every non-leaf (internal) node, from bottom to top:\nThis figure shows the heapify steps for a min-heap. The first tree is the initial state, which doesn't yet have the min-heap property. Leaves are already at the bottom, so bubbling them down has no effect. The next 3 trees show the evolution after bubbling down the two nodes at depth 1 and then the node at depth 0.\nIn the array-based heap implementation, heapify()\nlooks like this:\ndef heapify(self, arr):\nself.heap = arr\nfor idx in range(len(self.heap) // 2, -1, -1):\nself.bubble\\_down(idx)\nThe reason why we start bubbling down from the middle of the heap is that, in a complete tree, at least half the nodes are leaves, and we don't need to bubble those down.\nHere, we won't prove that it works, only that its analysis is O(n)\n.\nProof\nI'll start with a definition and a fact we'll use later:\nA perfect binary tree is a complete tree where the last level is full:\nFact 1: In a perfect tree, the number of leaves is 1 more than the number of internal nodes.\nFor instance:\n- Height 1: 1 leaf, 0 internal nodes, 1 total\n- Height 2: 2 leaves, 1 internal node, 3 total\n- Height 3: 4 leaves, 3 internal nodes, 7 total\n- Height 4: 8 leaves, 7 internal nodes, 15 total\nFact 1 is true because the number of nodes at each level is a power of 2, so:\n- the number of leaves is a power of 2, and\n- the number of internal nodes is the sum of all the previous powers of 2.\nThe sum of the first few powers of 2 add up to one less than the next power of 2. You can see that if you line them up like this:\nIt's a bit like Zeno's paradox, where each power of 2 in the sum halves the remaining distance, but never quite gets to 64.\nWith that out of the way, back to heapify:\nIn the worst case, each node will get bubbled down all the way to a leaf. Thus, each node needs to move down O(log n)\nlevels, so one might reasonably expect heapify to take O(n log n)\ntime. This is correct in the 'upper bound' sense, but not tight: the total time is actually O(n)\n. The intuition for why that is the case is that most nodes are in the deeper levels of the tree, where they don't need to travel a lot to get to the bottom.\nWe'll actually prove a stronger claim:\nMain Claim: If you heapify a perfect tree, the number of 'bubble-down' swaps is smaller than n\n, the number of nodes.\n- We'll assume the worst case, in which every node is bubbled down to a leaf position.\n- If the claim is true and heapify does\n= len(self.heap)\nif is\\_leaf: return # Leaves cannot be bubbled down.\n# Find the index of the smallest child\nchild\\_idx = left\\_idx\nif right\\_idx < len(self.heap) and self.heap[right\\_idx] < self.heap[left\\_idx]:\nchild\\_idx = right\\_idx\nif self.heap[child\\_idx] < self.heap[idx]:\nself.heap[idx], self.heap[child\\_idx] = self.heap[child\\_idx], self.heap[idx]\nself.bubble\\_down(child\\_idx)\ndef heapify(self, arr):\nself.heap = arr\nfor idx in range(len(self.heap) // 2, -1, -1):\nself.bubble\\_down(idx)",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/heapify-analysis",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Lazy vs Eager Algorithms",
      "content": "Lazy vs Eager Algorithms\nWarning: I have not tested any code snippet below. Please let me know if you find a bug.\nIntroduction\nMost algorithms have multiple valid implementations. For instance, in a binay tree problem, you have multiple ways of handling NULL nodes. I'm currently writing Beyond Cracking the Coding Interview (beyondctci.com), which means that my co-authors and I need to take a stance on what version of each algorithm to use. Ideally, we want to show the simplest version of each algorithm:\n- Easy to recall for interview,\n- Easy to explain to interviewers,\n- Easy to debug by hand,\n- Short, so that it is quick to code.\nIn the book, we don't claim that the version we show is \"the best\" - we say to use the one that works best for you. But showing one in the book is an implicit endorsement.\nOne particular decision that comes up again and again with recursive algorithms is choosing between the lazy version and the eager version of an algorithm.\n- An eager recursive function expects 'valid' inputs and ensures to only call the recursive function with 'valid' inputs. We can also call it a clean (call) stack algorithm.\n- A lazy recursive algorithm allows 'invalid' inputs, so it starts by validating the input. Then, it calls the recursive function without validating the inputs passed to it. We can also call it a dirty stack algorithm.\nWhat 'valid' means depends on the algorithm--we'll see plenty of examples. We'll also translate the concept of eager vs lazy to iterative algorithms.\nLazy vs Eager Tree Traversals\nAn eager tree traversal eagerly validates that the children are not NULL before passing them to the recursive function. A lazy tree traversal doesn't, so it needs to check if the current node is NULL before accessing it.\nFor instance, here is eager vs lazy preorder traversal:\nclass Node:\ndef \\_\\_init\\_\\_(self, val, left=None, right=None):\nself.val = val\nself.left = left\nself.right = right\ndef preorder\\_traversal\\_eager(root):\nres = []\n# CANNOT be called with node == None\ndef visit(node):\nres.append(node.val)\nif node.left:\nvisit(node.left)\nif node.right:\nvisit(node.right)\nif not root:\nreturn []\nvisit(root)\nreturn res\ndef preorder\\_traversal\\_lazy(root):\nres = []\n# CAN be called with node == None\ndef visit(node):\nif not node:\nreturn\nres.append(node.val)\nvisit(node.left)\nvisit(node.right)\nvisit(root)\nreturn res\nBoth have the same runtime and space analysis. Even the constant factors probably don't change much, so it comes down to style preference. Which one do you prefer?\nLazy vs Eager graph DFS\nAn eager graph DFS eagerly checks that the neighbors are not already visited before passing them to the recursive function. A lazy graph DFS doesn't, so it needs to check if the current node is already visited.\n# Returns all nodes reachable from start\ndef dfs\\_eager(adj\\_lists, start):\nres = []\nvisited = set()\ndef visit(node):\nres.append(node)\nfor neighbor in adj\\_lists[node]:\nif neighbor not in visited:\nvisited.add(neighbor)\nvisit(neighbor)\nvisited.add(start)\nvisit(start)\nreturn res\ndef dfs\\_lazy(adj\\_lists, start):\nres = []\nvisited = set()\ndef visit(node):\nif node in visited:\nreturn\nvisited.add(node)\nres.append(node)\nfor neighbor in adj\\_lists[node]:\nvisit(neighbor)\nvisit(start)\nreturn res\nFor a graph DFS, we can also do a mix between lazy and eager: we can eagerly check if nodes are already visited, and lazily mark them as visited:\ndef dfs\\_lazy(adj\\_lists, start):\nres = []\nvisited = set()\ndef visit(node):\nvisited.add(node)\nres.append(node)\nfor neighbor in adj\\_lists[node]:\nif neighbor not in visited:\nvisit(neighbor)\nvisit(start)\nreturn res\nAgain, they all have the same analysis. Which one do you prefer?\nLazy vs Eager grid algorithms\nConsider the same DFS algorithm but on a grid of 0's and 1's. The 0's are walkable cells, the 1's are obstacles, and walkable cells next to each other are connected. This time, we need to check that the neighbors are not out of bounds, which we can do lazily or greedily.\n# Returns all cells reachable from (start\\_row, start\\_col).\ndef grid\\_dfs\\_eager(grid, start\\_row, start\\_col):\nnr, nc = len(grid), len(grid[0])\nres = []\nvisited = set()\ndef visit(row, col):\nres.append((row, col))\nfor dir in ((-1, 0), (1, 0), (0, 1), (0, -1)):\nr, c = row + dir[0], col + dir[1]\nif 0 <= r < nr and 0 <= c < nc and grid[r][c] == 0 and (r, c) not in visited:\nvisited.add((r, c))\nvisit(r, c)\n# Assumes (start\\_row, start\\_col) is within bounds\nvisited.add((start\\_row, start\\_col))\nvisit(start\\_row, start\\_col)\nreturn res\ndef grid\\_dfs\\_lazy(grid, start\\_row, start\\_col):\nnr, nc = len(grid), len(grid[0])\nres = []\nvisited = set()\ndef visit(row, col):\nif row < 0 or row >= nr or col < 0 or col >= nc or grid[row][col] == 1:\nreturn\nif (row, col) in visited:\nreturn\nvisited.add((row, col))\nres.append((row, col))\nfor dir in ((-1, 0), (1, 0), (0, 1), (0, -1)):\nvisit(row + dir[0], col + dir[1])\nvisit(start\\_row, start\\_col)\nreturn res\nLazy vs Eager Memoization DP\nIn a lazy memoization DP (Dynamic Programming) algorithm, we call the recursive function for a subproblem without checking first if we have already computed that subproblem. In an eager algorithm, we only call the recursive function for subproblems that we still need to compute.\n# Returns all cells reachable from (start\\_row, start\\_col).\ndef fibonacci\\_eager(n):\nmemo = {}\ndef fib\\_rec(i):\nif i <= 1:\nreturn 1\nif i-1 in memo:\nprev = memo[i-1]\nelse:\nprevprev = fib\\_rec(i-1)\nif i-2 in memo:\nprevprev = memo[i-2]\nelse:\nprev = fib\\_rec(i-2)\nmemo[i] = prev + prevprev\nreturn memo[i]\nreturn fib\\_rec(n)\ndef fibonacci\\_lazy(n):\nmemo = {}\ndef fib\\_rec(i):\nif i <= 1:\nreturn 1\nif i in memo:\nreturn memo[i]\nmemo[i] = fib\\_rec(i-1) + fib\\_rec(i-2)\nreturn memo[i]\nreturn fib\\_rec(n)\nFor memoization DP, I think lazy is cleaner and more conventional.\nLazy vs Eager Iterative Tree traversals\nConsider a level-order traversal on a binary tree. A level-order traversal is an iterative algorithm that uses a queue data structure.\n- A lazy version puts children in the queue without checking if they are NULL first. We can call it a dirty queue algorithm.\n- An eager version checks for NULL nodes and avoids putting them in the queue. We can call it a clean queue algorithm.\ndef level\\_order\\_traversal\\_eager(root):\nif not root:\nreturn []\nres = []\nQ = deque([root])\nwhile Q:\nnode = Q.popleft()\nres.append(node.val)\nif node.left:\nQ.append(node.left)\nif node.right:\nQ.append(node.right)\nreturn res\ndef level\\_order\\_traversal\\_lazy(root):\nres = []\nQ = deque([root])\nwhile Q:\nnode = Q.popleft()\nif not node:\ncontinue\nres.append(node.val)\nQ.append(node.left)\nQ.append(node.right)\nreturn res\nEager Graph BFS is better than lazy Graph BFS\nThis is the first exception where one is better than the other in terms of big O analysis. The lazy BFS allows adding already-visited nodes to the queue, while the eager one does not. We'll first look at the two versions, and then analyze them.\ndef graph\\_bfs\\_eager(adj\\_lists, start):\nres = []\nvisited = set()\nvisited.add(start)\nQ = deque([start])\nwhile Q:\nnode = Q.popleft()\nres.append(node.val)\nfor neighbor in adj\\_lists[node]:\nif neighbor not in visited:\nvisited.add(neighbor)\nQ.append(neighbor)\nreturn res\ndef graph\\_bfs\\_lazy(adj\\_lists, start):\nres = []\nvisited = set()\nQ = deque([start])\nwhile Q:\nnode = Q.popleft()\nif node in visited:\ncontinue\nvisited.add(node)\nres.append(node)\nfor neighbor in adj\\_lists[node]:\nQ.append(neighbor)\nreturn res\nIt may come as a surprise that these two are not equivalent like all the other examples.\nLet's say V\nis the number of nodes and E\nis the number of edges. To keep things simple, consider that the graph is connected, meaning that E\nis at least V-1\nand at most O(V²)\n.\nBoth versions take O(E)\ntime. The difference is in the space complexity: the eager version takes O(V)\nspace because we never have the same node twice in the queue. The lazy version takes O(E)\nspace because we allow the same nodes multiple times in the queue.\nTo see this, consider a complete graph:\n- When we visit start, we add A, B, C, D, E to the queue. Now the queue is:\n[A, B, C, D, E]\n- When we visit A, we add start, B, C, D, E to the queue. Now the queue is:\n[B, C, D, E, start, B, C, D, E]\n- When we visit B, we add start, A, C, D, E to the queue. Now the queue is:\n[C, D, E, start, B, C, D, E, start, A, C, D, E]\n- And so on.\nBy the time we finish popping the nodes added as neighbors of the start node, we've done V\nqueue pops and V²\nqueue appends, so the queue size is O(V²)\n.\nSo, why didn't this happen for other lazy algorithms we have seen?\n- For tree traversals, each tree node has a single parent that it can be reached from, so we don't need to worry about the same node appearing twice in the call stack or in the level-order traversal queue.\n- For graph DFS, every node in the call stack is marked visited, so if we call\nvisit()\non a node that is already in the call stack, we'll immediately return as we'll see it is marked as visited.\nEager Dijkstra is better than Lazy Dijkstra, but harder to implement\nI wrote extensively about different Dijktsra implementations in this Dijkstra blog post.\nDijkstra is similar to BFS, with the main difference that it uses a priority queue (PQ) instead of a queue to visit the nodes that are closer first (in terms of shortest paths).\nIn BFS, when a node is added to the queue, its distance from the starting node is already established and there is never a reason to add it again to the queue. In Dijkstra, when a node is added to the PQ, we might later find a shorter path while it is still in the PQ. When that happens, we can do two things:\n- Lazy Dijkstra: just add the node again with the new, improved distance. It will get popped before the previous occurrence because it has higher priority in the PQ. When a node with a \"stale\" distance gets popped off from the queue, we just ignore it.\n- Eager Dijkstra (called textbook Dijkstra in the other blog post): instead of adding the node again, find the existing occurrence of it in the PQ, and update it with the new found distance. This guarantees that the same node never appears twice in the PQ.\nBoth versions take O(E\\*log V)\ntime, but eager is more space efficient, analogously to eager BFS: O(V)\nfor eager Dijkstra vs O(E)\nfor lazy Dijkstra.\nHere is lazy Dijkstra:\ndef dijkstra\\_lazy(adj\\_lists, start):\ndist = defaultdict(int)\ndist[start] = 0\nvisited = set()\nPQ = [(0, start)]\nwhile PQ:\n\\_, node = heappop(PQ) # Only need the node, not the distance.\nif node in visited:\ncontinue # Not the first extraction.\nvisited.add(node)\nfor neighbor, weight in adj\\_lists[node]:\nif dist[node]+weight < dist[neighbor]:\ndist[neighbor] = dist[node]+weight\n# Neighbor may already be in the PQ; we add it anyway.\nheappush(PQ, (dist[neighbor], neighbor))\nreturn dist\nUnfortunately, eager Dijkstra is not so easy to implement in Python because we are missing the decrease\\_key()\noperation in a heap (and Python does have a self-balancing BST data structure, which can also be used for eager Dijkstra). You can see a BST-based C++ implementation in my other blog post.\nThe dijkstra\\_lazy()\nalgorithm above is more or less standard and it has been known as \"lazy Dijkstra\" for a while. However, it is possible to make an even lazier version which has the same runtime and space analysis (but likely bigger constant factors). The idea is that instead of only adding to the PQ the neighbors for whom we find an improved distance, we can simply add all of them, and discard duplicates once we extract them from the PQ:\ndef dijkstra\\_super\\_lazy(adj\\_lists, start):\ndist = defaultdict(int)\ndist[start] = 0\nPQ = [(0, s)]\nwhile PQ:\nd, node = heappop(PQ)\nif dist[node] != math.inf: continue\ndist[node] = d\nfor neighbor, weight in adj\\_lists[node]:\nheappush(PQ, (dist[node]+weight, neighbor))\nreturn dist\nSo, Lazy or Eager?\nWe could keep looking at lazy vs eager algorithms, but I'll stop here. In aggregate, these are the pros and cons that I see:\nPros of lazy algorithms\n- Lazy algorithms require less code. This is because you only need to validate the parameters of the recursive function once at the beginning, instead of validating what you pass to each recursive call. This is specially true in binary tree problems, where you usually have two recursive calls. It doesn't apply as much for graphs.\n- Lazy algorithms require less indentation. For instance, in graph problems, we don't need to do checks inside the for loop over the neighbors.\n- Lazy algorithms do not require special handling for the first recursive call. You don't need to worry about things like checking if the root is NULL or marking the start node as visited.\n- Lazy recursive functions have simpler preconditions. You can just pass anything to them, and they work.\nPros of eager algorithms\n- For a graph BFS, eager has a better space complexity. This is a case where eager is objectively better. (Eager Dijkstra is also better but it is not expected to be implemented in interviews. Your interviewer is probably expecting lazy Dijkstra.)\n- Eager algorithms do fewer recursive calls or iterations. In a binary tree, the number of NULL nodes is always one more than the number of internal nodes. This means that a lazy traversal does twice as many recursive calls/iterations as the eager counterpart. This could make a big difference if you want to debug the code manually. For instance, in this picture, you can see that adding NULLs to the queue makes visualizing the steps more painful:\n- Eager algorithm can 'feel safer'. A friend commented that, with a lazy algorithm, they feel like they are missing an edge case.\nMy preference\nHere are my personal preferences for coding interviews (not those of the other authors of 'Beyond Cracking the Coding Interview'):\nStrong preferences:\n- For BFS, use eager. This one is clear cut.\n- For memoization DP, use lazy. It is much cleaner to code.\n- For Dijkstra, use lazy Dijkstra (not super lazy Dijkstra). It is what is realistic to do in an interview and probably what the interviewer expects.\nWeak preferences:\n- For binary tree traversals (iterative or recursive), use lazy. It is a bit cleaner.\n- For graph DFS, use eager. It is a bit more standard, and aligned with a graph BFS.\nIn the book, we'll definitely mention that some algorithms can be implemented in a lazy or eager way (in way less detail than here), and that you should choose the one that feels easier to you. But, we still need to pick one to show in the problem solutions. One idea is trying to be consistent throughout (e.g., doing all tree and graph traversals in an eager way). If you have an opinion on which one is better, please reach out! I'd love to hear it.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/lazy-vs-eager",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Actually Implementing Dijkstra's Algorithm",
      "content": "Actually Implementing Dijkstra's Algorithm\nIntroduction\nDijkstra's algorithm for the shortest-path problem is one of the most important graph algorithms, so it is often covered in algorithm classes. However, going from the pseudocode to an actual implementation is made difficult by the fact that it relies on a priority queue with a \"decrease key\" operation. While most programming languages offer a priority queue data structure as part of their standard library, this operation is generally not supported (e.g., in C++, Java or Python). In this blog, we go over the different ways to implement Dijkstra's algorithm with and without this operation, and the implications of using each. All in all, we consider 5 versions of Dijkstra (names mostly made up by me):\n- Textbook Dijkstra: the version commonly taught in textbooks where we assume that we have a priority queue with the \"decrease key\" operation. As we said, this often does not hold true in reality.\n- Linear-search Dijkstra: the most naive implementation, but which is actually optimal for dense graphs.\n- Lazy Dijkstra: practical version which does not use the \"decrease key\" operation at all, at the cost of using some extra space.\n- BST Dijkstra: version which uses a self-balancing binary search tree to implement the priority queue functionality, including the \"decrease key\" operation.\n- Theoretical Dijkstra: version that uses a Fibonacci heap for the priority queue in order to achieve the fastest possible runtime in terms of big-O notation. This is actually impractical due to the complexity and high constant factors of the Fibonacci heap.\nRoughly, each of the 5 versions corresponds to a different data structure used to implement the priority queue. Throughout the post, let n\nbe the number of nodes and m\nthe number of edges. Here is summary of the resulting runtime and space complexities:\n- Textbook Dijkstra: indexed binary heap. Runtime:\nO(m\\*log n)\n; space:O(n)\n. - Linear-search Dijkstra: unordered array. Runtime:\nO(n²)\n; space:O(n)\n. - Lazy Dijkstra: binary heap. Runtime:\nO(m\\*log n)\n; space:O(m)\n. - BST Dijkstra: self-balancing BST. Runtime:\nO(m\\*log n)\n; space:O(n)\n. - Theoretical Dijkstra: Fibonacci heap. Runtime:\nO(m + n\\*log n)\n; space:O(n)\n.\nWe provide implementations in Python and C++. The initial sections are mostly background. If you are already familiar with Dijkstra's algorithm, you can skip to the code snippets.\nThe shortest-path problem\nThe input consists of a graph G\nand a special node s\n. The edges of G\nare directed and have non-negative weights. The edge weights represent the \"lengths\" of the edges. The goal is to find the distance from s\nto every other node in G\n. The distance from s\nto another node is the length of the shortest path from s\nto that node, and the length of a path is the sum of the lengths of its edges. If a node is unreachable from s\n, then we say that the distance is infinite.\nMore precisely, this is known as the \"single-source shortest-path\" (SSSP) problem, because we find the distance from one node to every other node. Related problems include the \"all-pairs shortest paths\" problem and the single-source single-destination problem. Dijkstra's algorithm is a really efficient algorithm for the SSSP problem when the edges are non-negative. Dijkstra's algorithm does not work in the presence of negative edges (zero-weight edges are fine). If G\ncontains negative edges, we should use the Bellman-Ford algorithm instead.\nThe constraint that the edges are directed is not important: if G\nis undirected, we can simply replace every undirected edge {u,v}\nwith a pair of directed edges (u,v)\nand (v,u)\nin opposite directions and with the weight of the original edge.\nTo simplify things, we make a couple of assumptions that do not make any actual difference:\n- Nodes not reachable by\ns\nplay no role in the algorithm, so we assume thats\ncan reach every node. This is so that, in the analysis, we can assume thatn=O(m)\n. - We assume that the distance from\ns\nto every node is unique. This allows us to talk about \"the\" shortest path to a node, when in general there could be many.\nThe graph's representation\nA graph is a mathematical concept. In the context of graph algorithms, we need to specify how the graph is represented as a data structure. For Dijkstra's algorithm, the most convenient representation is the adjacency list. The valuable thing about the adjacency list representation is that it allows us to iterate through the out-going edges of a node efficiently.\nIn the version of the adjacency list that we use, each node is identified with an index from 0\nto n-1\n. The adjacency list contains one list for each node. For each node u\nbetween 0\nand n-1\n, the list G[u]\ncontains one entry for each neighbor of u\n. In a directed graph, if we have an edge (u,v)\nfrom u\nto v\n, we say that v\nis a neighbor of u\n, but u\nis not a neighbor of v\n. Since the graph is weighted, the entry for each neighbor v\nconsists of a pair of values, (v, l)\n: the destination node v\n, and the length l\nof the edge (u,v)\n.\nDijkstra's algorithm idea\nOne of the data structures that we maintain is a list dist\nwhere dist[u]\nis the best distance known for u\nso far. At the beginning, dist[s] = 0\n, and for every other node dist[u] = infinity\n. These distances improve during the algorithm as we consider new paths. Our goal is to get to the point where dist\ncontains the correct distance for every node.\nDuring the algorithm, the dist\nlist is only updated through an operation called \"relaxing\" an edge.\ndef relax(u,v,l): #l is the length of the edge (u,v)\nif dist[u] + l < dist[v]:\ndist[v] = dist[u] + l\nIn words, relaxing an edge (u,v)\nmeans checking if going to u\nfirst and then using the edge (u,v)\nis shorter than the best distance known for v\n. If it is shorter, then we update dist[v]\nto the new, better value.\nDijkstra's algorithm is based on the following observations:\n- if\ndist[u]\nis correct and the shortest path froms\ntov\nends in the edge(u,v)\n, then if we relax the edge(u,v)\n, we will find the correct distance tov\n. If either of the conditions are not satisfied, relaxing(u,v)\nmay improvedist[v]\n, but it will not be the correct distance. - To find the correct distance to\nv\n, we need to relax all the edges in the shortest path froms\ntov\n, in order. If we do it in order, each node in the path will have the correct distance when we relax the edge to the next node, satisfying the conditions.\nDijkstra's algorithm is efficient because every edge is relaxed only once (unlike other algorithms like Bellman-Ford, which relaxes the edges multiple times). To relax every edge only once, we must relax the out-going edges of each node only after we have found the correct distance for that node.\nAt the beginning, only s\nhas the correct distance, so we relax its edges. This updates the entries in dist\nfor its neighbors. The neighbor of s\nthat is closest to s\n, say, x\n, has the correct distance at this point. This is because every other path from s\nto x\nstarts with a longer edge, and, since the graph does not have negative-weight edges, additional edges can only increase the distance. Next, since x\nhas the correct distance, we can relax its out-going edges. After that, the node y\nwith the 3rd smallest distance in dist\n(after s\nand x\n) has the correct distance because the node before y\nin the shortest path from s\nto y\nmust be either s\nor x\n. It cannot be any other node because simply reaching any node that is not s\nor x\nis already more expensive than the distance we have found for y\n. We continue relaxing the out-going edges of nodes, always taking the next node with the smallest found distance. By generalizing the argument above, when we relax the out-going edges of each node, that node already has the correct distance. We finish after we have gone through all the nodes. At that point, dist\ncontains the correct distance for every node.\nHigh-level pseudocode of Dijkstra's algorithm\ndijkstra(G, s):\ndist = list of length n initialized with INF everywhere except for a 0 at position s\nmark every node as unvisited\nwhile there are unvisited nodes:\nu = unvisited node with smallest distance in dist\nmark u as visited\nfor each edge (u,v):\nrelax((u,v))\nIn order to implement Dijkstra's algorithm, we need to decide the data structures used to find the unvisited node with the smallest distance at each iteration.\nPriority queues\nPriority queues are data structures that are useful in many applications, including Dijkstra's algorithm.\nIn a normal queue, we can insert new elements and extract the oldest element. A priority queue is similar, but we can associate a priority with each element. Then, instead of extracting the oldest element, we extract the one with highest priority. Depending on the context, \"highest priority\" can mean the element with the smallest or largest priority value. In this context, we will consider that the highest priority is the element with the smallest priority value.\nA priority queue is an abstract data structure. That means that it only specifies which operations it supports, but not how they are implemented. There actually exist many ways to implement a priority queue. To make matters more confusing, different priority queues implementations support different sets of operations. The only agreed part is that they must support two basic operations:\ninsert(e, k)\n: insert elemente\nwith priorityk\n.extract\\_min()\n: remove and return the element with the smallest priority value.\nFor Dijkstra's algorithm, we can use a priority queue to maintain the nodes, using dist[u]\nas the priority for a node u\n. Then, at each iteration we can extract the unvisited node with the smallest distance. However, there is a problem: when we relax an edge, the value dist[u]\nmay decrease. Thus, we need the priority queue to support a third operation which is not commonly supported:\nchange\\_priority(e, k)\n: set the priority ofe\ntok\n(assuming thate\nis in the priority queue).\nA related operation is removing elements that are not the most prioritary:\nremove(e)\n: removee\n(assuming thate\nis in the priority queue).\nIf a priority queue implements remove, we can use it to obtain the same functionality as change-priority(e, k)\n: we can first call remove(e)\nand then reinsert the element with the new key by calling insert(e, k)\n.\nPseudocode with a priority queue\nAssuming that we have a priority queue data structure that supports insert\n, extract-min\n, and change-priority\n, Dijkstra's pseudocode would be as follows.\nThe priority queue contains the unvisited nodes, prioritized by distance from s\n. At the beginning, the priority queue contains all the nodes, and they are removed as they are visited.\nDijkstra pseudocode (with a priority queue)\ndijkstra(G, s):\ndist = list of length n initialized with INF everywhere except for a 0 at position s\nPQ = empty priority queue\nfor each node u: PQ.insert(u, dist[u])\nwhile not PQ.empty():\nu = PQ.extract\\_min()\nfor each edge (u,v) of length l:\nif dist[u]+l < dist[v]:\ndist[v] = dist[u]+l\nPQ.change\\_priority(v, dist[v])\nA common variation is to add them to the priority queue when they are reached for the first time, instead of adding all the nodes at the beginning. The only change is how the priority queue is initialized and the if-else cases at the end:\nDijkstra pseudocode (with deferred insertions to the PQ)\ndijkstra(G, s):\ndist = list of length n initialized with INF everywhere except for a 0 at position s\nPQ = empty priority queue\nPQ.insert(s, 0)\nwhile not PQ.empty():\nu = PQ.extract\\_min()\nfor each edge (u,v) of length l:\nif dist[u]+l < dist[v]:\ndist[v] = dist[u]+l\nif v in PQ: PQ.change\\_priority(v, dist[v])\nelse: PQ.insert(v, dist[v])\nIt does not change the runtime or space complexity, but there is also no downside to deferring insertions to the PQ. On average, the PQ will contains fewer elements.\nAnalysis of Dijkstra's algorithm\nUsually, we analyze the algorithms after implementing them. However, in order to choose the best data structure for the priority queue, we need to analyze how much we use each type of operation.\nThus, it is convenient to define the runtime in terms of the priority queue operations, without specifying yet how they are done. Let T\\_ins\n, T\\_min\n, and T\\_change\nbe the time per insert\n, extract\\_min\n, and change\\_priority\noperation, respectively, on a priority queue containing n\nelements.\nThe main while\nloop has n\niterations, and the total number of iterations of the inner for\nloop, across all n\niterations, is m\n. This is because each edge is relaxed once.\nThe runtime is dominated by the priority queue operations, so it is O(n\\*T\\_ins + n\\*T\\_min + m\\*T\\_change)\n. These operations dominate the runtime because everything else combined (like updating the dist\nlist) takes O(n+m)\ntime.\nLinear-search Dijkstra for dense graphs\nThe simplest way to simulate the extract\\_min\nfunctionality of a priority queue is to iterate through the entire dist\nlist to find the smallest value among the non-visited entries. If we do this, we don't need a priority queue. We call this linear-search Dijkstra. We get T\\_ins = O(1)\n, T\\_min = O(n)\n, and T\\_change = O(1)\n. Plugging those in, the total runtime of linear-search Dijkstra is O(n + n\\*n + m) = O(n²)\n, where we simplify out the m\nterm because n² > m\nin any graph. More precisely, a directed graph with n\nnodes has at most n\\*(n-1)=O(n²)\nedges.\nA graph with \"close to\" n\\*(n-1)\nedges is called dense. Linear-search Dijkstra is actually optimal for dense graphs. This is because Dijkstra's algorithm must take O(m)\ntime just to relax all edges, so it cannot be faster than O(m)\n, and, in dense graphs that is already proportional to O(n²)\n.\nHere is a Python implementation:\ndef linearSearchDijkstra(G, s):\nn = len(G)\nINF = 9999999\ndist = [INF for node in range(n)]\ndist[s] = 0\nvis = [False for node in range(n)]\nfor i in range(n):\nu = -1\nfor v in range(n):\nif not vis[v] and (u == -1 or dist[v] < dist[u]):\nu = v\nif dist[u] == INF: break #no more reachable nodes\nvis[u] = True\nfor v, l in G[u]:\nif dist[u] + l < dist[v]:\ndist[v] = dist[u] + l\nreturn dist\nAnd C++. We omit the includes and \"using namespace std;\n\".\nvector linearSearchDijkstra(const vector>>& G, int s) {\nint n = G.size();\nvector dist(n, INT\\_MAX);\ndist[s] = 0;\nvector vis(n, false);\nfor (int i = 0; i < n; i++) {\nint u = -1;\nfor (int v = 0; v < n; v++)\nif (not vis[v] and (u == -1 or dist[v] < dist[u]))\nu = v;\nif (dist[u] == INT\\_MAX) break; //no more reachable nodes\nvis[u] = true;\nfor (auto edge : G[u]) {\nint v = edge.first, l = edge.second;\nif (dist[u]+l < dist[v])\ndist[v] = dist[u]+l;\n}\n}\nreturn dist;\n}\nPriority queues for sparse graphs\nThe O(n²)\ntime from the implementation above is slow if the graph G\nis sparse, meaning that the number of edges is small relative to O(n²)\n. Recall that the time is O(n\\*T\\_ins + n\\*T\\_min + m\\*T\\_change)\n. If m\nis more similar to n\nthan to n²\n, then we would be happy to trade a slower change\\_priority\ntime for a faster extract\\_min\ntime.\nThe best possible answer in terms of big-O notation is to use a priority queue implementation based on a data structure known as a Fibonacci Heap. A Fibonacci heap containing at most n\nelements achieves the following times:\ninsert\n:O(log n)\namortized time.extract\\_min\n:O(log n)\namortized time.change\\_priority\n:O(1)\namortized time.\nAmortized time means that it could take more time, but, if we average out the times for that operation across the execution of an algorithm, each one takes that time on average.\nUsing a Fibonacci heap, we get a total time of O(n\\*log n + m)\nfor Dijkstra's algorithm. This is really fast in terms of big-O notation, but Fibonacci heaps have larger constant factors than other data structures, making them slower in practice.\nThe most common way to implement a priority queue is with a binary heap. It is simple and fast in practice. Binary heaps support insert\nand extract\\_min\nin O(log n)\nlike a Fibonacci heap. However, they do not support the change\\_priority\noperation.\nIt is possible to modify a binary heap to to support the change\\_priority\noperation in O(log n)\ntime. The result is sometimes called an \"indexed priority queue\". Using an indexed priority queue, we would get a total runtime of O(n\\*log n + m\\*log n) = O(m\\*log n)\n. This is slightly worse than with a Fibonacci heap, and faster in practice.\nIn any case, the priority queues provided by languages like C++, Python, and Java, do not support the change\\_priority\noperation. This creates a disconnect between the pseudocode taught in classrooms and the actual code that we can write.\nThe goal of this post is to illustrate the options to deal with this issue. There are 3:\n- Textbook Dijkstra: find or implement our own indexed priority queue.\n- Lazy Dijkstra: we implement Dijkstra without using the\nchange\\_priority\noperation at all. - BST Dijkstra: we use a self-balancing binary search tree as the priority queue.\nWe will cover the latter two options. The first option is an interesting exercise in data structures (I implemented it once for a project), but it is more about the inner workings of binary heaps than it is about Dijkstra's algorithm.\nAll three options have a runtime of O(m\\*log n)\n. Note that for dense graphs, this becomes O(n² log n)\ntime, so they are all worse than the naive linear-search Dijkstra. In terms of space, lazy Dijkstra is worse than the others, as it needs O(m)\nspace, as opposed to O(n)\nfor the other options.\nLazy Dijkstra\nWe implement Dijkstra using a priority queue that does not support the change-priority operation. We need the following change: when we find a shorter distance to a node that is already in the priority-queue, instead of using the \"change-priority\" operation, we simply use an \"insert\" operation and add a copy of the node in the priority queue with the new distance. Then, when we extract a node from the priority queue, we ignore it if it is not the first time we extract that node. We call this version of Dijkstra \"lazy Dijkstra\" because we \"postpone\" the removal of the pre-existing copy of the node.\nHere is a Python version. The logical structure of a binary heap is a binary tree, but, internally the tree is represented as an array for efficiency reasons. Python is a bit whack because, instead of having a priority queue module that encapsulates the implementation, we have the heapq module, which provides priority queue operations that can be used directly on a list representing a binary heap. heapq\noffers functions heappop\n(equivalent to extract\\_min\n) and heappush\n(equivalent to insert\n). These functions receive a normal Python list as a parameter, and this list is assumed to represent a binary heap. In Python, if the priority queue contains tuples, then the first element in the tuple is the priority. Thus, in the implementation we insert tuples to the priority queue with the distance first and the node second.\ndef lazyDijkstra(G, s):\nn = len(G)\nINF = 9999999\ndist = [INF for u in range(n)]\ndist[s] = 0\nvis = [False for u in range(n)]\nPQ = [(0, s)]\nwhile len(PQ) > 0:\n\\_, u = heappop(PQ) #only need the node, not the distance\nif vis[u]: continue #not first extraction\nvis[u] = True\nfor v, l in G[u]:\nif dist[u]+l < dist[v]:\ndist[v] = dist[u]+l\nheappush(PQ, (dist[u]+l, v))\nreturn dist\nHere is a C++ version:\nvector lazyDijkstra(const vector>>& G, int s) {\nint n = G.size();\nvector dist(n, INT\\_MAX);\ndist[s] = 0;\nvector vis(n, false);\n//PQ of (distance, node) pairs prioritized by smallest distance\npriority\\_queue, vector>, greater>> PQ;\nPQ.push({0, s});\nwhile (not PQ.empty()) {\nint u = PQ.top().second;\nPQ.pop();\nif (vis[u]) continue; //not first extraction\nvis[u] = true;\nfor (auto edge : G[u]) {\nint v = edge.first, l = edge.second;\nif (dist[u]+l < dist[v]) {\ndist[v] = dist[u]+l;\nPQ.push({dist[v], v});\n}\n}\n}\nreturn dist;\n}\nAnalysis: since nodes can be added to the priority queue multiple times, in lazy Dijkstra the maximum number of elements in the priority queue increases from O(n)\nto O(m)\n. As a result, we do O(m)\nextract\\_min\nand insert\noperations. The total runtime is O(m\\*log m)\n. This can be simplified to O(m\\*log n)\n, because log m < log (n²) = 2 log n = O(log n)\n. Thus, in terms of big-O notation, lazy Dijkstra is equally fast as textbook Dijkstra (Dijkstra with an indexed priority queue). The only thing that got worse is the space used by the priority queue.\nBST Dijkstra\nSelf-balancing binary search trees, like red-black trees or AVL trees, are a type of data structure that maintains a set of elements ordered according to values associated with the elements, known as the elements' keys. They support a few operations, all in O(log n)\ntime. For our use case, we are interested in the following ones:\n- Insert an element with a given key.\n- Find the element with the smallest/largest key.\n- Given a key, find if there is an element with that key, and optionally remove it.\nThese operations allow us to use a self-balancing BST to implement a priority queue. With the third operation, we can even implement the change\\_priority\noperation, as we mentioned.\nPython does not actually have a self-balancing binary search tree module (why?!), so we cannot implement this version of Dijkstra either without finding or implementing our own self-balancing BST.\nHere is a C++ version. In C++, the set data structure is implemented as a self-balancing BST:\nvector bstDijkstra(const vector>>& G, int s) {\nint n = G.size();\nvector dist (n, INT\\_MAX);\ndist[s] = 0;\n//self-balancing BST of (distance, node) pairs, sorted by smallest distance\nset> PQ;\nPQ.insert({0, s});\nwhile (not PQ.empty()) {\nint u = PQ.begin()->second; //extract-min\nPQ.erase(PQ.begin());\nfor (auto edge : G[u]) {\nint v = edge.first, l = edge.second;\nif (dist[u]+l < dist[v]) {\n//erase and insert instead of change-priority\nPQ.erase({dist[v], v});\ndist[v] = dist[u]+l;\nPQ.insert({dist[v], v});\n}\n}\n}\nreturn dist;\n}\nAnalysis: in a sense, BST Dijkstra combines the best of both worlds: it has the same runtime and space complexity as textbook Dijkstra, without needing the extra space of Lazy Dijkstra, but it uses a much more ubiquitous data structure, a self-balancing BST. However, in practice, self-balancing BSTs are slower than binary heaps. This has to do with the fact that heaps can be implemented on top of an array, while BSTs use recursive tree data structures with child pointers. The array has much better locality of reference. For sparse graphs, I'd expect the performance of the different versions to be ordered as follows:\nTextbook Dijkstra > Lazy Dijkstra > BST Dijkstra > Theoretical Dijkstra > Linear-search Dijkstra\nPractice problems\nHere are some problems on leetcode:",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/implementing-dijkstra",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Reachability Problems and DFS",
      "content": "Reachability Problems and DFS\nIntroduction\nDepth-first search, or DFS, is a fundamental graph algorithm that can be used to solve reachability problems. This post shows how to adapt the basic DFS template to solve several problems of this kind. Reachability problems are often easier in undirected graphs. Below, we specify if the algorithm works for undirected graphs, directed graphs, or both.\nPrerequisites\nWe assume that the reader is already familiar with the concept of DFS. Here is an excellent video introducing DFS with step-by-step animations. We also assume that the reader is familiar with the adjacency list representation of a graph, and we use big-O notation in the analysis.\nCoding conventions\nThe algorithms below are in Python. n\ndenotes the number of nodes. Nodes are identified with integers in the range 0..n-1\n. The graph G\nis a graph stored as an adjacency list: G\nis a list of n\nlists. For each v\nbetween 0\nand n-1\n, G[v]\nis the list of neighbors of G\n.\nIf the graph is given as an edge list instead, we can initialize it as follows:\ndef makeAdjList(edgeList):\nn = max(max(edge) for edge in edgeList) + 1\nG = [[] for v in range(n)]\nfor u,v in edgeList:\nG[u].append(v)\nG[v].append(u) #omit this for directed graphs\nreturn G\nIf the graph is given as an adjacency matrix, we can iterate through the rows of the adjacency matrix instead of through the adjacency lists. To iterate through the neighbors of a node v\n, instead of\nfor u in G[v]:\n#u is a neighbor of v\n...\nwe do\nfor u in range(n):\nif adjMatrix[v][u]:\n#u is a neighbor of v\n...\nNote that using an adjacency matrix affects the runtime analysis of DFS: O(n²)\ninstead of O(m)\n.\nWhich nodes can be reached from node s?\nThis is the simplest question that can be answered with DFS. The primary data structure in DFS is a list of booleans to keep track of already visited nodes (we call it vis\n). If we start a DFS search from a node s\n, the reachable nodes will be the ones for which vis\nis true.\nFor this, G\ncan be directed or undirected. We make use of a nested function in Python so that we do not need to pass G\nand vis\nas parameters (in Python nested functions have visibility over the variables in the scope where they are defined).\ndef reachableNodes(G, s): #G is directed or undirected\nn = len(G)\nvis = n \\* [False]\nvis[s] = True\n#invariant: v is marked as visited when calling visit(v)\ndef visit(v):\nfor nbr in G[v]:\nif not vis[nbr]:\nvis[nbr] = True\nvisit(nbr)\nvisit(s)\nreturn [v for v in range(n) if vis[v]]\nDFS runs in O(m)\ntime and O(n)\nspace, where m\nis the number of edges. This is because each edge is considered twice, once from each endpoint, if the endpoints end up being visited, or zero times if the endpoints are not visited.\nIterative version\ndef reachableNodes(G, s): #G is directed or undirected\nn = len(G)\nvis = n \\* [False]\nstk = [s]\n#mark nodes as visited when removed from the stack, not when added\nwhile stk:\nv = stk.pop()\nif vis[v]: continue\nvis[v] = True\nfor nbr in G[v]:\nif not vis[nbr]:\nstk.append(nbr)\nreturn [v for v in range(n) if vis[v]]\nThe iterative version takes O(m)\nspace instead of O(n)\nbecause nodes can be inserted into the stack multiple times (up to one time for each incident edge). Alternatively, we can mark the nodes as visited when we add them to the stack instead of when we remove them. This change reduces the space usage to the usual O(n)\n. However, with this change, the algorithm is no longer DFS. It still works for answering reachability questions because the set visited nodes is the same, but the order in which they are visited is no longer consistent with a depth-first search order (it is closer to a BFS (breath-first search) order, but also not exactly a BFS order).\nThe difference between marking nodes when they added vs removed from the stack is discussed in detail here. Since the recursive version is shorter and optimal in terms of space, we favor it from now on. That said, it should be easy to adapt the iterative version above to the problems below.\nCan node s reach node t?\nWe use the same code from before, but we add early termination as soon as we see t\n. Now, the recursive function has a return value.\ndef canReachNode(G, s, t): #G is directed or undirected\nn = len(G)\nvis = n \\* [False]\nvis[s] = True\n#returns True if the search reaches t\ndef visit(v):\nif v == t: return True\nfor nbr in G[v]:\nif not vis[nbr]:\nvis[nbr] = True\nif visit(nbr): return True\nreturn False\nreturn visit(s)\nAdding the early termination can make the DFS faster, but in the worst-case the time/space complexity is the same.\nPractice problems\nThe hardest part on this problem is constructing the graph in the first place.\nFind a path from s to t\nThe edges \"traversed\" in a DFS search form a tree called the \"DFS tree\". The DFS tree changes depending on where we start the search. The starting node is called the root. We can construct the DFS tree by keeping track of the predecessor of each node in the search (the root has no predecessor). If we construct the DFS tree rooted at s\n, we can follow the sequence of predecessors from t\nto s\nto find a path from s\nto t\nin reverse order.\nInstead of using the list vis\nto keep track of visited nodes, we know a node is unvisited if it has no predecessor yet. We indicate that a node has no predecessor with the special value -1\n.\ndef findPath(G, s, t): #G is directed or undirected\nn = len(G)\npred = n \\* [-1]\npred[s] = None\ndef visit(v):\nfor nbr in G[v]:\nif pred[nbr] == -1:\npred[nbr] = v\nvisit(nbr)\nvisit(s) #builds DFS tree\npath = [t]\nwhile path[-1] != s:\np = pred[path[-1]]\nif p == -1: return None #cannot reach t from s\npath.append(p)\npath.reverse()\nreturn path\nNote that DFS does not find the shortest path form s\nto t\n. For that, we can use BFS (breath-first search). It just returns any path without repeated nodes.\nIs the graph connected?\nFor undirected graphs, this is almost the same question as the first question (\"which nodes can be reached by s\n?\") because of the following property:\nAn undirected graph is connected if and only if every node can be reached from s\n, where s\nis any of the nodes.\nThus, the code is exactly the same as for the first question, with two differences: 1) we choose s\nto be 0\n(could be anything), and 2) we change the last line to check if every entry in vis\nis true.\ndef isConnected(G): #G is undirected\nn = len(G)\nvis = n \\* [False]\nvis[0] = True\ndef visit(v):\nfor nbr in G[v]:\nif not vis[nbr]:\nvis[nbr] = True\nvisit(nbr)\nvisit(0)\nreturn all(vis)\nFor directed graphs, we need to take into account the direction of the edges. A directed graph is strongly connected if every node can reach every other node. We can use the following property:\nA directed graph is strongly connected if and only if s\ncan reach every node and every node can reach s\n, where s\nis any of the nodes.\nWe already know how to use DFS to check if s\ncan reach every node. To check if every node can reach s\n, we can do a DFS starting from s\n, but in the reverse graph of G. The reverse graph of G\nis like G\nbut reversing the directions of all the edges.\ndef isConnected(G): #G is directed\nn = len(G)\nvis = n \\* [False]\nvis[0] = True #use 0 for start node\ndef visit(G, v):\nfor nbr in G[v]:\nif not vis[nbr]:\nvis[nbr] = True\nvisit(G, nbr)\nvisit(G, 0) #nodes reachable from s\nif not all(vis): return False\nGreverse = [[] for v in range(n)]\nfor v in range(n):\nfor nbr in G[v]:\nGreverse[nbr].append(v)\nvis = n \\* [False] #reset vis for the second search\nvis[0] = True\nvisit(Greverse, 0) #nodes that can reach s\nreturn all(vis)\nThe runtime is still O(m)\n, but the space is now O(m)\nbecause we need to create and store the reverse graph. There are alternative algorithms (like Tarjan's algorithm) which can do this in O(n)\nspace.\nHow many connected components are there?\nWe can use the typical DFS to answer this question for undirected graphs. We use a common pattern in DFS algorithms: an outer loop through all the nodes where we launch a search for every yet-unvisited node.\ndef numConnectedComponents(G): #G is undirected\nn = len(G)\nvis = n \\* [False]\ndef visit(v):\nfor nbr in G[v]:\nif not vis[nbr]:\nvis[nbr] = True\nvisit(nbr)\nnumCCs = 0\nfor v in range(n):\nif not vis[v]:\nnumCCs += 1\nvis[v] = True\nvisit(v)\nreturn numCCs\nThe runtime is now O(n+m)\nbecause, if m < n\n, we still spend O(n)\ntime iterating through the loop at the end.\nFor directed graphs, instead of connected components, we talk about strongly connected components. A strongly connected component is a maximal subset of nodes where every node can reach every other node.\nIf we want to find the number of strongly connected components, we can use something like Tarjan's algorithm, a DFS-based algorithm that requires some additional data structures.\nPractice problems\n- https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/ (Premium only)\n- https://leetcode.com/problems/number-of-islands/\n- https://leetcode.com/problems/friend-circles/\nWhich nodes are in the same connected components?\nThis question is more general than the previous two. We label each node v\nwith a number CC[v]\nso that nodes with the same number belong to the same CC. Instead of having a list CC\nin addition to vis\n, we use the CC number -1\nto indicate unvisited nodes. This way, we do not need vis\ndef connectedComponents(G): #G is undirected\nn = len(G)\nCC = n \\* [-1]\n##invariant: v is labeled with CC i>=0\ndef visit(v, i):\nfor nbr in G[v]:\nif CC[nbr] == -1:\nCC[nbr] = i\nvisit(nbr, i)\ni = 0\nfor v in range(n):\nif CC[v] == -1:\nCC[v] = i\nvisit(v, i)\ni += 1\nreturn CC\nFor directed graphs, again we need Tarjan's algorithm or an equivalent algorithm.\nPractice problems\n- https://leetcode.com/problems/max-area-of-island/\n- https://leetcode.com/problems/sentence-similarity-ii/\nIn the second problem, nodes are given by names, not indices, so they need to be converted.\nIs the graph acyclic?\nFor undirected graphs, this question is simple. First, we consider the problem in each CC independently. This is very common pattern in graph problems. We do this with an outer loop through all the nodes where we launch a search for every yet-unvisited node.\nDuring the DFS search in each CC, if we find an edge to an already visited node that is not the predecessor in the search (the node we just came from), there is a cycle. Such edges in a DFS search are called back edges. We add one parameter to the recursive function visit\nto know the predecessor node.\ndef hasCycles(G): #G is undirected\nn = len(G)\nvis = n \\* [False]\n#returns True if the search finds a back edge\ndef visit(v, p):\nfor nbr in G[v]:\nif vis[nbr] and nbr != p: return True\nif not vis[nbr]:\nvis[nbr] = True\nif visit(nbr, v): return True\nreturn False\nfor v in range(n):\nif not vis[v]:\nvis[v] = True\n#the root of the search has no predecessor\nif visit(v, -1): return True\nreturn False\nFor directed graphs, it is not as simple: the fact that a neighbor nbr\nis already visited during the DFS search does not mean that nbr\ncan reach the current node. To check if a directed graph is acyclic, we can use the linear-time peel-off algorithm for finding a topological ordering. This algorithm detects if the graph is acyclic and finds a topological ordering if so, though we are only interested in the first part.\nPractice problems\nThis problem is easier to solve using union-find, but it can be done with DFS.\nIs the graph a tree?\nUsually, we ask this question for undirected graphs. We can use this characterization of trees:\nAn undirected graph is a tree if and only if it is connected and has exactly n-1\nedges.\nWe already saw how to check if the graph is connected with DFS, and counting the number of edges is straightforward:\n#for undirected graphs:\nm = sum(len(G[v]) for v in range(n)) / 2\n#for directed graphs:\nm = sum(len(G[v]) for v in range(n))\nPractice problems\nIs the graph bipartite?\nThis is exactly the same question as whether the graph can be two-colored, so see the next section.\nCan the graph be two-colored?\nTwo-coloring a graph means assigning colors to the nodes such that no two adjacent nodes have the same color, using only two colors. Usually, we consider coloring question for undirected graphs.\nWe consider whether each CC can be colored independently from the others. We can color each CC using DFS. We use values 0\nand 1\nfor the colors. The color of the start node can be anything, so we set it to 0\n. For the remaining nodes, the color has to be different from the parent, so we only have one option.\nInstead of having a vis\narray, we use the special color -1\nto denote unvisited nodes.\ndef is2Colorable(G): #G is undirected\nn = len(G)\ncolor = n \\* [-1]\n#returns True if we can color all the nodes reached from v\n#invariant: v has an assigned color\ndef visit(v):\nfor nbr in G[v]:\nif color[nbr] == color[v]: return False\nif color[nbr] == -1:\ncolor[nbr] = 1 if color[v] == 0 else 0\nif not visit(nbr): return False\nreturn True\nfor v in range(n):\nif color[v] == -1:\ncolor[v] = 0\nif not visit(v): return False\nreturn True\nWith 3 or more colors, the problem becomes a lot harder.\nPractice problems\nWhat is the distance from a node s to every other node in a tree?\nWe cannot use DFS to find the distance between nodes in a graph which can have cycles, because DFS is not guaranteed to follow the shortest path from the root to the other nodes. For that, BFS is more suitable (if the graph is unweighted). However, since trees are acyclic, there is a unique path between any two nodes, so DFS must use the unique path, which, by necessity, is the shortest path. Thus, we can use DFS to find distances in a tree.\ndef getDistances(G, s): #G is undirected and a tree\nn = len(G)\ndists = n \\* [-1]\ndists[s] = 0\n#invariant: v has an assigned distance\ndef visit(v):\nfor nbr in G[v]:\n#check nbr is not the predecessor\nif dists[nbr] != -1: continue\ndists[nbr] = dists[v] + 1\nvisit(nbr)\nvisit(s)\nreturn dists\nPractice problems\nFind a spanning tree\nA spanning tree of a connected, undirected graph G\nis a subgraph which has the same nodes as G\nthat is a tree.\nThe edges traversed by a DFS search on a connected graph form a spanning tree (sometimes called a DFS tree). Thus, we do DFS and add the traversed edges to the resulting tree.\ndef spanningTree(G): #G is undirected and connected\nn = len(G)\nvis = n \\* [False]\nvis[0] = True\nT = [[] for v in range(n)]\ndef visit(v):\nfor nbr in G[v]:\nif not vis[nbr]:\nvis[nbr] = True\nT[v].append(nbr)\nT[nbr].append(v)\nvisit(nbr)\nvisit(0)\nreturn T\nConclusions\nDFS has many uses. We showed how to make minor modifications to the DFS template to answer reachability and connectivity questions.\nAfter DFS, the next algorithm to learn would be BFS (breath-first search). Like DFS, it can answer reachability questions. On top of that, it can also answer questions about distance in undirected graphs.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/reachability-problems-and-dfs",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Breaking Down Dynamic Programming",
      "content": "Breaking Down Dynamic Programming\nNote: the approach in this guide later became the foundation for the dynamic programming chapter in Beyond Cracking the Coding Interview.\nIntroduction\nWhen I was a TA for \"Algorithm Design and Analysis\", the students struggled with dynamic programming. To simplify/demystify it, I tried to break it down into a logical sequence of steps, each of which should not feel too intimidating on its own. This is explained in detail here. To complement the explanations, there are links to problems on leetcode.com, in case the reader wants to practice. The code snippets are in Python, but Leetcode accepts most popular languages.\nOverview: Recursive vs Iterative DP\nIn short, dynamic programming (DP) is a technique for problems that seem hard to solve as a whole, but become easy if we know the solution to smaller subproblems. More technically, we can use it in problems where the (value of the) solution can be expressed as an equation which is a function of the input, and is expressed in terms of itself with smaller inputs. This is called a recurrence equation. The classic example is the Fibonacci recurrence: Fib(n) = Fib(n-1) + Fib(n-2)\n.\nA recurrence equation can be translated into code:\ndef Fib(n):\nif n == 0 or n == 1:\nreturn 1\nreturn Fib(n-1) + Fib(n-2)\nHowever, the above function has an exponential runtime. A recursive function becomes exponential when it is possible to reach the same subcall through different execution paths. In the Fibonacci case, we have the following nested calls: Fib(n) -> Fib(n-1) -> Fib(n-2)\n, and Fib(n) -> Fib(n-2)\n. Since Fib(n-2)\nis called twice all the work from this call is duplicated, which in turn means that subcalls made from Fib(n-2)\nwill start to duplicate and grow exponentially.\nDynamic programming is simply a workaround to this duplication issue. Instead of recomputing the solutions of the subproblems, we store them and then we recall them as needed. This guarantees that each subproblem is computed only once.\nThere are two main approaches for DP.\nRecursive / Top-down DP\nWe start with the code which is a literal translation of the recurrence equation, but then we add a dictionary / hash table to store results.\nmemo = {}\ndef Fib(n):\nif n == 0 or n == 1:\nreturn 1\nif n in memo:\nreturn memo[n]\nres = Fib(n-1) + Fib(n-2)\nmemo[n] = res\nreturn res\nThere are three changes in the code above:\n- declaring our dictionary for storing results,\nmemo\noutside the recursive function (memo comes \"memorization\" or \"memoization\", a name used in the literature). - before computing the result, we check if the solution has already been computed. This check can be done before or after the base case.\n- before returning, we save the result in the\nmemo\ntable.\nUsing a memoization table in this way solves the inefficiency (we will go deeper into the analysis part later).\nIterative / Bottom-up DP\nInstead of starting from the largest input and recursively reaching smaller subproblems, we can directly compute the subproblems from smallest to largest. This way, we already have the solutions to the subproblems when we need them. For this approach, we change the dictionary for an array/vector, and we change recursive calls for a for loop.\ndef Fib(n):\nif n == 0: return 1\nmemo = [0 for i in range(n+1)]\nmemo[0], memo[1] = 1, 1\nfor i in range(2, n+1):\nmemo[i] = memo[i-1] + memo[i-2]\nreturn memo[n]\nMost problems can be solved with both recursive and iterative DP. Here are some considerations for how to choose:\n- Recursive DP matches the recurrence equation more directly, so it can be easier to implement.\n- Both have the same runtime complexity, but the recursive version will generally have larger constant factors due to all the recursive function calling and due to using a hash table instead of an array.\n- Iterative DP often allows for an optimization to reduce the space complexity (discussed later).\nRecursive DP in 5 Steps\n- Choose what your subproblems are.\n- Find the recurrence equation.\n- Translate the recurrence equation into recursive code.\n- Add memoization.\n- (Optional) Reconstruct the solution.\nWe already saw steps 1–4 with the Fibonacci example. Now, we will walk through all the steps in more detail using a more complicated example, the longest common subsequence problem:\nGiven two strings s1\nand s2\n, find the length of the longest string which is a subsequence of both s1\nand s2\n. A string t\nis a subsequence of a string s\nif every char in t\nappears in order in s\n, but are not necessarily contiguous. For example, abc\nis a subsequence of axbyz\n, but ba\nis not (do not confuse subsequence with substring or subset).\nStep 1: choose our subproblems. This varies from problem to problem, but when the input to the problem is a string, a natural way to obtain smaller problems is to look at shorter strings. Here we can use as a subproblem a prefix of s1\nand a prefix of s2\n.\nSome notation: let n\nbe the length of s1\nand m\nthe length of s2\n. Let LCS(i,j)\nbe the solution for the LCS problem for the prefix of s1\nof length n\n(s1[0..i-1]\n) and the prefix of s2\nof length m\n(s2[0..j-1]\n). Then, our goal is to find LCS(n, m)\n.\nStep 2: find the recurrence equation. Now we need to come up with an expression for LCS(i,j)\nas a function of LCS\nwith smaller indices (as well as a base case). This is the hardest step of DP, and often it is here that we realize that we chose bad subproblems in Step 1. If that happens, hopefully we will discover some hint for what our subproblems should be.\nIn order to derive the recurrence equation for LCS, we need the following observation: if the two strings end with the same character c\n, then, to maximize the length of the subsequence, it is \"safe\" to add c\nto the subsequence. In contrast, if both strings end with different characters, then at least one of them cannot appear in the subsequence. The complication is that we do not know which one. Thus, instead of guessing, we can simply consider both options.\nThis observation yields the recurrence equation (excluding base case):\nLCS(i, j) = 1 + LCS(i-1, j-1) if s[i] == s[j]\nmax(LCS(i, j-1), LCS(i-1, j)) otherwise\nThis step is not intuitive at first, and requires practice. After having done a few problems, one starts to recognize the typical patterns in DP. For instance, using max\namong a set of options of which we do not know which one is the best is easily the most common pattern in DP.\nStep 3. Translate the recurrence equation into recursive code. This step is a very simple programming task. Pay attention to the base case.\n#outer call:\nLCS(len(s1), len(s2))\ndef LCS(i, j):\nif i == 0 or j == 0:\nreturn 0\nif s1[i-1] == s2[j-1]:\nreturn 1 + LCS(i-1, j-1)\nelse:\nreturn max(LCS(i, j-1), LCS(i-1, j))\nIf we draw the few first steps of the call graph, we will see that the same subproblem is reached twice. Thus, call graph blows up, leading to an exponential runtime.\nStep 4. Add memo table. This step should be automatic: one does not even need to understand the previous code in order to add the memo table.\n#outer call:\nmemo = {}\nLCS(len(s1), len(s2))\ndef LCS(i, j):\nif i == 0 or j == 0:\nreturn 0\nif (i,j) in memo:\nreturn memo[(i,j)]\nif s1[i-1] == s2[j-1]:\nres = 1 + LCS(i-1, j-1)\nelse:\nres = max(LCS(i, j-1), LCS(i-1, j))\nmemo[(i,j)] = res\nreturn res\nThe base case corresponds to when one of the strings is empty. The LCS of an empty string with another string is clearly an empty string.\nIncidentally, if we flip the check on the memo table, the code becomes a bit more streamlined (fewer lines + merging the two returns). I prefer this form (it does the same):\ndef LCS(i, j):\nif i == 0 or j == 0:\nreturn 0\nif (i,j) not in memo:\nif s1[i-1] == s2[j-1]:\nmemo[(i,j)] = 1 + LCS(i-1, j-1)\nelse:\nmemo[(i,j)] = max(LCS(i, j-1), LCS(i-1, j))\nreturn memo[(i,j)]\nWe have eliminated the exponential blowup. In general, DP algorithms can be analyzed as follows: # of distinct subproblems times time per subproblem excluding recursive calls. For LCS, we get O(nm)\\*O(1)=O(nm)\n.\nStep 5. Reconstruct the solution.\nWe used DP to compute the length of the LCS. What if we want to find the LCS itself?\nA naive way to do it would be to store the entire result of each subproblem in the memoization table instead of just its length. While this works, it is clear that it will require a lot of memory to store O(nm)\nstrings of length O(min(n,m))\neach. We can do better.\nStep 5, \"Reconstruct the solution\", is how to reuse the table that we constructed in Step 4 to find the actual solution instead of just its length. I said that this step is optional because sometimes we just need the value of the solution, so there is no reconstruction needed.\nThe good news is that we do not need to modify the code that we already wrote in Step 4. The reconstruction is a separate step that comes after. In addition, the reconstruction step is very similar (follows the same set of cases) as the step of building the memo table. In short, we use the memo table as an \"oracle\" to guide us in our choices. Based on the values in the memo table, we know which option is better, so we know how to reconstruct the solution.\n#outer calls\nmemo = {}\nn, m = len(s1), len(s2)\nLCS(n, m) #build memo table\nsol = reconstructLCS(n, m)\ndef reconstructLCS(i, j):\nif i == 0 or j == 0:\nreturn \"\"\nif s1[i-1] == s2[j-1]:\nreturn reconstructLCS(i-1, j-1) + s1[i-1]\nelif memo[(i-1,j)] >= memo[(i,j-1)]:\nreturn reconstructLCS(i-1, j)\nelse:\nreturn reconstructLCS(i, j-1)\nIn the code above, first we run LCS(n,m)\nto fill the memo table. Then, we use it in the reconstruction. The condition memo[(i-1,j)] >= memo[(i,j-1)]\ntells us that we can obtain a longer or equal LCS by discarding a char from s1\ninstead of from s2\n.\nNote that there is a single recursive call in the reconstruction function, so the complexity is just O(n+m)\n.\nIterative DP in 6 Steps\n- Choose what your subproblems are.\n- Find the recurrence equation.\n- Design the memo table.\n- Fill the memo table.\n- (Optional) Reconstruct the solution.\n- (Optional) Space optimization.\nThe new/different steps are highlighted. Step 3. is to design the layout of the table/matrix where we are going to store the subproblem solutions. There is no coding in this step. By \"design\", I mean making the following choices:\n- what are the dimensions of the table, and what does each index mean. Generally speaking, the table should have one dimension for each parameter of the recurrence equation. In the case of LCS, it will be a 2-dimensional table.\n- where are the base cases.\n- where is the cell with the final solution.\n- what is the ``dependence relationship'' between cells (which cells do you need in order to compute each cell).\n- which cells do not need to be filled (in the case of LCS, we need them all).\nHere is how I would lay out the table for LCS (you can find a different layout in the problems below):\nNext (Step 4), we fill the memo table with a nested for loop. If the layout is good, this should be easy. Before the main loop, we fill the base case entries. Then, we must make sure to iterate through the table in an order that respects the dependencies between cells. In the case of LCS, we can iterate both by rows or by columns.\nWe obtain the following algorithm:\ndef LCS(s1, s2):\nn, m = len(s1), len(s2)\nmemo = [[0 for j in range(m+1)] for i in range(n+1)]\nfor i in range(1, n+1):\nfor j in range(1, m+1):\nif s1[i-1] == s2[j-1]:\nmemo[i][j] = 1 + memo[i-1][j-1]\nelse:\nmemo[i][j] = max(memo[i-1][j], memo[i][j-1])\nreturn memo[n][m]\nIn the code above, the base case entries are filled implicitly when we initialize the table with zeros everywhere.\nIf we need to reconstruct the solution, we can do it in the same way as for the recursive DP. The only difference is that memo is a matrix instead of dictionary.\nSpace optimization\nClearly, the space complexity of iterative DP is the size of the DP table. Often, we can do better. The idea is to only store the already-computed table entries that we will use to compute future entries. For instance, in the case of Fibonacci, we do not need to create an entire array -- keeping the last two numbers suffice. In the case of a 2-dimensional DP table, if we are filling the DP table by rows and each cell only depends on the previous row, we only need to keep the last row (and similarly if we iterated by columns). Here is the final version for LCS where we improve the space complexity from O(nm)\nto O(n+m)\n:\ndef LCS(s1, s2):\nn, m = len(s1), len(s2)\nlastRow = [0 for j in range(m+1)]\nfor i in range(1,n+1):\ncurRow = [0 for j in range(m+1)]\nfor j in range(1,m+1):\nif s1[i-1] == s2[j-1]:\ncurRow[j] = 1 + lastRow[j-1]\nelse:\ncurRow[j] = max(lastRow[j], curRow[j-1])\nlastRow = curRow\nreturn lastRow[m]\nNote: this optimization is incompatible with reconstructing the solution, because that uses the entire table as an \"oracle\".\nDP Patterns\nHere are some typical patterns:\nFor Step 1. The subproblems.\n- If the input is a string or a list, the subproblems are usually prefixes or substrings/sublists, which can be specified as a pair of indices.\n- If the input is a number, the subproblems are usually smaller numbers.\n- Generally speaking, the number of subproblems will be linear or quadratic on the input size.\nFor Step 2. The recurrence equation.\n- Often, we use\nmax\normin\nto choose between options, or sum to aggregate subsolutions. - The number of subproblems is most often constant, but sometimes it is linear on the subproblem size. In the latter case, we use an inner loop to aggregate/choose the best solution.\n- Sometimes, the recurrence equation is not exactly for the original problem, but for a related but more constrained problem. See an example below, \"Longest Increasing Subsequence\".\nPractice Problems\nHere are some practice problems showcasing the patterns mentioned above. Follow the Leetcode links for the statements and example inputs. I jump directly to the solutions. I'd recommend trying to solve the problems before checking them.\nHere, the goal is to count the number of substrings of a string s\nwhich are palindromic. There is a trivial O(n³)\ntime solution without DP:\ndef countSubstrings(s):\nn = len(s)\ncount = 0\nfor i in range(n):\nfor j in range(i, n):\nif isPalindrome(s[i:j+1]):\ncount += 1\nreturn count\nWe can improve this to O(n²)\nwith DP. The subproblems are all the substrings of s\n. Let Pal(i, j)\nbe true iff s[i..j]\nis a palindrome. We have the following recurrence equation (excluding base cases):\nPal(i, j) = false if s[i] != s[j],\nPAl(i, j) = Pal(i+1, j-1) otherwise\nBased on this recurrence equation, we can design the following DP table:\nThis type of \"diagonal\" DP tables are very common when the subproblems are substrings/sublists. In this case, the base cases are substrings of length 1 or 2. The goal is Pal(0,n-1)\n.\nGiven the dependency, the table can be filled by rows (starting from the last row), by columns (starting each column from the bottom), or by diagonals (i.e., from shortest to longest substrings). In the code below, I illustrate how to fill the table by diagonals.\ndef countSubstrings(s):\nn = len(s)\nT = [[False for j in range(n)] for i in range(n)]\nfor i in range(n):\nT[i][i] = True\nfor i in range(n-1):\nT[i][i+1] = s[i] == s[i+1]\nfor size in range(2, n+1):\nfor i in range(0,n-size):\nj = i + size\nT[i][j] = s[i] == s[j] and T[i+1][j-1]\ncount = 0\nfor row in T:\nfor val in row:\nif val:\ncount += 1\nreturn count\nHere, a subproblem can be a grid with reduced width and height. Let T[i][j]\nbe the cheapest cost to reach cell (i,j)\n. The goal is to find T[n-1][m-1]\n, where n\nand m\nare the dimensions of the grid. The base case is when either i\nor j\nare zero, in which case we do not have any choices for how to get there. In the general case, we have the recurrence equation T[i][j] = grid[i][j] + min(T[i-1][j], T[i][j-1])\n: to get to (i,j)\n, we first need to get to either (i-1,j)\nor to (i,j-1)\n. We use min\nto choose the best of the two. We convert this into an iterative solution:\ndef minPathSum(grid):\nn, m = len(grid), len(grid[0])\nT = [[0 for j in range(m)] for i in range(n)]\nT[0][0] = grid[0][0]\nfor i in range(1, n):\nT[i][0] = grid[i][0] + T[i-1][0]\nfor j in range(1, m):\nT[0][j] = grid[0][j] + T[0][j-1]\nfor i in range(1, n):\nfor j in range(1, m):\nT[i][j] = grid[i][j] + min(T[i-1][j], T[i][j-1])\nreturn T[n-1][m-1]\nThis is similar to the previous problem, but we need to accumulate the solutions to the subproblems, instead of choosing between them. Problems about counting solutions can often be solved with DP.\nThis problem will illustrate a new trick: if you cannot find a recurrence equation for the original problem, try to find one for a more restricted version of the problem which nevertheless you enough information to compute the original problem.\nHere, the input is a list L\nof numbers, and we need to find the length of the longest increasing subsequence (a subsequence does not need to be contiguous). Again, the subproblems correspond to prefixes of the list.\nLet LIS(i)\nbe the solution for the prefix of length i\n(L[0..i]\n). The goal is to find LIS(n-1)\n, where n\nis the length of L\n.\nHowever, it is not easy to give a recurrence equation for LIS(i)\nas a function of smaller prefixes. In particular, the following is wrong (I will let the reader think why):\nLIS(i) = LIS(i-1) + 1 if L[i] > L[i-1],\nLIS(i) = LIS(i-1) otherwise\nThus, we actually give a recurrence equation for a slightly modified type of subproblems: let LIS2(i)\nbe the length of the LIS ending at index i. This constraint makes it easier to give a recurrence equation:\nLIS2(i) = 1 + max(LIS2(j)) over all j < i such that L[j] < L[i]\nIn short, since we know that the LIS ends at L[i]\n, we consider all candidate predecessors, which are the numbers smaller than it, and get the best one by using max\n. Crucially, this recurrence works for LIS2(i)\nbut not for LIS(i)\n.\nHere is a full solution:\ndef LIS(L):\nn = len(L)\nT = [0 for i in range(n)]\nT[0] = 1\nfor i in range(1, n):\nT[i] = 1\nfor j in range(0, i):\nif L[j] < L[i]:\nT[i] = max(T[i], T[j] + 1)\nreturn max(T)\nAt the end, we do not simply return T[n-1]\nbecause T\nis the table for LCS2\n, not LCS\n. We return max(T)\nbecause the LCS must end somewhere, so LCS(n-1) = LCS2(j)\nfor some j < n\n.\nNote that the runtime is O(n²)\neven though the table has linear size. This is because we take linear time per subproblem.\nA harder version of the previous problem. A similar approach works. First solve the LIS problem as before, and then do a second pass to count the solutions.\nThis problem is similar to LCS, and it requires reconstruction.\nI should mention that not every problem that can be solved with DP fits into the mold discussed above. Despite that, it should be a useful starting framework. Here are many more practice problems:\n- https://leetcode.com/tag/dynamic-programming/",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/breaking-down-dynamic-programming",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Iterative Tree Traversals: A Practical Guide",
      "content": "Iterative Tree Traversals: A Practical Guide\nIntroduction\nI don't know how often tree traversals come up in actual software projects, but they are popular in coding interviews and competitive programming. In this article, I share an approach for implementing tree traversal algorithms iteratively that I found to be simple to remember and implement, while being flexible enough to do anything that a recursive algorithm can (I also didn't like most suggestions I saw online). The main technique is given in section \"Iterative Postorder and Inorder Traversal\", but first I give some context. I also link to practice problems on leetcode.com for the reader to play with. I provide some solutions, but I suggest trying the problems out first. The code snippets are in C++, but leetcode accepts most languages.\nWhat are Tree Traversals\nMathematically, trees are just connected acyclic graphs. However, in the context of tree traversals, we are usually working with rooted trees represented with a recursive structure such as the following (which is the default definition in Leetcode for binary trees). A leaf is a node with two null pointers as children:\nstruct TreeNode {\nint val;\nTreeNode \\*left;\nTreeNode \\*right;\nTreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nA tree traversal is an algorithm that visits every node in a tree in a specific order (and does some computation with them, depending on the problem). For binary trees specifically, there are three important orders:\n- Preorder: root before children. As we will see, this is the simplest to implement.\n- Inorder: left child, then root, then right child. This traversal is most often used on binary search trees (BST). A BST is a rooted binary tree with the additional property that every node in the left subtree has a smaller value than the root, and every node in the right subtree has a larger value than the root. This traversal is called \"inorder\" because, when used on a BST, it will visit the nodes from smallest to largest.\n- Postorder: children before root. It comes up in problems where we have to aggregate information about the entire subtree rooted at each node. Classic examples are computing the size, the height, or the sum of values of the tree.\nBecause rooted trees are recursive data structures, algorithms on trees are most naturally expressed recursively. Here are the three traversals. I use the function process(node)\nas a placeholder for whatever computation the problem calls for.\nvoid preorderTraversal(TreeNode\\* root) {\nif (!root) return;\nprocess(root);\npreorderTraversal(root->left);\npreorderTraversal(root->right);\n}\nvoid inorderTraversal(TreeNode\\* root) {\nif (!root) return;\ninorderTraversal(root->left);\nprocess(root);\ninorderTraversal(root->right);\n}\nvoid postorderTraversal(TreeNode\\* root) {\nif (!root) return;\npostorderTraversal(root->left);\npostorderTraversal(root->right);\nprocess(root);\n}\nSide-note: in C++, pointers are implicitly converted to booleans: a pointer evaluates to true if and only if it is not null. So, in the code above, \"if (!root)\n\" is equivalent to \"if (root == NULL)\n\".\nTraversal problems on leetcode\n- https://leetcode.com/problems/binary-tree-preorder-traversal/\n- https://leetcode.com/problems/binary-tree-inorder-traversal/\n- https://leetcode.com/problems/binary-tree-postorder-traversal/\nWhy / When to Use an Iterative Traversal\nIf the recursive implementation is so simple, why bother with an iterative one? Of course, to avoid stack overflow. Most runtime engines/compilers set a limit on how many nested calls a program can make. For example, according to this article:\nDefault stack size varies between 320k and 1024k depending on the version of Java and the system used. For a 64 bits Java 8 program with minimal stack usage, the maximum number of nested method calls is about 7000.\nIf the height of the tree is larger than this limit, the program will crash with a stack overflow error. A recursive implementation is safe to use if:\n- Somehow we know that the input trees will be small enough.\n- The tree is balanced, which means that, for each node, the left and right subtrees have roughly the same height. In a balanced tree, the height is guaranteed to be logarithmic on the number of nodes (indeed, that is why balanced BSTs guarantee O(log n) search time), so any tree that fits in RAM (or even disk) will require a tiny number of recursive calls.\nHowever, if we are not in either of the cases above, an iterative solution is safer.\nRecursive and iterative traversals have the same runtime complexity, so this is not a concern when choosing either (all the problems shown in this article can be solved in linear time using either).\nThe main approach for converting recursive implementations to iterative ones is to \"simulate\" the call stack with an actual stack where we push and pop the nodes explicitly. This works great \"out-of-the-box\" with preorder traversal.\nIncidentally, when implementing tree traversals we need to make an implementation choice about how to handle NULL pointers. We can be eager and filter them out before adding them to the stack, or we can be lazy and detect them once we extract them from the stack. Both are fine—what matters is to be deliberate and consistent about which approach we are using. I prefer the latter as it yields slightly shorter code, so I will use it in all the following examples. For comparison, here is the iterative preorder traversal with both approaches:\n//eager NULL checking\nvoid preorderTraversal(TreeNode\\* root) {\nstack stk;\nif (!root) return;\nstk.push(root);\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top();\nstk.pop();\nprocess(node);\nif (node->right) stk.push(node->right);\nif (node->left) stk.push(node->left);\n}\n}\n//lazy NULL checking\nvoid preorderTraversal(TreeNode\\* root) {\nstack stk;\nstk.push(root);\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top();\nstk.pop();\nif (!node) continue;\nprocess(node);\nstk.push(node->right);\nstk.push(node->left);\n}\n}\nNote that the right child is pushed to the stack before the left one. This is because we want the left child to be above in the stack so that it is processed first.\nPreorder traversal practice problems\n- https://leetcode.com/problems/invert-binary-tree/\n- https://leetcode.com/problems/maximum-depth-of-binary-tree/\nThis problem asks to find the depth of a binary tree (follow the link for the description and examples). It requires passing information from each node to its children. We can do this by changing the stack to stack>\n, so that we can pass an int\nto each child, as in the solution below:\nint maxDepth(TreeNode\\* root) {\nint res = 0;\nstack> stk;\nstk.push({root, 1}); //node, depth\nwhile (!stk.empty()) {\nauto node = stk.top().first;\nint depth = stk.top().second;\nstk.pop();\nif (!node) continue;\nres = max(res, depth);\nstk.push({node->left, depth+1});\nstk.push({node->right, depth+1});\n}\nreturn res;\n}\nIn the code above, the {}\nnotation is used to create pairs (e.g., {root, 0}\n). If one is not familiar with pairs in C++, or is using a language without the equivalent, a simple alternative is to use two separate stacks, one for the nodes and one for the info.\nThe next two problems are similar:\n- https://leetcode.com/problems/minimum-depth-of-binary-tree/\n- https://leetcode.com/problems/path-sum/\n- https://leetcode.com/problems/symmetric-tree/\nA solution for the last one, this time using a stack with a pair of nodes:\nbool isSymmetric(TreeNode\\* root) {\nif (!root) return true;\nstack> stk;\nstk.push({root->left, root->right});\nwhile (!stk.empty()) {\nTreeNode\\* l = stk.top().first;\nTreeNode\\* r = stk.top().second;\nstk.pop();\nif (!l and !r) continue;\nif (!l or !r or l->val != r->val) return false;\nstk.push({l->left, r->right});\nstk.push({l->right, r->left});\n}\nreturn true;\n}\nIterative Postorder and Inorder Traversal\nWhile iterative preorder traversal is straightforward, with postorder and inorder we run into a complication: we cannot simply swap the order of the lines as with the recursive implementation. In other words, the following does not yield a postorder traversal:\n...\nstk.push(node->right);\nstk.push(node->left);\nprocess(node);\n...\nThe node is still processed before its children, which is not what we want.\nThe workaround, once again emulating the recursive implementation, is to visit each node twice. We consider postorder traversal first. In the first visit, we only push the children onto the stack. In the second visit, we do the actual processing.\nThe simplest way to do this is to enhance the stack with a \"visit number flag\". Implementation-wise, we change the stack to stack>\nso that we can pass the flag along with each node. The iterative postorder looks like this:\nvoid postorderTraversal(TreeNode\\* root) {\nstack> stk; //node, visit #\nstk.push({root, 0});\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top().first;\nint visit = stk.top().second;\nstk.pop();\nif (!node) continue;\nif (visit == 0) {\nstk.push({node, 1});\nstk.push({node->right, 0});\nstk.push({node->left, 0});\n} else { //visit == 1\nprocess(node);\n}\n}\n}\nNote the order in which the nodes are added to the stack when visit == 0\n. The parent ends up under its children, with the left child on top. Since it is the first time that the children are added to the stack, their visit-number flag is 0. For the parent, it is 1.\nFor simplicity, I also follow the convention to always immediately call pop after extracting the top element from the stack.\nThe same approach also works for inorder traversal (that's the point). Here is a version where we visit each node three times: one to push the left child, one to process the node, and one to push the right child.\n//3-visit version\nvoid inorderTraversal(TreeNode\\* root) {\nstack> stk;\nstk.push({root, 0});\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top().first;\nint visit = stk.top().second;\nstk.pop();\nif (!node) continue;\nif (visit == 0) {\nstk.push({node, 1});\nstk.push({node->left, 0});\n} else if (visit == 1) {\nstk.push({node, 2});\nprocess(node);\n} else { //visit == 2\nstk.push({node->right, 0});\n}\n}\n}\nIn fact, the second and third visits can be merged together: processing the node does not modify the stack, so the two visits are followed one after the other anyway. Here is my preferred version:\n//2-visit version\nvoid inorderTraversal(TreeNode\\* root) {\nstack> stk;\nstk.push({root, 0});\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top().first;\nint visit = stk.top().second;\nstk.pop();\nif (!node) continue;\nif (visit == 0) {\nstk.push({node, 1});\nstk.push({node->left, 0});\n} else { //visit == 1\nprocess(node);\nstk.push({node->right, 0});\n}\n}\n}\nFor completeness, here is the version found in most of my top Google hits (see this for a nice explanation):\nvoid inorderTraversal(TreeNode\\* root) {\nstack stk;\nTreeNode\\* curr = root;\nwhile (curr or !stk.empty()) {\nwhile (curr) {\nstk.push(curr);\ncurr = curr->left;\n}\ncurr = stk.top();\nstk.pop();\nprocess(curr);\ncurr = curr->right;\n}\n}\nWhile it is shorter, it cannot be easily converted to postorder traversal, so it is not as flexible. Also, I find it easier to follow the execution flow with the visit-number flag.\nInorder traversal practice problems\nA solution (follow the link for the statement and examples):\nint kthSmallest(TreeNode\\* root, int k) {\nint count = 1;\nstack> stk;\nstk.push({root, 0});\nwhile (!stk.empty()) {\nauto node = stk.top().first;\nint visit = stk.top().second;\nstk.pop();\nif (!node) continue;\nif (visit == 0) {\nstk.push({node, 1});\nstk.push({node->left, 0});\n} else { //visit == 1\nif (count == k) return node->val;\ncount++;\nstk.push({node->right, 0});\n}\n}\nreturn -1;\n}\nA solution:\nbool isValidBST(TreeNode\\* root) {\nint lastVal;\nbool init = false;\nstack> stk;\nstk.push({root, 0});\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top().first;\nint visit = stk.top().second;\nstk.pop();\nif (!node) continue;\nif (visit == 0) {\nstk.push({node, 1});\nstk.push({node->left, 0});\n} else { //second visit\nif (!init) {\ninit = true;\nlastVal = node->val;\n} else {\nif (node->val <= lastVal) return false;\nlastVal = node->val;\n}\nstk.push({node->right, 0});\n}\n}\nreturn true;\n}\nPostorder traversal practice problems\nThis problem asks to check if a binary tree is balanced. It requires passing information back from the children to the parent node in a postorder traversal. Passing information from the children to the parent is easy with recursion. It can be done both with return values or with parameters passed by reference. For this problem we need to pass two things: a bool\nindicating if the subtree is balanced, and an int\nindicating its height. I use a reference parameter for the latter (returning a pair\nwould be cleaner).\nbool isBalancedRec(TreeNode\\* root, int& height) {\nif (!root) {\nheight = 0;\nreturn true;\n}\nint lHeight, rHeight;\nbool lBal = isBalancedRec(root->left, lHeight);\nbool rBal = isBalancedRec(root->right, rHeight);\nheight = max(lHeight, rHeight) + 1;\nreturn lBal && rBal && abs(lHeight - rHeight) <= 1;\n}\nbool isBalanced(TreeNode\\* root) {\nint height;\nreturn isBalancedRec(root, height);\n}\nPassing information from the children to the parent in an iterative implementation is more intricate. There are three general approaches:\n- Use a hash table mapping each node to the information.\nThis is the easiest way, but also the most expensive. While the asymptotic runtime is still linear, hash tables generally have significant constant factors.\nbool isBalanced(TreeNode\\* root) {\nstack> stk;\nstk.push({root, 0});\nunordered\\_map height;\nheight[NULL] = 0;\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top().first;\nint visit = stk.top().second;\nstk.pop();\nif (!node) continue;\nif (visit == 0) {\nstk.push({node, 1});\nstk.push({node->right, 0});\nstk.push({node->left, 0});\n} else { // visit == 1\nint lHeight = height[node->left], rHeight = height[node->right];\nif (abs(lHeight - rHeight) > 1) return false;\nheight[node] = max(lHeight, rHeight) + 1;\n}\n}\nreturn true;\n}\n- Add a field to the definition of the node structure for the information needed.\nThen, we can read it from the parent node by traversing the children's pointers.\nIn Leetcode we cannot modify the TreeNode\ndata structure so, to illustrate this approach, I build a new tree first with a new struct:\nstruct MyNode {\nint val;\nint height;\nMyNode \\*left;\nMyNode \\*right;\nMyNode(TreeNode\\* node): val(node->val), height(-1), left(NULL), right(NULL) {\nif (node->left) left = new MyNode(node->left);\nif (node->right) right = new MyNode(node->right);\n}\n};\nbool isBalanced(TreeNode\\* root) {\nif (!root) return true;\nMyNode\\* myRoot = new MyNode(root);\nstack> stk;\nstk.push({myRoot, 0});\nwhile (!stk.empty()) {\nMyNode\\* node = stk.top().first;\nint visit = stk.top().second;\nstk.pop();\nif (!node) continue;\nif (visit == 0) {\nstk.push({node, 1});\nstk.push({node->right, 0});\nstk.push({node->left, 0});\n} else { // visit == 1\nint lHeight = 0, rHeight = 0;\nif (node->left) lHeight = node->left->height;\nif (node->right) rHeight = node->right->height;\nif (abs(lHeight - rHeight) > 1) return false;\nnode->height = max(lHeight, rHeight) + 1;\n}\n}\nreturn true;\n}\n- Pass the information through an additional stack.\nThis is the most efficient, but one must be careful to keep both stacks in synch. When processing a node, that node first pops the information from its children, and then pushes its own info for its parent. Here is a solution (with eager NULL-pointer detection):\nbool isBalanced(TreeNode\\* root) {\nif (!root) return true;\nstack> stk;\nstk.push({root, 0});\nstack heights;\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top().first;\nint visit = stk.top().second;\nstk.pop();\nif (visit == 0) {\nstk.push({node, 1});\nif (node->right) stk.push({node->right, 0});\nif (node->left) stk.push({node->left, 0});\n} else { // visit == 1\nint rHeight = 0, lHeight = 0;\nif (node->right) {\nrHeight = heights.top();\nheights.pop();\n}\nif (node->left) {\nlHeight = heights.top();\nheights.pop();\n}\nif (abs(lHeight - rHeight) > 1) return false;\nheights.push(max(lHeight, rHeight) + 1);\n}\n}\nreturn true;\n}\nThis problem also requires passing information from the children to the parent in a postorder traversal. Here is a solution using the third approach again, but this time with lazy NULL-pointer detection. Note that we push a 0 to the depths\nstack when we extract a NULL pointer from the main stack, and during processing we always do two pops regardless of the number of non-NULL children:\nint diameterOfBinaryTree(TreeNode\\* root) {\nstack> stk;\nstk.push({root, 0});\nstack depths;\nint res = 0;\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top().first;\nint visit = stk.top().second;\nstk.pop();\nif (!node) {\ndepths.push(0);\ncontinue;\n}\nif (visit == 0) {\nstk.push({node, 1});\nstk.push({node->right, 0});\nstk.push({node->left, 0});\n} else { //visit == 1\nint rDepth = depths.top();\ndepths.pop();\nint lDepth = depths.top();\ndepths.pop();\nint depth = max(lDepth, rDepth) + 1;\ndepths.push(depth);\nint dia = lDepth + rDepth;\nres = max(res, dia);\n}\n}\nreturn res;\n}\n- https://leetcode.com/problems/binary-tree-tilt/\n- https://leetcode.com/problems/most-frequent-subtree-sum/\n- https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/\nTraversals in n-ary Trees\nSo far, we have looked at binary trees. In an n-ary tree, each node has an arbitrary number of children.\nstruct Node {\nint val;\nvector children;\nNode(int val): val(val), children(0) {}\n};\nFor n-ary trees, preorder traversal is also straightforward, and inorder traversal is not defined.\nFor postorder traversal, we can use a visit-number flag again. Two visits suffice for each node: one to push all the children into the stack, and another to process the node itself. I do not include the code here because it is very similar to the binary tree case.\nConsider a more complicated setting where we need to compute something at the node after visiting each child. Let's call this \"interleaved traversal\". I use process(node, i)\nas placeholder for the computation done before visiting the i-th child. Here is the recursive implementation and the corresponding iterative one using visit-number flags.\n//recursive\nvoid interleavedTraversal(Node\\* root) {\nif (!root) return;\nint n = root->children.size();\nfor (int i = 0; i < n; i++) {\nprocess(root, i);\ninterleavedTraversal(root->children[i]);\n}\n}\n//iterative\nvoid interleavedTraversal(Node\\* root) {\nstack> stk;\nstk.push({root, 0});\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top().first;\nint visit = stk.top().second;\nstk.pop();\nif (!node) continue;\nint n = node->children.size();\nif (visit < n) {\nstk.push({node, visit+1});\nprocess(node, visit);\nstk.push({node->children[visit], 0});\n}\n}\n}\nN-ary tree practice problems\n- https://leetcode.com/problems/n-ary-tree-preorder-traversal/\n- https://leetcode.com/problems/n-ary-tree-postorder-traversal/\nAn Alternative Way of Passing the Visit Flag\nThe common framework to all our solutions has been to pass a visit-number flag along with the nodes on the stack. User \"heiswyd\" on leetcode posted here an alternative way to pass the flag implicitly: initially, it pushes each node on the stack twice. Then, it can distinguish between the first visit and the second visit by checking whether the node that has just been extracted from the stack matches the node on top of the stack. This happens only when we extract the first of the two occurrences. Post-order traversal looks like this:\nvoid postorderTraversal(TreeNode\\* root) {\nstack stk;\nstk.push(root);\nstk.push(root);\nwhile (!stk.empty()) {\nTreeNode\\* node = stk.top();\nstk.pop();\nif (!node) continue;\nif (!stk.empty() and stk.top() == node) {\nstk.push(node->right);\nstk.push(node->right);\nstk.push(node->left);\nstk.push(node->left);\n} else {\nprocess(node);\n}\n}\n}\nIt is cool, but I prefer passing the flag explicitly for clarity.",
      "content_type": "blog",
      "source_url": "https://nilmamano.com/blog/iterativetreetraversal",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Shreycation | Shrey G | Substack",
      "content": "Shreycation\nSubscribe\nSign in\nHome\nSnacks\nLeaderboard\nsnacks\nSnacks: It's not too late for Euro Summer flights\nProcrastinators rejoice: you can still fly to Europe for 15k miles each way\nMay 30\n•\nShrey G\n1\nShare this post\nShreycation\nSnacks: It's not too late for Euro Summer flights\nCopy link\nFacebook\nEmail\nNotes\nMore\nSnacks: How to girl math your Lyfts\nYour Lyfts could be free...if you know what you're doing.\nApr 6, 2024\n•\nShrey G\n2\nShare this post\nShreycation\nSnacks: How to girl math your Lyfts\nCopy link\nFacebook\nEmail\nNotes\nMore\nSnacks: Alaska joins Bilt\nAlso: half off London flights, check if you're flying Boeing, and more\nMar 21, 2024\n•\nShrey G\n3\nShare this post\nShreycation\nSnacks: Alaska joins Bilt\nCopy link\nFacebook\nEmail\nNotes\nMore\n2\nSnacks: fly cross-country for just 5k points?!\nAir Canada 🤝 Bilt brings you the deal of the month with an unheard of 150% transfer bonus. Here's how to make the most of it.\nJan 30, 2024\n•\nShrey G\n5\nShare this post\nShreycation\nSnacks: fly cross-country for just 5k points?!\nCopy link\nFacebook\nEmail\nNotes\nMore\nSnacks: earn free miles when shopping\nI flew NYC to SF for free and all I did was click a button\nJan 22, 2024\n•\nShrey G\n2\nShare this post\nShreycation\nSnacks: earn free miles when shopping\nCopy link\nFacebook\nEmail\nNotes\nMore\n2\nShare\nCopy link\nFacebook\nEmail\nNotes\nMore\nThis site requires JavaScript to run correctly. Please\nturn on JavaScript\nor unblock scripts",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/t/snacks",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Snacks: It's not too late for Euro Summer flights",
      "content": "Snacks: It's not too late for Euro Summer flights\nProcrastinators rejoice: you can still fly to Europe for 15k miles each way\nHi Shreycationers,\nIt’s been a while! I hope you didn’t miss me too much, but rest assured, Shreycation is back and here to stay. In a later post I’ll share a bit more about what I’ve been up to (launching the world’s first hybrid human + AI travel agency, Anecdote Travel!), but for now, there’s something more pressing: helping you get flights for your Europe summer plans.\nNothing quite says summer like hopping across the Atlantic to sip an Aperol spritz, but if you’re a procrastinator like me, those flights are getting pricey.\nHere’s the price map for roundtrips between San Francisco and various spots in Europe. Big yikes:\nReally, there’s nothing south of $1000. Fortunately, you read Shreycation and we’ve identified the best opportunities for you to use your points. Here’s how you can get your bank to pick up the tab for your sunny spree on the Spanish coast.\nAir France/KLM Flying Blue\nYou may remember my love for the Air France and KLM’s joint program, Flying Blue. Every month, Flying Blue chooses a set of cities to enjoy a promotional discount of 25% off — if you fly from those cities to basically anywhere in Europe, you’ll be able to enjoy the promo rate, if they have availability.\nEconomy flights between the USA and Europe cost 25k Flying Blue points one-way usually, so with the 25% discount, you’re looking at 18.75k points instead. And as a cherry on top, if you’ve got a Chase card, Chase Ultimate Rewards currently has a 25% transfer bonus to Flying Blue. That means you just need to transfer 15k Chase points to Flying Blue — that’ll get boosted to 18.75k, and you’re looking at a free flight to Europe!\nThe current promo cities are also quite convenient for my coastal readers here: San Francisco, Atlanta, Washington, Miami, Boston, and even my hometown of Phoenix are all getting repped this time! Even some of my readers over in Asia are getting some love, with discount fares from Hong Kong and Singapore. I’ve rarely seen such a convenient set of origin cities for Flying Blue promo award, so take advantage now. (Full list of promo cities here.)\nGenerally, I saw a decent amount of availability left for July and August flights. Here’s a sample one I found for SF to Madrid on July 5:\nFlying Blue does charge you for fuel surcharges, so you’ll still owe some money, but it’s still a great deal. Let’s do some quick maths: this flight costs $610 on Google Flights, so after the $120 in surcharges, we’re using 18750 Flying Blue miles to pay for the remaining $490. If you’re transferring from Chase, you’re really only burning 15000 Chase points, so that’s $490/15000 = 3.2¢/point, more than double what your points are worth in the Chase portal!\nIf you like a little more luxury, business class tickets are 45k points as long as you fly from Montreal — this might be a viable move for my NYC friends here (just grab a cheap NYC > Montreal flight, and fly business across the pond).\nA few quick tips for this Flying Blue promotion:\nThe promotion is almost over — May 31 is the last day to book. However, you can book for any dates up till Oct 31, so there’s no need to fly soon. New promo rates will go live in June, but the origin cities might not be this convenient.\nIf you need to change or cancel, it costs 70 EUR. Even if you’re not sure about your trip, given how good the savings are, it might still be worth getting a ticket.\nEven if you don’t live in one of the origin cities, you can just buy a cheap flight to one of those cities, and then fly from there.\nNot all dates will have the promo rates still available. We’re in the last 2 days of this promotion, so many June dates are gone by now, but just use their point calendar at the top of the search screen to locate the 18750 mile fares. It bugs out sometimes when you search roundtrips, so I’d suggest searching one-ways instead.\nVirgin Atlantic\nAnother one of my favorite hacks for getting to Europe for cheap is using Virgin Atlantic. For many summer dates, you can fly from NYC to London for just 12k Virgin Atlantic miles. And even better, Chase is also running a 25% transfer bonus for Virgin Atlantic too — you can be in London for just 9600 Chase points.\nNote that Virgin Atlantic does also charge fuel surcharges, but like with Flying Blue, it’s still a great deal. This flight would usually cost $358 on Google Flights, so after deducting the $76 surcharge and factoring in the Chase transfer bonus, you’re getting just shy of 3¢/point!\nAnd if you want to mourn the end of summer with some off-season travel to London, it’s just 6000 Virgin miles for that same flight in September (or just 4800 Chase points)! This is so insanely cheap that I might just buy one of these on impulse.\nA few quick caveats:\nHere I showed one-ways to London, but the flights from London back to the US can sometimes be surprisingly expensive if you buy them as one-ways rather than as part of a roundtrip ticket. If you fly back from somewhere else in Europe, this isn’t much of a problem.\nUnlike with Flying Blue, these cheaper rates exist mostly just for flights to/from London. If you’re on the west coast, expect to pay a little more (e.g. 15k points).\nSave Money, Travel Well\nEven though we’re officially in summer now, doesn’t mean you can’t get some cheap tickets to Europe! Flying Blue and Virgin Atlantic consistently offer some great fares to Europe, and they aren’t slouching one bit for summertime. Chase holders get some extra sprinkles on top with that transfer bonus.\nAnd if you’re looking for hotels for Europe, it’s still not too late for that either. At Anecdote, we’ve been handling dozens of summer trips — we can help you find a great hotel and add some awesome perks (free breakfast, room upgrades) to boot.\nThe world of points has changed a lot in the last year, so let me know what you want me to talk about next!\nAnd if you haven’t yet, subscribe for more travel and points goodness.",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/snacks-its-not-too-late-for-euro",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Comments - Snacks: It's not too late for Euro Summer flights",
      "content": "Shreycation\nSubscribe\nSign in\nShare this post\nShreycation\nSnacks: It's not too late for Euro Summer flights\nCopy link\nFacebook\nEmail\nNotes\nMore\nSnacks: It's not too late for Euro Summer…\nShrey G\nMay 30\n1\nShare this post\nShreycation\nSnacks: It's not too late for Euro Summer flights\nCopy link\nFacebook\nEmail\nNotes\nMore\nProcrastinators rejoice: you can still fly to Europe for 15k miles each way\nRead →\nComments\nShare\nCopy link\nFacebook\nEmail\nNotes\nMore\nThis site requires JavaScript to run correctly. Please\nturn on JavaScript\nor unblock scripts\nShare this post\nSnacks: It's not too late for Euro Summer…\nShare this post\nProcrastinators rejoice: you can still fly to Europe for 15k miles each way",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/snacks-its-not-too-late-for-euro/comments",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Snacks: How to girl math your Lyfts - by Shrey G",
      "content": "It’s Saturday and a lot of you are about to end your night by taking a $50 Lyft back home. Not a fun expense, but saving 20% on it would make it feel a bit better.\nThis isn’t a limited time discount — turns out you can get at least 20% off any time on your Lyfts. It just requires a bit of girl math.\nThe Chase Sapphire Reserve earns a whopping 10x points on Lyft rides. Last year I flew a $10000 business class itinerary in United Polaris business class by transferring 99k Chase points to United MileagePlus, garnering a value of 10¢/point. I definitely had some of my Lyfts contribute to those 99k points, and since I earned 10x points and redeemed those points for 10¢ a point, I effectively got $1 back for every $1 I spent on a Lyft. In other words, my Lyfts were free.\nNow a 10¢/point redemption isn’t super common and mostly exists when flying premium cabins, but even if you just redeem on economy flights, you can still get a pretty sizable discount on your Lyfts. At the very least, you can redeem Chase points in the Chase portal directly for 1.5¢/point. But if you transfer those points into airlines, you can easily and routinely get at least 2¢/point. That means you’re effectively earning 20¢ per dollar you spend on Lyft — 20% off!\nSo next time it’s late at night and you’re Lyfting back home, know that if you girl math it, you’re at least getting it at a discount.\n(Unfortunately for my Uber loyalists, this arbitrage is a Lyft only thing. The Capital One Savor cards will give you 10% off Ubers, but 10% isn’t the same as 10x points.)\nIf you’re subscribed yet, this is your sign. Saving on Lyfts is just the tip of the iceberg. Follow for points tips, tricks, frameworks, and breakdowns that you can actually use.",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/snacks-lyft-girl-math",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Comments - Snacks: How to girl math your Lyfts - by Shrey G",
      "content": "Shreycation\nSubscribe\nSign in\nShare this post\nShreycation\nSnacks: How to girl math your Lyfts\nCopy link\nFacebook\nEmail\nNotes\nMore\nSnacks: How to girl math your Lyfts\nShrey G\nApr 6, 2024\n2\nShare this post\nShreycation\nSnacks: How to girl math your Lyfts\nCopy link\nFacebook\nEmail\nNotes\nMore\nYour Lyfts could be free...if you know what you're doing.\nRead →\nComments\nShare\nCopy link\nFacebook\nEmail\nNotes\nMore\nThis site requires JavaScript to run correctly. Please\nturn on JavaScript\nor unblock scripts\nShare this post\nSnacks: How to girl math your Lyfts\nShare this post\nYour Lyfts could be free...if you know what you're doing.",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/snacks-lyft-girl-math/comments",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Robinhood's Latest Quest - by Shrey G - Shreycation",
      "content": "Hi Shreycationers,\nThis week I was gonna talk about how to hack basic economy, but then Robinhood upended those plans when they dropped one of their biggest announcements in years: a 3% cash back credit card.\nI mean she is truly a stunning card. But looks aren’t everything. Let’s dive in and see what this card is made of.\n(It’s made of 17 grams of stainless steel.)\n(Disclaimer: This post is not financial advice and you should do your own research to ensure the cards mentioned in this article are right for you. Applying will likely affect your credit score.)\nWhat’s great\nFirst things first, Robinhood’s done a great job stealing headlines with this card, and it’s not just all show. This is indeed a wonderfully designed card.\nA simple 3% cash back on everything\nEveryone’s talking about the flagship feature, the 3% cash back on everything. And with good reason: 3% is the highest base cash back rate across any card I’ve seen. There’s not much else to say here — it’s truly a great cash back rate with no hoops to jump through. There’s something refreshing about the simplicity here, and it’s especially great for beginners.\nBut there’s other features that didn’t get as much attention and are also worth highlighting.\nNo foreign transaction fees\nNo foreign transaction fees means you can truly use this card to earn 3% on everything, including that shopping spree in Milan.\nWaiving foreign transaction fees used to limited to high annual fee cards, but recently low/no annual fee cards have been introducing it too, including the Apple Card and the Capital One Quicksilver. The Robinhood Gold card is by far the most versatile and valuable of these though. For those who don’t like to carry many cards, you can now ditch whatever low annual fee, no foreign transaction fee card you might have and get 3% on your abroad expenses instead.\nSpend using Virtual Cards\nThis is actually the perk I’m most excited for with this card, because as far as I know, no other card on the market offers native virtual cards.\nVirtual cards let you hide your true credit card number when spending online, and allow you to set an expiry date and spending limit. The killer use case here is managing subscriptions: if you just want 1 month of Hulu to binge Shogun, you can load a virtual card with $8 and have it expire in a month. If you forget to cancel your subscription, it won’t matter; your payment method will be invalid by the month’s end anyway.\nVirtual card services like Privacy have existed for a while, but as third party services they’re not as convenient, and their free offerings aren’t as robust as what Robinhood seems to be providing here.\nSurprising amount of protections\nThe Robinhood Gold card is part of the Visa Signature family, which comes with various optional benefits that credit card providers can activate. I’m happy to say Robinhood really went for extra credit here; this card is loaded with benefits, including:\nPurchase security: If you buy something nice and it gets lost or stolen in 90 days, you can get up to $1k back.\nExtended warranties: You can extend the warranty of new purchases by up to a year.\nReturn protection: If you aren’t satisfied with a recent purchase and the store won’t take it back, you can get reimbursed up to $250.\nTrip cancellation protection: If you get injured before or during a trip, you can get up to $2k to cover nonrefundable arrangements.\nAuto rental collision damage waiver: You can skip the insurance at the rental car office when you use you card to rent.\nMany other low annual fee cards have some subset of these perks, but Robinhood is giving you basically everything. If you’ve got premium cards like an Amex platinum, you likely already have access to many of these perks (and with better limits), but this is still spectacular for what is effectively a starter card. The only notable perk that’s missing here is cell phone protection (get reimbursed if your phone is lost/stolen).\n5% cash back when booking travel\n…but that travel has to be booked through Robinhood’s forthcoming travel portal. Now if you’ve used these travel portals through Chase or Amex or other cards, you know these portals aren’t that fun or convenient to use. Also, sometimes these portals don’t have the flights and hotels you’re interested in. Robinhood’s portal isn’t live so it’s hard to make judgements quite yet, but something tells me it won’t be groundbreaking here.\n5% cash back has been emerging as a popular number for spend in travel portals, so this number isn’t as groundbreaking as the 3% cash back. You’ll earn the same with a Chase Freedom or a Capital One Quicksilver. But still, 5% is 5%, and it’s good to see Robinhood meeting the industry standard here.\nWhat’s not so great\nYou need Robinhood Gold…and you need to maintain it\nThe card’s $0 annual fee branding is a little bit misleading. In order to get the card, you’ll need to be a Robinhood Gold subscriber. But you also need to maintain Robinhood Gold to keep the card.\nThis will be one of the first times I’ve seen a card’s good standing status tied to some external monthly subscription, and I’m not totally sure how this will work. If you decide not to pause your Robinhood Gold subscription for a month or two, do they close your credit card? Who knows.\nFortunately, Robinhood Gold is only $5/month, and if you already invest with Robinhood, it’s a bit of a no brainer: you’ll get a free $1k in margin, lower margin interest rates, 5% on uninvested cash, and more.\nThis card earns cash back, not points\nIn the world of cash back cards, Robinhood’s 3% universal cash back might as well make it the new king. But cash back cards are the little league since they aren’t nearly as flexible or value as cards earning points. That’s because the value of cash back is fixed but the value of points is variable. 1¢ of cash back is 1¢ of cash back and will always be just 1¢ of cash back. But depending on your skill and luck, 1 point could be redeemed for anything from 1¢ to 10¢. That means a card that earns a standard 1x points on everything could be the equivalent of earning 1% to 10% cash back depending on how you use those points.\nShreycation is all about helping you learn how to use your points well. With some basic knowledge, it’s pretty easy to achieve a rate of at least 2¢/point on virtually all of your award travel redemptions. That means a card like the Chase Freedom Unlimited that earns 1.5x points on everything nets me at least 3¢ per dollar I spend. On the other hand, the Robinhood Gold card also earns me 3¢ per dollar, but that’s a hard cap — it’ll only earn me 3¢ per dollar.\nNo sign up bonus or intro 0% APR\nThe Robinhood Gold account comes with no sign up bonuses or introductory 0% APR rates whatsoever. For other cards in this category, there’s usually a ~$200 sign up bonus, and at least 1 year of 0% APR.\nIf you intend on actively using this card for many years, the lack of a bonus might not be a huge issue today, but do note that it’ll take almost $7k in spending to match the free sign up bonus of its peers.\nThe bigger issue is the lack of a 0% APR intro period. Right now, if you rack up a $10k balance on a card with 12 months of 0% APR, you can instead invest all that money in a high yield savings account and earn 5% over the course of the year. That’s basically the equivalent of a 5% cash back on everything. You’re forgoing that option if you choose to spend more on a Robinhood Gold card.\nA word of caution\nThe card has some pretty awesome perks and a killer cash back earning structure today, but these aren’t necessarily guaranteed in the future, especially for younger companies like Robinhood.\nWe’ve seen this in the past with cards like the Uber Visa Card, which used to give 4% on dining, 3% on travel, and 2% on Ubers — pretty awesome for a no annual fee card. But over time, the card kept getting nerfed and eventually became less and less compelling until it was finally shuttered.\nThat’s not to say this will necessarily happen to the Robinhood card, but it’s good to know that this may not last in perpetuity.\nIf you’re enjoying our breakdown of the Robinhood Gold card, subscribe for more! I’ll be writing about my favorite underrated cards and hacks to save you money.\nWho should actually get this card?\nBeginners and people who don’t wanna deal with points.\nBy itself, this card ticks a lot of boxes: great cash back on everything, solid protections, no transaction fees. This makes it an excellent card for beginners.\nI’ve waxed poetic about the value of points above, but if care more about simplicity, a card that gives 3% cash back without having to think about it is a pretty solid middle ground. And if you don’t travel much in the first place, you won’t be able to extract much of the value of your points anyway — cash back could be the better option.\nThe Robinhood Gold card also effectively renders many other cash back cards obsolete, meaning you can double down on simplicity and get by with fewer cards. Most cash back fans can now get by with just two cards: (1) the Robinhood Gold, and (2) some card that earns 5% on seasonal categories (e.g. Chase Freedom Flex, Discover It).\nPeople who don’t have a great catch all card yet\nA key element of any good personal card portfolio is a “catch all” card that earns > 1% cash back or 1x points on non-category spend. In other words, it’s cool if you have swanky cards that earn 3% on travel and dining (“category spend”), but if you also drop $3000 a year on Rumble Boxing or have a crippling shopping addiction, it would be nice to earn boosted cash back here too.\nCatch all cards usually don’t have highly boosted cash back on special categories, but they do have slightly boosted cash back on everything. Up till now, 2% was about the best you could do for a catch all cash back card (RIP Citi Double Cash), but now Robinhood has blown this out of the water with its 3% and is the obvious choice.\nThere’s one big caveat: if you have one of the premium travel cards — a Chase Sapphire, Amex Gold or Platinum, or a Capital One Venture — it might make sense to choose a card in those ecosystems as your catch all card. That’s a topic for another Shreycation issue, but generally you’ll get more value (and better purchase protections) on those cards than the Robinhood Gold.\nPeople who hate taxes but like math\nDeath and taxes may be the only two things guaranteed in life, but the Robinhood card can help you reduce your annual subscription to Uncle Sam.\nThe IRS lets you pay your outstanding taxes using a credit card. They’ll charge you 1.8% for this privilege, but if you’re using a card that gives you 3% cash back…you see where I’m going here.\nCourtesy of Robinhood, you can now enjoy a 1.2% discount on income taxes you pay directly. If most of your income comes from W-2 earnings, your employer is already withholding most of your income taxes for you and you’re likely not paying much on tax day, meaning this hack probably won’t be as useful. But if you have lots of 1099 earnings (e.g. from freelancing or side gigs), have high capital gains, or own a business and pay quarterly taxes, you’re usually paying a large chunk of your tax liability directly. By using the Robinhood Gold card to pay, you could keep hundreds of extra dollars in your pocket.\nWe can go one step further for a really cheeky version of this hack. Since you’re paying taxes with a credit card, you have at least a whole month to pay down the balance while avoiding an interest charge. So maybe instead of paying down the card immediately, stick that tax money in a 5% APY high yield savings account for a month, and then pay your card. 5% APY earned for one month translates to a ~0.4% ROI, boosting your effective tax discount to 1.6%.\nYou can also do this hack with the Paypal Mastercard (which gives you 3% cash back on Paypal transactions), but the Robinhood Gold card is a way more versatile card to have in your wallet.\nIf you’ve decided the Robinhood Gold is the way to go for you, you can use the link below to add yourself to the waitlist. We’ve also got some alternative cards below that are worth your consideration!\nOther cards that might be worth instead\nChase Freedom Unlimited\nI’ve mentioned this card a few times in this article, but the Chase Freedom Unlimited is a very compelling alternative to the Robinhood Gold if you’ve already got a Chase Sapphire Preferred or Reserve.\n1.5% cash back on everything…BUT if you have a Chase Sapphire card, you can opt to receive 1.5x points instead. And as we discussed above, 1.5 pts is easily worth at least 3¢.\nAlso, 5x on travel booked through Chase Travel, 3x on dining, 3x on drugstores\nMany of the same protections as the Robinhood card, minus return protection.\nSign up bonus of 20000 points and 15 months of 0% APR.\nNo annual fee.\nWells Fargo Autograph\nWells Fargo has really been stepping up its game lately and has started building their own points ecosystem with their own transfer partners. I’ll write more about it later, but their starter card is the Wells Fargo Autograph and its quite compelling.\n3x points on many categories: dining, gas, travel, transit, streaming, and phone services. For some of you, this might be the majority of your spend (groceries and shopping are notably missing though).\nSign up bonus of 20000 points and 12 months of 0% APR.\nDoesn’t have as many protections as the Robinhood Gold, but does offer cell phone protection.\nNo annual fee.\nThanks for reading! At the end of the day, Robinhood is selling simplicity, but credit cards don’t exist in a vacuum — they exist in your wallet with your other cards. I hope this article helped breakdown the Robinhood Gold card, and gives you a good sense of whether its right for you. As always, feel free to add questions in the comments, and share with a friend.\nBon Voyage,\nShrey",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/robinhood-gold-card",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Comments - Robinhood's Latest Quest - by Shrey G",
      "content": "Shreycation\nSubscribe\nSign in\nShare this post\nShreycation\nRobinhood's Latest Quest\nCopy link\nFacebook\nEmail\nNotes\nMore\nRobinhood's Latest Quest\nShrey G\nMar 28, 2024\n2\nShare this post\nShreycation\nRobinhood's Latest Quest\nCopy link\nFacebook\nEmail\nNotes\nMore\nIs the new Gold credit card really a bullseye?\nRead →\nComments\nShare\nCopy link\nFacebook\nEmail\nNotes\nMore\nThis site requires JavaScript to run correctly. Please\nturn on JavaScript\nor unblock scripts\nShare this post\nRobinhood's Latest Quest\nShare this post\nIs the new Gold credit card really a bullseye?",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/robinhood-gold-card/comments",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Snacks: Alaska joins Bilt - by Shrey G - Shreycation",
      "content": "Snacks: Alaska joins Bilt\nAlso: half off London flights, check if you're flying Boeing, and more\nHi Shreycationers,\nIt’s been a minute! Some awesome stuff coming soon, but for now, a nice ol’ bag of snacks.\nAlaska Airlines Joins Bilt\nAlaska Airlines has some of the best redemptions in the market, but they’ve always been so hard to claim since Alaska wasn’t a transfer partner of any major credit card. Read: if you want Alaska miles, you gotta fly Alaska.\nThat changed last week, when Bilt signed on Alaska as a transfer partner. I swear, I’m not sponsored by Bilt but they do keep rolling out the hits. I’m actually surprised they managed to make this partnership work, but they also did manage to break through with American Airlines, and American + Alaska have their own partnership too now … maybe just a simple matter of 2 + 2.\nAlaska Airlines’ Mileage Plan program has a couple awesome attributes:\nYou can book flights across all of oneworld (e.g. American, British Airways, Cathay Pacific, Japan Airlines, Qatar, Qantas, Iberia) AND their non-alliance partners (e.g. Korean Air, Singapore Airlines, LATAM). This list covers some of the best airlines in the world!\nYou can book free stopovers even on one-way awards. If you don’t know what a stopover is, I’ve written extensively about them before — it’s your way to turn a single trip into multiple for free.\nHere’s how you can use all this to your advantage. Let’s say you want to do a huge Asia trip. You can book NYC <> HKG (Hong Kong) with a stopover in Tokyo on the way there and another stopover in Singapore on the way back. This would usually cost you 152k miles if you booked every leg individually, but thanks to the free stopover policy, you only spend 108k miles. Valuing your miles at 2¢/point, that’s $880 saved on a 3 destination Asia trip.\nH/t to my buddy Sweyn for sending me this even before it came up on my news feed.\nCheck if you’re on a Boeing plane\nBoeing has been in the news for all the wrong reasons lately. I won’t care to speculate on the causes here, but even though air travel remains remarkably safe, it’s understandable if you to avoid Boeing so you can sleep better on your flight.\nIf you’ve got a flight coming up, you can check out amiflyingonaboeing.com, made by yours truly to quickly check what aircraft you’re flying on.\n50% off London flights via Virgin Atlantic\nVirgin Atlantic has a 50% off deal on all award flights from the US to the UK ending midnight tonight!\nThat means for a sample NYC <> LHR trip:\neconomy roundtrips start from 10k miles (usually 20k)\npremium economy roundtrips start from 17.5k miles (usually 35k)\nbusiness economy roundtrips start from 47.5k miles (usually 95k)\nNote that this only applies to flights on Virgin Atlantic itself, and must involve trips that complete before June 30.\nNow there is one somewhat unfortunate issue preventing this from being one of the greatest points deals this year. Virgin Atlantic charges fuel surcharges on award flights, meaning you can’t just focus on the miles cost. For example, a roundtrip starting May 10th requires 10k Virgin miles + $492, but the equivalent “Economy Classic” ticket would cost $667. That still values your miles at 1.75¢/point (($667 - $492) / 10000), but it’s not amazing. Premium economy gives you some better value, at 3.1¢/point (would usually cost $1773 in cash).\nBut there’s a hack. I won’t get into the weeds here, but often you can get cheaper fuel surcharges if you book two separate one-way tickets rather than one roundtrip. For example, here’s what happens if I book the same premium economy itinerary, but as two one ways.\nNote the points cost remains the same: 8.75k + 8.75k = 17.5k miles. But the fuel surcharge is cheaper; instead of $1227, it’s $453 + £394, which converts to $957. You save $270 literally by clicking some buttons differently.\nWait I don’t have Virgin Atlantic miles though. Oh my friend, you most definitely do. Virgin Atlantic partners with every major card program, so transfer away. (If you ever forget who transfers to who, I’ve made a super nice diagram here.)\nWhat if I’m not ready to commit to a flight now? It’s inconvenient that this deal expires tonight. But you can always change your flight for $50. You can also cancel at least 24 hrs before the flight to get your miles and taxes back. Fuel surcharges should also be refunded in most cases.\nUse AirTags to save your bags\nOne of my favorite travel hacks is sticking an AirTag in your luggage. There’s nothing like having peace of mind that your checked bags have truly made it onto the plane! And if something goes wrong, you have some reference of where your bag might be.\nSince chances are someone handling your bag has an iPhone, you can usually track your bag’s journey in granular detail. Also, as soon as you log onto inflight wifi with an iPhone, chances are some other iPhone user is sitting just above where your bag is in the cargo hold, and you can make sure your bag is happily enjoying its flight too 😄\nAirTags are on discount right now too! AirTags usually cost $100 for a set of 4, but Amazon is selling them for $80 right now.\nThanks for reading! I know I’ve been away for a while; I’ve been gearing up for a launch that’s very near and dear to my heart, and you’ll be hearing it first here.\nI’ve also got so many awesome in-depth articles planned for the coming weeks, including how to hack basic economy, the (only) hotel program that’s worth pursuing, and a framework on how to actually think about using your points. If you’re not subscribed yet, be sure to subscribe and share with a friend so you don’t miss out!\nBon Voyage,\nShrey\nHot\nShreycation killing it again!!",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/snacks-alaska-joins-bilt",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to actually transfer your points - by Shrey G",
      "content": "Hi Shreycationers,\nWe’ve been talking a lot about how you can use your credit card points to get outsized value on your points. Instead of just getting 1¢/point, you can squeeze out 3x, 5x, or even 10x the value just by transferring your points into airline mileage programs to book “award travel.” This also lets you book free flights on airlines where you might not otherwise have any miles; just transfer them over from a card! There are entire forums dedicated to going down the rabbit hole on strategies for optimally deploying your points.\nBut if it’s your first rodeo, you’re probably hung up on a more fundamental question: how do I actually move the points from one program to another? The UIs for many of these credit card and airlines program are historically a bit lacking, so the process can be unintuitive.\nSo without further ado, a play by play guide on how to actually transfer your points.\nStep 0: Identify your redemption\nOne of my dear Shreycation readers was recently fed up with the 29 degree weather in NYC and needed to escape somewhere warm. He wanted to book a flight to Hawaii, so I helped him through the process. Now I’ll be walking you through that same process in this issue.\nBefore we can book our travel using points, we must pinpoint available award seats that can be redeemed with an airline's mileage program. It’s essential to ensure this award space exists BEFORE we transfer points from your credit card, as once points are transferred, there's no going back. Point transfers are one-way and irreversible. Finding ideal award space is the subject of Shreycation issues past, present, and future, but for the purpose of this example, we’ll work with one of my favorite award redemption paths.\nI’ve previously talked about how you can book dirt cheap domestic flights on United Airlines by redeeming miles in the Turkish Airlines Miles & Smiles program. (Turkish and United are partners, meaning I can redeem Turkish points on a United ticket.) Traveling to Hawaii counts as domestic travel in Turkish’s eyes, so we can take advantage of a sweet spot here and book a EWR (Newark) to HNL (Honolulu) flight for a very cheap 10k Turkish miles. (Booking this flight directly with United would cost 30k+ United miles.)\nNow I don’t have any Turkish miles since I rarely fly on Turkish in the first place, but there’s where our credit card points come in. We can mint miles in Turkish by transferring from points from a card.\nStep 1: Transfer the points\nNow that you know where you want to redeem your points, go to your credit card rewards portal to start the transfer. You’re looking for a button that says something like “Transfer points.” Note that you do NOT want to go through their “Book travel” feature; this is for booking travel on cash (or using your credit card points directly, which is usually a pretty poor use of points).\nSome quick links to your rewards portal: Chase, Amex, Capital One, Citi, Bilt (use app)\nHere’s where to find the magic “transfer points” button in a few major card portals:\nConfirm your credit card is partnered with your desired airline mileage program\nNot all airlines are partnered with all credit card partners, so you’ll first need to make sure you use a credit card that can transfer to your desired airline mileage program. (This is also why I recommend having cards in multiple programs, even if it’s the entry level cards!)\nHere’s a handy diagram I made for y’all to see all the transfer partners at a glance:\nGoing back to our EWR-HNL example, we’re booking through Turkish Airlines, so according to the diagram above, I’d need to use Bilt, Capital One, or Citi to transfer points. If I go the “Transfer” tab in the Bilt app, I can scroll down and select Turkish:\nIf you haven’t made an account with the target mileage program yet, you’ll need to do that first and enter your account number when transferring.\nCalculate how many points you need to transfer\nMost of the time, this is dead simple. The vast majority of points transfer tend to be at a 1:1 ratio, so if you need 10k airline miles, just transfer 10k credit card points. That means I just need to transfer 10k Bilt points into Turkish Airlines to book my EWR-HNL flight.\nA few caveats:\nThere are some rare exceptions to the 1:1 transfer ratio, like transferring to EVA Air via Capital One.\nCredit card programs often run transfer bonuses where you get more miles per point you transfer. You can take advantage of these bonuses to get hilariously cheap award travel, like many Shreycation readers did on Air Canada earlier this month. Bilt is renowned for their killer 75-150% transfer bonuses on the 1st of each month, and other programs like Chase and Amex have run 30-60% bonuses in the past.\nLearning how to finally use that small fortune of points you’ve been sitting on? Send this article to a friend who desperately needs some help! (We have a referral program here at Shreycation that’ll score you some dope content and perks; use the button below to make sure your referral counts.)\nStep 2: Wait\nMany point transfers are nearly instant. Once you’ve triggered the request from the credit card portal, you can usually make a quick coffee and by the time you’re back, the miles will be credited to your airline mileage account.\nFor example, my points took 10 minutes to transfer from Bilt to Turkish, and I got an email confirmation from Bilt telling me the deed was done.\nSometimes, the transfers can take longer though. For example, transferring Bilt points to American AAdvantage or Amex points to Singapore KrisFlyer can take up to 24 hours. Good award tickets tend to go away quickly, so if you’re dealing with a partner that has a transfer delay, you can often call up the airline to “hold” the award for you. This lets you rest easy knowing someone else won’t swoop your spot just because your points were in transit.\nStep 3: Book it\nNow that you’ve transferred the points, you can return back to the portal for the airline you’re booking through and complete your booking!\nWait why am I being charged cash too?\nOften when booking award travel, you might notice you’ll still need to enter your credit card and pay some cash. This is because most award travel has a few taxes and surcharges, on top of the miles you’re redeeming. You can’t pay for these extra fees in miles unfortunately.\nThe surcharges vary pretty significantly across different mileage programs. Some programs like United charge a nominal amount of $5.60 (to cover the TSA security fee). However, others may charge you the dreaded “fuel surcharge”, a fee that often scales by distance and cabin class and can add hundreds to the flight cost. Air France is known for doing this:\nSince these fuel surcharges can be hefty, it’s important to consider those when valuing your redemption — spending 27k miles to get a $400 flight for free is less compelling if you’re spending $170 in surcharges.\nStep 4: Manage your flight\nNow that you have your flight booked, you might be wondering how to manage your flight (e.g. check in, change your seat, upgrade, etc.). This differs based on whether you booked your award directly with the airline or if you booked via a partner.\nIf you booked an award with the airline directly\nIf you booked an award ticket with the same airline that’s operating the flight (e.g. you booked on United and you’re flying United), it’s business as usual. Once you book, you’ll already see your flight linked to your mileage account and in your app, no action required. You’ll also be able to change seats, upgrade, check in, etc. like it’s a normal flight. If you have an issue, you just take it up with the airline.\nIf you booked an award via a partner\nIn our example though, we’re using Turkish to book a ticket on a United flight, so things get a little more complicated since there’s 2 airlines involved: the one we booked from (Turkish), and the one we’re actually flying (United). Upon booking, Turkish will send me an email with a confirmation number.\nNow I can enter that confirmation on the United website and it should link the reservation to my MileagePlus account (sometimes you may need to contact them if this doesn’t work automatically though). United may assign me a different confirmation number than the one Turkish gave me, but rest assured, it’s the same flight.\nSince I have United status, linking my trip to my United account lets me enjoy my United perks on the flight (e.g. picking a Economy Plus seat for free). To be clear, I won’t earn any United miles or status points on this flight, but I will get to enjoy my existing perks.\nWhat if I need to make changes or need customer support? If you need help with the booking (e.g. cancel/change flight), contact the airlines you booked through (Turkish in this case). If you need help with the flight (delays, missed flight, seat change), contact the airline you’re actually flying on (United in this case).\nPutting it together\nWe’ve now gone through the full process of transferring points to get killer redemptions. It may seem like a lot at first, but after a few redemptions, it’ll be second nature to you!\nAs I mentioned earlier, this article is inspired by an actual Hawaii trip I was helping a Shreycation reader with. The golden rule of free travel is to earn lots of points per dollar and redeem them for lots of cents per point. Using tips and tricks we’ve covered in previous issues, he executed this to a T. He earned 10k miles from a single fancy dinner with friends because he took advantage of a whopping 16x bonus on Bilt Dining on the 1st of the month. He then identified a Turkish airlines redemption for his Hawaii trip for just 10k miles. Just by strategically earning and deploying points, his one dinner from 2 months ago paid for his Hawaii flight today. (That flight would have cost $775 by the way. That’s 7.75¢/point — insane value, especially for economy.)\nNote for the Eagle Eyed: Turkish Devaluations\nThose of you who have been following along with previous Shreycation issues might have noticed that the Turkish redemption here is 2.5k miles more than expected. After all, just 1 month ago I wrote that all domestic redemptions were 7.5k miles. Unfortunately, this week Turkish has finally succumbed to inflation the same way United and many others have, and they made various routes more expensive (sometimes as much as 90% higher). The silver lining is domestic trip awards only increased 33% from 7.5k to 10k, so it’s still one of the best deals out there for domestic travel.\nThanks for reading! I know it’s been a minute. I’ve been working on something new and exciting in the travel space, and y’all will be the first to hear about it once it’s up. It’s the culmination of months of work, and I’m excited to share it soon!\nShreycation has received so much love and support from y’all, and I’d love to keep that going. Share with a friend, and if this is your first time reading Shreycation, subscribe for more.",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/how-to-actually-transfer-your-points",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Comments - How to actually transfer your points",
      "content": "You've got points and you know you can transfer them for great value...but how do you actually do that? A button by button tutorial on putting your points to work.\nShare this post\nHow to actually transfer your points\nShare this post\nYou've got points and you know you can transfer them for great value...but how do you actually do that? A button by button tutorial on putting your points to work.",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/how-to-actually-transfer-your-points/comments",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Using Air Canada to fly cross-country for just 5k miles",
      "content": "This snack covers a Bilt-specific deal, but if you don’t have one, scroll down because there’s still a bonus snack for you to nibble on!\nI’ve mentioned before that one of the best ways to fly cross-country routes like NYC <> SFO/LAX is via Turkish Airlines for 7.5k points. But on February 1, we get to breathe rare air and go up to 33% cheaper.\nBilt has a habit of pulling out some killer transfer bonuses on the 1st of the month, and February is no exception. On February 1, Bilt is offering a whopping 75-150% transfer bonus to Air Canada’s Aeroplan frequent flyer program. Your exact bonus depends on your status level with Bilt, which you can check in the app.\nI want to emphasize how crazy this deal is. In the past, programs like Chase have offered a 20% bonus; even the lowest-tier Bilt members get almost 4 times that here!\nNow here’s how you turn that into the cheapest cross-country flight I’ve ever seen. We can go on the Air Canada Aeroplan site and look up EWR <> SFO flights on March 5 and we’ll see these options:\nFlying cross-country takes 12.5k Aeroplan miles on a typical day, which usually means transferring 12.5k Bilt points. But on Feb 1 we’re armed with a huge transfer bonus from Bilt, which means it could cost as low as 12.5/2.5 = 5k Bilt points if you’re Bilt Platinum. But even if you’re just Bilt Blue, it’s still just 7.2k points — strictly better than transferring 7.5k points to Turkish! Also, the cash value of regular economy on these flights is $165. That values your Bilt points as much as 3.3¢/point. That’s pretty darn good, especially for economy!\nThis deal is ONLY available on Feb 1, so make sure not to miss out! Aeroplan is quickly becoming one of the most compelling Star Alliance programs, and I’m not sure when we’ll be lucky enough to see an Aeroplan bonus this crazy again.\nBut Shrey, I can’t really commit to a flight today. That’s fine! All you need to do on Feb 1 is transfer some miles. You can book later.\nDo Aeroplan miles expire? That is a great question. Aeroplan miles do expire 18 months after you receive them, but only if you have zero activity on your Aeroplan account. Basically anything you do with Aeroplan resets the clock, including transferring more points. So if you’re worried about forgetting, you can add yourself to this calendar invite for July 2025, which will remind you to transfer the minimal amount of points to Aeroplan to delay expiration.\nIs NYC <> SFO the only good route to book? Nope! You can use this transfer bonus to book any of the awesome routes in the bonus snack below.\nIf this article made you curious about the Bilt card, you can learn more in my review here. If you do end up getting it, I would appreciate you using my referral link. It gets me some extra points which I can use to power more issues of Shreycation!\n(Disclaimer: This post is not financial advice and you should do your own research to ensure this card is right for you. Applying will likely affect your credit score.)\nBonus Snack: Air Canada vs. United\nYou know how your Chipotle bowl costs 20% more because of inflation? Turns out points are affected by inflation too, and in summer 2023, United devalued their points program. Routes that may have cost just 35k United miles now cost upwards of 55k. This opens the field for other programs to offer some great deals.\nUnited MileagePlus used to be one of the most cost-effective ways to book many Star Alliance flights on points, but now Air Canada Aeroplan is eyeing that crown. Let’s analyze some of the most popular travel routes:\nAeroplan outperforms in the vast majority of routes except for West Coast <> Europe. Especially great savings come from the short-haul North American routes, North America <> West/South Asia routes, and North America <> South America routes.\nEagle-eyed readers will notice that Air Canada levies higher cash fees on their award flights. But don’t worry, the math is mathing. Let’s take North America <> East Asia for example: 50k miles + 77 CAD on Aeroplan vs. 55k miles + 6 USD on United. 77 CAD is about 56 USD, meaning there’s a difference of +50 USD and -5k miles between the two. 5k miles is worth just 50 USD only if you’re a points novice and value each mile at 1¢/point. But the whole point of Shreycation is to help you get way more value from your points than the default 1¢/point, so just by subscribing, you’re making those 5k miles worth way more than 50 USD! The math indeed maths.\nAnd if you’re wondering why the Delhi route is so cheap, it’s because Air Canada considers India part of the “Atlantic” region, along with all of Europe and Africa. Air Canada is filled with fun sweet spots like this that I’ll cover in depth in the future.\nThanks for reading! Wielding the point-hacking force is a lot more fun with friends. Plus, if you refer 3 friends, I’ll send you my exclusive, comprehensive guide on stopover programs so you can hack multi-city trips. (And if you don’t know what stopovers are, boy are you missing out.)",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/snacks-air-canada-bonus",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Comments - Using Air Canada to fly cross-country for just 5k miles",
      "content": "Air Canada 🤝 Bilt brings you the deal of the month with an unheard of 150% transfer bonus. Here's how to make the most of it.\nShare this post\nSnacks: fly cross-country for just 5k…\nShare this post\nAir Canada 🤝 Bilt brings you the deal of the month with an unheard of 150% transfer bonus. Here's how to make the most of it.",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/snacks-air-canada-bonus/comments",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Let the government pay for your next flight - by Shrey G",
      "content": "Let the government pay for your next flight\nHow to use stopovers to hack your multi-city itineraries\nDid you know Etihad Airways will practically pay you to visit Abu Dhabi during your next international trip? It’s called a stopover, and it’s the easiest hack for adding an extra stop to your itinerary.\nHere’s how it works. Let’s say I’m traveling from NYC to Delhi during mid March. There’s a $411 option that involves connecting through Abu Dhabi (AUH) with a 3.5 hour layover:\nBut Abu Dhabi is beautiful and maybe I’m not quite satisfied just exploring the airport — after all, if I’m connecting through Abu Dhabi anyway, I might as well stay there for a few nights and explore! This mean I need to book 2 separate one-way trips (JFK > AUH, AUH > DEL), but that costs a total of $802; almost double my original itinerary price!\nHere’s the secret galaxy brain travelers know: Etihad has a free stopover program where they’ll let you book an itinerary with a multi-day Abu Dhabi stay in between, but without the extra markup + taxes from booking two separate one-way trips. In other words, Etihad will just pretend you’ve booked a single trip (NYC-DEL in this case) that just happens to have a verrrrryyy long connection in their home city (AUH). Getting this free stopover is easy; I simply go to the Etihad site and check the box saying I’d like a free stopover:\nThis gives me access to a new itinerary option that costs $434, almost the same price as my original itinerary, but with one big difference: I get a 48 hr connection time rather than just 3.5 hrs. And obviously, I’m more than welcome to leave the airport and explore the city during that time.\nSo far, Etihad has subsidized my airfare by effectively treating my two separate trips as if it were just one. But Etihad goes one step further and actually comps my hotel for up to 2 nights! Etihad will let you choose from one of nine 3-star partner hotels for your complimentary stay (usually would cost $60-$100/night). Etihad also gives you the option to upgrade your stay by giving you deep 40% discounts on bougie 5-star hotels like the Shangri-La Qaryat Al Beri or the Grand Hyatt Abu Dhabi (details here).\nLet’s recap. I was going from NYC to Delhi but noticed I had a connection in AUH. Initially I was going to just rot at my gate for a lackluster 3.5 hr layover, but because of Etihad’s stopover program, I’m actually able to explore the glory of Abu Dhabi for 2 nights for practically the same cost! That’s 2 trips for the price of one! (If you’re doing the math, between the subsidized airfare and the free hotels, that one little stopover checkbox on the Etihad site has saved me over $500.)\nQuick Vocab Note: Layover vs Stopover\nLayovers are less than 24hrs in length, and usually don’t involve leaving the airport. The vast majority of flight connections are layovers — you’re just there as a means to an end.\nStopovers are usually 24hrs or more, and involve you intentionally leaving the airport to explore the city. The connecting city becomes a destination in and of itself.\nSome stopover programs require you to contact customer support, so knowing the difference and using precise language with the support rep can expedite your process.\nWhy do free stopovers even exist?\nAs you saw in the Etihad example, stopovers save you a ton of money on multi-city trips. But why does Etihad care about subsidizing your travel like this? Why do free stopover programs even exist? To answer these questions, we need a quick airlines industry lesson.\nMany of the world’s major airlines are at least partially, if not majority-owned by their home government. The Singaporean government’s investment arm, Temasek, owns 56% of Singapore Airlines. TAP Portugal was swallowed up by the Portuguese government in 2020 when they bought out 72.5% of the carrier — the list goes on. These nationalized carriers are often called “flag carriers.”\nMost governments have an active interest in boosting tourism to their nation. Since they have a majority stake in their flag carriers, foreign governments can use them to incentivize impulse visits by implementing stopover programs. So when Etihad offers you a free stopover in Abu Dhabi, you’re getting your travels subsidized by the Emirati government in the hope that you’ll come again and maybe even tell your friends. Talk about customer acquisition cost…\nThis concept might be a bit foreign to us in the USA; the airlines industry was deregulated and privatized in America in the 70s, so the USA doesn’t have official “flag carriers” that have the US government’s investment and blessing. For my international readers, that means stopovers in the US aren’t really a thing (although there is a hack that I’ll share in a future Shreycation Snack!).\nFive awesome stopover programs\nThere’s a ton of stopover programs out there, and they all vary in their perks, pricing, and how long you’re allowed to stay. Most aren’t as generous as Etihad and won’t comp your hotel, but in all cases, the programs below will let you stay a few days in their host city without needing to book separate one-way tickets, which saves you some dough. Other programs let you do free stopovers, but only on award tickets (i.e. tickets you buy using points/miles).\nGoing through all the stopover programs is beyond the scope of this article, but I will introduce a few fan favorites:\nTurkish Airlines\nLike Etihad, Turkish also gives you a truly free stopover experience with hotels and all. The rules are a little more specific though: you need to have already booked a route with a 20hr+ layover in Istanbul (IST). If you are, you’re entitled to (a) stopover without increasing your airfare and (b) one night in a 4-star hotel if you’re flying economy, or two nights in a 5-star hotel if you’re flying business! This can be a fantastic way to explore one of the world’s oldest and most historic cities.\nAs always though, Turkish is a little behind the times on technology. There may be little indication during the booking process that your flight is eligible, and you’ll need to contact them via email to actually arrange your stopover (it’s not an automatic process like others on this list).\nWhat if my layover is less than 24 hours? Well turns out Turkish still has something for ya! If your layover is 6-20 hrs, Turkish offers layover service! You can just hit up a “TourIstanbul” counter during your layover and they’ll put you on a tour bus and show you around and give you a meal for free. If you’re at the upper end of this layover range (12+ hrs), Turkish will let you relax in a hotel for free too (think of this as “Stopover-Lite”).\nLinks: Stopovers, TourIstanbul, Layover hotels\nJAL\nJapan Airlines will let you spend 1-6 nights in Tokyo or Osaka. If you’re heading to say, Niseko for skiing this season, might as well throw in a stop at Tokyo! Technically, you should be able to use Japan Airlines’ multicity booking tool to just specify your desired stopover, and it should give you the same price as with a non-stopover itinerary. In practice, JAL’s tech isn’t that great, so sometimes you’ll see the price jump. No worries though; you can call up their booking agents and they can set up the stopover without the price difference.\nI’m working on a definitive guide to stopovers that covers all the carriers that offer free stopovers, and the easiest way to book them. As you’ve seen above, stopover programs have various rules and quirks, but I’m working on compiling those in one place for you. If you refer 3 new subscribers to Shreycation, I’ll send it to you for free! Make sure to use the share button below (or the one earlier in this post), or your referral may not count.\nTAP Portugal\nTAP Portugal has been gaining popularity these days as one of the cheapest ways to fly to Europe on cash. If you’ve taken one of these flights, you know that you’ll likely layover in Lisbon or Porto. But you can also stopover in these cities for up to 10 days! TAP makes it super easy to book these directly on their site.\nAlso, TAP will give you 25% off airfare to other Portugal destinations during your stopover, including exotic getaways like the Azores!\nSingapore\nIf you’re flying into Asia, you can add a free stopover in Singapore as long as you’re booking using Singapore KrisFlyer miles (sorry, no free stopovers on cash tickets). For example if I want to fly SFO > BKK (Bangkok), that would cost 42k miles each way on Singapore Airlines, with a connection in SIN (Singapore). In theory, if I wanted to build in my own SIN stopover on miles, I’d actually need to book 3 flights on miles: SFO > SIN (42k), SIN > BKK (13k), BKK > SFO (42k), total of 95k miles. But since Singapore has a free stopover program, that SIN > BKK flight basically becomes free, and I save 13k miles!\nNote that you get 1 free stopover if you book a roundtrip saver award, or 1 free stopover on a one-way advantage award (saver, as the name suggests, is a cheaper award that has limited capacity). Also, Singapore doesn’t give complimentary hotels, but they do offer deep discount stopover packages that include accommodations, transportation, and attraction tickets.\nBut Shrey, I don’t have KrisFlyer miles! Yes you do. Every major card program except Bilt transfers points into Singapore KrisFlyer. If you’re not sure what that means, check out my breakdown on transfer partners!\nWhat if I have a long layover in SIN but I don’t want to stopover? SIN is widely considered the world’s best airport and there’s so much to do there (I almost missed a connection because I was too engrossed), but if you do want to get out, Singapore does offer free 2.5hr tours if your layover is 5.5hrs or longer.\nAir France/KLM Flying Blue\nI’ve written about the Flying Blue frequent flyer program before, and it’s truly the gift that keeps on giving. Let’s say you wanted to book an economy ticket on points from Toronto (YYZ) to Rome (FCO) for the Italian summer. Flying Blue currently has promo fares for routes involving Toronto, so you’d get a great rate; just 22k miles for YYZ > FCO on KLM, connecting through Amsterdam (AMS). But we can stretch our miles even further and make our AMS layover into an AMS stopover at no extra points cost!\nUnfortunately, you do have to book these over the phone, as their online award search tool doesn’t let you book multi-city itineraries. But Flying Blue makes up for it with the most liberal stopover policies of any other program on this list: you can stopover in ANY of the connecting cities on ANY of their partners. Flying Blue has 34 partners (including SkyTeam airlines like Delta and Virgin Atlantic), so you could do stopovers anywhere from LHR to HKG to CDG to GRU (Sao Paolo) and more. This is in stark contrast with other programs that only let you stopover in the carrier’s host country. Also, they let you spend up to 12 months on you stopovers; great for digital nomads!\nThanks for reading! As always, your feedback is crucial to making the next issue of Shreycation even better. If you’ve got 60 seconds (seriously), drop me some feedback here.\nAnd if you haven’t subscribed yet, what are you waiting for? New issues every week.\nWould love to see the whole list",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/issue-3",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Comments - Let the government pay for your next flight",
      "content": "Shreycation\nSubscribe\nSign in\nShare this post\nShreycation\nLet the government pay for your next flight\nCopy link\nFacebook\nEmail\nNotes\nMore\nLet the government pay for your next flight\nShrey G\nJan 26, 2024\n4\nShare this post\nShreycation\nLet the government pay for your next flight\nCopy link\nFacebook\nEmail\nNotes\nMore\n1\n1\nHow to use stopovers to hack your multi-city itineraries\nRead →\n1 Comment\nAra\nJan 26, 2024\nWould love to see the whole list\nExpand full comment\nReply\nShare\nShare\nCopy link\nFacebook\nEmail\nNotes\nMore\nThis site requires JavaScript to run correctly. Please\nturn on JavaScript\nor unblock scripts\nWould love to see the whole list",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/issue-3/comments",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Shreycation Snacks: earn free miles when shopping",
      "content": "Snacks: earn free miles when shopping\nI flew NYC to SF for free and all I did was click a button\nHi y’all,\nWelcome to Shreycation Snacks. This isn’t a full feature Shreycation issue — it’s a bite-sized snack with tasty tips. Read it on the subway, read it during a boring Zoom call, read it on the toilet — you do you. (Don’t worry, Issue 3 still comes out this week.)\nEarn free miles on stuff you’re already buying\nEveryone shops online, but in 2024 it’s time to get rewarded for it. Virtually every major US airline and credit card program has its own shopping portal where you can earn free miles. It’s easy. Let’s say I need to get yet another one of my favorite pants from Theory. If you’ve read my previous issues, you can guess I’m a big United MileagePlus fan. Before I buy, I’ll log onto shopping.mileageplus.com first, look up Theory, and click the “Shop Now” button. I’ll then proceed to buy the pants using any credit card, and I’ll get a free 2x United miles for doing basically nothing, on top of whatever points I get on my credit card.\nBam, that’s 400 free miles right there — same amount you’d get flying LAX to SFO.\nSometimes these programs will run promos where you’ll earn more miles (like 5x+) at certain merchants. They also run bonuses where if you spend say, $150 across all merchants, you get a bonus 500 miles. Also if you’re ever in the market for one of those money-losing D2C subscription companies (Hello Fresh, Stitch Fix, etc.), they’ll give you hella bonus miles (like 1000+ miles).\nIt adds up. I’ve been using these for a year and I’ve racked up about 20k miles; I recently used 15k for a last minute NYC-SFO flight that would have cost $400 otherwise.\nLinks for portals (bookmark them!): American, United, Delta, Alaska, Southwest, JetBlue, Capital One, Citi, Chase. (Unfortunately Amex and Bilt don’t have portals.)\nTips for success:\nMake sure to temporarily turn off your adblocker (cmd + period on Chrome for Mac) OR add the adblock filter list for your preferred shopping portal (e.g. here’s United’s).\nSometimes you can download browser extensions that will pop up whenever you go on a site that earns miles. No need to go to the shopping portal! For example, here’s United’s.\nIf you use Honey, you gotta disable it. No double dipping unfortunately.\nMake sure to complete your purchase in the tab that opens from the portal.\nIf you shop via a credit card shopping portal, you’ll usually need to use one of their cards to get the points. For airlines shopping portals, anything works.\nBonus snack: new Chase Sapphire lounge in LGA just dropped\nThe lounge battles are heating up. Chase is officially pissed that Amex cornered the market with their Centurion lounges, and they’ve decided enough is enough. Last week, Chase finally opened their hotly-anticipated Sapphire Lounge in LGA terminal B, their third lounge after BOS and HKG (hong kong).\nThe new LGA lounge is over 21800 sqft with plenty of little nooks for privacy, children’s play room, game room, and conference desks + phone booths. Also, they offer an upscale bar (with cocktails inspired by NYC’s own Apotheke and wine line from Parcelle), amazing food (both buffet + a la carte style), and complimentary mini-facials and skincare kits. For those who want extra style, they’ve got bookable private suites with caviar and wine service. The only issue is the lounge has no natural light or runway views, but it is very cozy.\nI haven’t had the pleasure of going yet, but here’s some pictures and videos from others:\nHow to access: If you have the Chase Sapphire Reserve, you can visit for free whenever with 2 guests. If you have Priority Pass through some other card, you get 1 free visit per year but no free guests.\nChase also has a JFK lounge opening tomorrow (!!) and is adding lounges in LAS, PHL, PHX, and SAN soon.\nIf you haven’t subscribed yet, what are you waiting for? New longform issues and shortform snacks dropping weekly.\nLove Shey Snacks! It’s like the Delta Biscoff Cookie of travel blogging 😂",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/snacks-free-miles-shopping-portals",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Comments - Shreycation Snacks: earn free miles when shopping",
      "content": "I flew NYC to SF for free and all I did was click a button\nLove Shey Snacks! It’s like the Delta Biscoff Cookie of travel blogging 😂\nsometimes you want a meal, sometimes you want the ice cream sundae, and sometimes you just need the biscoff. we got you covered at Shreycation Central regardless hehe\nLove Shey Snacks! It’s like the Delta Biscoff Cookie of travel blogging 😂\nsometimes you want a meal, sometimes you want the ice cream sundae, and sometimes you just need the biscoff. we got you covered at Shreycation Central regardless hehe",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/snacks-free-miles-shopping-portals/comments",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Why you need a Bilt card in your wallet - by Shrey G",
      "content": "One of the biggest questions I’ve gotten this past year is what in the \\*\\*\\*\\* is a Bilt card? It’s a justified question: their ads are everywhere from airports to subways, and they’ve quickly become one of the hottest credit cards on the market.\nIn my opinion they very much deserve the hype. I was a skeptic when I first heard of the card, but their team continues to deliver tremendous value. Here’s a few reasons why Bilt has quickly reached the top of my card stack.\nPoints on Rent\nThe marquee benefit of Bilt is the ability to earn 1x points on rent without paying the credit card transaction fees. Technically, you can earn 1x points on rent on many other cards too (rent would just fall in the “other” purchases category) but you’d have to pay a ~3% transaction fee, which wouldn’t be worth it in most cases. Bilt lets you bypass those fees and feasibly earn points on your rent. If you’re living in a typical US metro area, you’ll easily earn tens of thousands of free points per year this way! Given this is the only card product on the market that does this, it’s natural to have some questions:\n“So wait are they just fronting the transaction fee?”: Nope, Bilt spins up a special bank account that has your rent preloaded, and you use that to pay for your rent instead of your personal bank account. Your online rent payment portal will omit the standard credit card fee since you’re technically paying via bank transfer, and Bilt will charge you for the debited amount.\n“What if I don’t have an online rent portal?”: Bilt can send a check, PayPal, or Venmo to your landlord. This requires a bit of one-time setup, but you’ll earn points all the same. They don’t support Zelle yet unfortunately.\n“What if I Venmo my share of the rent to my roommate? How about subletting?”: Bilt can handle this too. You can set your special Bilt bank account as a payment option in Venmo and use that to pay your roommate. Bilt may ask for lease verification if you go this route though, which means YMMV for sublet situations.\n“Any catch?”: You need to use your Bilt card 5x a month to earn points on rent, but that’s about it! As you’ll see below, you’ll want to use it way more than that anyway.\nThe card isn’t just a one trick pony, and you’ll also earn 3x points on dining and 2x on travel. The dining multiplier rivals the best cards on the market, but that travel multiplier is middle of pack; I’d use other premium travel cards like the Amex Platinum card to book travel if you have them.\nSurprisingly Good Transfer Partners\nCool, so you can earn points on rent, but that’s only worth something if the points are useful. As we discussed in Issue 1, points are only as good as their transfer partners, and honestly, I’ve been shocked by how good the list is for Bilt:\nThat’s a pretty impressive list. Here’s some highlights:\nBilt is the ONLY card program that transfers to American. Oneworld loyalists rejoice! Also, American has been putting up some impressively cheap award tickets for Asia travel lately, but more on that in a future issue.\nBilt also covers United, which makes them the only card program that partners with 2 major US airlines. If you’re also sitting on an Amex, note that this gives you direct point transfers to the full US trifecta: United, American, and Delta.\nI’ve written about Air France/KLM before, and it’s a fantastic program for dirt cheap Europe trips. Air Canada, British Airways, Virgin Atlantic are also fantastic for a whole variety of partner awards, and I’ll certainly write about them soon. Most major card programs are partnered with these four airlines though, so this isn’t a unique benefit.\nTurkish Airlines and Avianca are stellar options for rare but super high value redemptions within Star Alliance. If you’re curious, you can learn how I saved 70k-90k points using these programs for an EWR-LHR trip, and how I used Turkish to fly cross country for a mere 7.5k miles. Turkish isn’t partnered with Amex or Chase, and Avianca isn’t partnered with Chase, so if you’re holding these cards, Bilt helps round out your transfer partner portfolio.\nHonestly, their BizDev team must be doing the most. I’ve personally been very invested in the Chase ecosystem, yet I’ve found myself spending more on Bilt lately because Bilt has access to killer partners I just don’t have on Chase.\nRent Day Promotions\nPaying your landlord isn’t typically something to celebrate, but Bilt makes the first of the month a little sweeter with their “Rent Day” bonuses. Every Rent Day, Bilt provides some wildly good deal or transfer bonus or status trial that’s usually hard or even impossible to find otherwise. Here’s some examples from the past:\nUp to 150% transfer bonuses for frequent flyer programs like Air France/KML Flying Blue, Emirates Skywards, and Virgin Atlantic Flying Club.\nUp to 18x on restaurants partnered with Bilt (more on that below).\nComplimentary United Silver or Gold status for 120 days, with the potential to retain it for a full year.\n90 day free trial of World of Hyatt Explorist status, Hyatt’s 2nd best status tier providing complimentary room upgrades and late checkouts.\nTransfer bonuses of 150% are absolutely unprecedented in the points world; usually people would rejoice over a 30% transfer bonus on the other major card programs. And re: the restaurant points boost, I have a friend who put his Bilt card down on a $750 friends’ dinner and walked away with a whopping 12k points — a free cross-country flight right there.\n(Note that some bonuses scale with your Bilt status tier. I won’t get into it this time, but Bilt has their own status program and you earn status based on the points you’ve earned. But even the entry-level tier got 75% transfer bonuses; still an insane deal.)\nBilt is perhaps the most gamified, content-forward, and youthful of the Big 5 credit card programs, and as such they have some fun Rent day programming too:\nPoint Quest: A trivia show where you earn up to 250 points for answering current events questions. (They also release their content on TikTok!)\nRentFree: A Family Feud-style game show where you enter a drawing to get your rent paid for by Bilt.\nComplimentary spots at local SoulCycle classes.\nAll spend categories (besides rent) earn double points! Dining goes from 3x to 6x, Travel goes from 2x to 4x, and all other non-rent spending goes from 1x to 2x.\nBilt Dining\nBilt has partnered with a whole variety of restaurants in major US metro cities, and you’ll earn anywhere from 2x to 10x extra points per dollar when you dine there. That’s on top of the 3x points you earn from any dining transaction on your Bilt.\nOne of the coolest parts of this program is you don’t even need to use your Bilt card; you can register other cards you own into your “Bilt Wallet” and you’ll still earn the extra Bilt points!\nI’ve registered my Chase Sapphire Reserve in my Bilt Wallet. Now let’s say I go eat at one of my new favorite NYC spots, 8282 in Lower East Side. 8282 is listed as a +3x Bilt Dining partner. I’ve got two options to earn points on my meal:\nAs you can see, Bilt Dining affords you flexibility on how you earn points on your nights out, which can be very useful as you try to build up points balances in multiple programs.\nYou can see the full list of Bilt Dining restaurants here. Bilt Dining has restaurants in many major cities like NYC, Boston, San Francisco, Seattle, Atlanta, Miami, and more, but I will say that some cities definitely have a more developed list of restaurant choices.\nAlso, as of yesterday it’s officially NYC restaurant week, and there’s plenty of Bilt Dining restaurants on the list right now! If you’ve already got the card, there’s a whole list of them in the app.\nBilt Experiences\nMany major credit card programs technically offer “exclusive experiences” for cardholders, but it’s often hard to access these, and they’re typically quite niche. Bilt has a significantly better experience program with events you’ll likely want to go to. In the past, they’ve offered unique dining experiences and even box tickets at NFL games bookable on points.\nI went to one of their events in November at Meduza, an up-and-coming mediterranean restaurant that had literally just opened a few days prior! It was a lovely 5 course menu with a cocktail pairing, and the vibes were excellent. They had all the guests sit on a long table together, so everyone got to socialize and become friends while drinking way too much. Plus they had some of the Bilt team at the event too, and I got to ask a bunch of my prying questions about the card.\nThe dining experiences were bookable in the Bilt app for $150/seat or 12,500 Bilt points; I personally opted for the former because I know I can extract more than 1.2¢ of value per point. They’ve also run dining experiences in Miami, Dallas, and Boston.\nI’m not personally the biggest football fan, but back in September, they also let cardholders book spots in a box suite for a Jets vs. Chiefs game. The cost was just 10k Bilt points — given that a typical box suite goes from $5-25k for 20 people, this was quite the steal! Plus apparently Taylor Swift attended that game to cheer on Travis Kelce, so who knows, you could have bumped into her at the stadium too.\nPeace of Mind + Protections\nBecause the Bilt card is also a World Elite Mastercard, you get some additional travel protections for peace of mind:\nAuto rental collision damage waiver: Rent a car and you can decline the extra collision insurance from the rental company.\nTrip delay reimbursement: If your trip gets delayed 6+ hrs, they’ll help cover costs.\nTrip cancellation protection: If your trip gets cancelled due to medical reasons, they’ll reimburse you even for non-refundable plans.\nCellphone protection: If you pay your phone bill with Bilt, they’ll pay you if you phone gets destroyed or stolen.\nPurchase protection: Buy something recently and it got destroyed or stolen? Bilt will reimburse you.\nI’m being a bit vague on the exact terms and reimbursements deliberately, since that deserves its own post. Most travel-focused cards have these protections too, but not all protections are created equal. The devil tends to be in the details, and having reviewed the fine print myself, I’ll say Bilt is probably below average in terms of the quality of these protections. Still, something is better than nothing, but if you’ve got cards like a Chase Sapphire or Capital One VentureX, I’d rely more on those protections instead. I’ll do a proper deep dive that compares the different cards and their protections in a future issue.\nBest Part: $0 Annual Fee\nAll of this comes for a $0 annual fee, which is honestly a bit wild. This makes it a super friendly “first travel card” for beginners, and an easy addition for experts.\nMy Verdict\nFriends have been asking me for years about the best card to start travel hacking with, and I used to say the Chase Sapphire Preferred. While that’s still an awesome card, it has a $95 annual fee, and Bilt is free with amazing benefits and partners to boot. I would highly recommend this card for beginners, but as I discussed above, there’s plenty of perks even for seasoned veterans. Even if you don’t pay rent, the rent day bonuses and transfer partners alone make the card worth it.\nThe card is definitely targeted towards younger generations living in major US metro cities, which is a refreshing positioning compared to some of the other cards. If you’re based in NYC, Bilt has an especially strong presence here (they’re based here after all), but you’ll also get a decently fulfilling set of perks and benefits on Bilt Dining and Bilt Experiences in other major US cities.\nFrom a business perspective, I’m also generally amazed at how fast their team has been building and how they’ve carved out a growing wedge in an otherwise oligopolized market run by legacy players. More than other cards, they’ve been focusing a lot on strategic partnerships that lend the card more utility, revenue streams, and virality. I have to imagine Bilt has identified fairly diverse revenue streams given their $0 fee strategy. This all means there’s likely more to come with this card!\nIf you do decide to get a Bilt, I would appreciate if you use my referral link below! It gets me some extra points which I can use to travel more and power more issues of Shreycation. I only provide this because Bilt is a product I’m personally a huge fan of (can you tell?), and I hope you enjoy it too!\n(Disclaimer: This post is not financial advice and you should do your own research to ensure this card is right for you, and that you have a reasonable chance of being accepted. Applying will likely affect your credit score. I’ll do a post later with tips on getting and maintaining high credit scores to maximize your chances of getting good cards and getting high limits.)\nIf you enjoyed this issue of Shreycation, please subscribe and share it with a friend!\nIf you’d like to help make the next issue of Shreycation better, fill out my feedback form here.\nGreat article Shrey! I'm new to the points game and wanted to clarify a few things you mentioned.\nMy understanding is that for people who are starting travel hacking, Bilt is not a great card because there is no signup bonus, which, if your goal is to travel hack, is how you will rack up most of your points. My thinking is that it's best to get Bilt and use it for rent, and for your minimum 5 transactions each moth, and then after that to put all your spend on cards you are trying to get signup bonuses for. My thinking is that if I have $5K to spend, even with the crazy Bilt transfer bonuses, it doesn't compare to getting 75K or 100K points from a signup.",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/issue-2",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Comments - Why you need a Bilt card in your wallet",
      "content": "One of the biggest questions I’ve gotten this past year is what in the \\*\\*\\*\\* is a Bilt card? They're everywhere, but what's the hype about, and is Bilt really worth it?\nGreat article Shrey! I'm new to the points game and wanted to clarify a few things you mentioned.\nMy understanding is that for people who are starting travel hacking, Bilt is not a great card because there is no signup bonus, which, if your goal is to travel hack, is how you will rack up most of your points. My thinking is that it's best to get Bilt and use it for rent, and for your minimum 5 transactions each moth, and then after that to put all your spend on cards you are trying to get signup bonuses for. My thinking is that if I have $5K to spend, even with the crazy Bilt transfer bonuses, it doesn't compare to getting 75K or 100K points from a signup.\nGreat article Shrey! I'm new to the points game and wanted to clarify a few things you mentioned.\nMy understanding is that for people who are starting travel hacking, Bilt is not a great card because there is no signup bonus, which, if your goal is to travel hack, is how you will rack up most of your points. My thinking is that it's best to get Bilt and use it for rent, and for your minimum 5 transactions each moth, and then after that to put all your spend on cards you are trying to get signup bonuses for. My thinking is that if I have $5K to spend, even with the crazy Bilt transfer bonuses, it doesn't compare to getting 75K or 100K points from a signup.",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/issue-2/comments",
      "author": "",
      "user_id": ""
    },
    {
      "title": "How to get 10x the value from your points - by Shrey G",
      "content": "Hi! I'm Shrey, and I'm a software engineer turned travel advisor. Back in March 2020, the travel bug bit me hard at probably the worst possible time. While the rest of the world was in quarantine picking up new hobbies, baking sourdough, and doing TikTok dances, I spent all my free time reading about the one thing I couldn’t do at the time: travel.\nOver the past two years, I've traveled hundreds of thousands of miles and redeemed tens of thousands of dollars in free travel. There’s a pervasive myth that traveling the world on points requires seven-figure spending or constantly hopping coast to coast for some big consulting firm. That hasn’t been my experience: I rarely traveled for work as an engineer and I’d like to think I spend frugally, yet I’ve learned to make these credit card and frequent flyer programs work for me.\nThere’s no shortage of travel hacking content online, but points are a chaotic, complex web of unintuitive axioms and odd stipulations. I’ve always found that you can’t actually get anywhere without reading dozens of articles, and even then, it feels like you’re trying to clear a forest with a butter knife. In this Substack, my goal is to cut through the noise and clear the path for you. You’ll learn hacks that you can apply today, and hopefully over time, you’ll also develop an intuition for hacking on your own too.\nToday we’re tackling transfer partners, one of the most important and high impact topics that will show you the path to doing tons of free flights. I imagine people are at very different levels of familiarity with transfer partners, so if you’re new, keep reading, and if you’re a seasoned veteran, feel free to scroll down a bit unless you want a refresher!\nFor beginners: Why do Transfer Partners matter?\nIf you’ve seen people zipping around on free business class flights, chances are they’re not just secretly point millionaires. Instead, they’re stretching their credit card points by transferring them into specific airline frequent flyer programs.\nThe major credit card programs for travel are Amex, Chase, Citi, Capital One, and Bilt — I’ll call these the Big 5. Most travelers know that the Big 5 programs each have a travel portal where you can easily redeem your points on flights. The catch is this usually involves spending your points at a fixed rate of 1-1.5¢/point. That means if you want a $1000 flight, you’re could be burning as much as 100k points — that’s more than most credit card sign up bonuses, just for one flight!\nWhat savvy travelers know is the Big 5 also allow you to transfer your points to specific frequent flyer partners, and this is the key to unlocking their true value. This is because unlike the Big 5 travel portals, most frequent flyer programs don’t set a fixed exchange rate. This means your points could be worth way more when you transfer! You can routinely find redemptions of 2-3¢/point, and if you’re really skilled or lucky, I’ve seen killer redemptions as high as 12¢/point! That same $1000 flight could cost you as little as 8k points — you might earn that in just a single month of smart spending.\nI could probably write a PhD thesis on transfer partners, but for now I’ll try and give you my best 10 minutes on the topic.\nRules of the Game\nGetting high redemptions doesn’t come for free, and it does involve a bit of a learning curve. First, a few ground rules for working with points:\nTransfers are one way. Once you transfer points from a credit card program to a frequent flyer program, you can’t go back. Only transfer if (a) you have a redemption in mind and are about to book or (b) there’s a great transfer bonus (we’ll talk about this in future issues).\nYou can’t just transfer to any program. Each of the big 5 credit card programs partners with specific frequent flyer programs. This is why it’s best to own cards across various programs.\nYou usually can’t transfer points across frequent flyer programs. For example, a mile in United MileagePlus usually can’t be transferred to Air Canada Aeroplan. (There are a few limited exceptions, but I’ll cover those in future issues.)\nTransfers are usually 1:1 but not always. For example, you can convert 1 Chase point into 1 United mile. While the majority of transfer partners for the Big 5 are 1:1, some have slightly unequal ratios like 1:2 or 2:1.5 for some of the less commonly used partners.\nA motivating example: Let’s go to London in the spring!\nNow for some examples! Let’s say you want to take advantage of the shoulder season for London in April — it’s starting to warm up but you’re not paying peak season prices. If you have a Chase Sapphire or Bilt card, you can transfer your credit card points to United MileagePlus and book a United Polaris business class flight departing March 30th from EWR to LHR for 80k miles.\nThe actual flight would cost $1988 if we bought outright in cash according to Google Flights:\nThat means we’re redeeming our points at a rate of roughly 2.48¢/point!\nCompare this the quote of 132487 points we get from the Chase portal:\nSince I have the Chase Sapphire Reserve, my Chase points redeem at a fixed rate of 1.5¢/point in their portal (a signature benefit of that card), but just by transferring into United instead, I squeeze out 65% more value from my points!\nIf you want to go far, go together: The magic of airline alliances\nAs I mentioned earlier, each of the Big 5 programs has a designated list of transfer partners. Here’s the list for Bilt for example:\nIt’s perfectly normal to look at this list and think “I’ve never heard of half of these airlines, let alone flown them.” But you don’t actually need to fly these airlines to get tremendous value out of their frequent flyer programs.\nLet me explain. Most airlines are part of a major airline alliance. You’ve probably heard of them:\nStar Alliance (cofounded by United)\nSkyteam (cofounded by Delta)\nOneworld (cofounded by American)\nWhen an airline join an alliance, they agree to allow other airlines in the alliance sell tickets on their flights, and in return they get to sell tickets on their partners flights. When you go on the United website and you see an option to buy a ticket that’s actually operated by Turkish Airlines, that’s why — both of them are in Star Alliance.\nFortunately for us, this cross-selling phenomenon isn’t just limited to tickets bought in cash (“revenue tickets”, in point hacker parlance). It also applies to tickets bought on points (“award tickets”)! In other words, Turkish Airlines can let members of their frequent flyer program, Miles&Smiles, book award tickets on United flights using their Turkish Airlines miles. Similarly, United MileagePlus members can often book Turkish Airlines flights using their United miles.\nThis opens up a whole glorious world of possibilities and points arbitrage. Each frequent flyer program uses a different method to calculate how many points a given flight should cost. Some look at the flight distance, some look at which regions the flight transits between, and others look at how much demand exists for that seat. This means you can sometimes find the exact same flight and cabin for fewer points in a partner program!\nSo let’s go back to our example: EWR-LHR in business class on flight UA 110. If we check the Turkish Airlines award search, we can find that same exact seat for just 45k Turkish miles. That’s a whopping 4.97¢/point!\nIf you’ll recall, this same flight would have cost 80k United miles or just above 130k Chase points — we’ve literally gotten 2-3x the value just by going through a United partner.\nYou may think “but wait, I don’t have any Turkish miles.” But if you have a Bilt card (or selected Citi or Capital One cards), your credit card points can transfer at a 1:1 ratio into Turkish Airlines Miles&Smiles. This is why these transferrable points programs are so powerful: you can use them to book flights in programs you don’t regular use.\nNow let’s say you only have an Amex. You wouldn’t be able to transfer to Turkish Airlines unfortunately, but there’s still a deal for you! Chances are you’ve never flown or even heard of Avianca, but all you need to know is they’re a Star Alliance partner too. And that same EWR-LHR United business class seat is still available for 60k Avianca Lifemiles. Not as amazing as the Turkish redemption, but still a nice discount from the United MileagePlus one!\n(As you can see, it does pay to have exposure to various Big 5 programs so you can always get the optimal redemption.)\nKnowing how alliances work can lead to tremendous savings and help us easily maximize our points. It’s not always easy to find these redemptions though, and exploring the whole web of airlines alliances can get complicated. That’s why point hacking is a skill, and it definitely takes practice to get better at it! In the “Advanced” section below, I share a few tips for finding these redemptions, and I’ll share more in future issues too.\nBy the way, that March 30th EWR-LHR flight I’ve been using as my example? That’s a real flight with actual award availability as of 6am this morning. Good points deals often get snapped up fast, so take a look if you’re interested!\nSome notes on redemption rates\nTypically you’ll see the really mouthwatering redemptions (>= 5¢/pt) on premium cabins. However, you can still find nice economy redemptions at a rate of 2-3¢/pt! For instance, our example EWR-LHR flight costs $460 for economy and is also available for 20k Avianca Lifemiles; that’s 2.3¢/pt.\nI’ve talked a lot about how you can get > 1¢/point by transferring points. But since the redemption rate isn’t fixed in most frequent flyer programs, the opposite can also be true. Sometimes you may see terrible redemptions of 0.5¢/point, in which case you need to look elsewhere, book via the credit card portal, or maybe even just book on cash.\nHow do I actually transfer points?\nUsually you can transfer points in your credit card’s rewards portal. Look for words like “transfer to partners”. From here, you’ll be asked to link your frequent flyer account — ensure that you’re entering your member number accurately! Once you’ve done that, you’ll be able to transfer points, usually in increments of 1000 points.\nFor most partners, the transfer is nearly instant. Go make a coffee and your freshly transferred miles should be deposited in your frequent flyer account by the time you’re back. On some occasions though, the transfer can take longer. This can be a bit inconvenient if you’re booking a particularly popular award ticket that may run out of space; I’ll talk about how to get around this in a future issue.\nDoes this mean I should never use my points my credit card’s travel portal?\nNope! If you’re trying to save cash, ultimately free travel is free travel. You might not be maximizing your points, but that might not be what matters then. However, be careful not to exhaust all your points in the portal; missing a killer partner redemption because you’re out of points is quite painful.\nMany portals also offer a combo of cash + points payment option. This can help take the edge off a particularly pricey flight by letting you, in effect, set your own preferred discount using points. I recently did this for a last-minute domestic flight; flights were $200 more than usual, so I used 13,000 points to offset the increase. Additionally, by using the Chase portal with my Chase Sapphire Reserve, my points were valued 50% higher (1.5¢/pt), and I earned 5x points on the cash portion— not bad!\nFor experts: Two of my favorite underrated transfer partners\nAs experts, you’ve probably used your fair share of transfer partners and gotten some awesome redemptions. There’s a few programs I don’t think get enough love, and I figure I’d talk about them below and exactly how you can add them to your repertoire.\nTypes of award space\n(For some of you, this may be review; I just want to make sure we have a shared vocabulary here!)\nNot all award space is created equally. Usually when an airlines releases award tickets for a given flight, they release it into 4 buckets:\nAirline saver space\nNon-saver space\nPartner saver space\nAirline saver space is a special promotional rate offered for award tickets. If you can snag one of these rates, you know you’re getting the best points rate that program can offer. Often airlines will have a fixed rate for saver space (e.g. “one way US-Europe economy = 20k”), but unfortunately many US-based airlines have dynamic rates even for saver space. There’s very limited seats available in this bucket, and once it’s exhausted, you’re just left with non-saver space.\nNon-saver space is usually much pricier (think ~2x the cost), and is more likely to be dynamically priced based on demand (read: you’re not gonna get a stellar redemption rate here). Non-saver space can still be worth booking though if the cash fare for the flight is super expensive.\nFinally the partner saver space bucket is similar to airline saver space, but allocated for the airlines’ partners instead. The partner program is allowed to choose whatever pricing strategy they want for these seats, and often, the best deals come from partners that price their partner saver space cheaper than the airlines’ own saver space. One catch: the amount of partner saver seats is less than the amount of airline saver space, so if you find one, you better book fast.\nTurkish Airlines Miles&Smiles for domestic coast-to-coast trips on United\nThe Sweet Spot\nYes, weirdly enough the cheapest way to fly across the USA on points is through a non-US based airline! The Miles&Smiles program uses a region-based award chart where the point cost of a flight depends on your start and end region. Generally most programs using such charts tend to split the US into an East and a West region, which bumps up the cost of flying cross country. Fortunately, Turkish Airlines has a sweet spot here: flights within a single country count as flying within a single region, regardless of the size of the country. If we reference their award charts, we can see the saver (“promotional”) award ticket rate for domestic/intracountry flights is just:\nEconomy one way for 7.5k miles\nBusiness one way for 12.5k miles\n(Turkish is in Star Alliance, so these flights are actually just United flights being cross-sold by Turkish.)\nThis is such a ridiculously low cost award that has managed to stay under the radar for quite a while now. But there’s a good reason for that: for the longest time, the only way to transfer to Turkish was through Citi or Capital One, which aren’t as popular. But that’s all changed with the Bilt card; it’s one of the fastest growing cards in America, and they have recently become the 3rd transfer partner for Turkish. Now these deals are way more accessible to travelers!\nFinding Award Availability\nUnlike other airlines, Turkish Airlines unfortunately doesn’t let you see a calendar of available dates, which makes finding award availability hard. However, we can use a little trick: we can use a different Star Alliance partner with a better award search tool to find the available dates, and then pop those dates into the Turkish award search and book from there. This works because all Star Alliance partners will have access to the same partner saver space; it’s just a matter of finding it.\nAir Canada Aeroplan is known for having a really great award search tool for Star Alliance partner space, so we can just pop in our origin + destination city here and some rough idea of a date we want to travel on. Once you sign into your Aeroplan account, you’ll be able to see a 5 day availability calendar at the top. Generally you’re looking for anything that is priced low (like 15k miles or less), and on United metal — chances are that’s partner saver space.\nLet’s look for NYC > SFO for Feb 13 (perfect V-Day timing for all the cross-country long distance couples!).\nAccording to the calendar at the top, we could also book on Feb 12 or Feb 14, but not Feb 11.\nNow that we’ve identified a date that has partner saver space, we can head back to Turkish and search there:\nAnd voila! We found Turkish partner saver space for this domestic United flight, and its just 7.5k Turkish miles compared to 12.5k Air Canada miles!\nOne caveat: before you get too excited about the 12.5k mile domestic business class redemptions, I should say that it’s very very hard to find award availability for this one. I’ve never succeeded on it personally, and if you find it, you might wanna buy a lottery ticket. The economy tickets are usually very doable though.\nAir France/KLM Flying Blue for insanely cheap trips to Europe\nThis one isn’t that underrated, and is actually one of the more popular redemptions for people who are getting started in the points game. It doesn’t hurt that Flying Blue is a transfer partner for each of the Big 5 credit card programs too! The reason I’ve still listed it here is many people tend to consider Flying Blue as just a good way to book Delta awards if you don’t have an Amex, but they’re missing the best part: Flying Blue promo rates.\nEvery month, Flying Blue releases a new set of cities that they offer promotional pricing on (usually 25% off their regular partner saver rates). As long as you fly between any country in Europe and these cities, you’re eligible for the discounted pricing (while seats last of course). The discounted pricing is in effect for trips within 6 months of the current month, so the January promos are in effect for trips till June 30.\nUnfortunately there’s no US-based cities on this list for January, but in December, you could have booked flights from the following cities for a discount:\nWashington D.C. to Europe from 15k miles (25% off)\nBoston to Europe from 15k miles (25% off)\nThis month there are lots of Canadian cities on the list though (Toronto, Montreal, Ottowa), so for my Canadian friends out there, it’s your time to shine! You can always see the list of cities here under “Long-Haul Flights” (I suggest bookmarking this link!)\nLet’s check out an example. Let’s say you’re looking to do V-Day in the city of love, Paris. We can pop in Toronto for the origin and Paris for the destination, and select Business. Seems there’s some partner saver space for Feb 13! You can tell because the button is in green; non-saver space is shown in blue.\n50k ain’t bad for Air France business class! You will need to pay a bit of a higher fee here (220 euros), but this flight is going for $5526 right now, so you’re getting an insane 10.5¢/pt redemption here. What a steal for V-day in Paris.\n(Pro tip: You don’t have to reside in Toronto to take this flight…there’s dozens of NYC <> YYZ flights every day, and you could just book a cheap one like the one below, chill in the Air Canada lounge for free with your business class ticket, and hop over to Paris from there.)\nThere’s so many more underrated transfer partners I could include, but this issue is getting kinda long, so I’ll throw ‘em in a future issue!\nDeals and Other Awesome Stuff\nBilt Dining has 100 restaurants participating in NYC Restaurant Week! You’ll earn extra Bilt points on these restaurants, even if you don’t use your Bilt card (just make sure to register your other card in the Bilt wallet). Plus you can register any Mastercard here (including your Bilt one) to get $10 in statement credits per restaurant, up to $30. You can check your Bilt app for the full 100 restaurant list.\nChase Offers has a few cool promos running (may vary by card). Be sure to activate them in the Chase app! Here’s a few on the Chase Sapphire Reserve:\n10% cash back on Liquid IV and McDonald’s for your next\ndrunk night outwholesome night in.10% back on various hotel chains, including Intercontinental, Crowne Plaza, Le Meridien, Kimpton, Hyatt Place, and Holiday Inn.\n$10 cash back on Turbotax: file your taxes early and feel like a true adult\nSince I’m a travel advisor working under a licensed travel agency, I can get you access to perks and rates that aren’t publicly available when you book through me. Virtually all of these options include free perks like buffet breakfast for 2, $100 hotel credit, and room upgrades! Here’s a few of the coolest ones:\nPark Hyatt Bangkok: Stay 3 nights, pay for 2 on stays till March 31. Also, stay 2 nights, pay for just 1 for specialty suites (with same perks)\nAndaz 5th Avenue (NYC): Stay 4 nights, pay for 3 on stays till March 31 (includes perks like free breakfast, $100 hotel credit, and room upgrade). The Andaz is one of my personal favorite hotels in NY!\nThompson Denver: Stay 3 nights, pay for 2 for stays till March 10. Those of you going for a \\*cough\\* certain digital asset conference \\*cough\\* might find this one useful! (I’ve stayed there personally too for that same conference in the past)\nGrand Hyatt Playa del Carmen Resort: Stay 3 nights, pay for 2 for stays till June 30. Also, you’ll get an extra $50 to spend at the spa (on top of the $100 hotel credit).\nIf you’re staying at a Kimpton hotel this month or next, say “Chalet All Day” to the front desk. You’ll be glad you did!\nThanks for making it this far and I hope you’re enjoyed this first issue!\nIt’s my first time doing anything like this, and I’d really appreciate your thoughts and feedback in my Google form here!\nBon Voyage,\nShrey\nLooking forward to the next one 👀\nJust booked our next trip to Italy on emirates using points. I don’t think we’ve paid for a flight with cash in years!",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/issue-1",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Comments - How to get 10x the value from your points",
      "content": "If you've seen people zooming around the world for free on points, it's not because they're point millionaires. Learn how you can maximize the value of your points by using transfer partners rather than just wasting them in your credit card portal. Also, 2 killer redemptions that you can claim today!\nLooking forward to the next one 👀\nJust booked our next trip to Italy on emirates using points. I don’t think we’ve paid for a flight with cash in years!\nAmazing move! Been subsidizing my travel for the last few years with points too and it’s been so much fun haha",
      "content_type": "blog",
      "source_url": "https://shreycation.substack.com/p/issue-1/comments",
      "author": "",
      "user_id": ""
    },
    {
      "title": "News & Updates on Startups, Venture Capital, & Technology | a16z",
      "content": "Latest\n-\nArcjet's David Mytton and a16z's Joel de la Garza discuss how sites can distinguish malicious bots from helpful AI agents — and what to do about it.\n-\nThe assumptions underpinning traditional penetration testing are starting to bend, and a new generation of AI-driven approaches is emerging.\n-\nNotes on distribution tactics, seizing mindshare…and an extended metaphor about pigeons.\n-\nInstabase's Anant Bhardwaj and a16z's Guido Appenzeller discuss the revolutionary impact of LLMs on analyzing and — some day — acting on unstructured data.\n-\n16 key shifts in how enterprises are budgeting for, buying, and deploying gen AI in 2025—and beyond.\n-\nWhat if one of healthcare’s most complex administrative challenges—revenue cycle management—was reframed as a data science problem? In this episode, Malinka Walaliyadde, co-founder and CEO of Akasa, joins Julie Yoo to un...\n-\nNew revenue benchmarks for gen AI startups in year one, based on dozens of enterprise and consumer AI companies we’ve spent significant time with.\n-\nEnterprises buying AI are like your grandma getting an iPhone: they want to use it, but they need you to set it up.\n-\nMarket research has long relied on expensive human surveys. Now AI research companies are replacing them with simulated societies of generative AI agents.\n-\nPlus: A framework for defining and refining your ICP, emerging developer patterns, and more in the May Enterprise newsletter.\n-\nLMArena is reframing the problem of benchmarking AI models: What if the best way to test is to put them in front of millions of users and let them vote?\n-\nIn the not-so-distant future, consumers and businesses will be able to instruct an agent to make any payments they want on their behalf.\n-\nThe United States should back a critical minerals champion powered by innovation, resilience, speed, and the ingenuity and resolve of American builders.\n-\nTo secure the United States’ position as the unrivaled world leader in AI, the federal government’s R&D strategy must prioritize tech startups, which we refer to as Little Tech. This strategy should focus on two pillars: (1) building robust national AI research infrastructure and (2) supporting research that will fuel American competitiveness.\n-\nTraditional search was built on links; GEO is built on language. A new paradigm is emerging, one driven not by page rank, but by AI models.\n-\nPolicymakers want a thriving national AI market—but model thresholds based on compute or training costs will harm startups. Thresholds that target the application of AI tools, like revenue-based thresholds, are more likely to properly identify companies that are well-positioned to bear more substantial regulatory burdens.\n-\nWhat if we stopped trying to cure disease and started preventing it instead? In this episode, Dr. Eric Topol joins general partner Vijay Pande, PhD, to unpack the future of aging, prevention, and precision health—as explored in Eric's new book, Super Agers: An Evidence-Based Approach to Longevity.\n-\nThe a16z Infra teams explores how LLMs are reshaping software development — from its potential as a new programming abstraction to its practical impacts.\n-\nArif Nathoo, cofounder and CEO of Komodo Health, joins Jorge Conde and Jay Rughani to explore the transformative potential of healthcare data in reshaping biotech and healthcare innovation. Arif reflects on a decade-long...\n-\nDevelopers are moving past AI as just tooling and starting to treat AI agents as a new foundation for how software gets built.\n-\nA step-by-step framework to test if you know who your ICP is—or build it out if you don’t.\n-\nWhy ICP misalignment is often the hidden cause of common problems across the entire company—and how to fix it.\n-\nA guide for product managers to stay current, build novel products, and level up their role alongside AI.\n-\nAnthropic's David Soria Parra discusses MCP's inception, exciting use cases for connecting LLMs to external sources, and what's coming next for the project.\n-\nJoin a16z general partners Marc Andreessen, Julie Yoo, and Vijay Pande for an incisive exploration of what's driving—and stalling—transformation in healthcare. With the industry now consuming nearly 20% of U.S. GDP yet d...\n-\na16z Infra partners Guido Appenzeller, Matt Bornstein, and Yoko Li discuss and debate one of the tech industry's buzziest words right now: AI agents.\n-\nWe’re inching close to generalizable, deployable robot models, but still struggling to find the right bounds for these deployed systems.\n-\nARES (Automatic Robot Evaluation System) is an all-in-one, open-source robot data platform, aimed at helping robotics researchers build better models.\n-\nAI-powered wearables will be more adaptive, agentic, and immersive than your smartphone. Meta’s Andrew Bosworth explains how.\n-\nPolicymakers are proposing new transparency requirements for AI developers to disclose information ranging from model design and training data to safety testing procedures and predictions about speculative harms. While transparency is a laudable goal, many of these mandates provide minimal benefit to end users, but threaten to overwhelm Little Tech—our term for startups—with unconstitutional compliance burdens that would make it harder for them to compete with larger platforms.\n-\na16z is excited to welcome Erik Torenberg as our newest General Partner, bringing a decade of experience at the intersection of investing, media, and networks. With our acquisition of Turpentine, Erik will help scale our media and network efforts while continuing to invest in the next generation of founders.\n-\nPresident Trump signs Congressional Review Act resolution. Stablecoin bill eligible for House Floor vote. SEC clarifies stablecoins view.\n-\nSeth Hain, SVP of R&D at Epic, joins a16z Bio + Health general partner Julie Yoo to explore technology in healthcare. Reflecting on over two decades of industry shifts, Seth shares how Epic has transitioned from enab...\n-\nWhat happens when AI doesn’t just generate content, but embodies it? I tested over 20 AI avatar products to understand what’s working and what's next.\n-\nBuilding your own GPU server—like the one described here—means no API calls to external services, no data leakage, and no usage throttles.\n-\nBy Colin Campbell and Jonathan Lai\n-\nWhen people think about startups working with the government, the phrase “black box” often comes up. But what if that box is finally being pried open?\n-\nElliot Cohen, cofounder of PillPack, joins Julie Yoo, a16z Bio + Health general partner. Together, they discuss Elliot's experience designing and building a consumer-first pharmacy alongside TJ Parker.\n-\nAt a16z'a fourth annual Connect/Fintech event, discussions spanned what's working in AI, operational lessons on how to scale faster, and the future of banking charters.\n-\nWe’re investing up to $1M in pre-seed/seed startups in tech, entertainment, and AI. Apply by May 11 → sr.a16z.com\n-\nCher's digital closet was just the beginning. Online shopping is becoming intelligent, predictive, and visually intuitive.\n-\nConvex cofounder and Chief Scientist Sujay Jayakar and a16z General Partner Martin Casado discuss the real challenges of autonomous software development and why robust evals — and guardrails like type safety — matter more than ever.\n-\nBundling your products can deepen your moat — or shrink your margins. Use these gut-checks before you pull the lever.\n-\nThis month, a16z’s Consumer team released the fourth edition of the GenAI 100 — a data-driven ranking of the top 50 AI-first web products and mobile apps, based on unique monthly visits and active users.\n-\nResend's Zeno Rocha and a16z's Yoko Li discuss how AI agents and MCP are reshaping the developer experience for email creation and programming overall.\n-\nYounger founders often lack the deep networks important for distribution and earned insights around high-value problems that older founders have. AI changes that.\n-\nThe global race for AI leadership is no longer just about companies—it’s about nations. AI isn’t just computing infrastructure; it’s cultural infrastructure, economic strategy, and national security all rolled into one.\n-\nWe explore what MCP is, how it changes the way AI interacts with tools, what developers are already building, and the challenges that still need solving.\n-\nAI voice technology has been around for years — think Siri or Alexa — but the magic has been missing. That’s changing, and quickly!\n-\nThe US government should invest in AI talent and infrastructure to ensure that Little Tech has the ability to compete and thrive.\n-\nThis week, a16z shared our recommendations with the White House Office of Science and Technology Policy (OSTP) for how the United States can implement a competitiveness agenda that will enable it to continue to lead the world in AI development.\n-\nSesame's Ankit Kumar and a16z's Anjney Midha do a deep dive into the research and engineering behind Sesame's cutting-edge AI model for conversations.\n-\nFor startups, working with the Department of Defense (DoD) can feel like stepping into a fortress of bureaucracy — procurement is slow, compliance is daunting, and knowing who actually makes buying decisions is like navi...\n-\nWe back founders pushing the limits of tech and entertainment.\n-\nThese 50 companies aren’t just strengthening America’s ability to deter conflict, they’re re-industrializing America in the process.\n-\nFor over a century, the United States has been the birthplace of world-changing innovation – from the Wright brothers’ first flight to the invention of the transistor, the moon landing, and the birth of the internet. But...\n-\nIn this episode, Slingshot AI cofounders Daniel Cahn and Neil Parikh join a16z Bio + Health general partner Julie Yoo to explore how their mission to transform mental health care with AI took shape. Drawing from their un...\n-\nWe unpacked the unconventional tactics in Deel's playbook to help guide the business strategy and culture of other startups.\n-\nAI is reshaping web development. At the center is agent experience (AX), a new paradigm where AI agents open new capabilities in web design and experience.\n-\nHenry Ward, cofounder and CEO of Carta, has spent over a decade scaling his company from an early-stage startup to a 2,000-person industry leader. In this a16z Speedrun conversation with Games partner Josh Lu, Henry shar...\n-\nWhich AI apps are people actively using? What’s actually making money, beyond being popular? We analyzed the data.\n-\na16z partners Guido Appenzeller and Marco Mascorro demystify how DeepSeek works and explain what the era of reasoning models means for AI.\n-\nWe recently kicked off the latest a16z Talent x Opportunity initiative cohort in San Francisco with founders from five promising startups building software-enabled companies across fashion, gaming, media, and music.\n-\nIn this episode of AI + a16z, a trio of security experts join a16z partner Joel de la Garza to discuss the security implications of the DeepSeek reasoning model that made waves recently. It's three separate discussions,...\n-\nFor voice agents in finance to become successful, they will need to navigate a number of industry-specific nuances.\n-\nBeing a creator in 2025 is tough—but building for creators is even harder. Perhaps no one understands this conundrum better than Scott Belsky. As the founder of Behance, a longtime executive at Adobe, and an advisor to c...\n-\nDr. Muthu Alagappan, MD, founder and CEO of Counsel Health, joins Julie Yoo, a16z Bio + Health general partner, to dive deep into the company's vision for revolutionizing healthcare through AI-powered asynchronous care....\n-\nHarvey's Aatish Nayak discusses building AI products for enterprises, including the legal profession, and how to address areas like UX, trust, and pricing.\n-\nWill the next era of the internet be shaped by a handful of players—or transformed into an open ecosystem?\n-\nThe right investment in RevOps separate great GTM engines from good-enough GTM engines. Here's a cheatsheet for investing in RevOps as you scale.\nRecent Investment News\n-\nGeneral\nFlow\nMarc Andreessen -\nEnterprise\nInvesting in Toma\nSeema Amble -\nInfra\nInvesting in LMArena: The Reliability Layer for AI\nAnjney Midha -\nConsumer\nInvesting in Hedra\nJustine Moore -\nAmerican Dynamism\nInvesting in Northwood\nKatherine Boyle -\nAmerican Dynamism\nInvesting in Base Power\nErin Price-Wright -\nConsumer\nInvesting in Krea\nAnish Acharya -\nInfra\nInvesting in Adaptive Security\nZane Lackey -\nGrowth\nInvesting in E3Tech\nScott Kupor -\nInfra\nInvesting in Sesame AI\nAnjney Midha -\nEnterprise\nInvesting in Camber\nDavid Haber -\nInfra\nInvesting in fal\nJennifer Li -\nInfra\nInvesting in Grepr\na16z Infra Team -\nEnterprise\nInvesting in Eve\nDavid Haber -\nBio + Health\nInvesting in Slingshot AI\nVijay Pande -\nConsumer\nInvesting in Raspberry AI\nZach Cohen -\nGames\nInvesting in Backflip\nTroy Kirwin -\nInfra\nInvesting in Stainless\nJennifer Li -\nConsumer\nInvesting in WaveForms AI\nJustine Moore -\nConsumer\nInvesting in HappyRobot\nAnish Acharya -\nInfra\nInvesting in Resend\nYoko Li -\nGames\nInvesting In Promise\nColin Campbell -\nEnterprise\nInvesting in 11x\nJoe Schmidt -\nConsumer\nInvesting in [untitled]\nAnish Acharya -\nGrowth\nInvesting in Infinitus\nScott Kupor -\nEnterprise\nInvesting in Pantheon\nKimberly Tan -\nBio + Health\nInvesting in Alchemy\nJulie Yoo -\nBio + Health\nInvesting in Arda Therapeutics\nBecky Pferdehirt -\nInfra\nInvesting in Braintrust\nMartin Casado -\nConsumer\nInvesting in Scribenote\nOlivia Moore -\nBio + Health\nInvesting in GC Therapeutics\nVineeta Agarwala -\nInfra\nWhat’s In a World? Investing in World Labs\nMartin Casado -\nInfra\nInvesting in Mintlify\nJennifer Li -\nEnterprise\nInvesting in Pylon\nJennifer Li -\nInfra\nInvesting in Cursor\nMatt Bornstein -\nCrypto\nInvesting in Story\nChris Dixon -\nInfra\nInvesting in Black Forest Labs\nAnjney Midha -\nCrypto\nInvesting in Daylight\nGuy Wuollet -\nAmerican Dynamism\nInvesting in Saronic\nKatherine Boyle -\nGrowth\nInvesting in Hebbia\nAlex Immerman -\nGrowth\nInvesting in Formation Bio\nScott Kupor -\nGames\nInvesting in k-ID\nJonathan Lai -\nBio + Health\nInvesting in Function Health\nVijay Pande -\nBio + Health\nInvesting in knownwell\nVineeta Agarwala -\nEnterprise\nInvesting in Decagon\nKimberly Tan -\nGrowth\nInvesting in Talkiatry\nScott Kupor -\nBio + Health\nInvesting in Valar Labs\nVineeta Agarwala -\nGames\nInvesting in Yellow\nJonathan Lai -\nGrowth\nInvesting in Wiz\nSarah Wang -\nEnterprise\nInvesting in Tennr\nKristina Shen -\nCrypto\nInvesting in Espresso\nAli Yahya -\nGames\nInvesting in Kaedim\nJonathan Lai -\nEnterprise\nInvesting in Ideogram\nMartin Casado -\nCrypto\nInvesting in EigenLayer\nAli Yahya -\nEnterprise\nInvesting in Tigris\nMartin Casado -\nEnterprise\nInvesting in Upstash\nJennifer Li -\nFintech\nInvesting in Crux\nDavid Haber -\nEnterprise\nInvesting in Doppel\nZane Lackey -\nFintech\nInvesting in hyperexponential\nAngela Strange -\nGrowth\nInvesting in Quora and Poe\nDavid George -\nEnterprise\nInvesting in Luma AI\nAnjney Midha -\nEnterprise\nInvesting in Distributional\nMartin Casado -\nBio + Health\nInvesting in Tome Biosciences\nJorge Conde -\nEnterprise\nInvesting in Mistral\nAnjney Midha -\nAmerican Dynamism\nInvesting in Air Space Intelligence\nDavid Ulevitch -\nCrypto\nInvesting in Pimlico\nSriram Krishnan -\nBio + Health\nInvesting in Gate Bioscience\nVineeta Agarwala -\nAmerican Dynamism\nInvesting in Prepared\nDavid Ulevitch -\nCrypto\nInvesting in Blackbird\nArianna Simpson -\nCrypto\nInvesting in Proof of Play\nChris Dixon -\nFintech\nInvesting in TipTop\nMarc Andreessen -\nGames\nInvesting in Series AI\nJoshua Lu -\nFintech\nInvesting in Moment\nDavid Haber -\nGames\nInvesting in Pahdo Labs\nJonathan Lai -\nEnterprise\nInvesting in Socket\nZane Lackey -\nCrypto\nInvesting in Sound.xyz\nAli Yahya -\nAmerican Dynamism\nInvesting in Apex\nKatherine Boyle -\nConsumer\nInvesting in Captions\nBryan Kim -\nEnterprise\nInvesting in ElevenLabs\nJennifer Li -\nCrypto\nInvesting in Gensyn\nAli Yahya -\nBio + Health\nInvesting in Pomelo Care\nVineeta Agarwala -\nBio + Health\nInvesting in Hippocratic AI\nJulie Yoo -\nEnterprise\nInvesting in Pinecone\nPeter Levine -\nBio + Health\nInvesting in Orbital Therapeutics\nVineeta Agarwala -\nAmerican Dynamism\nInvesting in Radiant\nDavid Ulevitch -\nBio + Health\nInvesting in Function Oncology\nVineeta Agarwala -\nGeneral\nInvesting in Character.AI\nSarah Wang -\nGames\nInvesting in CCP Games\nJonathan Lai -\nEnterprise\nInvesting in Coactive\nMartin Casado -\nEnterprise\nInvesting in Wingspan\nDavid Ulevitch -\nGames\nInvesting in Believer\nAndrew Chen -\nCrypto\nInvesting in Towns\nSriram Krishnan -\nEnterprise\nInvesting in Svix\nMatt Bornstein -\nEnterprise\nInvesting in Replicate\nMatt Bornstein -\nCrypto\nInvesting in Azra Games\nArianna Simpson -\nBio + Health\nInvesting in Marker Learning\nAnnie Collins -\nGames\nInvesting in Snapser\nJoshua Lu -\nEnterprise\nInvesting in Macro\nKristina Shen",
      "content_type": "blog",
      "source_url": "https://a16z.com/news-content/",
      "author": "",
      "user_id": ""
    },
    {
      "title": "American Dynamism: Supporting the National Interest | a16z",
      "content": "The American Dynamism practice invests in founders and companies that support the national interest: aerospace, defense, public safety, education, housing, supply chain, industrials, and manufacturing. We believe that mission-driven and civic-minded founders often build companies that transcend verticals and business models in their quest to solve important national problems. These companies view the government as a customer, competitor, or key stakeholder—and the success of these companies supports the flourishing of all Americans. Dynamic companies exist in all 50 states and have a global impact.\nAmerican Dynamism embodies the spirit of innovation, progress, and resilience that drives the United States forward. This powerful force is exemplified by groundbreaking achievements in technology and innovation, shaping both our nation and the global landscape. It reflects the American commitment to pushing boundaries, embracing challenges, and always striving for a brighter, more prosperous future. Investing in visionary founders and teams tackling the world’s most pressing problems is essential to fueling this dynamic spirit and ensuring continued progress for generations to come.\nThe Wright Brothers’ first successful powered flight revolutionized transportation, paving the way for modern aviation and radically altering global communication and trade.\nThe Manhattan Project developed the first atomic bomb, shifting the course of WWII and introducing the world to the power of nuclear technology.\nThe transistor’s invention led to smaller, faster electronics, enabling the digital age and transforming industries from computing and communications to medicine and entertainment.\nApollo 11’s moon landing showcased American technological prowess, inspiring generations and setting the stage for future space exploration and scientific advancements.\nThe invention of microprocessors reshaped modern life by revolutionizing computing and empowering the development of personal computers, smartphones, and countless other electronic devices.\nThe internet profoundly transformed society and culture by facilitating global communication, information sharing, and commerce.\nThe invention of the modern Lithium-ion battery enabled portable electronics and electric vehicles, significantly impacting energy storage, transportation, and sustainability.\nThe iPhone transformed mobile technology with its innovative touchscreen, advanced camera, and diverse app ecosystem, redefining communication and software interaction, and inspiring numerous consumer and enterprise products.\nSpaceX’s historic rocket landing demonstrated reusable rocket technology, drastically reducing space transportation costs, and opening new opportunities in space exploration and commercial activity.\nGenerative AI reshaped how we think about interacting with computers and the creative process. It also raised important—and yet unanswered—questions in areas such as law, philosophy, and the future of productivity.\nThe United States should back a critical minerals champion powered by innovation, resilience, speed, and the ingenuity and resolve of American builders.\nWe’re inching close to generalizable, deployable robot models, but still struggling to find the right bounds for these deployed systems.\nARES (Automatic Robot Evaluation System) is an all-in-one, open-source robot data platform, aimed at helping robotics researchers build better models.\nNorthwood is re-architecting ground infrastructure for satellite communications as a distributed, cloud-like network of phased array ground stations.\nBase Power installs batteries that lower energy bills, provide backup power, give customers control over their energy — and could help save our grid.\nWhen people think about startups working with the government, the phrase “black box” often comes up. But what if that box is finally being pried open?\nThe global race for AI leadership is no longer just about companies—it’s about nations. AI isn’t just computing infrastructure; it’s cultural infrastructure, economic strategy, and national security all rolled into one.\nFor startups, working with the Department of Defense (DoD) can feel like stepping into a fortress of bureaucracy — procurement is slow, compliance is daunting, and knowing who actually makes buying decisions is like navi...\nThese 50 companies aren’t just strengthening America’s ability to deter conflict, they’re re-industrializing America in the process.\nFor over a century, the United States has been the birthplace of world-changing innovation – from the Wright brothers’ first flight to the invention of the transistor, the moon landing, and the birth of the internet. But...\nMachine learning methods applied to physics will speed up simulation times by orders of magnitude and revolutionize the engineering development process.\nAs 2025 begins, industries are evolving at unprecedented speed: robots are revolutionizing manufacturing, terabytes of earth observation data are driving new possibilities, and gaming technology is transforming how we de...\nWorld models represent a credible promise for leveling the playing field, enabling “little robotics” to innovate and compete more effectively.\nAn external \"AI brain.\" Big swings in biopharma. Infinite games. A nuclear resurgence. \"Faceless\" creators. Google search challengers. Battlefield AI. We asked 50 a16z partners to preview one big idea that will spur innovation in 2025.\nAmerica is a country of immense wealth, but our manufacturing infrastructure is struggling to keep pace.\nBrian Roberts is joining Andreessen Horowitz as a General Partner, where he will work across the American Dynamism and AI Apps funds.\nAndy McCall is joining Andreessen Horowitz as a General Partner. He will work across the American Dynamism and AI Apps funds.\n2024 has been a milestone year for autonomous tech.\nWhat does Rich Sutton’s \"Bitter Lesson\" reveal about the decisions Tesla is making in its pursuit of autonomy?\nAcross the industries and companies that comprise American Dynamism, a decoupling of hardware and software for autonomy use cases is underway.\nAn acceleration of talent, capital, and research progress in the robotics domain could enable the development of a horizontal robotics platform.\nLogistics wins wars, and military logistics today means moving fuel. Advanced nuclear microreactors can replace fuel supply chains with on-site power, revolutionizing warfare and saving lives.\na16z is proud to lead Saronic’s Series B and continue supporting founder and CEO Dino Mavrookas and his team of engineers, veterans, and operators.\nThis is a 12-month program for early-career engineers and researchers with expertise at the intersection of hardware and software.\nThe stakes are high. The opportunities are profound. From the creation of new medicines to bolstering national defense, this is our vision for the AI-enabled future.\nRegulators influenced by the big companies create barriers to entry for \"little tech\" and curtail innovation.\nThe U.S. industrial base faces a series of risks that compromise our ability to remain globally competitive. AI is uniquely suited to tackle these complex challenges.\nTo seize a future of energy abundance, we must simplify the generation, transmission, and consumption of electricity; this entails decentralizing the grid.\nWe are pleased to welcome Erin Price-Wright as our newest American Dynamism partner.\nMarc Andreessen and Tyler Cowen discuss techno-optimism, AI, and other topics at the a16z American Dynamism Summit.\na16z's Martin Casado lays out the case for AI as a driving force behind incredible advancements in tech, creativity, and the human experience.\nCalifornia Forever CEO Jan Sramek discusses building an ambitious new city between San Francisco and Sacramento.\na16z's Ben Horowitz & Coinbase's Emilie Choi discuss crypto’s potential to power the next-generation internet and bolster individual freedoms.\nRep. Mike Gallagher (R-WI) and Jake Auchincloss (D-MA) discuss why the US must strengthen its technological advantage in areas like AI.\nAnduril Cofounder and CEO Brian Schimpf lays out the case for how and why technology plays a critical role in helping ensure a safer world.\nUS Dep. Sec. of Defense Kathleen Hicks is interviewed by Wall Street Journal national security and foreign policy editor Sharon Weinberger.\nSenator Todd Young speaks about the importance of open innovation and US leadership in AI, and why we need to support AI research.\nMark Cuban discusses the importance of entrepreneurship for maintaining America’s status as the most innovative place on the planet.\nMaryland Governor Wes Moore discusses his inspiring journey to the statehouse and how his experiences have shaped his leadership.\n50 groundbreaking tech companies advancing the national interest, from the last mile to low Earth orbit.\nAir Space Intelligence is a modern aerospace company addressing the software crisis in aerospace in both the enterprise and government sectors.\nSmart energy grids. Voice-first companion apps. Programmable medicines. AI tools for kids. We asked over 40 partners across a16z to preview one big idea they believe will drive innovation in the coming year.\nWe believe a strong America means a strong world. A safer world. A more civilized world, which is a term we should use more. And that technology is the backbone of maintaining this order and civilization and always will be.\n911 call centers – also known as public safety answering points (PSAPs) – are one of the most actively used public-safety infrastructure systems in the United States, fielding an estimated 240 million calls per year. Tha...\nNew and emerging technology solutions are beginning to make up a veritable tech stack aimed at tackling public safety.\nIf we’re going to normalize nuclear power as a reliable energy source, it's essential to understand how we’ve ended up in our current situation.\nThe cost of launching payloads to orbit has dramatically dropped, igniting a space renaissance. In 2022, a record 186 rocket launches (41 more than the previous year!) underscores this shift. In Part 1 of our satellite economy mini-series, we sit down with John Gedmark, co-founder of Astranis, to reflect on today's innovations, who’s on the other side of the satellite market, the capabilities they’re looking for, competition, and their mission to provide internet access to 4 billion underserved people.\nApex’s flagship Aries platform satellite bus is being manufactured for scale, targeting both commercial and defense companies where speed is critical.\nThere are tremendous opportunities in American Dynamism categories for full-stack startups to arise, and these companies can enable thriving new ecosystems.\nAmerican Dynamism doesn’t fit neatly into one vertical. It is a philosophy that encompasses nearly every aspect of American life and leadership.\nWe are in the early stages of a generational defense cycle that requires unconventional thinking and tools. Here are some ideas for how to do it.\nMost people don’t know that nuclear energy — a clean, carbon-free energy source — accounts for 20% of electricity in the United States and over half of its carbon-free electricity. However, while large nuclear reactors a...\nFor a full landscape of the commercial space market, see our previous post: Space: A Market Map.\nIn “The Space Age”, I wrote about the importance of mankind extending our reach into the stars. Moreover, I suggested that America is — and should remain — the leader in this endeavor. It was, in many ways, an appeal to...\nWhether through COVID-19, climate change, or geopolitical conflict, the past few years have laid bare the tenuous connections underpinning key parts of our modern world. Wars, pandemics, ransomware attacks, and extreme w...\n50 AI companies advancing the national interest, from the last mile to low Earth orbit.\nSee Who's on the listInnovation. Progress. Resiliency. Groundbreaking achievement. Our team is committed to identifying and supporting civic-minded founders ready to lead America. Tackling our biggest challenges requires courage. We find the companies who have it.\nSee Full TeamCome See What We’re Building\nAny investments or portfolio companies mentioned, referred to, or described on this page are not representative of all investments in vehicles managed by a16z and there can be no assurance that the investments will be profitable or that other investments made in the future will have similar characteristics or results. Exits include current and former a16z portfolio companies which have been acquired as well as companies which have undergone an initial public offering or direct public offering of shares. Certain publicly traded companies on this list may still be held in Andreessen Horowitz funds. A list of investments made by funds managed by a16z is available here: https://a16z.com/investment-list/. Additionally investments that have participated in a16z accelerator programs can also be found here: https://speedrun.a16z.com/companies/. Excluded from this list are investments for which the issuer has not provided permission for a16z to disclose publicly as well as unannounced investments in publicly traded digital assets. Further, the list of investments is updated monthly and as such may not reflect most recent a16z investments. Past results of Andreessen Horowitz’s investments, pooled investment vehicles, or investment strategies are not necessarily indicative of future results.",
      "content_type": "blog",
      "source_url": "https://a16z.com/american-dynamism/",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Terms of Use | Andreessen Horowitz",
      "content": "Please read the following terms and conditions (“Terms”). They govern your use of this website and its associated services, including email newsletters, associated content distribution platforms, and public a16z online social media accounts (collectively, “the “Services”). By using the Services, you agree to be bound by these Terms. We may update these Terms from time to time and any modifications will be effective immediately upon posting unless we indicate otherwise. If you use the Services after any changes to the Terms have been posted, that means you agree to all of the changes. We suggest that you review these Terms periodically for changes.\nExcept as otherwise noted on the Services, all content and material on the Services — including information, photos, podcasts, blog posts, videos, graphics/charts, icons, code, design, and overall appearance — are the property of AH Capital Management, LLC (“Andreessen Horowitz” or “a16z”) and should not be used, modified, or reproduced without our prior written consent. All trademarks, trade names, and logos displayed on the Services are the property of Andreessen Horowitz, its affiliates, or their respective third-party owners, and the Services grants no license to them. ANDREESSEN HOROWITZ and A16Z are registered trademarks in the United States and/or other countries and may not be used without the prior written permission of Andreessen Horowitz.\nCertain statements that individual personnel make may constitute “forward-looking statements” under the Privacy Securities Litigation Reform Act of 1995. To the extent any information herein constitutes forward-looking statements (which can be identified by the use of forward-looking terminology such as “may,” “will,” “should,” “expect,” “anticipation,” “upside,” “potential,” “project,” “estimate,” “intend,” “forecast,” “target” or “believe” or comparable terminology), please note that, due to various risks and uncertainties, actual events, results, or performance may differ materially from those reflected or contemplated in such statements. Forward-looking statements are not guarantees and involve risks, uncertainties, and assumptions. Andreessen Horowitz expressly disclaims any obligation to update any forward-looking statement in the event it later turns out to be inaccurate — whether as a result of new information, future events, or otherwise.\nThe Services may link to or integrate with other websites operated or content provided by third parties, and such other websites may link to this website. a16 has no control over any such other websites or their content and will have no liability arising out of or related to such websites or their content. The existence of any such link does not constitute an endorsement of such websites, the content of the websites, or the operators of the websites. Andreessen Horowitz is providing these links to you only as a convenience. You release and hold Andreessen Horowitz harmless from any and all liability arising from your use of any third-party website or service.\nDue to the large number of business plan ideas and related materials that Andreessen Horowitz reviews, and the similarity of many such plans and materials, we cannot agree to obligations of confidentiality, non-use, or non-disclosure with regard to any information or materials submitted or provided to or otherwise shared with us. By submitting information or materials to Andreessen Horowitz, you (or anyone acting on your behalf) agree that any such information or materials will not be considered confidential or proprietary, and that Andreessen Horowitz is free to use it without condition. In no event will Andreessen Horowitz be limited in, or restricted from, the pursuit of any opportunities, either alone or with third parties.\nAlthough certain individuals are identified in the Services as “Partners” or “General Partners,” such titles are not intended to indicate that any such individual is actually a partner or general partner of any partnership as those terms are used for legal purposes. Such titles should not be construed to indicate that an individual has any ownership interest in Andreessen Horowitz or an Andreessen Horowitz affiliate nor should such titles be construed to indicate that an individual has any particular decision-making authority or responsibility.\nYou are responsible for all information, content, and materials you contribute, disclose, or share in any manner on or through the Services and you represent and warrant you have all rights necessary to do so. You are responsible for all your activity in connection with the Services.\nNothing on the Services constitutes professional or financial advice of any kind (including business, employment, investment advisory, accounting, tax, and/or legal advice). Advice from a suitably qualified professional should always be sought in relation to any particular matter or circumstance. Nothing on the Services constitutes or forms a part of any offer for sale or subscription of, or any invitation to offer to buy or subscribe for, any securities, nor should it or any part of it form the basis of, or be relied upon in connection with, any contract or commitment whatsoever.\nYou acknowledge and agree that neither Andreessen Horowitz nor any other person (including, without limitation, any affiliate of Andreessen Horowitz) is in any way obligated to invest in any business you are associated with or offer you to invest in any Andreessen Horowitz entity or affiliate. Further, Andreessen Horowitz makes no representation, warranty, or guarantee that any use of its services will result in your employment or engagement as a consultant or receiving career development services of any kind.\nTHE SERVICES AND THE INFORMATION CONTAINED THEREIN ARE PROVIDED “AS IS.” NEITHER ANDREESSEN HOROWITZ NOR ANY OF ITS AFFILIATES IS PROVIDING ANY WARRANTIES AND REPRESENTATIONS REGARDING THE SERVICES. ANDREESSEN HOROWITZ AND ITS AFFILIATES DISCLAIM ALL WARRANTIES AND REPRESENTATIONS OF ANY KIND WITH REGARD TO THE SERVICES, INCLUDING ANY IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT OF THIRD-PARTY RIGHTS, FREEDOM FROM VIRUSES OR OTHER HARMFUL CODE, OR FITNESS FOR A PARTICULAR PURPOSE. ANDREESSEN HOROWITZ AND ITS AFFILIATES DO NOT WARRANT THE ACCURACY, ADEQUACY, OR COMPLETENESS OF THE INFORMATION AND MATERIALS CONTAINED ON THE SERVICES AND EXPRESSLY DISCLAIM LIABILITY FOR ERRORS OR OMISSIONS IN THE MATERIALS AND INFORMATION.\nTo the fullest extent allowed by applicable law, under no circumstances and regardless of the form of action, whether in contract, warranty, tort (including negligence), strict liability, or otherwise, will Andreessen Horowitz or its affiliates be liable to you or any other person for (i) any amount in excess of $100 or (ii) any consequential, incidental, special, punitive, or exemplary damages, regardless of whether Andreessen Horowitz or its affiliates have been apprised of the likelihood of such damages occurring.\nTo the fullest extent allowed by applicable law, you agree to indemnify and hold Andreessen Horowitz, its affiliates, officers, agents, employees, and partners harmless from and against any and all claims, liabilities, damages (actual and consequential), losses and expenses (including attorneys’ fees) arising from or in any way related to any third-party claims relating to (a) your use of the Services (including any actions taken by a third-party using your account), and (b) your violation of these Terms.\nYou and Andreessen Horowitz agree that these Terms are the complete and exclusive statement of the mutual understanding between you and Andreessen Horowitz and supersede all prior agreements and understandings relating to such subject matter. These Terms are governed by and will be construed under the laws of the State of California, without regard to the conflicts of laws provisions thereof. Any disputes relating to these Terms shall be resolved exclusively in the state or federal courts located in Santa Clara County, California. These Terms are binding on you as well as your successors and permitted assigns. If any provision of these Terms is found to be unenforceable or invalid, that provision will be limited or eliminated, to the minimum extent necessary, so that these Terms shall otherwise remain in full force and effect and enforceable.",
      "content_type": "blog",
      "source_url": "https://a16z.com/terms-of-use/",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Privacy Policy | Andreessen Horowitz",
      "content": "At AH Capital Management, LLC (“a16z”), we take your privacy seriously. Please read this Privacy Policy to learn how we treat Personal Data that we collect in relation to our website (https://a16z.com/) and its associated services, including email newsletters, associated content distribution platforms, and public a16z online social media accounts, or when you interact with us as a representative of our portfolio companies, business partners, vendors and other companies we do business with (collectively, the “Services”). By using or accessing our Services in any manner, you acknowledge that you accept the practices and policies outlined below, and you hereby consent that we will collect, use and share your information as described in this Privacy Policy.\nRemember that your use of a16z’s Services is at all times subject to our Terms of Use, which incorporates this Privacy Policy. Any terms we use in this Policy without defining them have the definitions given to them in the Terms of Use.\nYou may print a copy of this Privacy Policy by clicking here. If you have a disability, you may access this Privacy Policy in an alternative format by contacting privacy@a16z.com.\nThis Privacy Policy covers how we treat Personal Data that we gather when you access or use our Services. “Personal Data” means any information that identifies or relates to a particular individual and also includes information referred to as “personally identifiable information” or “personal information” under applicable data privacy laws, rules or regulations. This Privacy Policy does not cover the practices of companies we don’t own or control or people we don’t manage. In addition, this Privacy Policy does not apply to information we collect about job candidates or employees.\nBelow lists the categories of Personal Data, including sensitive Personal Data (denoted by \\*), that we collect and have collected over the past 12 months:\nWe collect Personal Data about you from the following categories of sources:\nThe Services use cookies and similar technologies such as pixel tags, web beacons, clear GIFs and JavaScript (collectively, “Cookies”) to enable our servers to recognize your web browser and tell us how and when you visit and use our Services, to analyze trends, learn about our user base and operate and improve our Services. Cookies are small pieces of data – usually text files – placed on your computer, tablet, phone or similar device when you use that device to access our Services. We may also supplement the information we collect from you with information received from third parties, including third parties that have placed their own Cookies on your device(s). Please note that because of our use of Cookies, the Services do not support “Do Not Track” requests sent from a browser at this time.\nWe use the following types of Cookies:\nYou can decide whether or not to accept Cookies through your internet browser’s settings. Most browsers have an option for turning off the Cookie feature, which will prevent your browser from accepting new Cookies, as well as (depending on the sophistication of your browser software) allow you to decide on acceptance of each new Cookie in a variety of ways. In addition, to opt out of Google Analytics, click here. You can also delete all Cookies that are already on your device. If you do this, however, you may have to manually adjust some preferences every time you visit our website and some of the Services and functionalities may not work.\nTo explore what Cookie settings are available to you, look in the “preferences” or “options” section of your browser’s menu. To find out more information about Cookies, including information about how to manage and delete Cookies, please visit http://www.allaboutcookies.org/.\nWe process Personal Data to operate, improve, understand and personalize our Services. We also collect and use Personal Data for the following purposes:\nWe will not collect additional categories of Personal Data or use the Personal Data we collected for materially different, unrelated, or incompatible purposes without providing you notice. We only use sensitive Personal Data as permitted by applicable laws, including the CCPA, or otherwise with your consent.\nAs noted in the list above, we may communicate with you if you’ve provided us the means to do so. For example, if you’ve given us your email address, we may send you promotional email offers or email you about your use of the Services. Also, we may receive a confirmation when you open an email from us, which helps us improve our Services. If you do not want to receive communications from us, please indicate your preference by emailing us at privacy@a16z.com.\nWe may create aggregated, de-identified or anonymized data from the Personal Data we collect, including by removing information that makes the data personally identifiable to a particular user. We may use such aggregated, de-identified or anonymized data and share it with third parties for our lawful business purposes, including to analyze, build and improve the Services and promote our business, provided that we will not share such data in a manner that could identify you. We will not attempt to reidentify any de-identified data, other than for the purposes of determining whether our deidentification processes satisfy the requirements of applicable laws.\nWe disclose and over the past 12 months have disclosed your Personal Data described above to the following categories of service providers and other parties:\nService Providers\nSuccessors to Our Business\nWe seek to protect your Personal Data from unauthorized access, use and disclosure using appropriate physical, technical, organizational and administrative security measures based on the type of Personal Data and how we are processing that data. For example, the Services use industry-standard Secure Sockets Layer (SSL) technology to allow for the encryption of Personal Data you provide to us. You should also help protect your data by appropriately selecting and protecting your password and/or another sign-on mechanism; limiting access to your computer or device and browser; and signing off after you have finished accessing your account. Although we work to protect the security of your account and other data that we hold in our records, please be aware that no method of transmitting data over the Internet or storing data is completely secure. We cannot guarantee the complete security of any data you share with us, and except as expressly required by law, we are not responsible for the theft, destruction, loss or inadvertent disclosure of your information or content.\nWe retain Personal Data about you for as long as is reasonably necessary for the business purposes specified in this Privacy Policy, based on criteria such as if retention is necessary to maintain our relationship or provide you the Services, comply with our legal obligations, resolve disputes or collect fees owed, enforce our contractual agreements, protect our rights, property or business, or if retention is otherwise permitted or required by applicable law, rule or regulation. We may further retain information in an anonymous or aggregated form where that information would not identify you personally.\nWe do not knowingly collect or solicit Personal Data about children under 13 years of age; if you are a child under the age of 13, please do not attempt to use the Services or send us any Personal Data. If we learn we have collected Personal Data from a child under 13 years of age, we will delete that information as quickly as possible. If you believe that a child under 13 years of age may have provided Personal Data to us, please contact us at privacy@a16z.com.\nIf you are a California resident, you have the rights set forth in this section. However, these rights are not absolute, and in certain cases, we may decline your request as permitted by law. Please see the “Exercising Your Rights” section below for instructions regarding how to exercise these rights. Please note that we may process Personal Data of our customers’ end users or employees in connection with our provision of certain services to our customers. If we are processing your Personal Data as a service provider, you should contact the entity that collected your Personal Data in the first instance to address your rights with respect to such data.\nIf there are any conflicts between this section and any other provision of this Privacy Policy and you are a California resident, the portion that is more protective of Personal Data shall control to the extent of such conflict. If you have any questions about this section or whether any of the following rights apply to you, please contact us at privacy@a16z.com.\nYou have the right to request certain information about our collection, use and disclosure of your Personal Data. In response, we will provide you with the following information:\nYou have the right to request that we delete the Personal Data that we have collected about you.\nYou have the right to request that we correct any inaccurate Personal Data that we maintain about you.\nTo exercise the rights described above, you must send us a request that (1) provides sufficient information to allow us to verify that you are either the person about whom we have collected Personal Data or are an agent authorized by that person, including without limitation your name and email address, and (2) describes your request in sufficient detail to allow us to understand, evaluate and respond to it. Each request that meets both of these criteria will be considered a “Valid Request.” We will only use Personal Data provided in a Valid Request to verify your identity and complete your request.\nWe will work to respond to your Valid Request within 45 days of receipt. We will not charge you a fee for making a Valid Request unless your Valid Request(s) is manifestly unfounded or excessive. If we determine that your Valid Request warrants a fee, we will notify you of the fee and explain that decision before completing your request.\nYou may submit a Valid Request using the following methods:\nYou may also authorize an agent (an “Authorized Agent”) to exercise your rights on your behalf. To do this, you must provide your Authorized Agent with written permission to exercise your rights on your behalf, and we may request a copy of this written permission from your Authorized Agent when they make a request on your behalf.\nWe will not discriminate against you for exercising your rights under the CCPA.\nWe’re constantly trying to improve our Services, so we may need to change this Privacy Policy from time to time, but we will alert you to any such changes by placing a notice on the a16z.com website, by sending you an email and/or by some other means. Please note that if you’ve opted not to receive legal notice emails from us (or you haven’t provided us with your email address), those legal notices will still govern your use of the Services, and you are still responsible for reading and understanding them. If you use the Services after any changes to the Privacy Policy have been posted, that means you agree to all of the changes. Use of information we collect is subject to the Privacy Policy in effect at the time such information is collected.\nIf you have any questions or comments about this Privacy Policy, the ways in which we collect and use your Personal Data or your choices and rights regarding such collection and use, please do not hesitate to contact us at privacy@a16z.com.",
      "content_type": "blog",
      "source_url": "https://a16z.com/privacy-policy/",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Privacy Policy | Andreessen Horowitz",
      "content": "At AH Capital Management, LLC (“a16z”), we take your privacy seriously. Please read this Privacy Policy to learn how we treat Personal Data that we collect in relation to our website (https://a16z.com/) and its associated services, including email newsletters, associated content distribution platforms, and public a16z online social media accounts, or when you interact with us as a representative of our portfolio companies, business partners, vendors and other companies we do business with (collectively, the “Services”). By using or accessing our Services in any manner, you acknowledge that you accept the practices and policies outlined below, and you hereby consent that we will collect, use and share your information as described in this Privacy Policy.\nRemember that your use of a16z’s Services is at all times subject to our Terms of Use, which incorporates this Privacy Policy. Any terms we use in this Policy without defining them have the definitions given to them in the Terms of Use.\nYou may print a copy of this Privacy Policy by clicking here. If you have a disability, you may access this Privacy Policy in an alternative format by contacting privacy@a16z.com.\nThis Privacy Policy covers how we treat Personal Data that we gather when you access or use our Services. “Personal Data” means any information that identifies or relates to a particular individual and also includes information referred to as “personally identifiable information” or “personal information” under applicable data privacy laws, rules or regulations. This Privacy Policy does not cover the practices of companies we don’t own or control or people we don’t manage. In addition, this Privacy Policy does not apply to information we collect about job candidates or employees.\nBelow lists the categories of Personal Data, including sensitive Personal Data (denoted by \\*), that we collect and have collected over the past 12 months:\nWe collect Personal Data about you from the following categories of sources:\nThe Services use cookies and similar technologies such as pixel tags, web beacons, clear GIFs and JavaScript (collectively, “Cookies”) to enable our servers to recognize your web browser and tell us how and when you visit and use our Services, to analyze trends, learn about our user base and operate and improve our Services. Cookies are small pieces of data – usually text files – placed on your computer, tablet, phone or similar device when you use that device to access our Services. We may also supplement the information we collect from you with information received from third parties, including third parties that have placed their own Cookies on your device(s). Please note that because of our use of Cookies, the Services do not support “Do Not Track” requests sent from a browser at this time.\nWe use the following types of Cookies:\nYou can decide whether or not to accept Cookies through your internet browser’s settings. Most browsers have an option for turning off the Cookie feature, which will prevent your browser from accepting new Cookies, as well as (depending on the sophistication of your browser software) allow you to decide on acceptance of each new Cookie in a variety of ways. In addition, to opt out of Google Analytics, click here. You can also delete all Cookies that are already on your device. If you do this, however, you may have to manually adjust some preferences every time you visit our website and some of the Services and functionalities may not work.\nTo explore what Cookie settings are available to you, look in the “preferences” or “options” section of your browser’s menu. To find out more information about Cookies, including information about how to manage and delete Cookies, please visit http://www.allaboutcookies.org/.\nWe process Personal Data to operate, improve, understand and personalize our Services. We also collect and use Personal Data for the following purposes:\nWe will not collect additional categories of Personal Data or use the Personal Data we collected for materially different, unrelated, or incompatible purposes without providing you notice. We only use sensitive Personal Data as permitted by applicable laws, including the CCPA, or otherwise with your consent.\nAs noted in the list above, we may communicate with you if you’ve provided us the means to do so. For example, if you’ve given us your email address, we may send you promotional email offers or email you about your use of the Services. Also, we may receive a confirmation when you open an email from us, which helps us improve our Services. If you do not want to receive communications from us, please indicate your preference by emailing us at privacy@a16z.com.\nWe may create aggregated, de-identified or anonymized data from the Personal Data we collect, including by removing information that makes the data personally identifiable to a particular user. We may use such aggregated, de-identified or anonymized data and share it with third parties for our lawful business purposes, including to analyze, build and improve the Services and promote our business, provided that we will not share such data in a manner that could identify you. We will not attempt to reidentify any de-identified data, other than for the purposes of determining whether our deidentification processes satisfy the requirements of applicable laws.\nWe disclose and over the past 12 months have disclosed your Personal Data described above to the following categories of service providers and other parties:\nService Providers\nSuccessors to Our Business\nWe seek to protect your Personal Data from unauthorized access, use and disclosure using appropriate physical, technical, organizational and administrative security measures based on the type of Personal Data and how we are processing that data. For example, the Services use industry-standard Secure Sockets Layer (SSL) technology to allow for the encryption of Personal Data you provide to us. You should also help protect your data by appropriately selecting and protecting your password and/or another sign-on mechanism; limiting access to your computer or device and browser; and signing off after you have finished accessing your account. Although we work to protect the security of your account and other data that we hold in our records, please be aware that no method of transmitting data over the Internet or storing data is completely secure. We cannot guarantee the complete security of any data you share with us, and except as expressly required by law, we are not responsible for the theft, destruction, loss or inadvertent disclosure of your information or content.\nWe retain Personal Data about you for as long as is reasonably necessary for the business purposes specified in this Privacy Policy, based on criteria such as if retention is necessary to maintain our relationship or provide you the Services, comply with our legal obligations, resolve disputes or collect fees owed, enforce our contractual agreements, protect our rights, property or business, or if retention is otherwise permitted or required by applicable law, rule or regulation. We may further retain information in an anonymous or aggregated form where that information would not identify you personally.\nWe do not knowingly collect or solicit Personal Data about children under 13 years of age; if you are a child under the age of 13, please do not attempt to use the Services or send us any Personal Data. If we learn we have collected Personal Data from a child under 13 years of age, we will delete that information as quickly as possible. If you believe that a child under 13 years of age may have provided Personal Data to us, please contact us at privacy@a16z.com.\nIf you are a California resident, you have the rights set forth in this section. However, these rights are not absolute, and in certain cases, we may decline your request as permitted by law. Please see the “Exercising Your Rights” section below for instructions regarding how to exercise these rights. Please note that we may process Personal Data of our customers’ end users or employees in connection with our provision of certain services to our customers. If we are processing your Personal Data as a service provider, you should contact the entity that collected your Personal Data in the first instance to address your rights with respect to such data.\nIf there are any conflicts between this section and any other provision of this Privacy Policy and you are a California resident, the portion that is more protective of Personal Data shall control to the extent of such conflict. If you have any questions about this section or whether any of the following rights apply to you, please contact us at privacy@a16z.com.\nYou have the right to request certain information about our collection, use and disclosure of your Personal Data. In response, we will provide you with the following information:\nYou have the right to request that we delete the Personal Data that we have collected about you.\nYou have the right to request that we correct any inaccurate Personal Data that we maintain about you.\nTo exercise the rights described above, you must send us a request that (1) provides sufficient information to allow us to verify that you are either the person about whom we have collected Personal Data or are an agent authorized by that person, including without limitation your name and email address, and (2) describes your request in sufficient detail to allow us to understand, evaluate and respond to it. Each request that meets both of these criteria will be considered a “Valid Request.” We will only use Personal Data provided in a Valid Request to verify your identity and complete your request.\nWe will work to respond to your Valid Request within 45 days of receipt. We will not charge you a fee for making a Valid Request unless your Valid Request(s) is manifestly unfounded or excessive. If we determine that your Valid Request warrants a fee, we will notify you of the fee and explain that decision before completing your request.\nYou may submit a Valid Request using the following methods:\nYou may also authorize an agent (an “Authorized Agent”) to exercise your rights on your behalf. To do this, you must provide your Authorized Agent with written permission to exercise your rights on your behalf, and we may request a copy of this written permission from your Authorized Agent when they make a request on your behalf.\nWe will not discriminate against you for exercising your rights under the CCPA.\nWe’re constantly trying to improve our Services, so we may need to change this Privacy Policy from time to time, but we will alert you to any such changes by placing a notice on the a16z.com website, by sending you an email and/or by some other means. Please note that if you’ve opted not to receive legal notice emails from us (or you haven’t provided us with your email address), those legal notices will still govern your use of the Services, and you are still responsible for reading and understanding them. If you use the Services after any changes to the Privacy Policy have been posted, that means you agree to all of the changes. Use of information we collect is subject to the Privacy Policy in effect at the time such information is collected.\nIf you have any questions or comments about this Privacy Policy, the ways in which we collect and use your Personal Data or your choices and rights regarding such collection and use, please do not hesitate to contact us at privacy@a16z.com.",
      "content_type": "blog",
      "source_url": "https://a16z.com/terms-of-use-privacy/",
      "author": "",
      "user_id": ""
    },
    {
      "title": "Essays",
      "content": "If you're not sure which to read, try\nHow to Do Great Work\n,\nHaving Kids\n, or\nHow to Lose Time and Money\n.\nThe Shape of the Essay Field\nGood Writing\nWhat to Do\nThe Origins of Wokeness\nWrites and Write-Nots\nWhen To Do What You Love\nFounder Mode\nThe Right Kind of Stubborn\nThe Reddits\nHow to Start Google\nThe Best Essay\nSuperlinear Returns\nHow to Do Great Work\nHow to Get New Ideas\nThe Need to Read\nWhat You (Want to)\\* Want\nAlien Truth\nWhat I've Learned from Users\nHeresy\nPutting Ideas into Words\nIs There Such a Thing as Good Taste?\nBeyond Smart\nWeird Languages\nHow to Work Hard\nA Project of One's Own\nFierce Nerds\nCrazy New Ideas\nAn NFT That Saves Lives\nThe Real Reason to End the Death Penalty\nHow People Get Rich Now\nWrite Simply\nDonate Unrestricted\nWhat I Worked On\nEarnestness\nBillionaires Build\nThe Airbnbs\nHow to Think for Yourself\nEarly Work\nModeling a Wealth Tax\nThe Four Quadrants of Conformism\nOrthodox Privilege\nCoronavirus and Credibility\nHow to Write Usefully\nBeing a Noob\nHaters\nThe Two Kinds of Moderate\nFashionable Problems\nHaving Kids\nThe Lesson to Unlearn\nNovelty and Heresy\nThe Bus Ticket Theory of Genius\nGeneral and Surprising\nCharisma / Power\nThe Risk of Discovery\nHow to Make Pittsburgh a Startup Hub\nLife is Short\nEconomic Inequality\nThe Refragmentation\nJessica Livingston\nA Way to Detect Bias\nWrite Like You Talk\nDefault Alive or Default Dead?\nWhy It's Safe for Founders to Be Nice\nChange Your Name\nWhat Microsoft Is this the Altair Basic of?\nThe Ronco Principle\nWhat Doesn't Seem Like Work?\nDon't Talk to Corp Dev\nLet the Other 95% of Great Programmers In\nHow to Be an Expert in a Changing World\nHow You Know\nThe Fatal Pinch\nMean People Fail\nBefore the Startup\nHow to Raise Money\nInvestor Herd Dynamics\nHow to Convince Investors\nDo Things that Don't Scale\nStartup Investing Trends\nHow to Get Startup Ideas\nThe Hardware Renaissance\nStartup = Growth\nBlack Swan Farming\nThe Top of My Todo List\nWriting and Speaking\nHow Y Combinator Started\nDefining Property\nFrighteningly Ambitious Startup Ideas\nA Word to the Resourceful\nSchlep Blindness\nSnapshot: Viaweb, June 1998\nWhy Startup Hubs Work\nThe Patent Pledge\nSubject: Airbnb\nFounder Control\nTablets\nWhat We Look for in Founders\nThe New Funding Landscape\nWhere to See Silicon Valley\nHigh Resolution Fundraising\nWhat Happened to Yahoo\nThe Future of Startup Funding\nThe Acceleration of Addictiveness\nThe Top Idea in Your Mind\nHow to Lose Time and Money\nOrganic Startup Ideas\nApple's Mistake\nWhat Startups Are Really Like\nPersuade xor Discover\nPost-Medium Publishing\nThe List of N Things\nThe Anatomy of Determination\nWhat Kate Saw in Silicon Valley\nThe Trouble with the Segway\nRamen Profitable\nMaker's Schedule, Manager's Schedule\nA Local Revolution?\nWhy Twitter is a Big Deal\nThe Founder Visa\nFive Founders\nRelentlessly Resourceful\nHow to Be an Angel Investor\nWhy TV Lost\nCan You Buy a Silicon Valley? Maybe.\nWhat I've Learned from Hacker News\nStartups in 13 Sentences\nKeep Your Identity Small\nAfter Credentials\nCould VC be a Casualty of the Recession?\nThe High-Res Society\nThe Other Half of \"Artists Ship\"\nWhy to Start a Startup in a Bad Economy\nA Fundraising Survival Guide\nThe Pooled-Risk Company Management Company\nCities and Ambition\nDisconnecting Distraction\nLies We Tell Kids\nBe Good\nWhy There Aren't More Googles\nSome Heroes\nHow to Disagree\nYou Weren't Meant to Have a Boss\nA New Venture Animal\nTrolls\nSix Principles for Making New Things\nWhy to Move to a Startup Hub\nThe Future of Web Startups\nHow to Do Philosophy\nNews from the Front\nHow Not to Die\nHolding a Program in One's Head\nStuff\nThe Equity Equation\nAn Alternative Theory of Unions\nThe Hacker's Guide to Investors\nTwo Kinds of Judgement\nMicrosoft is Dead\nWhy to Not Not Start a Startup\nIs It Worth Being Wise?\nLearning from Founders\nHow Art Can Be Good\nThe 18 Mistakes That Kill Startups\nA Student's Guide to Startups\nHow to Present to Investors\nCopy What You Like\nThe Island Test\nThe Power of the Marginal\nWhy Startups Condense in America\nHow to Be Silicon Valley\nThe Hardest Lessons for Startups to Learn\nSee Randomness\nAre Software Patents Evil?\n6,631,372\nWhy YC\nHow to Do What You Love\nGood and Bad Procrastination\nWeb 2.0\nHow to Fund a Startup\nThe Venture Capital Squeeze\nIdeas for Startups\nWhat I Did this Summer\nInequality and Risk\nAfter the Ladder\nWhat Business Can Learn from Open Source\nHiring is Obsolete\nThe Submarine\nWhy Smart People Have Bad Ideas\nReturn of the Mac\nWriting, Briefly\nUndergraduation\nA Unified Theory of VC Suckage\nHow to Start a Startup\nWhat You'll Wish You'd Known\nMade in USA\nIt's Charisma, Stupid\nBradley's Ghost\nA Version 1.0\nWhat the Bubble Got Right\nThe Age of the Essay\nThe Python Paradox\nGreat Hackers\nMind the Gap\nHow to Make Wealth\nThe Word \"Hacker\"\nWhat You Can't Say\nFilters that Fight Back\nHackers and Painters\nIf Lisp is So Great\nThe Hundred-Year Language\nWhy Nerds are Unpopular\nBetter Bayesian Filtering\nDesign and Research\nA Plan for Spam\nRevenge of the Nerds\nSuccinctness is Power\nWhat Languages Fix\nTaste for Makers\nWhy Arc Isn't Especially Object-Oriented\nWhat Made Lisp Different\nThe Other Road Ahead\nThe Roots of Lisp\nFive Questions about Language Design\nBeing Popular\nJava's Cover\nBeating the Averages\nLisp for Web-Based Applications\nChapter 1 of Ansi Common Lisp\nChapter 2 of Ansi Common Lisp\nProgramming Bottom-Up\nThis Year We Can End the Death Penalty in California\nRSS\nfeed",
      "content_type": "blog",
      "source_url": "http://www.paulgraham.com/articles.html ",
      "author": "",
      "user_id": ""
    }
  ]
}